###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           12/Jun/2013  19:50:47 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v1.4 -              #
#                    12.06.2013\core\udp.c                                    #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\core\udp.c" -D AT91SAM7S256 -D AT91SAM7SEK    #
#                    -D iH -D _LCD_NEGATIV_OLD_ -D __ALARM -D __WIFI_MODULE   #
#                    -D _DEBUG_ -D S300iOld -D _TESTER_ -lC                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\TESTER S300X (Old)\List\" --diag_suppress     #
#                    Pa082 -o "D:\Zeuron\Projekty\S300\S300-program v1.4 -    #
#                    12.06.2013\TESTER S300X (Old)\Obj\" --no_unroll          #
#                    --no_inline --no_tbaa --no_scheduling --debug --endian   #
#                    little --cpu ARM7TDMI -e --fpu None --dlib_config        #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    5.0\ARM\INC\DLib_Config_Normal.h" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v1.4 - 12.06.2013\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v1.4 - 12.06.2013\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v1.4 - 12.06.2013\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\Framework\Configuration\" -I "C:\Program      #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\INC\" --section .text=Debug.txt --interwork      #
#                    --cpu_mode thumb -Om                                     #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v1.4 -              #
#                    12.06.2013\TESTER S300X (Old)\List\udp.lst               #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v1.4 -              #
#                    12.06.2013\TESTER S300X (Old)\Obj\udp.o                  #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\core\udp.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support  -  ROUSSET  -
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2006, Atmel Corporation
      5          
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaiimer below.
     13           *
     14           * - Redistributions in binary form must reproduce the above copyright notice,
     15           * this list of conditions and the disclaimer below in the documentation and/or
     16           * other materials provided with the distribution.
     17           *
     18           * Atmel's name may not be used to endorse or promote products derived from
     19           * this software without specific prior written permission.
     20           *
     21           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     22           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     23           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     24           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     25           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     26           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     27           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     28           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     29           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     30           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31           * ----------------------------------------------------------------------------
     32           */
     33          
     34          
     35          extern char znak;
     36          
     37          /*
     38          $Id: udp.c,v 1.1.2.1 2006/12/05 08:33:25 danielru Exp $
     39          */
     40          
     41          //------------------------------------------------------------------------------
     42          //      Includes
     43          //------------------------------------------------------------------------------
     44          
     45          #include "common.h"

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork unsigned int min(unsigned int, unsigned int)
   \                     min:
   \   00000000   8842               CMP      R0,R1
   \   00000002   00D9               BLS      ??min_0
   \   00000004   0800               MOVS     R0,R1
   \                     ??min_0:
   \   00000006   7047               BX       LR               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork signed char lastSetBit(unsigned int)
   \                     lastSetBit:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0100               MOVS     R1,R0
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   C043               MVNS     R0,R0            ;; #-1
   \   00000008   0A0C               LSRS     R2,R1,#+16
   \   0000000A   1204               LSLS     R2,R2,#+16
   \   0000000C   01D0               BEQ      ??lastSetBit_0
   \   0000000E   0F20               MOVS     R0,#+15
   \   00000010   090C               LSRS     R1,R1,#+16
   \                     ??lastSetBit_0:
   \   00000012   FF22               MOVS     R2,#+255
   \   00000014   1202               LSLS     R2,R2,#+8        ;; #+65280
   \   00000016   1142               TST      R1,R2
   \   00000018   03D0               BEQ      ??lastSetBit_1
   \   0000001A   0830               ADDS     R0,R0,#+8
   \   0000001C   0006               LSLS     R0,R0,#+24
   \   0000001E   0016               ASRS     R0,R0,#+24
   \   00000020   090A               LSRS     R1,R1,#+8
   \                     ??lastSetBit_1:
   \   00000022   0A00               MOVS     R2,R1
   \   00000024   F023               MOVS     R3,#+240
   \   00000026   1A42               TST      R2,R3
   \   00000028   03D0               BEQ      ??lastSetBit_2
   \   0000002A   001D               ADDS     R0,R0,#+4
   \   0000002C   0006               LSLS     R0,R0,#+24
   \   0000002E   0016               ASRS     R0,R0,#+24
   \   00000030   0909               LSRS     R1,R1,#+4
   \                     ??lastSetBit_2:
   \   00000032   0A00               MOVS     R2,R1
   \   00000034   0C23               MOVS     R3,#+12
   \   00000036   1A42               TST      R2,R3
   \   00000038   03D0               BEQ      ??lastSetBit_3
   \   0000003A   801C               ADDS     R0,R0,#+2
   \   0000003C   0006               LSLS     R0,R0,#+24
   \   0000003E   0016               ASRS     R0,R0,#+24
   \   00000040   8908               LSRS     R1,R1,#+2
   \                     ??lastSetBit_3:
   \   00000042   0A00               MOVS     R2,R1
   \   00000044   9207               LSLS     R2,R2,#+30
   \   00000046   03D5               BPL      ??lastSetBit_4
   \   00000048   401C               ADDS     R0,R0,#+1
   \   0000004A   0006               LSLS     R0,R0,#+24
   \   0000004C   0016               ASRS     R0,R0,#+24
   \   0000004E   4908               LSRS     R1,R1,#+1
   \                     ??lastSetBit_4:
   \   00000050   C907               LSLS     R1,R1,#+31
   \   00000052   02D5               BPL      ??lastSetBit_5
   \   00000054   401C               ADDS     R0,R0,#+1
   \   00000056   0006               LSLS     R0,R0,#+24
   \   00000058   0016               ASRS     R0,R0,#+24
   \                     ??lastSetBit_5:
   \   0000005A   08BC               POP      {R3}
   \   0000005C   02BC               POP      {R1}
   \   0000005E   0847               BX       R1               ;; return
     46          #include "device.h"
     47          #include "board.h"
     48          #include "trace.h"
     49          #include "usb.h"

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork struct <unnamed> *USB_GetEndpoint(S_usb const *, unsigned char)
   \                     USB_GetEndpoint:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   8268               LDR      R2,[R0, #+8]
   \   00000004   9142               CMP      R1,R2
   \   00000006   01D3               BCC      ??USB_GetEndpoint_0
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   03E0               B        ??USB_GetEndpoint_1
   \                     ??USB_GetEndpoint_0:
   \   0000000C   2822               MOVS     R2,#+40
   \   0000000E   5143               MULS     R1,R2,R1
   \   00000010   4068               LDR      R0,[R0, #+4]
   \   00000012   4018               ADDS     R0,R0,R1
   \                     ??USB_GetEndpoint_1:
   \   00000014   08BC               POP      {R3}
   \   00000016   02BC               POP      {R1}
   \   00000018   0847               BX       R1               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork struct <unnamed> *USB_GetSetup(S_usb const *)
   \                     USB_GetSetup:
   \   00000000   0069               LDR      R0,[R0, #+16]
   \   00000002   7047               BX       LR               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork unsigned int USB_GetDriverID(S_usb const *)
   \                     USB_GetDriverID:
   \   00000000   0068               LDR      R0,[R0, #+0]
   \   00000002   C068               LDR      R0,[R0, #+12]
   \   00000004   7047               BX       LR               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork unsigned int USB_GetDriverPMC(S_usb const *)
   \                     USB_GetDriverPMC:
   \   00000000   0068               LDR      R0,[R0, #+0]
   \   00000002   0069               LDR      R0,[R0, #+16]
   \   00000004   7047               BX       LR               ;; return

   \                                 In section Debug.txt, align 4, keep-with-next
   \   static __??Code16?? __code __interwork void USB_InitCallback(S_usb const *)
   \                     USB_InitCallback:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   C168               LDR      R1,[R0, #+12]
   \   00000004   0968               LDR      R1,[R1, #+0]
   \   00000006   0029               CMP      R1,#+0
   \   00000008   03D0               BEQ      ??USB_InitCallback_0
   \   0000000A   C168               LDR      R1,[R0, #+12]
   \   0000000C   0968               LDR      R1,[R1, #+0]
   \   0000000E   ........           BL       __iar_via_R1
   \                     ??USB_InitCallback_0:
   \   00000012   08BC               POP      {R3}
   \   00000014   01BC               POP      {R0}
   \   00000016   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4, keep-with-next
   \   static __??Code16?? __code __interwork void USB_ResetCallback(S_usb const *)
   \                     USB_ResetCallback:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   C168               LDR      R1,[R0, #+12]
   \   00000004   4968               LDR      R1,[R1, #+4]
   \   00000006   0029               CMP      R1,#+0
   \   00000008   03D0               BEQ      ??USB_ResetCallback_0
   \   0000000A   C168               LDR      R1,[R0, #+12]
   \   0000000C   4968               LDR      R1,[R1, #+4]
   \   0000000E   ........           BL       __iar_via_R1
   \                     ??USB_ResetCallback_0:
   \   00000012   08BC               POP      {R3}
   \   00000014   01BC               POP      {R0}
   \   00000016   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4, keep-with-next
   \   static __??Code16?? __code __interwork void USB_SuspendCallback(S_usb const *)
   \                     USB_SuspendCallback:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   C168               LDR      R1,[R0, #+12]
   \   00000004   8968               LDR      R1,[R1, #+8]
   \   00000006   0029               CMP      R1,#+0
   \   00000008   03D0               BEQ      ??USB_SuspendCallback_0
   \   0000000A   C168               LDR      R1,[R0, #+12]
   \   0000000C   8968               LDR      R1,[R1, #+8]
   \   0000000E   ........           BL       __iar_via_R1
   \                     ??USB_SuspendCallback_0:
   \   00000012   08BC               POP      {R3}
   \   00000014   01BC               POP      {R0}
   \   00000016   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4, keep-with-next
   \   static __??Code16?? __code __interwork void USB_ResumeCallback(S_usb const *)
   \                     USB_ResumeCallback:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   C168               LDR      R1,[R0, #+12]
   \   00000004   C968               LDR      R1,[R1, #+12]
   \   00000006   0029               CMP      R1,#+0
   \   00000008   03D0               BEQ      ??USB_ResumeCallback_0
   \   0000000A   C168               LDR      R1,[R0, #+12]
   \   0000000C   C968               LDR      R1,[R1, #+12]
   \   0000000E   ........           BL       __iar_via_R1
   \                     ??USB_ResumeCallback_0:
   \   00000012   08BC               POP      {R3}
   \   00000014   01BC               POP      {R0}
   \   00000016   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4, keep-with-next
   \   static __??Code16?? __code __interwork void USB_NewRequestCallback(S_usb const *)
   \                     USB_NewRequestCallback:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   C168               LDR      R1,[R0, #+12]
   \   00000004   0969               LDR      R1,[R1, #+16]
   \   00000006   0029               CMP      R1,#+0
   \   00000008   03D0               BEQ      ??USB_NewRequestCallback_0
   \   0000000A   C168               LDR      R1,[R0, #+12]
   \   0000000C   0969               LDR      R1,[R1, #+16]
   \   0000000E   ........           BL       __iar_via_R1
   \                     ??USB_NewRequestCallback_0:
   \   00000012   08BC               POP      {R3}
   \   00000014   01BC               POP      {R0}
   \   00000016   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4, keep-with-next
   \   static __??Code16?? __code __interwork void USB_StartOfFrameCallback(S_usb const *)
   \                     USB_StartOfFrameCallback:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   C168               LDR      R1,[R0, #+12]
   \   00000004   4969               LDR      R1,[R1, #+20]
   \   00000006   ........           BL       __iar_via_R1
   \   0000000A   08BC               POP      {R3}
   \   0000000C   01BC               POP      {R0}
   \   0000000E   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork void USB_Connect(S_usb const *)
   \                     USB_Connect:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0168               LDR      R1,[R0, #+0]
   \   00000004   4969               LDR      R1,[R1, #+20]
   \   00000006   C96A               LDR      R1,[R1, #+44]
   \   00000008   ........           BL       __iar_via_R1
   \   0000000C   08BC               POP      {R3}
   \   0000000E   01BC               POP      {R0}
   \   00000010   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork void USB_Disconnect(S_usb const *)
   \                     USB_Disconnect:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0168               LDR      R1,[R0, #+0]
   \   00000004   4969               LDR      R1,[R1, #+20]
   \   00000006   096B               LDR      R1,[R1, #+48]
   \   00000008   ........           BL       __iar_via_R1
   \   0000000C   08BC               POP      {R3}
   \   0000000E   01BC               POP      {R0}
   \   00000010   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork unsigned int USB_GetState(S_usb const *)
   \                     USB_GetState:
   \   00000000   4069               LDR      R0,[R0, #+20]
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   0004               LSLS     R0,R0,#+16
   \   00000006   000C               LSRS     R0,R0,#+16
   \   00000008   7047               BX       LR               ;; return
     50          
     51          #ifdef UDP
     52          
     53          #define UDP_STATE_SHOULD_RECONNECT      0x10000000
     54          #define UDP_EPTYPE_INDEX                8
     55          #define UDP_EPDIR_INDEX                 10
     56          
     57          #define ISR_MASK                      0x00003FFF
     58          
     59          //------------------------------------------------------------------------------
     60          //      Structures
     61          //------------------------------------------------------------------------------
     62          
     63          // \brief  Endpoint states
     64          typedef enum {
     65          
     66              endpointStateDisabled,
     67              endpointStateIdle,
     68              endpointStateWrite,
     69              endpointStateRead,
     70              endpointStateHalted
     71          
     72          } EndpointState_t;
     73          
     74          //------------------------------------------------------------------------------
     75          //      Macros
     76          //------------------------------------------------------------------------------
     77          
     78          // \brief  Clear flags in the UDP_CSR register and waits for synchronization
     79          // \param  pUsb      Pointer to a S_usb instance
     80          // \param  bEndpoint Index of endpoint
     81          // \param  dFlags    Flags to clear
     82          #define UDP_CLEAREPFLAGS(pUsb, bEndpoint, dFlags) { \
     83              while (!ISCLEARED(UDP_GetDriverInterface(pUsb)->UDP_CSR[bEndpoint], dFlags)) \
     84                  CLEAR(UDP_GetDriverInterface(pUsb)->UDP_CSR[bEndpoint], dFlags); \
     85          }
     86          
     87          // \brief  Set flags in the UDP_CSR register and waits for synchronization
     88          // \param  pUsb      Pointer to a S_usb instance
     89          // \param  bEndpoint Index of endpoint
     90          // \param  dFlags    Flags to clear
     91          #define UDP_SETEPFLAGS(pUsb, bEndpoint, dFlags) { \
     92              while (ISCLEARED(UDP_GetDriverInterface(pUsb)->UDP_CSR[bEndpoint], dFlags)) \
     93                  SET(UDP_GetDriverInterface(pUsb)->UDP_CSR[bEndpoint], dFlags); \
     94          }
     95          
     96          //------------------------------------------------------------------------------
     97          //      Internal Functions
     98          //------------------------------------------------------------------------------
     99          //------------------------------------------------------------------------------
    100          // \brief  Returns a pointer to the UDP controller interface used by an USB
    101          //         driver
    102          //
    103          //         The pointer is cast to the correct type (AT91PS_UDP).
    104          // \param  pUsb Pointer to a S_usb instance
    105          // \return Pointer to the USB controller interface
    106          // \see    S_usb
    107          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    108          extern __inline AT91PS_UDP UDP_GetDriverInterface(const S_usb *pUsb)
    109          {
    110              return (AT91PS_UDP) pUsb->pDriver->pInterface;
   \                     UDP_GetDriverInterface:
   \   00000000   0068               LDR      R0,[R0, #+0]
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   7047               BX       LR               ;; return
    111          }
    112          
    113          //------------------------------------------------------------------------------
    114          // \brief  Enables the peripheral clock of the USB controller associated with
    115          //         the specified USB driver
    116          // \param  pUsb Pointer to a S_usb instance
    117          // \see    S_usb
    118          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    119          extern __inline void UDP_EnableMCK(const S_usb *pUsb)
    120          {
   \                     UDP_EnableMCK:
   \   00000000   10B5               PUSH     {R4,LR}
    121              AT91C_BASE_PMC->PMC_PCER = 1 << USB_GetDriverID(pUsb);
   \   00000002   0124               MOVS     R4,#+1
   \   00000004   ........           BL       USB_GetDriverID
   \   00000008   8440               LSLS     R4,R4,R0
   \   0000000A   0248               LDR      R0,??UDP_EnableMCK_0  ;; 0xfffffc10
   \   0000000C   0460               STR      R4,[R0, #+0]
    122          }
   \   0000000E   10BC               POP      {R4}
   \   00000010   01BC               POP      {R0}
   \   00000012   0047               BX       R0               ;; return
   \                     ??UDP_EnableMCK_0:
   \   00000014   10FCFFFF           DC32     0xfffffc10
    123          
    124          //------------------------------------------------------------------------------
    125          // \brief  Disables the peripheral clock of the USB controller associated with
    126          //         the specified USB driver
    127          // \param  pUsb Pointer to a S_usb instance
    128          // \see    S_usb
    129          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    130          extern __inline void UDP_DisableMCK(const S_usb *pUsb)
    131          {
   \                     UDP_DisableMCK:
   \   00000000   10B5               PUSH     {R4,LR}
    132              AT91C_BASE_PMC->PMC_PCDR = 1 << USB_GetDriverID(pUsb);
   \   00000002   0124               MOVS     R4,#+1
   \   00000004   ........           BL       USB_GetDriverID
   \   00000008   8440               LSLS     R4,R4,R0
   \   0000000A   0248               LDR      R0,??UDP_DisableMCK_0  ;; 0xfffffc14
   \   0000000C   0460               STR      R4,[R0, #+0]
    133          }
   \   0000000E   10BC               POP      {R4}
   \   00000010   01BC               POP      {R0}
   \   00000012   0047               BX       R0               ;; return
   \                     ??UDP_DisableMCK_0:
   \   00000014   14FCFFFF           DC32     0xfffffc14
    134          
    135          //------------------------------------------------------------------------------
    136          // \brief  Enables the 48MHz clock of the USB controller associated with
    137          //         the specified USB driver
    138          // \param  pUsb Pointer to a S_usb instance
    139          // \see    S_usb
    140          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    141          extern __inline void UDP_EnableUDPCK(const S_usb *pUsb)
    142          {
   \                     UDP_EnableUDPCK:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    143              SET(AT91C_BASE_PMC->PMC_SCER, USB_GetDriverPMC(pUsb));
   \   00000002   044C               LDR      R4,??UDP_EnableUDPCK_0  ;; 0xfffffc00
   \   00000004   2568               LDR      R5,[R4, #+0]
   \   00000006   ........           BL       USB_GetDriverPMC
   \   0000000A   2843               ORRS     R0,R0,R5
   \   0000000C   2060               STR      R0,[R4, #+0]
    144          }
   \   0000000E   38BC               POP      {R3-R5}
   \   00000010   01BC               POP      {R0}
   \   00000012   0047               BX       R0               ;; return
   \                     ??UDP_EnableUDPCK_0:
   \   00000014   00FCFFFF           DC32     0xfffffc00
    145          
    146          //------------------------------------------------------------------------------
    147          // \brief  Disables the 48MHz clock of the USB controller associated with
    148          //         the specified USB driver
    149          // \param  pUsb Pointer to a S_usb instance
    150          // \see    S_usb
    151          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    152          extern __inline void UDP_DisableUDPCK(const S_usb *pUsb)
    153          {
   \                     UDP_DisableUDPCK:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    154              SET(AT91C_BASE_PMC->PMC_SCDR, USB_GetDriverPMC(pUsb));
   \   00000002   044C               LDR      R4,??UDP_DisableUDPCK_0  ;; 0xfffffc04
   \   00000004   2568               LDR      R5,[R4, #+0]
   \   00000006   ........           BL       USB_GetDriverPMC
   \   0000000A   2843               ORRS     R0,R0,R5
   \   0000000C   2060               STR      R0,[R4, #+0]
    155          }
   \   0000000E   38BC               POP      {R3-R5}
   \   00000010   01BC               POP      {R0}
   \   00000012   0047               BX       R0               ;; return
   \                     ??UDP_DisableUDPCK_0:
   \   00000014   04FCFFFF           DC32     0xfffffc04
    156          
    157          //------------------------------------------------------------------------------
    158          // \brief  Enables the transceiver of the USB controller associated with
    159          //         the specified USB driver
    160          // \param  pUsb Pointer to a S_usb instance
    161          // \see    S_usb
    162          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    163          extern __inline void UDP_EnableTransceiver(const S_usb *pUsb)
    164          {
   \                     UDP_EnableTransceiver:
   \   00000000   01B5               PUSH     {R0,LR}
    165              CLEAR(UDP_GetDriverInterface(pUsb)->UDP_TXVC, AT91C_UDP_TXVDIS);
   \   00000002   ........           BL       UDP_GetDriverInterface
   \   00000006   416F               LDR      R1,[R0, #+116]
   \   00000008   024A               LDR      R2,??UDP_EnableTransceiver_0  ;; 0xfffffeff
   \   0000000A   0A40               ANDS     R2,R2,R1
   \   0000000C   4267               STR      R2,[R0, #+116]
    166          }
   \   0000000E   08BC               POP      {R3}
   \   00000010   01BC               POP      {R0}
   \   00000012   0047               BX       R0               ;; return
   \                     ??UDP_EnableTransceiver_0:
   \   00000014   FFFEFFFF           DC32     0xfffffeff
    167          
    168          //------------------------------------------------------------------------------
    169          // \brief  Disables the transceiver of the USB controller associated with
    170          //         the specified USB driver
    171          // \param  pUsb Pointer to a S_usb instance
    172          // \see    S_usb
    173          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    174          extern __inline void UDP_DisableTransceiver(const S_usb *pUsb)
    175          {
   \                     UDP_DisableTransceiver:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    176              SET(UDP_GetDriverInterface(pUsb)->UDP_TXVC, AT91C_UDP_TXVDIS);
   \   00000004   ........           BL       UDP_GetDriverInterface
   \   00000008   0500               MOVS     R5,R0
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       UDP_GetDriverInterface
   \   00000010   406F               LDR      R0,[R0, #+116]
   \   00000012   8021               MOVS     R1,#+128
   \   00000014   4900               LSLS     R1,R1,#+1        ;; #+256
   \   00000016   0143               ORRS     R1,R1,R0
   \   00000018   6967               STR      R1,[R5, #+116]
    177          }
   \   0000001A   38BC               POP      {R3-R5}
   \   0000001C   01BC               POP      {R0}
   \   0000001E   0047               BX       R0               ;; return
    178          
    179          //------------------------------------------------------------------------------
    180          // \brief  Invokes the callback associated with a finished transfer on an
    181          //         endpoint
    182          // \param  pEndpoint Pointer to a S_usb_endpoint instance
    183          // \param  bStatus   Status code returned by the transfer operation
    184          // \see    Status codes
    185          // \see    S_usb_endpoint
    186          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    187          extern __inline void UDP_EndOfTransfer(S_usb_endpoint *pEndpoint,
    188                                                 char bStatus)
    189          {
   \                     UDP_EndOfTransfer:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    190              if ((pEndpoint->dState == endpointStateWrite)
    191                  || (pEndpoint->dState == endpointStateRead)) 
   \   00000004   606A               LDR      R0,[R4, #+36]
   \   00000006   0228               CMP      R0,#+2
   \   00000008   02D0               BEQ      ??UDP_EndOfTransfer_0
   \   0000000A   606A               LDR      R0,[R4, #+36]
   \   0000000C   0328               CMP      R0,#+3
   \   0000000E   0CD1               BNE      ??UDP_EndOfTransfer_1
    192              {
    193          
    194                                                                                         // TRACE_DEBUG_L("EoT ");
    195          
    196                  // Endpoint returns in Idle state
    197                  pEndpoint->dState = endpointStateIdle;
   \                     ??UDP_EndOfTransfer_0:
   \   00000010   0120               MOVS     R0,#+1
   \   00000012   6062               STR      R0,[R4, #+36]
    198                                                                                          
    199                  // Invoke callback is present
    200                  if (pEndpoint->fCallback != 0) 
   \   00000014   2069               LDR      R0,[R4, #+16]
   \   00000016   0028               CMP      R0,#+0
   \   00000018   07D0               BEQ      ??UDP_EndOfTransfer_1
    201                  {                                                                      
    202          
    203                      pEndpoint->fCallback((unsigned int) pEndpoint->pArgument,
    204                                           (unsigned int) bStatus,
    205                                           pEndpoint->dBytesTransferred,
    206                                           pEndpoint->dBytesRemaining
    207                                           + pEndpoint->dBytesBuffered);
   \   0000001A   6068               LDR      R0,[R4, #+4]
   \   0000001C   A268               LDR      R2,[R4, #+8]
   \   0000001E   8318               ADDS     R3,R0,R2
   \   00000020   E268               LDR      R2,[R4, #+12]
   \   00000022   6069               LDR      R0,[R4, #+20]
   \   00000024   2469               LDR      R4,[R4, #+16]
   \   00000026   ........           BL       __iar_via_R4
    208                                                                                          
    209                  }
    210                  
    211              }
    212                                                                                          //TRACE_DEBUG_L("KON_EoT ");
    213          }
   \                     ??UDP_EndOfTransfer_1:
   \   0000002A   10BC               POP      {R4}
   \   0000002C   01BC               POP      {R0}
   \   0000002E   0047               BX       R0               ;; return
    214          
    215          //------------------------------------------------------------------------------
    216          // \brief  Clears the correct RX flag in an endpoint status register
    217          // \param  pUsb      Pointer to a S_usb instance
    218          // \param  bEndpoint Index of endpoint
    219          // \see    S_usb_endpoint
    220          // \see    S_usb
    221          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    222          static void UDP_ClearRXFlag(const S_usb * pUsb,
    223                                      unsigned char bEndpoint)
    224          {
   \                     UDP_ClearRXFlag:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    225              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   00000006   ........           BL       USB_GetEndpoint
   \   0000000A   0600               MOVS     R6,R0
   \   0000000C   AF00               LSLS     R7,R5,#+2
   \   0000000E   07E0               B        ??UDP_ClearRXFlag_0
    226          
    227              // Clear flag
    228              UDP_CLEAREPFLAGS(pUsb, bEndpoint, pEndpoint->dFlag);
   \                     ??UDP_ClearRXFlag_1:
   \   00000010   2000               MOVS     R0,R4
   \   00000012   ........           BL       UDP_GetDriverInterface
   \   00000016   C019               ADDS     R0,R0,R7
   \   00000018   016B               LDR      R1,[R0, #+48]
   \   0000001A   F269               LDR      R2,[R6, #+28]
   \   0000001C   9143               BICS     R1,R1,R2
   \   0000001E   0163               STR      R1,[R0, #+48]
   \                     ??UDP_ClearRXFlag_0:
   \   00000020   2000               MOVS     R0,R4
   \   00000022   ........           BL       UDP_GetDriverInterface
   \   00000026   C019               ADDS     R0,R0,R7
   \   00000028   006B               LDR      R0,[R0, #+48]
   \   0000002A   F169               LDR      R1,[R6, #+28]
   \   0000002C   0140               ANDS     R1,R1,R0
   \   0000002E   EFD1               BNE      ??UDP_ClearRXFlag_1
    229          
    230              // Swap banks
    231              if (pEndpoint->dFlag == AT91C_UDP_RX_DATA_BK0) {
   \   00000030   F069               LDR      R0,[R6, #+28]
   \   00000032   0228               CMP      R0,#+2
   \   00000034   06D1               BNE      ??UDP_ClearRXFlag_2
    232          
    233                  if (pEndpoint->dNumFIFO > 1) {
   \   00000036   2020               MOVS     R0,#+32
   \   00000038   305C               LDRB     R0,[R6, R0]
   \   0000003A   0228               CMP      R0,#+2
   \   0000003C   04D3               BCC      ??UDP_ClearRXFlag_3
    234          
    235                      // Swap bank if in dual-fifo mode
    236                      pEndpoint->dFlag = AT91C_UDP_RX_DATA_BK1;
   \   0000003E   4020               MOVS     R0,#+64
   \   00000040   F061               STR      R0,[R6, #+28]
   \   00000042   01E0               B        ??UDP_ClearRXFlag_3
    237                  }
    238              }
    239              else {
    240          
    241                  pEndpoint->dFlag = AT91C_UDP_RX_DATA_BK0;
   \                     ??UDP_ClearRXFlag_2:
   \   00000044   0220               MOVS     R0,#+2
   \   00000046   F061               STR      R0,[R6, #+28]
    242              }
    243          }
   \                     ??UDP_ClearRXFlag_3:
   \   00000048   F8BC               POP      {R3-R7}
   \   0000004A   01BC               POP      {R0}
   \   0000004C   0047               BX       R0               ;; return
    244          
    245          //------------------------------------------------------------------------------
    246          // \brief  Transfers a data payload from the current tranfer buffer to the
    247          //         endpoint FIFO.
    248          // \param  pUsb      Pointer to a S_usb instance
    249          // \param  bEndpoint Index of endpoint
    250          // \return Number of bytes transferred
    251          // \see    S_usb
    252          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    253          static unsigned int UDP_WritePayload(const S_usb * pUsb,
    254                                               unsigned char bEndpoint)
    255          {
   \                     UDP_WritePayload:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0C00               MOVS     R4,R1
    256              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000006   ........           BL       UDP_GetDriverInterface
   \   0000000A   0500               MOVS     R5,R0
    257              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   0000000C   2100               MOVS     R1,R4
   \   0000000E   3000               MOVS     R0,R6
   \   00000010   ........           BL       USB_GetEndpoint
   \   00000014   0600               MOVS     R6,R0
    258              unsigned int   dBytes;
    259              unsigned int   dCtr;
    260          
    261              // Get the number of bytes to send
    262              dBytes = min(pEndpoint->wMaxPacketSize, pEndpoint->dBytesRemaining);
   \   00000016   7168               LDR      R1,[R6, #+4]
   \   00000018   B069               LDR      R0,[R6, #+24]
   \   0000001A   ........           BL       min
    263          
    264              // Transfer one packet in the FIFO buffer
    265              for (dCtr = 0; dCtr < dBytes; dCtr++) {
   \   0000001E   0021               MOVS     R1,#+0
   \   00000020   08E0               B        ??UDP_WritePayload_0
    266          
    267                  pInterface->UDP_FDR[bEndpoint] = *(pEndpoint->pData);
   \                     ??UDP_WritePayload_1:
   \   00000022   A200               LSLS     R2,R4,#+2
   \   00000024   AA18               ADDS     R2,R5,R2
   \   00000026   3368               LDR      R3,[R6, #+0]
   \   00000028   1B78               LDRB     R3,[R3, #+0]
   \   0000002A   1365               STR      R3,[R2, #+80]
    268                  pEndpoint->pData++;
   \   0000002C   3268               LDR      R2,[R6, #+0]
   \   0000002E   521C               ADDS     R2,R2,#+1
   \   00000030   3260               STR      R2,[R6, #+0]
    269              }
   \   00000032   491C               ADDS     R1,R1,#+1
   \                     ??UDP_WritePayload_0:
   \   00000034   8142               CMP      R1,R0
   \   00000036   F4D3               BCC      ??UDP_WritePayload_1
    270          
    271              pEndpoint->dBytesBuffered += dBytes;
   \   00000038   B168               LDR      R1,[R6, #+8]
   \   0000003A   0918               ADDS     R1,R1,R0
   \   0000003C   B160               STR      R1,[R6, #+8]
    272              pEndpoint->dBytesRemaining -= dBytes;
   \   0000003E   7168               LDR      R1,[R6, #+4]
   \   00000040   091A               SUBS     R1,R1,R0
   \   00000042   7160               STR      R1,[R6, #+4]
    273          
    274              return dBytes;
   \   00000044   70BC               POP      {R4-R6}
   \   00000046   02BC               POP      {R1}
   \   00000048   0847               BX       R1               ;; return
    275          }
    276          
    277          //------------------------------------------------------------------------------
    278          // \brief  Transfers a data payload from an endpoint FIFO to the current
    279          //         transfer buffer.
    280          // \param  pUsb        Pointer to a S_usb instance
    281          // \param  bEndpoint   Index of endpoint
    282          // \param  wPacketSize Size of received data packet
    283          // \return Number of bytes transferred
    284          // \see    S_usb
    285          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    286          static unsigned int UDP_GetPayload(const S_usb * pUsb,
    287                                             unsigned char bEndpoint,
    288                                             unsigned short wPacketSize)
    289          {
   \                     UDP_GetPayload:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0C00               MOVS     R4,R1
   \   00000006   1700               MOVS     R7,R2
    290              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000008   ........           BL       UDP_GetDriverInterface
   \   0000000C   0500               MOVS     R5,R0
    291              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   0000000E   2100               MOVS     R1,R4
   \   00000010   3000               MOVS     R0,R6
   \   00000012   ........           BL       USB_GetEndpoint
   \   00000016   0600               MOVS     R6,R0
    292              unsigned int   dBytes;
    293              unsigned int   dCtr;
    294          
    295                                                                                          //TRACE_DEBUG_L("IN_GetPayLoad ");
    296              // Get number of bytes to retrieve
    297              dBytes = min(pEndpoint->dBytesRemaining, wPacketSize);
   \   00000018   3900               MOVS     R1,R7
   \   0000001A   7068               LDR      R0,[R6, #+4]
   \   0000001C   ........           BL       min
    298          
    299              // Retrieve packet
    300              for (dCtr = 0; dCtr < dBytes; dCtr++) {
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   08E0               B        ??UDP_GetPayload_0
    301          
    302                  *pEndpoint->pData = (char) pInterface->UDP_FDR[bEndpoint];
   \                     ??UDP_GetPayload_1:
   \   00000024   3268               LDR      R2,[R6, #+0]
   \   00000026   A300               LSLS     R3,R4,#+2
   \   00000028   EB18               ADDS     R3,R5,R3
   \   0000002A   1B6D               LDR      R3,[R3, #+80]
   \   0000002C   1370               STRB     R3,[R2, #+0]
    303                  pEndpoint->pData++;
   \   0000002E   3268               LDR      R2,[R6, #+0]
   \   00000030   521C               ADDS     R2,R2,#+1
   \   00000032   3260               STR      R2,[R6, #+0]
    304                  
    305              }
   \   00000034   491C               ADDS     R1,R1,#+1
   \                     ??UDP_GetPayload_0:
   \   00000036   8142               CMP      R1,R0
   \   00000038   F4D3               BCC      ??UDP_GetPayload_1
    306          
    307              pEndpoint->dBytesRemaining -= dBytes;
   \   0000003A   7168               LDR      R1,[R6, #+4]
   \   0000003C   091A               SUBS     R1,R1,R0
   \   0000003E   7160               STR      R1,[R6, #+4]
    308              pEndpoint->dBytesTransferred += dBytes;
   \   00000040   F168               LDR      R1,[R6, #+12]
   \   00000042   0918               ADDS     R1,R1,R0
   \   00000044   F160               STR      R1,[R6, #+12]
    309              pEndpoint->dBytesBuffered += wPacketSize - dBytes;
   \   00000046   B168               LDR      R1,[R6, #+8]
   \   00000048   C919               ADDS     R1,R1,R7
   \   0000004A   091A               SUBS     R1,R1,R0
   \   0000004C   B160               STR      R1,[R6, #+8]
    310                                                                                          //TRACE_DEBUG_L("KON_GetPayLoad ");
    311              return dBytes;
   \   0000004E   F8BC               POP      {R3-R7}
   \   00000050   02BC               POP      {R1}
   \   00000052   0847               BX       R1               ;; return
    312                                                                                
    313          }
    314          
    315          //------------------------------------------------------------------------------
    316          // \brief  Transfers a received SETUP packet from endpoint 0 FIFO to the
    317          //         S_usb_request structure of an USB driver
    318          // \param  pUsb Pointer to a S_usb instance
    319          // \see    S_usb
    320          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    321          static void UDP_GetSetup(S_usb const *pUsb)
    322          {
   \                     UDP_GetSetup:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    323              char *pData = (char *) USB_GetSetup(pUsb);
   \   00000004   ........           BL       USB_GetSetup
   \   00000008   0500               MOVS     R5,R0
    324              AT91PS_UDP pInterface = UDP_GetDriverInterface(pUsb);
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       UDP_GetDriverInterface
    325              unsigned int dCtr;
    326          
    327              // Copy packet
    328              for (dCtr = 0; dCtr < 8; dCtr++) {
   \   00000010   0021               MOVS     R1,#+0
   \   00000012   03E0               B        ??UDP_GetSetup_0
    329          
    330                  *pData = (char) pInterface->UDP_FDR[0];
   \                     ??UDP_GetSetup_1:
   \   00000014   026D               LDR      R2,[R0, #+80]
   \   00000016   2A70               STRB     R2,[R5, #+0]
    331                  pData++;
   \   00000018   6D1C               ADDS     R5,R5,#+1
    332              }
   \   0000001A   491C               ADDS     R1,R1,#+1
   \                     ??UDP_GetSetup_0:
   \   0000001C   0829               CMP      R1,#+8
   \   0000001E   F9D3               BCC      ??UDP_GetSetup_1
    333          }
   \   00000020   38BC               POP      {R3-R5}
   \   00000022   01BC               POP      {R0}
   \   00000024   0047               BX       R0               ;; return
    334          
    335          //------------------------------------------------------------------------------
    336          // \brief  This function reset all endpoint transfer descriptors
    337          // \param  pUsb Pointer to a S_usb instance
    338          // \see    S_usb
    339          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    340          static void UDP_ResetEndpoints(const S_usb *pUsb)
    341          {
   \                     UDP_ResetEndpoints:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
    342              S_usb_endpoint *pEndpoint;
    343              unsigned char bEndpoint;
    344          
    345              // Reset the transfer descriptor of every endpoint
    346              for (bEndpoint = 0; bEndpoint < pUsb->dNumEndpoints; bEndpoint++) {
   \   00000004   0025               MOVS     R5,#+0
   \   00000006   2E00               MOVS     R6,R5
   \   00000008   0FE0               B        ??UDP_ResetEndpoints_0
    347          
    348                  pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \                     ??UDP_ResetEndpoints_1:
   \   0000000A   3100               MOVS     R1,R6
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       USB_GetEndpoint
    349          
    350                  // Reset endpoint transfer descriptor
    351                  pEndpoint->pData = 0;
   \   00000012   0560               STR      R5,[R0, #+0]
    352                  pEndpoint->dBytesRemaining = 0;
   \   00000014   4560               STR      R5,[R0, #+4]
    353                  pEndpoint->dBytesTransferred = 0;
   \   00000016   C560               STR      R5,[R0, #+12]
    354                  pEndpoint->dBytesBuffered = 0;
   \   00000018   8560               STR      R5,[R0, #+8]
    355                  pEndpoint->fCallback = 0;
   \   0000001A   0561               STR      R5,[R0, #+16]
    356                  pEndpoint->pArgument = 0;
   \   0000001C   4561               STR      R5,[R0, #+20]
    357          
    358                  // Configure endpoint characteristics
    359                  pEndpoint->dFlag = AT91C_UDP_RX_DATA_BK0;
   \   0000001E   0221               MOVS     R1,#+2
   \   00000020   C161               STR      R1,[R0, #+28]
    360                  pEndpoint->dState = endpointStateDisabled;
   \   00000022   4562               STR      R5,[R0, #+36]
    361              }
   \   00000024   761C               ADDS     R6,R6,#+1
   \   00000026   3606               LSLS     R6,R6,#+24
   \   00000028   360E               LSRS     R6,R6,#+24
   \                     ??UDP_ResetEndpoints_0:
   \   0000002A   A068               LDR      R0,[R4, #+8]
   \   0000002C   8642               CMP      R6,R0
   \   0000002E   ECD3               BCC      ??UDP_ResetEndpoints_1
    362          }
   \   00000030   70BC               POP      {R4-R6}
   \   00000032   01BC               POP      {R0}
   \   00000034   0047               BX       R0               ;; return
    363          
    364          //------------------------------------------------------------------------------
    365          // \brief  Disable all endpoints (except control endpoint 0), aborting current
    366          //         transfers if necessary.
    367          // \param  pUsb Pointer to a S_usb instance
    368          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    369          static void UDP_DisableEndpoints(const S_usb *pUsb)
    370          {
   \                     UDP_DisableEndpoints:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
    371              S_usb_endpoint *pEndpoint;
    372              unsigned char bEndpoint;
    373          
    374              // For each endpoint, if it is enabled, disable it and invoke the callback
    375              // Control endpoint 0 is not disabled
    376              for (bEndpoint = 1; bEndpoint < pUsb->dNumEndpoints; bEndpoint++) {
   \   00000004   0125               MOVS     R5,#+1
   \   00000006   0CE0               B        ??UDP_DisableEndpoints_0
    377          
    378                  pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \                     ??UDP_DisableEndpoints_1:
   \   00000008   2900               MOVS     R1,R5
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       USB_GetEndpoint
   \   00000010   0600               MOVS     R6,R0
    379                  UDP_EndOfTransfer(pEndpoint, USB_STATUS_RESET);
   \   00000012   0321               MOVS     R1,#+3
   \   00000014   ........           BL       UDP_EndOfTransfer
    380                  pEndpoint->dState = endpointStateDisabled;
   \   00000018   0020               MOVS     R0,#+0
   \   0000001A   7062               STR      R0,[R6, #+36]
    381              }
   \   0000001C   6D1C               ADDS     R5,R5,#+1
   \   0000001E   2D06               LSLS     R5,R5,#+24
   \   00000020   2D0E               LSRS     R5,R5,#+24
   \                     ??UDP_DisableEndpoints_0:
   \   00000022   A068               LDR      R0,[R4, #+8]
   \   00000024   8542               CMP      R5,R0
   \   00000026   EFD3               BCC      ??UDP_DisableEndpoints_1
    382          }
   \   00000028   70BC               POP      {R4-R6}
   \   0000002A   01BC               POP      {R0}
   \   0000002C   0047               BX       R0               ;; return
    383          
    384          //------------------------------------------------------------------------------
    385          // \brief  Endpoint interrupt handler.
    386          //
    387          //         Handle IN/OUT transfers, received SETUP packets and STALLing
    388          // \param  pUsb      Pointer to a S_usb instance
    389          // \param  bEndpoint Index of endpoint
    390          // \see    S_usb
    391          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    392          static void UDP_EndpointHandler(const S_usb *pUsb, unsigned char bEndpoint)
    393          {
   \                     UDP_EndpointHandler:
   \   00000000   F2B5               PUSH     {R1,R4-R7,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0400               MOVS     R4,R0
    394              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   00000006   ........           BL       USB_GetEndpoint
   \   0000000A   0500               MOVS     R5,R0
    395              AT91PS_UDP pInterface = UDP_GetDriverInterface(pUsb);
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       UDP_GetDriverInterface
   \   00000012   0090               STR      R0,[SP, #+0]
    396              unsigned int dStatus = pInterface->UDP_CSR[bEndpoint];
   \   00000014   6846               MOV      R0,SP
   \   00000016   007A               LDRB     R0,[R0, #+8]
   \   00000018   8600               LSLS     R6,R0,#+2
   \   0000001A   0098               LDR      R0,[SP, #+0]
   \   0000001C   8019               ADDS     R0,R0,R6
   \   0000001E   076B               LDR      R7,[R0, #+48]
    397          
    398                                                                                          //TRACE_DEBUG_L("Ept%d ", bEndpoint);
    399          
    400              // Handle interrupts
    401              
    402              // IN packet sent
    403              if (ISSET(dStatus, AT91C_UDP_TXCOMP)) 
   \   00000020   3800               MOVS     R0,R7
   \   00000022   C007               LSLS     R0,R0,#+31
   \   00000024   78D5               BPL      ??UDP_EndpointHandler_0
    404              {
    405          
    406                                                                                          //TRACE_DEBUG_L("Wr ");
    407          
    408                  // Check that endpoint was in Write state
    409                  if (pEndpoint->dState == endpointStateWrite) 
   \   00000026   686A               LDR      R0,[R5, #+36]
   \   00000028   0228               CMP      R0,#+2
   \   0000002A   6ED1               BNE      ??UDP_EndpointHandler_1
    410                  {
    411                                                                                          
    412                   
    413                                                                                          
    414                      // End of transfer ?
    415                      if ((pEndpoint->dBytesBuffered < pEndpoint->wMaxPacketSize)
    416          
    417                          ||
    418                          (!ISCLEARED(dStatus, AT91C_UDP_EPTYPE)
    419                           && (pEndpoint->dBytesRemaining == 0)
    420                           && (pEndpoint->dBytesBuffered == pEndpoint->wMaxPacketSize))) 
   \   0000002C   E020               MOVS     R0,#+224
   \   0000002E   C000               LSLS     R0,R0,#+3        ;; #+1792
   \   00000030   A968               LDR      R1,[R5, #+8]
   \   00000032   AA69               LDR      R2,[R5, #+24]
   \   00000034   9142               CMP      R1,R2
   \   00000036   07D3               BCC      ??UDP_EndpointHandler_2
   \   00000038   0742               TST      R7,R0
   \   0000003A   1BD0               BEQ      ??UDP_EndpointHandler_3
   \   0000003C   6968               LDR      R1,[R5, #+4]
   \   0000003E   0029               CMP      R1,#+0
   \   00000040   18D1               BNE      ??UDP_EndpointHandler_3
   \   00000042   A968               LDR      R1,[R5, #+8]
   \   00000044   9142               CMP      R1,R2
   \   00000046   15D1               BNE      ??UDP_EndpointHandler_3
    421                      {
    422          
    423                                                                                          
    424                                                                                         // TRACE_DEBUG_L("%d ", pEndpoint->dBytesBuffered);
    425          
    426                          pEndpoint->dBytesTransferred += pEndpoint->dBytesBuffered;
   \                     ??UDP_EndpointHandler_2:
   \   00000048   E968               LDR      R1,[R5, #+12]
   \   0000004A   AA68               LDR      R2,[R5, #+8]
   \   0000004C   8918               ADDS     R1,R1,R2
   \   0000004E   E960               STR      R1,[R5, #+12]
    427                          pEndpoint->dBytesBuffered = 0;
   \   00000050   0021               MOVS     R1,#+0
   \   00000052   A960               STR      R1,[R5, #+8]
    428          
    429                          // Disable interrupt if this is not a control endpoint
    430                          if (!ISCLEARED(dStatus, AT91C_UDP_EPTYPE)) 
   \   00000054   0742               TST      R7,R0
   \   00000056   08D0               BEQ      ??UDP_EndpointHandler_4
    431                          {
    432                                                                                          
    433                              SET(pInterface->UDP_IDR, 1 << bEndpoint);
   \   00000058   0098               LDR      R0,[SP, #+0]
   \   0000005A   0100               MOVS     R1,R0
   \   0000005C   4A69               LDR      R2,[R1, #+20]
   \   0000005E   0121               MOVS     R1,#+1
   \   00000060   6B46               MOV      R3,SP
   \   00000062   1B7A               LDRB     R3,[R3, #+8]
   \   00000064   9940               LSLS     R1,R1,R3
   \   00000066   1143               ORRS     R1,R1,R2
   \   00000068   4161               STR      R1,[R0, #+20]
    434                          }
    435          
    436                          UDP_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
   \                     ??UDP_EndpointHandler_4:
   \   0000006A   0021               MOVS     R1,#+0
   \   0000006C   2800               MOVS     R0,R5
   \   0000006E   ........           BL       UDP_EndOfTransfer
   \   00000072   4AE0               B        ??UDP_EndpointHandler_1
    437                      }
    438                      
    439                      else 
    440                      {
    441                                                                                          
    442                     
    443                          // Transfer remaining data
    444                                                                                          TRACE_DEBUG_L("%d ", pEndpoint->wMaxPacketSize);
    445          
    446                          pEndpoint->dBytesTransferred += pEndpoint->wMaxPacketSize;
   \                     ??UDP_EndpointHandler_3:
   \   00000074   E868               LDR      R0,[R5, #+12]
   \   00000076   1100               MOVS     R1,R2
   \   00000078   4018               ADDS     R0,R0,R1
   \   0000007A   E860               STR      R0,[R5, #+12]
    447                          pEndpoint->dBytesBuffered -= pEndpoint->wMaxPacketSize;
   \   0000007C   A868               LDR      R0,[R5, #+8]
   \   0000007E   401A               SUBS     R0,R0,R1
   \   00000080   A860               STR      R0,[R5, #+8]
   \   00000082   2020               MOVS     R0,#+32
   \   00000084   285C               LDRB     R0,[R5, R0]
   \   00000086   0128               CMP      R0,#+1
   \   00000088   29D1               BNE      ??UDP_EndpointHandler_5
    448          
    449                          // Send next packet
    450                          if (pEndpoint->dNumFIFO == 1) {
    451          
    452                              // No double buffering
    453                              UDP_WritePayload(pUsb, bEndpoint);
   \   0000008A   6846               MOV      R0,SP
   \   0000008C   017A               LDRB     R1,[R0, #+8]
   \   0000008E   2000               MOVS     R0,R4
   \   00000090   ........           BL       UDP_WritePayload
    454                              UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_TXPKTRDY);
   \                     ??UDP_EndpointHandler_6:
   \   00000094   2000               MOVS     R0,R4
   \   00000096   ........           BL       UDP_GetDriverInterface
   \   0000009A   8019               ADDS     R0,R0,R6
   \   0000009C   006B               LDR      R0,[R0, #+48]
   \   0000009E   1021               MOVS     R1,#+16
   \   000000A0   0842               TST      R0,R1
   \   000000A2   32D1               BNE      ??UDP_EndpointHandler_1
   \   000000A4   2000               MOVS     R0,R4
   \   000000A6   ........           BL       UDP_GetDriverInterface
   \   000000AA   0190               STR      R0,[SP, #+4]
   \   000000AC   2000               MOVS     R0,R4
   \   000000AE   ........           BL       UDP_GetDriverInterface
   \   000000B2   8019               ADDS     R0,R0,R6
   \   000000B4   006B               LDR      R0,[R0, #+48]
   \   000000B6   1021               MOVS     R1,#+16
   \   000000B8   0143               ORRS     R1,R1,R0
   \   000000BA   0198               LDR      R0,[SP, #+4]
   \   000000BC   8019               ADDS     R0,R0,R6
   \   000000BE   0163               STR      R1,[R0, #+48]
   \   000000C0   E8E7               B        ??UDP_EndpointHandler_6
    455                          }
    456                          else {
    457          
    458                              // Double buffering
    459                              UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_TXPKTRDY);
   \                     ??UDP_EndpointHandler_7:
   \   000000C2   2000               MOVS     R0,R4
   \   000000C4   ........           BL       UDP_GetDriverInterface
   \   000000C8   0190               STR      R0,[SP, #+4]
   \   000000CA   2000               MOVS     R0,R4
   \   000000CC   ........           BL       UDP_GetDriverInterface
   \   000000D0   8019               ADDS     R0,R0,R6
   \   000000D2   006B               LDR      R0,[R0, #+48]
   \   000000D4   1021               MOVS     R1,#+16
   \   000000D6   0143               ORRS     R1,R1,R0
   \   000000D8   0198               LDR      R0,[SP, #+4]
   \   000000DA   8019               ADDS     R0,R0,R6
   \   000000DC   0163               STR      R1,[R0, #+48]
   \                     ??UDP_EndpointHandler_5:
   \   000000DE   2000               MOVS     R0,R4
   \   000000E0   ........           BL       UDP_GetDriverInterface
   \   000000E4   8019               ADDS     R0,R0,R6
   \   000000E6   006B               LDR      R0,[R0, #+48]
   \   000000E8   1021               MOVS     R1,#+16
   \   000000EA   0842               TST      R0,R1
   \   000000EC   E9D0               BEQ      ??UDP_EndpointHandler_7
    460                              UDP_WritePayload(pUsb, bEndpoint);
   \   000000EE   6846               MOV      R0,SP
   \   000000F0   017A               LDRB     R1,[R0, #+8]
   \   000000F2   2000               MOVS     R0,R4
   \   000000F4   ........           BL       UDP_WritePayload
   \   000000F8   07E0               B        ??UDP_EndpointHandler_1
    461                          }
    462                      }
    463                  }
    464          
    465                  
    466                  
    467                  
    468                  // Acknowledge interrupt
    469                  UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_TXCOMP);
   \                     ??UDP_EndpointHandler_8:
   \   000000FA   2000               MOVS     R0,R4
   \   000000FC   ........           BL       UDP_GetDriverInterface
   \   00000100   8019               ADDS     R0,R0,R6
   \   00000102   016B               LDR      R1,[R0, #+48]
   \   00000104   0122               MOVS     R2,#+1
   \   00000106   9143               BICS     R1,R1,R2
   \   00000108   0163               STR      R1,[R0, #+48]
   \                     ??UDP_EndpointHandler_1:
   \   0000010A   2000               MOVS     R0,R4
   \   0000010C   ........           BL       UDP_GetDriverInterface
   \   00000110   8019               ADDS     R0,R0,R6
   \   00000112   006B               LDR      R0,[R0, #+48]
   \   00000114   C007               LSLS     R0,R0,#+31
   \   00000116   F0D4               BMI      ??UDP_EndpointHandler_8
    470              }
    471              
    472              
    473              
    474                                                                                          
    475          
    476          
    477          
    478              // OUT packet received
    479              if (ISSET(dStatus, AT91C_UDP_RX_DATA_BK0)
    480                  || ISSET(dStatus, AT91C_UDP_RX_DATA_BK1)) 
   \                     ??UDP_EndpointHandler_0:
   \   00000118   3800               MOVS     R0,R7
   \   0000011A   4221               MOVS     R1,#+66
   \   0000011C   0842               TST      R0,R1
   \   0000011E   49D0               BEQ      ??UDP_EndpointHandler_9
    481              {
    482                                                                                                                                                                   
    483                  // Check that the endpoint is in Read state
    484                  if (pEndpoint->dState != endpointStateRead) {
   \   00000120   686A               LDR      R0,[R5, #+36]
   \   00000122   0328               CMP      R0,#+3
   \   00000124   20D0               BEQ      ??UDP_EndpointHandler_10
    485          
    486                                                                                              
    487                      // Endpoint is NOT in Read state
    488                      if (ISCLEARED(dStatus, AT91C_UDP_EPTYPE)
    489                          && ISCLEARED(dStatus, 0xFFFF0000)) 
   \   00000126   5A48               LDR      R0,??UDP_EndpointHandler_11  ;; 0xffff0700
   \   00000128   3840               ANDS     R0,R0,R7
   \   0000012A   09D1               BNE      ??UDP_EndpointHandler_12
    490                      {
    491                                                                                          
    492                          // Control endpoint, 0 bytes received
    493                          // Acknowledge the data and finish the current transfer
    494                                                                                          TRACE_DEBUG_L("Ack ");
    495                          UDP_ClearRXFlag(pUsb, bEndpoint);
   \   0000012C   6846               MOV      R0,SP
   \   0000012E   017A               LDRB     R1,[R0, #+8]
   \   00000130   2000               MOVS     R0,R4
   \   00000132   ........           BL       UDP_ClearRXFlag
    496          
    497                          UDP_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
   \   00000136   0021               MOVS     R1,#+0
   \   00000138   2800               MOVS     R0,R5
   \   0000013A   ........           BL       UDP_EndOfTransfer
   \   0000013E   39E0               B        ??UDP_EndpointHandler_9
    498                      }
    499                   
    500                      else if (ISSET(dStatus, AT91C_UDP_FORCESTALL)) 
   \                     ??UDP_EndpointHandler_12:
   \   00000140   3800               MOVS     R0,R7
   \   00000142   2021               MOVS     R1,#+32
   \   00000144   0842               TST      R0,R1
   \   00000146   05D0               BEQ      ??UDP_EndpointHandler_13
    501                      {
    502                                                                                          
    503                          // Non-control endpoint
    504                          // Discard stalled data
    505                                                                                          TRACE_DEBUG_L("Disc ");
    506                          UDP_ClearRXFlag(pUsb, bEndpoint);
   \   00000148   6846               MOV      R0,SP
   \   0000014A   017A               LDRB     R1,[R0, #+8]
   \   0000014C   2000               MOVS     R0,R4
   \   0000014E   ........           BL       UDP_ClearRXFlag
   \   00000152   2FE0               B        ??UDP_EndpointHandler_9
    507                      }
    508                      else 
    509                      {
    510                                                                                          
    511                          // Non-control endpoint
    512                          // Nak data
    513                                                                                         // TRACE_DEBUG_L("Nak ");
    514                          SET(pInterface->UDP_IDR, 1 << bEndpoint);
   \                     ??UDP_EndpointHandler_13:
   \   00000154   0098               LDR      R0,[SP, #+0]
   \   00000156   0100               MOVS     R1,R0
   \   00000158   4A69               LDR      R2,[R1, #+20]
   \   0000015A   0121               MOVS     R1,#+1
   \   0000015C   6B46               MOV      R3,SP
   \   0000015E   1B7A               LDRB     R3,[R3, #+8]
   \   00000160   9940               LSLS     R1,R1,R3
   \   00000162   1143               ORRS     R1,R1,R2
   \   00000164   4161               STR      R1,[R0, #+20]
   \   00000166   25E0               B        ??UDP_EndpointHandler_9
    515                      }
    516                  }
    517                  else 
    518                  {
    519          
    520                                                                                         
    521                    // Endpoint is in Read state
    522                      // Retrieve data and store it into the current transfer buffer
    523                      unsigned short wPacketSize = (unsigned short) (dStatus >> 16);
   \                     ??UDP_EndpointHandler_10:
   \   00000168   3800               MOVS     R0,R7
   \   0000016A   000C               LSRS     R0,R0,#+16
   \   0000016C   0190               STR      R0,[SP, #+4]
    524                                                                                          //TRACE_DEBUG_L("%d ", wPacketSize);
    525                      //importuje dane z 
    526                      UDP_GetPayload(pUsb, bEndpoint, wPacketSize);
   \   0000016E   0200               MOVS     R2,R0
   \   00000170   6846               MOV      R0,SP
   \   00000172   017A               LDRB     R1,[R0, #+8]
   \   00000174   2000               MOVS     R0,R4
   \   00000176   ........           BL       UDP_GetPayload
    527                      
    528          
    529                                                                                         
    530                                                                                         
    531                                                                                          
    532                      UDP_ClearRXFlag(pUsb, bEndpoint);
   \   0000017A   6846               MOV      R0,SP
   \   0000017C   017A               LDRB     R1,[R0, #+8]
   \   0000017E   2000               MOVS     R0,R4
   \   00000180   ........           BL       UDP_ClearRXFlag
    533          
    534                      if ((pEndpoint->dBytesRemaining == 0)
    535                          || (wPacketSize < pEndpoint->wMaxPacketSize)) 
   \   00000184   6868               LDR      R0,[R5, #+4]
   \   00000186   0028               CMP      R0,#+0
   \   00000188   03D0               BEQ      ??UDP_EndpointHandler_14
   \   0000018A   0198               LDR      R0,[SP, #+4]
   \   0000018C   A969               LDR      R1,[R5, #+24]
   \   0000018E   8842               CMP      R0,R1
   \   00000190   10D2               BCS      ??UDP_EndpointHandler_9
    536                      {
    537                                                                                         
    538                          // Disable interrupt if this is not a control endpoint
    539                          if (!ISCLEARED(dStatus, AT91C_UDP_EPTYPE)) {
   \                     ??UDP_EndpointHandler_14:
   \   00000192   E020               MOVS     R0,#+224
   \   00000194   C000               LSLS     R0,R0,#+3        ;; #+1792
   \   00000196   0742               TST      R7,R0
   \   00000198   08D0               BEQ      ??UDP_EndpointHandler_15
    540          
    541                              SET(pInterface->UDP_IDR, 1 << bEndpoint);
   \   0000019A   0098               LDR      R0,[SP, #+0]
   \   0000019C   0100               MOVS     R1,R0
   \   0000019E   4A69               LDR      R2,[R1, #+20]
   \   000001A0   0121               MOVS     R1,#+1
   \   000001A2   6B46               MOV      R3,SP
   \   000001A4   1B7A               LDRB     R3,[R3, #+8]
   \   000001A6   9940               LSLS     R1,R1,R3
   \   000001A8   1143               ORRS     R1,R1,R2
   \   000001AA   4161               STR      R1,[R0, #+20]
    542                          }
    543          
    544                          UDP_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
   \                     ??UDP_EndpointHandler_15:
   \   000001AC   0021               MOVS     R1,#+0
   \   000001AE   2800               MOVS     R0,R5
   \   000001B0   ........           BL       UDP_EndOfTransfer
   \                     ??UDP_EndpointHandler_9:
   \   000001B4   3800               MOVS     R0,R7
   \   000001B6   0421               MOVS     R1,#+4
   \   000001B8   0842               TST      R0,R1
   \   000001BA   3ED0               BEQ      ??UDP_EndpointHandler_16
    545                          
    546                      }
    547                  }
    548                  
    549                  
    550              }
    551              
    552              
    553              
    554              
    555              
    556              
    557              // SETUP packet received
    558              if (ISSET(dStatus, AT91C_UDP_RXSETUP)) 
    559              {
    560          
    561                                                                                          TRACE_DEBUG_L("Stp ");
    562                                                                                         
    563                  // If a transfer was pending, complete it
    564                  // Handle the case where during the status phase of a control write
    565                  // transfer, the host receives the device ZLP and ack it, but the ack
    566                  // is not received by the device
    567                  if ((pEndpoint->dState == endpointStateWrite)
    568                      || (pEndpoint->dState == endpointStateRead)) {
   \   000001BC   686A               LDR      R0,[R5, #+36]
   \   000001BE   0228               CMP      R0,#+2
   \   000001C0   02D0               BEQ      ??UDP_EndpointHandler_17
   \   000001C2   686A               LDR      R0,[R5, #+36]
   \   000001C4   0328               CMP      R0,#+3
   \   000001C6   03D1               BNE      ??UDP_EndpointHandler_18
    569                                                                                          
    570                      UDP_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
   \                     ??UDP_EndpointHandler_17:
   \   000001C8   0021               MOVS     R1,#+0
   \   000001CA   2800               MOVS     R0,R5
   \   000001CC   ........           BL       UDP_EndOfTransfer
    571                  }
    572          
    573                  // Copy the setup packet in S_usb
    574                  UDP_GetSetup(pUsb);
   \                     ??UDP_EndpointHandler_18:
   \   000001D0   2000               MOVS     R0,R4
   \   000001D2   ........           BL       UDP_GetSetup
   \   000001D6   2000               MOVS     R0,R4
    575          
    576                  // Set the DIR bit before clearing RXSETUP in Control IN sequence
    577                  if (USB_GetSetup(pUsb)->bmRequestType & 0x80) {
   \   000001D8   ........           BL       USB_GetSetup
   \   000001DC   0078               LDRB     R0,[R0, #+0]
   \   000001DE   8021               MOVS     R1,#+128
   \   000001E0   0842               TST      R0,R1
   \   000001E2   0ED1               BNE      ??UDP_EndpointHandler_19
   \   000001E4   15E0               B        ??UDP_EndpointHandler_20
    578                                                                                          
    579                      UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_DIR);
   \                     ??UDP_EndpointHandler_21:
   \   000001E6   2000               MOVS     R0,R4
   \   000001E8   ........           BL       UDP_GetDriverInterface
   \   000001EC   0090               STR      R0,[SP, #+0]
   \   000001EE   2000               MOVS     R0,R4
   \   000001F0   ........           BL       UDP_GetDriverInterface
   \   000001F4   8019               ADDS     R0,R0,R6
   \   000001F6   006B               LDR      R0,[R0, #+48]
   \   000001F8   8021               MOVS     R1,#+128
   \   000001FA   0143               ORRS     R1,R1,R0
   \   000001FC   0098               LDR      R0,[SP, #+0]
   \   000001FE   8019               ADDS     R0,R0,R6
   \   00000200   0163               STR      R1,[R0, #+48]
   \                     ??UDP_EndpointHandler_19:
   \   00000202   2000               MOVS     R0,R4
   \   00000204   ........           BL       UDP_GetDriverInterface
   \   00000208   8019               ADDS     R0,R0,R6
   \   0000020A   006B               LDR      R0,[R0, #+48]
   \   0000020C   8021               MOVS     R1,#+128
   \   0000020E   0842               TST      R0,R1
   \   00000210   E9D0               BEQ      ??UDP_EndpointHandler_21
    580                  }
    581          
    582                  UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_RXSETUP);
   \                     ??UDP_EndpointHandler_20:
   \   00000212   2000               MOVS     R0,R4
   \   00000214   ........           BL       UDP_GetDriverInterface
   \   00000218   8019               ADDS     R0,R0,R6
   \   0000021A   006B               LDR      R0,[R0, #+48]
   \   0000021C   0421               MOVS     R1,#+4
   \   0000021E   0842               TST      R0,R1
   \   00000220   08D0               BEQ      ??UDP_EndpointHandler_22
   \   00000222   2000               MOVS     R0,R4
   \   00000224   ........           BL       UDP_GetDriverInterface
   \   00000228   8019               ADDS     R0,R0,R6
   \   0000022A   016B               LDR      R1,[R0, #+48]
   \   0000022C   0422               MOVS     R2,#+4
   \   0000022E   9143               BICS     R1,R1,R2
   \   00000230   0163               STR      R1,[R0, #+48]
   \   00000232   EEE7               B        ??UDP_EndpointHandler_20
    583          
    584                  // Forward the request to the upper layer
    585                  USB_NewRequestCallback(pUsb);
   \                     ??UDP_EndpointHandler_22:
   \   00000234   2000               MOVS     R0,R4
   \   00000236   ........           BL       USB_NewRequestCallback
   \                     ??UDP_EndpointHandler_16:
   \   0000023A   0820               MOVS     R0,#+8
   \   0000023C   0742               TST      R7,R0
   \   0000023E   08D1               BNE      ??UDP_EndpointHandler_23
   \   00000240   23E0               B        ??UDP_EndpointHandler_24
    586                  
    587              }// koniec -  SETUP packet received
    588              
    589              
    590              
    591              
    592              // STALL sent
    593              if (ISSET(dStatus, AT91C_UDP_STALLSENT)) 
    594              {
    595                                                                                          
    596                  TRACE_WARNING("Sta ");
    597          
    598                  // Acknowledge the stall flag
    599                  UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_STALLSENT);
   \                     ??UDP_EndpointHandler_25:
   \   00000242   2000               MOVS     R0,R4
   \   00000244   ........           BL       UDP_GetDriverInterface
   \   00000248   8019               ADDS     R0,R0,R6
   \   0000024A   016B               LDR      R1,[R0, #+48]
   \   0000024C   0822               MOVS     R2,#+8
   \   0000024E   9143               BICS     R1,R1,R2
   \   00000250   0163               STR      R1,[R0, #+48]
   \                     ??UDP_EndpointHandler_23:
   \   00000252   2000               MOVS     R0,R4
   \   00000254   ........           BL       UDP_GetDriverInterface
   \   00000258   8019               ADDS     R0,R0,R6
   \   0000025A   006B               LDR      R0,[R0, #+48]
   \   0000025C   0821               MOVS     R1,#+8
   \   0000025E   0842               TST      R0,R1
   \   00000260   EFD1               BNE      ??UDP_EndpointHandler_25
    600          
    601                  // If the endpoint is not halted, clear the stall condition
    602                  if (pEndpoint->dState != endpointStateHalted) {
   \   00000262   686A               LDR      R0,[R5, #+36]
   \   00000264   0428               CMP      R0,#+4
   \   00000266   08D1               BNE      ??UDP_EndpointHandler_26
   \   00000268   0FE0               B        ??UDP_EndpointHandler_24
    603                                                                                         
    604                      UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_FORCESTALL);
   \                     ??UDP_EndpointHandler_27:
   \   0000026A   2000               MOVS     R0,R4
   \   0000026C   ........           BL       UDP_GetDriverInterface
   \   00000270   8019               ADDS     R0,R0,R6
   \   00000272   016B               LDR      R1,[R0, #+48]
   \   00000274   2022               MOVS     R2,#+32
   \   00000276   9143               BICS     R1,R1,R2
   \   00000278   0163               STR      R1,[R0, #+48]
   \                     ??UDP_EndpointHandler_26:
   \   0000027A   2000               MOVS     R0,R4
   \   0000027C   ........           BL       UDP_GetDriverInterface
   \   00000280   8019               ADDS     R0,R0,R6
   \   00000282   006B               LDR      R0,[R0, #+48]
   \   00000284   2021               MOVS     R1,#+32
   \   00000286   0842               TST      R0,R1
   \   00000288   EFD1               BNE      ??UDP_EndpointHandler_27
    605                  }
    606                }// koniec - STALL sent
    607              
    608                                                                                          //TRACE_DEBUG_L("a1 ");
    609                                                                                          //TRACE_DEBUG_L("KON_Ept%d ", bEndpoint);
    610          
    611          }
   \                     ??UDP_EndpointHandler_24:
   \   0000028A   FEBC               POP      {R1-R7}
   \   0000028C   01BC               POP      {R0}
   \   0000028E   0047               BX       R0               ;; return
   \                     ??UDP_EndpointHandler_11:
   \   00000290   0007FFFF           DC32     0xffff0700
    612          
    613          //------------------------------------------------------------------------------
    614          //      Exported functions
    615          //------------------------------------------------------------------------------
    616          //------------------------------------------------------------------------------
    617          // \brief  Configure an endpoint with the provided endpoint descriptor
    618          // \param  pUsb    Pointer to a S_usb instance
    619          // \param  pEpDesc Pointer to the endpoint descriptor
    620          // \return true if the endpoint is now configured, false otherwise
    621          // \see    S_usb_endpoint_descriptor
    622          // \see    S_usb
    623          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    624          bool UDP_ConfigureEndpoint(const S_usb                     *pUsb,
    625                                     const S_usb_endpoint_descriptor *pEpDesc)
    626          {
   \                     UDP_ConfigureEndpoint:
   \   00000000   F3B5               PUSH     {R0,R1,R4-R7,LR}
   \   00000002   81B0               SUB      SP,SP,#+4
    627              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   ........           BL       UDP_GetDriverInterface
   \   00000008   0500               MOVS     R5,R0
    628              S_usb_endpoint *pEndpoint;
    629              unsigned char  bEndpoint;
    630              unsigned char  bType;
    631              bool           isINEndpoint;
    632              unsigned int   dFlags;
    633          
    634              // NULL descriptor -> Control endpoint 0
    635              if (pEpDesc == 0) {
   \   0000000A   0298               LDR      R0,[SP, #+8]
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   03D1               BNE      ??UDP_ConfigureEndpoint_0
    636          
    637                  bEndpoint = 0;
   \   00000010   0024               MOVS     R4,#+0
   \   00000012   0094               STR      R4,[SP, #+0]
    638                  bType = ENDPOINT_TYPE_CONTROL;
   \   00000014   2600               MOVS     R6,R4
    639                  isINEndpoint = false;
   \   00000016   0FE0               B        ??UDP_ConfigureEndpoint_1
    640              }
    641              else {
    642          
    643                  bEndpoint = (unsigned char) (pEpDesc->bEndpointAddress & 0x7);
   \                     ??UDP_ConfigureEndpoint_0:
   \   00000018   8078               LDRB     R0,[R0, #+2]
   \   0000001A   4007               LSLS     R0,R0,#+29
   \   0000001C   400F               LSRS     R0,R0,#+29
   \   0000001E   0090               STR      R0,[SP, #+0]
    644                  bType = (unsigned char) (pEpDesc->bmAttributes & 0x3);
   \   00000020   0298               LDR      R0,[SP, #+8]
   \   00000022   C078               LDRB     R0,[R0, #+3]
   \   00000024   8607               LSLS     R6,R0,#+30
   \   00000026   B60F               LSRS     R6,R6,#+30
    645          
    646                  if (ISSET(pEpDesc->bEndpointAddress, 1 << 7)) {
    647          
    648                      isINEndpoint = true;
    649                  }
    650                  else {
    651          
    652                      isINEndpoint = false;
   \   00000028   0298               LDR      R0,[SP, #+8]
   \   0000002A   8078               LDRB     R0,[R0, #+2]
   \   0000002C   8021               MOVS     R1,#+128
   \   0000002E   0140               ANDS     R1,R1,R0
   \   00000030   4C1E               SUBS     R4,R1,#+1
   \   00000032   A441               SBCS     R4,R4,R4
   \   00000034   E443               MVNS     R4,R4
   \   00000036   E40F               LSRS     R4,R4,#+31
    653                  }
    654              }
    655          
    656              // Get pointer on endpoint
    657              pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \                     ??UDP_ConfigureEndpoint_1:
   \   00000038   0099               LDR      R1,[SP, #+0]
   \   0000003A   0906               LSLS     R1,R1,#+24
   \   0000003C   090E               LSRS     R1,R1,#+24
   \   0000003E   0198               LDR      R0,[SP, #+4]
   \   00000040   ........           BL       USB_GetEndpoint
   \   00000044   0700               MOVS     R7,R0
    658              if (pEndpoint == 0) {
   \   00000046   01D1               BNE      ??UDP_ConfigureEndpoint_2
    659          
    660                  return false;
   \   00000048   0020               MOVS     R0,#+0
   \   0000004A   48E0               B        ??UDP_ConfigureEndpoint_3
    661              }
    662          
    663              // Configure wMaxPacketSize
    664              if (pEpDesc != 0) {
   \                     ??UDP_ConfigureEndpoint_2:
   \   0000004C   0298               LDR      R0,[SP, #+8]
   \   0000004E   0028               CMP      R0,#+0
   \   00000050   06D0               BEQ      ??UDP_ConfigureEndpoint_4
    665          
    666                  pEndpoint->wMaxPacketSize = pEpDesc->wMaxPacketSize;
   \   00000052   0279               LDRB     R2,[R0, #+4]
   \   00000054   4179               LDRB     R1,[R0, #+5]
   \   00000056   0906               LSLS     R1,R1,#+24
   \   00000058   090C               LSRS     R1,R1,#+16
   \   0000005A   0A43               ORRS     R2,R2,R1
   \   0000005C   BA61               STR      R2,[R7, #+24]
   \   0000005E   01E0               B        ??UDP_ConfigureEndpoint_5
    667              }
    668              else {
    669          
    670                  pEndpoint->wMaxPacketSize = USB_ENDPOINT0_MAXPACKETSIZE;
   \                     ??UDP_ConfigureEndpoint_4:
   \   00000060   0820               MOVS     R0,#+8
   \   00000062   B861               STR      R0,[R7, #+24]
    671              }
    672          
    673              // Abort the current transfer is the endpoint was configured and in
    674              // Write or Read state
    675              if ((pEndpoint->dState == endpointStateRead)
    676                  || (pEndpoint->dState == endpointStateWrite)) {
   \                     ??UDP_ConfigureEndpoint_5:
   \   00000064   786A               LDR      R0,[R7, #+36]
   \   00000066   0328               CMP      R0,#+3
   \   00000068   02D0               BEQ      ??UDP_ConfigureEndpoint_6
   \   0000006A   786A               LDR      R0,[R7, #+36]
   \   0000006C   0228               CMP      R0,#+2
   \   0000006E   03D1               BNE      ??UDP_ConfigureEndpoint_7
    677          
    678                  UDP_EndOfTransfer(pEndpoint, USB_STATUS_RESET);
   \                     ??UDP_ConfigureEndpoint_6:
   \   00000070   0321               MOVS     R1,#+3
   \   00000072   3800               MOVS     R0,R7
   \   00000074   ........           BL       UDP_EndOfTransfer
    679              }
    680          
    681              // Enter IDLE state
    682              pEndpoint->dState = endpointStateIdle;
   \                     ??UDP_ConfigureEndpoint_7:
   \   00000078   0120               MOVS     R0,#+1
   \   0000007A   7862               STR      R0,[R7, #+36]
    683          
    684              // Reset Endpoint Fifos
    685              SET(pInterface->UDP_RSTEP, 1 << bEndpoint);
   \   0000007C   0099               LDR      R1,[SP, #+0]
   \   0000007E   8840               LSLS     R0,R0,R1
   \   00000080   A96A               LDR      R1,[R5, #+40]
   \   00000082   0143               ORRS     R1,R1,R0
   \   00000084   A962               STR      R1,[R5, #+40]
    686              CLEAR(pInterface->UDP_RSTEP, 1 << bEndpoint);
   \   00000086   A96A               LDR      R1,[R5, #+40]
   \   00000088   8143               BICS     R1,R1,R0
   \   0000008A   A962               STR      R1,[R5, #+40]
    687          
    688              // Configure endpoint
    689              dFlags = AT91C_UDP_EPEDS;
    690              SET(dFlags, bType << UDP_EPTYPE_INDEX);
   \   0000008C   3100               MOVS     R1,R6
   \   0000008E   0902               LSLS     R1,R1,#+8
   \   00000090   8027               MOVS     R7,#+128
   \   00000092   3F02               LSLS     R7,R7,#+8        ;; #+32768
   \   00000094   0F43               ORRS     R7,R7,R1
    691          
    692              if (isINEndpoint) {
   \   00000096   002C               CMP      R4,#+0
   \   00000098   03D0               BEQ      ??UDP_ConfigureEndpoint_8
    693          
    694                  SET(dFlags, 1 << UDP_EPDIR_INDEX);
   \   0000009A   3900               MOVS     R1,R7
   \   0000009C   8027               MOVS     R7,#+128
   \   0000009E   FF00               LSLS     R7,R7,#+3        ;; #+1024
   \   000000A0   0F43               ORRS     R7,R7,R1
    695              }
    696          
    697              if (bType == ENDPOINT_TYPE_CONTROL) {
   \                     ??UDP_ConfigureEndpoint_8:
   \   000000A2   002E               CMP      R6,#+0
   \   000000A4   0FD1               BNE      ??UDP_ConfigureEndpoint_9
    698          
    699                  SET(pInterface->UDP_IER, 1 << bEndpoint);
   \   000000A6   2969               LDR      R1,[R5, #+16]
   \   000000A8   0843               ORRS     R0,R0,R1
   \   000000AA   2861               STR      R0,[R5, #+16]
   \   000000AC   0BE0               B        ??UDP_ConfigureEndpoint_9
    700              }
    701          
    702                                                                                          //TRACE_DEBUG_L("CfgEpt%d ", bEndpoint);
    703          
    704              UDP_SETEPFLAGS(pUsb, bEndpoint, dFlags);
   \                     ??UDP_ConfigureEndpoint_10:
   \   000000AE   0198               LDR      R0,[SP, #+4]
   \   000000B0   ........           BL       UDP_GetDriverInterface
   \   000000B4   0500               MOVS     R5,R0
   \   000000B6   0198               LDR      R0,[SP, #+4]
   \   000000B8   ........           BL       UDP_GetDriverInterface
   \   000000BC   0019               ADDS     R0,R0,R4
   \   000000BE   006B               LDR      R0,[R0, #+48]
   \   000000C0   3843               ORRS     R0,R0,R7
   \   000000C2   2919               ADDS     R1,R5,R4
   \   000000C4   0863               STR      R0,[R1, #+48]
   \                     ??UDP_ConfigureEndpoint_9:
   \   000000C6   0098               LDR      R0,[SP, #+0]
   \   000000C8   0006               LSLS     R0,R0,#+24
   \   000000CA   000E               LSRS     R0,R0,#+24
   \   000000CC   8400               LSLS     R4,R0,#+2
   \   000000CE   0198               LDR      R0,[SP, #+4]
   \   000000D0   ........           BL       UDP_GetDriverInterface
   \   000000D4   0019               ADDS     R0,R0,R4
   \   000000D6   006B               LDR      R0,[R0, #+48]
   \   000000D8   3840               ANDS     R0,R0,R7
   \   000000DA   E8D0               BEQ      ??UDP_ConfigureEndpoint_10
    705          
    706              return true;
   \   000000DC   0120               MOVS     R0,#+1
   \                     ??UDP_ConfigureEndpoint_3:
   \   000000DE   FEBC               POP      {R1-R7}
   \   000000E0   02BC               POP      {R1}
   \   000000E2   0847               BX       R1               ;; return
    707          }
    708          
    709          //------------------------------------------------------------------------------
    710          // \brief  UDP interrupt handler
    711          //
    712          //         Manages device resume, suspend, end of bus reset. Forwards endpoint
    713          //         interrupts to the appropriate handler.
    714          // \param  pUsb Pointer to a S_usb instance
    715          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    716          void UDP_Handler(const S_usb *pUsb)
    717          {
   \                     UDP_Handler:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
    718              AT91PS_UDP          pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   ........           BL       UDP_GetDriverInterface
   \   00000008   0500               MOVS     R5,R0
   \   0000000A   2000               MOVS     R0,R4
    719              unsigned int        dStatus;
    720              unsigned char       bEndpoint;
    721          
    722              
    723              if ( (!ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED))
    724                 && (ISSET(USB_GetState(pUsb), USB_STATE_POWERED))){
   \   0000000C   ........           BL       USB_GetState
   \   00000010   2021               MOVS     R1,#+32
   \   00000012   0842               TST      R0,R1
   \   00000014   02D1               BNE      ??UDP_Handler_0
   \   00000016   2000               MOVS     R0,R4
   \   00000018   ........           BL       USB_GetState
   \                     ??UDP_Handler_0:
   \   0000001C   E869               LDR      R0,[R5, #+28]
   \   0000001E   A969               LDR      R1,[R5, #+24]
   \   00000020   0140               ANDS     R1,R1,R0
   \   00000022   8E04               LSLS     R6,R1,#+18
   \   00000024   B60C               LSRS     R6,R6,#+18
   \   00000026   1DE0               B        ??UDP_Handler_1
    725          
    726                  LED_TOGGLE(LED_USB);
    727              }
    728          
    729                                                                                         //TRACE_DEBUG_L("Hlr ");
    730          
    731              // Get interrupts status
    732              dStatus = pInterface->UDP_ISR & pInterface->UDP_IMR & ISR_MASK;
    733          
    734              // Handle all UDP interrupts
    735              while (dStatus != 0) 
    736              {
    737          
    738                  // Start Of Frame (SOF)
    739                  if (ISSET(dStatus, AT91C_UDP_SOFINT)) {
    740                                                                                           
    741                                                                                          //TRACE_DEBUG_L("SOF ");
    742          
    743                      // Invoke the SOF callback
    744                      USB_StartOfFrameCallback(pUsb);
    745          
    746                      // Acknowledge interrupt
    747                      SET(pInterface->UDP_ICR, AT91C_UDP_SOFINT);
    748                      CLEAR(dStatus, AT91C_UDP_SOFINT);
    749                  }
    750          
    751                  // Suspend
    752                  if (dStatus == AT91C_UDP_RXSUSP) 
    753                  {                                                                       //TRACE_DEBUG_L("Susp ");
    754          
    755                      if (!ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED)) 
    756                      {
    757                                                                                          //TRACE_DEBUG_L("Susp_in ");
    758                          // The device enters the Suspended state                        
    759                          //      MCK + UDPCK must be off
    760                          //      Pull-Up must be connected
    761                          //      Transceiver must be disabled
    762          
    763                          // Enable wakeup
    764                          SET(pInterface->UDP_IER, AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM);
    765          
    766                          // Acknowledge interrupt
    767                          SET(pInterface->UDP_ICR, AT91C_UDP_RXSUSP);
    768          
    769                          SET(*(pUsb->pState), USB_STATE_SUSPENDED);
    770                          UDP_DisableTransceiver(pUsb);
    771                          UDP_DisableMCK(pUsb);
    772                          UDP_DisableUDPCK(pUsb);
    773          
    774                          // Invoke the Suspend callback
    775                          USB_SuspendCallback(pUsb);
    776          
    777                      }
    778                      
    779                      
    780                      
    781                  }//End of Suspend
    782                  // Resume
    783                  else if (ISSET(dStatus, AT91C_UDP_WAKEUP)
    784                        || ISSET(dStatus, AT91C_UDP_RXRSM)) 
    785                  {
    786          
    787                      // Invoke the Resume callback
    788                      USB_ResumeCallback(pUsb);
    789          
    790                                                                                          //TRACE_DEBUG_L("Res ");
    791          
    792                      // The device enters Configured state
    793                      //      MCK + UDPCK must be on
    794                      //      Pull-Up must be connected
    795                      //      Transceiver must be enabled
    796          
    797                      if (ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED)) 
    798                      {
    799          
    800                          // Powered state
    801                          UDP_EnableMCK(pUsb);
    802                          UDP_EnableUDPCK(pUsb);
    803          
    804                          // Default state
    805                          if (ISSET(USB_GetState(pUsb), USB_STATE_DEFAULT)) 
    806                          {
    807          
    808                              UDP_EnableTransceiver(pUsb);
    809                          }
    810          
    811                          CLEAR(*(pUsb->pState), USB_STATE_SUSPENDED);
    812                      }
    813                      SET(pInterface->UDP_ICR,
    814                          AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM | AT91C_UDP_RXSUSP);
    815                      SET(pInterface->UDP_IDR, AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM);
    816                  }
    817                  // End of bus reset
    818                  else if (ISSET(dStatus, AT91C_UDP_ENDBUSRES)) 
    819                  {
    820          
    821                                                                                          //TRACE_DEBUG_L("EoBRes ");
    822          
    823                      // The device enters the Default state
    824                      //      MCK + UDPCK are already enabled
    825                      //      Pull-Up is already connected
    826                      //      Transceiver must be enabled
    827                      //      Endpoint 0 must be enabled
    828                      SET(*(pUsb->pState), USB_STATE_DEFAULT);
    829                      UDP_EnableTransceiver(pUsb);
    830          
    831                      // The device leaves the Address & Configured states
    832                      CLEAR(*(pUsb->pState), USB_STATE_ADDRESS | USB_STATE_CONFIGURED);
    833                      UDP_ResetEndpoints(pUsb);
    834                      UDP_DisableEndpoints(pUsb);
    835                      UDP_ConfigureEndpoint(pUsb, 0);
    836          
    837                      // Flush and enable the Suspend interrupt
    838                      SET(pInterface->UDP_ICR,
    839                          AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM | AT91C_UDP_RXSUSP);
    840          
    841                      // Enable the Start Of Frame (SOF) interrupt if needed
    842                      if (pUsb->pCallbacks->startOfFrame != 0) {
    843          
    844                          SET(pInterface->UDP_IER, AT91C_UDP_SOFINT);
    845                      }
    846          
    847                      // Invoke the Reset callback
    848                      USB_ResetCallback(pUsb);
    849          
    850                      // Acknowledge end of bus reset interrupt
    851                      SET(pInterface->UDP_ICR, AT91C_UDP_ENDBUSRES);
    852                  }
    853                  // Endpoint interrupts
    854                  else {
    855                                                                                                                                                     
    856                      while (dStatus != 0) 
    857                      {
    858                                                                                          //TRACE_DEBUG_L("E_it ");   
    859                          // Get endpoint index
    860                          bEndpoint = lastSetBit(dStatus);
   \                     ??UDP_Handler_2:
   \   00000028   3000               MOVS     R0,R6
   \   0000002A   ........           BL       lastSetBit
   \   0000002E   0700               MOVS     R7,R0
   \   00000030   3F06               LSLS     R7,R7,#+24
   \   00000032   3F0E               LSRS     R7,R7,#+24
    861                          UDP_EndpointHandler(pUsb, bEndpoint);
   \   00000034   3900               MOVS     R1,R7
   \   00000036   2000               MOVS     R0,R4
   \   00000038   ........           BL       UDP_EndpointHandler
    862                                                                                          
    863                          /*CLEAR(pInterface->UDP_CSR[bEndpoint],
    864                                AT91C_UDP_TXCOMP | AT91C_UDP_RX_DATA_BK0
    865                              | AT91C_UDP_RX_DATA_BK1 | AT91C_UDP_RXSETUP
    866                              | AT91C_UDP_STALLSENT);*/
    867          
    868                          CLEAR(dStatus, 1 << bEndpoint);
   \   0000003C   0120               MOVS     R0,#+1
   \   0000003E   B840               LSLS     R0,R0,R7
   \   00000040   8643               BICS     R6,R6,R0
    869          
    870                          if (dStatus != 0) {
    871                                                                                          
    872                                                                                          //TRACE_DEBUG_L("\n\r  - ");
    873          
    874                          }
    875                      }
   \                     ??UDP_Handler_3:
   \   00000042   002E               CMP      R6,#+0
   \   00000044   F0D1               BNE      ??UDP_Handler_2
    876                                                                                         
    877                  }
    878                  
    879                                                                                         
    880                  
    881          
    882                  // Retrieve new interrupt status
    883                  dStatus = pInterface->UDP_ISR & pInterface->UDP_IMR & ISR_MASK;
   \                     ??UDP_Handler_4:
   \   00000046   E869               LDR      R0,[R5, #+28]
   \   00000048   A969               LDR      R1,[R5, #+24]
   \   0000004A   0140               ANDS     R1,R1,R0
   \   0000004C   8E04               LSLS     R6,R1,#+18
   \   0000004E   B60C               LSRS     R6,R6,#+18
    884          
    885                  // Mask unneeded interrupts
    886                  if (!ISSET(USB_GetState(pUsb), USB_STATE_DEFAULT)) {
   \   00000050   2000               MOVS     R0,R4
   \   00000052   ........           BL       USB_GetState
   \   00000056   0421               MOVS     R1,#+4
   \   00000058   0842               TST      R0,R1
   \   0000005A   03D1               BNE      ??UDP_Handler_1
    887          
    888                      dStatus &= AT91C_UDP_ENDBUSRES | AT91C_UDP_SOFINT;
   \   0000005C   3000               MOVS     R0,R6
   \   0000005E   C026               MOVS     R6,#+192
   \   00000060   7601               LSLS     R6,R6,#+5        ;; #+6144
   \   00000062   0640               ANDS     R6,R6,R0
    889                  }
   \                     ??UDP_Handler_1:
   \   00000064   002E               CMP      R6,#+0
   \   00000066   00D1               BNE      .+4
   \   00000068   8DE0               B        ??UDP_Handler_5
   \   0000006A   8020               MOVS     R0,#+128
   \   0000006C   0001               LSLS     R0,R0,#+4        ;; #+2048
   \   0000006E   0642               TST      R6,R0
   \   00000070   0AD0               BEQ      ??UDP_Handler_6
   \   00000072   2000               MOVS     R0,R4
   \   00000074   ........           BL       USB_StartOfFrameCallback
   \   00000078   286A               LDR      R0,[R5, #+32]
   \   0000007A   8021               MOVS     R1,#+128
   \   0000007C   0901               LSLS     R1,R1,#+4        ;; #+2048
   \   0000007E   0143               ORRS     R1,R1,R0
   \   00000080   2962               STR      R1,[R5, #+32]
   \   00000082   3000               MOVS     R0,R6
   \   00000084   464E               LDR      R6,??UDP_Handler_7  ;; 0xfffff7ff
   \   00000086   0640               ANDS     R6,R6,R0
   \                     ??UDP_Handler_6:
   \   00000088   8027               MOVS     R7,#+128
   \   0000008A   7F00               LSLS     R7,R7,#+1        ;; #+256
   \   0000008C   BE42               CMP      R6,R7
   \   0000008E   20D1               BNE      ??UDP_Handler_8
   \   00000090   2000               MOVS     R0,R4
   \   00000092   ........           BL       USB_GetState
   \   00000096   2021               MOVS     R1,#+32
   \   00000098   0842               TST      R0,R1
   \   0000009A   D4D1               BNE      ??UDP_Handler_4
   \   0000009C   2869               LDR      R0,[R5, #+16]
   \   0000009E   8821               MOVS     R1,#+136
   \   000000A0   8901               LSLS     R1,R1,#+6        ;; #+8704
   \   000000A2   0143               ORRS     R1,R1,R0
   \   000000A4   2961               STR      R1,[R5, #+16]
   \   000000A6   286A               LDR      R0,[R5, #+32]
   \   000000A8   0743               ORRS     R7,R7,R0
   \   000000AA   2F62               STR      R7,[R5, #+32]
   \   000000AC   6069               LDR      R0,[R4, #+20]
   \   000000AE   0100               MOVS     R1,R0
   \   000000B0   0968               LDR      R1,[R1, #+0]
   \   000000B2   2022               MOVS     R2,#+32
   \   000000B4   0A43               ORRS     R2,R2,R1
   \   000000B6   0260               STR      R2,[R0, #+0]
   \   000000B8   2000               MOVS     R0,R4
   \   000000BA   ........           BL       UDP_DisableTransceiver
   \   000000BE   2000               MOVS     R0,R4
   \   000000C0   ........           BL       UDP_DisableMCK
   \   000000C4   2000               MOVS     R0,R4
   \   000000C6   ........           BL       UDP_DisableUDPCK
   \   000000CA   2000               MOVS     R0,R4
   \   000000CC   ........           BL       USB_SuspendCallback
   \   000000D0   B9E7               B        ??UDP_Handler_4
   \                     ??UDP_Handler_8:
   \   000000D2   8827               MOVS     R7,#+136
   \   000000D4   BF01               LSLS     R7,R7,#+6        ;; #+8704
   \   000000D6   3E42               TST      R6,R7
   \   000000D8   25D0               BEQ      ??UDP_Handler_9
   \   000000DA   2000               MOVS     R0,R4
   \   000000DC   ........           BL       USB_ResumeCallback
   \   000000E0   2000               MOVS     R0,R4
   \   000000E2   ........           BL       USB_GetState
   \   000000E6   2021               MOVS     R1,#+32
   \   000000E8   0842               TST      R0,R1
   \   000000EA   13D0               BEQ      ??UDP_Handler_10
   \   000000EC   2000               MOVS     R0,R4
   \   000000EE   ........           BL       UDP_EnableMCK
   \   000000F2   2000               MOVS     R0,R4
   \   000000F4   ........           BL       UDP_EnableUDPCK
   \   000000F8   2000               MOVS     R0,R4
   \   000000FA   ........           BL       USB_GetState
   \   000000FE   0421               MOVS     R1,#+4
   \   00000100   0842               TST      R0,R1
   \   00000102   02D0               BEQ      ??UDP_Handler_11
   \   00000104   2000               MOVS     R0,R4
   \   00000106   ........           BL       UDP_EnableTransceiver
   \                     ??UDP_Handler_11:
   \   0000010A   6069               LDR      R0,[R4, #+20]
   \   0000010C   0168               LDR      R1,[R0, #+0]
   \   0000010E   2022               MOVS     R2,#+32
   \   00000110   9143               BICS     R1,R1,R2
   \   00000112   0160               STR      R1,[R0, #+0]
   \                     ??UDP_Handler_10:
   \   00000114   286A               LDR      R0,[R5, #+32]
   \   00000116   8C21               MOVS     R1,#+140
   \   00000118   8901               LSLS     R1,R1,#+6        ;; #+8960
   \   0000011A   0143               ORRS     R1,R1,R0
   \   0000011C   2962               STR      R1,[R5, #+32]
   \   0000011E   6869               LDR      R0,[R5, #+20]
   \   00000120   0743               ORRS     R7,R7,R0
   \   00000122   6F61               STR      R7,[R5, #+20]
   \   00000124   8FE7               B        ??UDP_Handler_4
   \                     ??UDP_Handler_9:
   \   00000126   8027               MOVS     R7,#+128
   \   00000128   7F01               LSLS     R7,R7,#+5        ;; #+4096
   \   0000012A   3E42               TST      R6,R7
   \   0000012C   89D0               BEQ      ??UDP_Handler_3
   \   0000012E   6069               LDR      R0,[R4, #+20]
   \   00000130   0100               MOVS     R1,R0
   \   00000132   0968               LDR      R1,[R1, #+0]
   \   00000134   0422               MOVS     R2,#+4
   \   00000136   0A43               ORRS     R2,R2,R1
   \   00000138   0260               STR      R2,[R0, #+0]
   \   0000013A   2000               MOVS     R0,R4
   \   0000013C   ........           BL       UDP_EnableTransceiver
   \   00000140   6069               LDR      R0,[R4, #+20]
   \   00000142   0168               LDR      R1,[R0, #+0]
   \   00000144   1822               MOVS     R2,#+24
   \   00000146   9143               BICS     R1,R1,R2
   \   00000148   0160               STR      R1,[R0, #+0]
   \   0000014A   2000               MOVS     R0,R4
   \   0000014C   ........           BL       UDP_ResetEndpoints
   \   00000150   2000               MOVS     R0,R4
   \   00000152   ........           BL       UDP_DisableEndpoints
   \   00000156   0021               MOVS     R1,#+0
   \   00000158   2000               MOVS     R0,R4
   \   0000015A   ........           BL       UDP_ConfigureEndpoint
   \   0000015E   286A               LDR      R0,[R5, #+32]
   \   00000160   8C21               MOVS     R1,#+140
   \   00000162   8901               LSLS     R1,R1,#+6        ;; #+8960
   \   00000164   0143               ORRS     R1,R1,R0
   \   00000166   2962               STR      R1,[R5, #+32]
   \   00000168   E068               LDR      R0,[R4, #+12]
   \   0000016A   4069               LDR      R0,[R0, #+20]
   \   0000016C   0028               CMP      R0,#+0
   \   0000016E   03D0               BEQ      ??UDP_Handler_12
   \   00000170   2869               LDR      R0,[R5, #+16]
   \   00000172   7908               LSRS     R1,R7,#+1
   \   00000174   0143               ORRS     R1,R1,R0
   \   00000176   2961               STR      R1,[R5, #+16]
   \                     ??UDP_Handler_12:
   \   00000178   2000               MOVS     R0,R4
   \   0000017A   ........           BL       USB_ResetCallback
   \   0000017E   286A               LDR      R0,[R5, #+32]
   \   00000180   0743               ORRS     R7,R7,R0
   \   00000182   2F62               STR      R7,[R5, #+32]
   \   00000184   5FE7               B        ??UDP_Handler_4
    890                                                                                         
    891                  //TRACE_DEBUG_L("\n\r");
    892                                                                                          
    893                  if (dStatus != 0) {
    894          
    895                                                                                          //TRACE_DEBUG_L("  - ");
    896                  }
    897              }
    898          
    899              if ( (!ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED))
    900                 && (ISSET(USB_GetState(pUsb), USB_STATE_POWERED))){
   \                     ??UDP_Handler_5:
   \   00000186   2000               MOVS     R0,R4
   \   00000188   ........           BL       USB_GetState
   \   0000018C   2021               MOVS     R1,#+32
   \   0000018E   0842               TST      R0,R1
   \   00000190   02D1               BNE      ??UDP_Handler_13
   \   00000192   2000               MOVS     R0,R4
   \   00000194   ........           BL       USB_GetState
    901          
    902                  LED_TOGGLE(LED_USB);
    903              }
    904              
    905                                                                                         //TRACE_DEBUG_L("KON_Hdl ");
    906                                                                                         //TRACE_DEBUG_L("\n\r");
    907              
    908          }
   \                     ??UDP_Handler_13:
   \   00000198   F8BC               POP      {R3-R7}
   \   0000019A   01BC               POP      {R0}
   \   0000019C   0047               BX       R0               ;; return
   \   0000019E   C046               Nop      
   \                     ??UDP_Handler_7:
   \   000001A0   FFF7FFFF           DC32     0xfffff7ff
    909          
    910          //------------------------------------------------------------------------------
    911          // \brief  Sends data through an USB endpoint
    912          //
    913          //         Sets up the transfer descriptor, write one or two data payloads
    914          //         (depending on the number of FIFO banks for the endpoint) and then
    915          //         starts the actual transfer. The operation is complete when all
    916          //         the data has been sent.
    917          // \param  pUsb      Pointer to a S_usb instance
    918          // \param  bEndpoint Index of endpoint
    919          // \param  pData     Pointer to a buffer containing the data to send
    920          // \param  dLength   Length of the data buffer
    921          // \param  fCallback Optional function to invoke when the transfer finishes
    922          // \param  pArgument Optional argument for the callback function
    923          // \return Operation result code
    924          // \see    Operation result codes
    925          // \see    Callback_f
    926          // \see    S_usb
    927          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    928          char UDP_Write(const S_usb   *pUsb,
    929                         unsigned char bEndpoint,
    930                         const void    *pData,
    931                         unsigned int  dLength,
    932                         Callback_f    fCallback,
    933                         void          *pArgument)
    934          {
   \                     UDP_Write:
   \   00000000   FEB5               PUSH     {R1-R7,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0400               MOVS     R4,R0
   \   00000006   0A9E               LDR      R6,[SP, #+40]
   \   00000008   0B9F               LDR      R7,[SP, #+44]
    935              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   0000000A   ........           BL       USB_GetEndpoint
   \   0000000E   0500               MOVS     R5,R0
    936              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000010   2000               MOVS     R0,R4
   \   00000012   ........           BL       UDP_GetDriverInterface
   \   00000016   0090               STR      R0,[SP, #+0]
   \   00000018   2800               MOVS     R0,R5
   \   0000001A   2030               ADDS     R0,R0,#+32
   \   0000001C   4068               LDR      R0,[R0, #+4]
   \   0000001E   0128               CMP      R0,#+1
   \   00000020   01D0               BEQ      ??UDP_Write_0
    937          
    938              // Check that the endpoint is in Idle state
    939              if (pEndpoint->dState != endpointStateIdle) {
    940          
    941                  return USB_STATUS_LOCKED;
   \   00000022   0120               MOVS     R0,#+1
   \   00000024   40E0               B        ??UDP_Write_1
    942              }
    943          
    944                                                                                         // TRACE_DEBUG_L("Write%d(%d) ", bEndpoint, dLength);
    945          
    946              // Setup the transfer descriptor
    947              pEndpoint->pData = (char *) pData;
   \                     ??UDP_Write_0:
   \   00000026   0398               LDR      R0,[SP, #+12]
   \   00000028   2860               STR      R0,[R5, #+0]
    948              pEndpoint->dBytesRemaining = dLength;
   \   0000002A   0498               LDR      R0,[SP, #+16]
   \   0000002C   6860               STR      R0,[R5, #+4]
    949              pEndpoint->dBytesBuffered = 0;
   \   0000002E   0020               MOVS     R0,#+0
   \   00000030   A860               STR      R0,[R5, #+8]
    950              pEndpoint->dBytesTransferred = 0;
   \   00000032   E860               STR      R0,[R5, #+12]
    951              pEndpoint->fCallback = fCallback;
   \   00000034   2E61               STR      R6,[R5, #+16]
    952              pEndpoint->pArgument = pArgument;
   \   00000036   6F61               STR      R7,[R5, #+20]
    953          
    954              // Send one packet
    955              pEndpoint->dState = endpointStateWrite;
   \   00000038   2800               MOVS     R0,R5
   \   0000003A   2030               ADDS     R0,R0,#+32
   \   0000003C   0221               MOVS     R1,#+2
   \   0000003E   4160               STR      R1,[R0, #+4]
    956              UDP_WritePayload(pUsb, bEndpoint);
   \   00000040   6846               MOV      R0,SP
   \   00000042   017A               LDRB     R1,[R0, #+8]
   \   00000044   2000               MOVS     R0,R4
   \   00000046   ........           BL       UDP_WritePayload
   \   0000004A   0CE0               B        ??UDP_Write_2
    957              UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_TXPKTRDY);
   \                     ??UDP_Write_3:
   \   0000004C   2000               MOVS     R0,R4
   \   0000004E   ........           BL       UDP_GetDriverInterface
   \   00000052   0700               MOVS     R7,R0
   \   00000054   2000               MOVS     R0,R4
   \   00000056   ........           BL       UDP_GetDriverInterface
   \   0000005A   8019               ADDS     R0,R0,R6
   \   0000005C   006B               LDR      R0,[R0, #+48]
   \   0000005E   1021               MOVS     R1,#+16
   \   00000060   0143               ORRS     R1,R1,R0
   \   00000062   B819               ADDS     R0,R7,R6
   \   00000064   0163               STR      R1,[R0, #+48]
   \                     ??UDP_Write_2:
   \   00000066   6846               MOV      R0,SP
   \   00000068   007A               LDRB     R0,[R0, #+8]
   \   0000006A   8600               LSLS     R6,R0,#+2
   \   0000006C   2000               MOVS     R0,R4
   \   0000006E   ........           BL       UDP_GetDriverInterface
   \   00000072   8019               ADDS     R0,R0,R6
   \   00000074   006B               LDR      R0,[R0, #+48]
   \   00000076   1021               MOVS     R1,#+16
   \   00000078   0842               TST      R0,R1
   \   0000007A   E7D0               BEQ      ??UDP_Write_3
    958          
    959              // If double buffering is enabled and there is data remaining,
    960              // prepare another packet
    961              if ((pEndpoint->dNumFIFO > 1) && (pEndpoint->dBytesRemaining > 0)) {
   \   0000007C   2020               MOVS     R0,#+32
   \   0000007E   285C               LDRB     R0,[R5, R0]
   \   00000080   0228               CMP      R0,#+2
   \   00000082   07D3               BCC      ??UDP_Write_4
   \   00000084   6868               LDR      R0,[R5, #+4]
   \   00000086   0028               CMP      R0,#+0
   \   00000088   04D0               BEQ      ??UDP_Write_4
    962          
    963                  UDP_WritePayload(pUsb, bEndpoint);
   \   0000008A   6846               MOV      R0,SP
   \   0000008C   017A               LDRB     R1,[R0, #+8]
   \   0000008E   2000               MOVS     R0,R4
   \   00000090   ........           BL       UDP_WritePayload
    964              }
    965          
    966              // Enable interrupt on endpoint
    967              SET(pInterface->UDP_IER, 1 << bEndpoint);
   \                     ??UDP_Write_4:
   \   00000094   0098               LDR      R0,[SP, #+0]
   \   00000096   0100               MOVS     R1,R0
   \   00000098   0969               LDR      R1,[R1, #+16]
   \   0000009A   0122               MOVS     R2,#+1
   \   0000009C   6B46               MOV      R3,SP
   \   0000009E   1B7A               LDRB     R3,[R3, #+8]
   \   000000A0   9A40               LSLS     R2,R2,R3
   \   000000A2   0A43               ORRS     R2,R2,R1
   \   000000A4   0261               STR      R2,[R0, #+16]
    968                                                                                         //TRACE_DEBUG_L("KON_USB_Write ");
    969                                                                                         //TRACE_DEBUG_L("\n\r");
    970              return USB_STATUS_SUCCESS;
   \   000000A6   0020               MOVS     R0,#+0
   \                     ??UDP_Write_1:
   \   000000A8   05B0               ADD      SP,SP,#+20
   \   000000AA   F0BC               POP      {R4-R7}
   \   000000AC   02BC               POP      {R1}
   \   000000AE   0847               BX       R1               ;; return
    971              
    972              
    973          }
    974          
    975          //------------------------------------------------------------------------------
    976          // \brief  Reads incoming data on an USB endpoint
    977          //
    978          //         This methods sets the transfer descriptor and activate the endpoint
    979          //         interrupt. The actual transfer is then carried out by the endpoint
    980          //         interrupt handler. The Read operation finishes either when the
    981          //         buffer is full, or a short packet (inferior to endpoint maximum
    982          //         packet size) is received.
    983          // \param  pUsb      Pointer to a S_usb instance
    984          // \param  bEndpoint Index of endpoint
    985          // \param  pData     Pointer to a buffer to store the received data
    986          // \param  dLength   Length of the receive buffer
    987          // \param  fCallback Optional callback function
    988          // \param  pArgument Optional callback argument
    989          // \return Operation result code
    990          // \see    Callback_f
    991          // \see    S_usb
    992          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    993          char UDP_Read(const S_usb   *pUsb,
    994                        unsigned char bEndpoint,
    995                        void          *pData,
    996                        unsigned int  dLength,
    997                        Callback_f    fCallback,
    998                        void          *pArgument)
    999          {
   \                     UDP_Read:
   \   00000000   FDB5               PUSH     {R0,R2-R7,LR}
   \   00000002   0700               MOVS     R7,R0
   \   00000004   0C00               MOVS     R4,R1
   \   00000006   099D               LDR      R5,[SP, #+36]
   1000              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000008   ........           BL       UDP_GetDriverInterface
   \   0000000C   0600               MOVS     R6,R0
   1001              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   0000000E   2100               MOVS     R1,R4
   \   00000010   3800               MOVS     R0,R7
   \   00000012   ........           BL       USB_GetEndpoint
   1002          
   1003              //! Return if the endpoint is not in IDLE state
   1004              if (pEndpoint->dState != endpointStateIdle) {
   \   00000016   416A               LDR      R1,[R0, #+36]
   \   00000018   0129               CMP      R1,#+1
   \   0000001A   01D0               BEQ      ??UDP_Read_0
   1005          
   1006                  return USB_STATUS_LOCKED;
   \   0000001C   0120               MOVS     R0,#+1
   \   0000001E   11E0               B        ??UDP_Read_1
   1007              }
   1008          
   1009                                                                                          //TRACE_DEBUG_L("Read%d(%d) ", bEndpoint, dLength);
   1010              // Endpoint enters Read state
   1011              pEndpoint->dState = endpointStateRead;
   \                     ??UDP_Read_0:
   \   00000020   0321               MOVS     R1,#+3
   \   00000022   4162               STR      R1,[R0, #+36]
   1012          
   1013              // Set the transfer descriptor
   1014              pEndpoint->pData = (char *) pData;
   \   00000024   0199               LDR      R1,[SP, #+4]
   \   00000026   0160               STR      R1,[R0, #+0]
   1015              pEndpoint->dBytesRemaining = dLength;
   \   00000028   0299               LDR      R1,[SP, #+8]
   \   0000002A   4160               STR      R1,[R0, #+4]
   1016              pEndpoint->dBytesBuffered = 0;
   \   0000002C   0021               MOVS     R1,#+0
   \   0000002E   8160               STR      R1,[R0, #+8]
   1017              pEndpoint->dBytesTransferred = 0;
   \   00000030   C160               STR      R1,[R0, #+12]
   1018              pEndpoint->fCallback = fCallback;
   \   00000032   0899               LDR      R1,[SP, #+32]
   \   00000034   0161               STR      R1,[R0, #+16]
   1019              pEndpoint->pArgument = pArgument;
   \   00000036   4561               STR      R5,[R0, #+20]
   1020          
   1021              // Enable interrupt on endpoint
   1022              SET(pInterface->UDP_IER, 1 << bEndpoint);
   \   00000038   3069               LDR      R0,[R6, #+16]
   \   0000003A   0121               MOVS     R1,#+1
   \   0000003C   A140               LSLS     R1,R1,R4
   \   0000003E   0143               ORRS     R1,R1,R0
   \   00000040   3161               STR      R1,[R6, #+16]
   1023              
   1024              //znak=USB_STATUS_SUCCESS;
   1025                                                                                         //TRACE_DEBUG_L("KON_USB_Read ");
   1026                                                                                         //TRACE_DEBUG_L("\n\r");
   1027                                                                                        
   1028              return USB_STATUS_SUCCESS;
   \   00000042   0020               MOVS     R0,#+0
   \                     ??UDP_Read_1:
   \   00000044   FEBC               POP      {R1-R7}
   \   00000046   02BC               POP      {R1}
   \   00000048   0847               BX       R1               ;; return
   1029          }
   1030          
   1031          //------------------------------------------------------------------------------
   1032          // \brief  Clears, sets or returns the Halt state on specified endpoint
   1033          //
   1034          //         When in Halt state, an endpoint acknowledges every received packet
   1035          //         with a STALL handshake. This continues until the endpoint is
   1036          //         manually put out of the Halt state by calling this function.
   1037          // \param  pUsb Pointer to a S_usb instance
   1038          // \param  bEndpoint Index of endpoint
   1039          // \param  bRequest  Request to perform
   1040          //                   -> USB_SET_FEATURE, USB_CLEAR_FEATURE, USB_GET_STATUS
   1041          // \return true if the endpoint is currently Halted, false otherwise
   1042          // \see    S_usb
   1043          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1044          bool UDP_Halt(const S_usb   *pUsb,
   1045                        unsigned char bEndpoint,
   1046                        unsigned char bRequest)
   1047          {
   \                     UDP_Halt:
   \   00000000   F3B5               PUSH     {R0,R1,R4-R7,LR}
   \   00000002   81B0               SUB      SP,SP,#+4
   \   00000004   1500               MOVS     R5,R2
   1048              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000006   ........           BL       UDP_GetDriverInterface
   \   0000000A   0400               MOVS     R4,R0
   1049              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   0000000C   6846               MOV      R0,SP
   \   0000000E   017A               LDRB     R1,[R0, #+8]
   \   00000010   0198               LDR      R0,[SP, #+4]
   \   00000012   ........           BL       USB_GetEndpoint
   \   00000016   0090               STR      R0,[SP, #+0]
   1050          
   1051              // Clear the Halt feature of the endpoint if it is enabled
   1052              if (bRequest == USB_CLEAR_FEATURE) {
   \   00000018   012D               CMP      R5,#+1
   \   0000001A   20D1               BNE      ??UDP_Halt_0
   1053          
   1054                                                                                          TRACE_DEBUG_L("Unhalt%d ", bEndpoint);
   1055          
   1056                  // Return endpoint to Idle state
   1057                  pEndpoint->dState = endpointStateIdle;
   \   0000001C   0121               MOVS     R1,#+1
   \   0000001E   4162               STR      R1,[R0, #+36]
   \   00000020   07E0               B        ??UDP_Halt_1
   1058          
   1059                  // Clear FORCESTALL flag
   1060                  UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_FORCESTALL);
   \                     ??UDP_Halt_2:
   \   00000022   0198               LDR      R0,[SP, #+4]
   \   00000024   ........           BL       UDP_GetDriverInterface
   \   00000028   4019               ADDS     R0,R0,R5
   \   0000002A   016B               LDR      R1,[R0, #+48]
   \   0000002C   2022               MOVS     R2,#+32
   \   0000002E   9143               BICS     R1,R1,R2
   \   00000030   0163               STR      R1,[R0, #+48]
   \                     ??UDP_Halt_1:
   \   00000032   6846               MOV      R0,SP
   \   00000034   007A               LDRB     R0,[R0, #+8]
   \   00000036   8500               LSLS     R5,R0,#+2
   \   00000038   0198               LDR      R0,[SP, #+4]
   \   0000003A   ........           BL       UDP_GetDriverInterface
   \   0000003E   4019               ADDS     R0,R0,R5
   \   00000040   006B               LDR      R0,[R0, #+48]
   \   00000042   2021               MOVS     R1,#+32
   \   00000044   0842               TST      R0,R1
   \   00000046   ECD1               BNE      ??UDP_Halt_2
   1061          
   1062                  // Reset Endpoint Fifos, beware this is a 2 steps operation
   1063                  SET(pInterface->UDP_RSTEP, 1 << bEndpoint);
   \   00000048   0120               MOVS     R0,#+1
   \   0000004A   6946               MOV      R1,SP
   \   0000004C   097A               LDRB     R1,[R1, #+8]
   \   0000004E   8840               LSLS     R0,R0,R1
   \   00000050   A16A               LDR      R1,[R4, #+40]
   \   00000052   0143               ORRS     R1,R1,R0
   \   00000054   A162               STR      R1,[R4, #+40]
   1064                  CLEAR(pInterface->UDP_RSTEP, 1 << bEndpoint);
   \   00000056   A16A               LDR      R1,[R4, #+40]
   \   00000058   8143               BICS     R1,R1,R0
   \   0000005A   A162               STR      R1,[R4, #+40]
   \   0000005C   2FE0               B        ??UDP_Halt_3
   1065              }
   1066              // Set the Halt feature on the endpoint if it is not already enabled
   1067              // and the endpoint is not disabled
   1068              else if ((bRequest == USB_SET_FEATURE)
   1069                       && (pEndpoint->dState != endpointStateHalted)
   1070                       && (pEndpoint->dState != endpointStateDisabled)) {
   \                     ??UDP_Halt_0:
   \   0000005E   032D               CMP      R5,#+3
   \   00000060   2DD1               BNE      ??UDP_Halt_3
   \   00000062   406A               LDR      R0,[R0, #+36]
   \   00000064   0428               CMP      R0,#+4
   \   00000066   2AD0               BEQ      ??UDP_Halt_3
   \   00000068   0098               LDR      R0,[SP, #+0]
   \   0000006A   406A               LDR      R0,[R0, #+36]
   \   0000006C   0028               CMP      R0,#+0
   \   0000006E   26D0               BEQ      ??UDP_Halt_3
   1071          
   1072                                                                                          TRACE_DEBUG_L("Halt%d ", bEndpoint);
   1073          
   1074                  // Abort the current transfer if necessary
   1075                  UDP_EndOfTransfer(pEndpoint, USB_STATUS_ABORTED);
   \   00000070   0221               MOVS     R1,#+2
   \   00000072   0098               LDR      R0,[SP, #+0]
   \   00000074   ........           BL       UDP_EndOfTransfer
   \   00000078   0BE0               B        ??UDP_Halt_4
   1076          
   1077                  // Put endpoint into Halt state
   1078                  UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_FORCESTALL);
   \                     ??UDP_Halt_5:
   \   0000007A   0198               LDR      R0,[SP, #+4]
   \   0000007C   ........           BL       UDP_GetDriverInterface
   \   00000080   0700               MOVS     R7,R0
   \   00000082   0198               LDR      R0,[SP, #+4]
   \   00000084   ........           BL       UDP_GetDriverInterface
   \   00000088   4019               ADDS     R0,R0,R5
   \   0000008A   006B               LDR      R0,[R0, #+48]
   \   0000008C   0643               ORRS     R6,R6,R0
   \   0000008E   7819               ADDS     R0,R7,R5
   \   00000090   0663               STR      R6,[R0, #+48]
   \                     ??UDP_Halt_4:
   \   00000092   6846               MOV      R0,SP
   \   00000094   007A               LDRB     R0,[R0, #+8]
   \   00000096   8500               LSLS     R5,R0,#+2
   \   00000098   2026               MOVS     R6,#+32
   \   0000009A   0198               LDR      R0,[SP, #+4]
   \   0000009C   ........           BL       UDP_GetDriverInterface
   \   000000A0   4019               ADDS     R0,R0,R5
   \   000000A2   006B               LDR      R0,[R0, #+48]
   \   000000A4   3100               MOVS     R1,R6
   \   000000A6   0842               TST      R0,R1
   \   000000A8   E7D0               BEQ      ??UDP_Halt_5
   1079                  pEndpoint->dState = endpointStateHalted;
   \   000000AA   0098               LDR      R0,[SP, #+0]
   \   000000AC   0421               MOVS     R1,#+4
   \   000000AE   4162               STR      R1,[R0, #+36]
   1080          
   1081                  // Enable the endpoint interrupt
   1082                  SET(pInterface->UDP_IER, 1 << bEndpoint);
   \   000000B0   2069               LDR      R0,[R4, #+16]
   \   000000B2   0121               MOVS     R1,#+1
   \   000000B4   6A46               MOV      R2,SP
   \   000000B6   127A               LDRB     R2,[R2, #+8]
   \   000000B8   9140               LSLS     R1,R1,R2
   \   000000BA   0143               ORRS     R1,R1,R0
   \   000000BC   2161               STR      R1,[R4, #+16]
   1083              }
   1084          
   1085              // Return the endpoint halt status
   1086              if (pEndpoint->dState == endpointStateHalted) {
   \                     ??UDP_Halt_3:
   \   000000BE   0098               LDR      R0,[SP, #+0]
   \   000000C0   406A               LDR      R0,[R0, #+36]
   \   000000C2   0428               CMP      R0,#+4
   \   000000C4   01D1               BNE      ??UDP_Halt_6
   1087          
   1088                  return true;
   \   000000C6   0120               MOVS     R0,#+1
   \   000000C8   00E0               B        ??UDP_Halt_7
   1089              }
   1090              else {
   1091          
   1092                  return false;
   \                     ??UDP_Halt_6:
   \   000000CA   0020               MOVS     R0,#+0
   \                     ??UDP_Halt_7:
   \   000000CC   FEBC               POP      {R1-R7}
   \   000000CE   02BC               POP      {R1}
   \   000000D0   0847               BX       R1               ;; return
   1093              }
   1094          }
   1095          
   1096          //------------------------------------------------------------------------------
   1097          // \brief  Causes the endpoint to acknowledge the next received packet with
   1098          //         a STALL handshake.
   1099          //
   1100          //         Further packets are then handled normally.
   1101          // \param  pUsb      Pointer to a S_usb instance
   1102          // \param  bEndpoint Index of endpoint
   1103          // \return Operation result code
   1104          // \see    S_usb
   1105          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1106          char UDP_Stall(const S_usb *pUsb,
   1107                         unsigned char bEndpoint)
   1108          {
   \                     UDP_Stall:
   \   00000000   F2B5               PUSH     {R1,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   1109              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   1110          
   1111              // Check that endpoint is in Idle state
   1112              if (pEndpoint->dState != endpointStateIdle) {
   \   00000004   ........           BL       USB_GetEndpoint
   \   00000008   406A               LDR      R0,[R0, #+36]
   \   0000000A   0128               CMP      R0,#+1
   \   0000000C   0DD0               BEQ      ??UDP_Stall_0
   1113          
   1114                  TRACE_WARNING("W: UDP_Stall: Endpoint%d locked\n\r", bEndpoint);
   1115                  return USB_STATUS_LOCKED;
   \   0000000E   0120               MOVS     R0,#+1
   \   00000010   18E0               B        ??UDP_Stall_1
   1116              }
   1117          
   1118                                                                                          TRACE_DEBUG_L("Stall%d ", bEndpoint);
   1119          
   1120              UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_FORCESTALL);
   \                     ??UDP_Stall_2:
   \   00000012   2000               MOVS     R0,R4
   \   00000014   ........           BL       UDP_GetDriverInterface
   \   00000018   0700               MOVS     R7,R0
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       UDP_GetDriverInterface
   \   00000020   4019               ADDS     R0,R0,R5
   \   00000022   006B               LDR      R0,[R0, #+48]
   \   00000024   0643               ORRS     R6,R6,R0
   \   00000026   7819               ADDS     R0,R7,R5
   \   00000028   0663               STR      R6,[R0, #+48]
   \                     ??UDP_Stall_0:
   \   0000002A   6846               MOV      R0,SP
   \   0000002C   0078               LDRB     R0,[R0, #+0]
   \   0000002E   8500               LSLS     R5,R0,#+2
   \   00000030   2026               MOVS     R6,#+32
   \   00000032   2000               MOVS     R0,R4
   \   00000034   ........           BL       UDP_GetDriverInterface
   \   00000038   4019               ADDS     R0,R0,R5
   \   0000003A   006B               LDR      R0,[R0, #+48]
   \   0000003C   3100               MOVS     R1,R6
   \   0000003E   0842               TST      R0,R1
   \   00000040   E7D0               BEQ      ??UDP_Stall_2
   1121          
   1122              return USB_STATUS_SUCCESS;
   \   00000042   0020               MOVS     R0,#+0
   \                     ??UDP_Stall_1:
   \   00000044   F8BC               POP      {R3-R7}
   \   00000046   02BC               POP      {R1}
   \   00000048   0847               BX       R1               ;; return
   1123          }
   1124          
   1125          //------------------------------------------------------------------------------
   1126          // \brief  Activates a remote wakeup procedure
   1127          // \param  pUsb Pointer to a S_usb instance
   1128          // \see    S_usb
   1129          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1130          void UDP_RemoteWakeUp(const S_usb *pUsb)
   1131          {
   \                     UDP_RemoteWakeUp:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0500               MOVS     R5,R0
   1132              AT91PS_UDP pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   ........           BL       UDP_GetDriverInterface
   \   00000008   0400               MOVS     R4,R0
   1133          
   1134              UDP_EnableMCK(pUsb);
   \   0000000A   2800               MOVS     R0,R5
   \   0000000C   ........           BL       UDP_EnableMCK
   1135              UDP_EnableUDPCK(pUsb);
   \   00000010   2800               MOVS     R0,R5
   \   00000012   ........           BL       UDP_EnableUDPCK
   1136              UDP_EnableTransceiver(pUsb);
   \   00000016   2800               MOVS     R0,R5
   \   00000018   ........           BL       UDP_EnableTransceiver
   1137          
   1138                                                                                          TRACE_DEBUG_L("Remote WakeUp ");
   1139          
   1140              // Activates a remote wakeup (edge on ESR)
   1141              SET(pInterface->UDP_GLBSTATE, AT91C_UDP_ESR);
   \   0000001C   6068               LDR      R0,[R4, #+4]
   \   0000001E   0421               MOVS     R1,#+4
   \   00000020   0143               ORRS     R1,R1,R0
   \   00000022   6160               STR      R1,[R4, #+4]
   1142              // Then clear ESR
   1143              CLEAR(pInterface->UDP_GLBSTATE, AT91C_UDP_ESR);
   \   00000024   6068               LDR      R0,[R4, #+4]
   \   00000026   0421               MOVS     R1,#+4
   \   00000028   8843               BICS     R0,R0,R1
   \   0000002A   6060               STR      R0,[R4, #+4]
   1144          }
   \   0000002C   38BC               POP      {R3-R5}
   \   0000002E   01BC               POP      {R0}
   \   00000030   0047               BX       R0               ;; return
   1145          
   1146          //------------------------------------------------------------------------------
   1147          // \brief  Handles attachment or detachment from the USB when the VBus power
   1148          //         line status changes.
   1149          // \param  pUsb Pointer to a S_usb instance
   1150          // \return true if VBus is present, false otherwise
   1151          // \see    S_usb
   1152          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1153          bool UDP_Attach(const S_usb *pUsb)
   1154          {
   \                     UDP_Attach:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   1155              AT91PS_UDP pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   ........           BL       UDP_GetDriverInterface
   \   00000008   0500               MOVS     R5,R0
   1156          
   1157                                                                                          TRACE_DEBUG_L("Attach(");
   1158          
   1159              // Check if VBus is present
   1160              if (!ISSET(USB_GetState(pUsb), USB_STATE_POWERED)
   1161                  && BRD_IsVBusConnected(pInterface)) {
   \   0000000A   0226               MOVS     R6,#+2
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       USB_GetState
   \   00000012   3100               MOVS     R1,R6
   \   00000014   0842               TST      R0,R1
   \   00000016   28D1               BNE      ??UDP_Attach_0
   \   00000018   2800               MOVS     R0,R5
   \   0000001A   ........           BL       BRD_IsVBusConnected
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   23D0               BEQ      ??UDP_Attach_0
   1162          
   1163                  // Powered state:
   1164                  //      MCK + UDPCK must be on
   1165                  //      Pull-Up must be connected
   1166                  //      Transceiver must be disabled
   1167          
   1168                  // Invoke the Resume callback
   1169                  USB_ResumeCallback(pUsb);
   \   00000022   2000               MOVS     R0,R4
   \   00000024   ........           BL       USB_ResumeCallback
   1170          
   1171                  UDP_EnableMCK(pUsb);
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   ........           BL       UDP_EnableMCK
   1172                  UDP_EnableUDPCK(pUsb);
   \   0000002E   2000               MOVS     R0,R4
   \   00000030   ........           BL       UDP_EnableUDPCK
   1173          
   1174                  // Reconnect the pull-up if needed
   1175                  if (ISSET(*(pUsb->pState), UDP_STATE_SHOULD_RECONNECT)) {
   \   00000034   6069               LDR      R0,[R4, #+20]
   \   00000036   0068               LDR      R0,[R0, #+0]
   \   00000038   C000               LSLS     R0,R0,#+3
   \   0000003A   07D5               BPL      ??UDP_Attach_1
   1176          
   1177                      USB_Connect(pUsb);
   \   0000003C   2000               MOVS     R0,R4
   \   0000003E   ........           BL       USB_Connect
   1178                      CLEAR(*(pUsb->pState), UDP_STATE_SHOULD_RECONNECT);
   \   00000042   6069               LDR      R0,[R4, #+20]
   \   00000044   0168               LDR      R1,[R0, #+0]
   \   00000046   284A               LDR      R2,??UDP_Attach_2  ;; 0xefffffff
   \   00000048   0A40               ANDS     R2,R2,R1
   \   0000004A   0260               STR      R2,[R0, #+0]
   1179                  }
   1180          
   1181                  // Clear the Suspend and Resume interrupts
   1182                  SET(pInterface->UDP_ICR,
   1183                      AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM | AT91C_UDP_RXSUSP);
   \                     ??UDP_Attach_1:
   \   0000004C   286A               LDR      R0,[R5, #+32]
   \   0000004E   8C21               MOVS     R1,#+140
   \   00000050   8901               LSLS     R1,R1,#+6        ;; #+8960
   \   00000052   0143               ORRS     R1,R1,R0
   \   00000054   2962               STR      R1,[R5, #+32]
   1184          
   1185                  SET(pInterface->UDP_IER, AT91C_UDP_RXSUSP);
   \   00000056   2869               LDR      R0,[R5, #+16]
   \   00000058   F101               LSLS     R1,R6,#+7
   \   0000005A   0143               ORRS     R1,R1,R0
   \   0000005C   2961               STR      R1,[R5, #+16]
   1186          
   1187                  // The device is in Powered state
   1188                  SET(*(pUsb->pState), USB_STATE_POWERED);
   \   0000005E   6069               LDR      R0,[R4, #+20]
   \   00000060   0100               MOVS     R1,R0
   \   00000062   0968               LDR      R1,[R1, #+0]
   \   00000064   0E43               ORRS     R6,R6,R1
   \   00000066   0660               STR      R6,[R0, #+0]
   \   00000068   33E0               B        ??UDP_Attach_3
   1189          
   1190              }
   1191              else if (ISSET(USB_GetState(pUsb), USB_STATE_POWERED)
   1192                       && !BRD_IsVBusConnected(pInterface)) {
   \                     ??UDP_Attach_0:
   \   0000006A   2000               MOVS     R0,R4
   \   0000006C   ........           BL       USB_GetState
   \   00000070   3042               TST      R0,R6
   \   00000072   2ED0               BEQ      ??UDP_Attach_3
   \   00000074   2800               MOVS     R0,R5
   \   00000076   ........           BL       BRD_IsVBusConnected
   \   0000007A   0028               CMP      R0,#+0
   \   0000007C   29D1               BNE      ??UDP_Attach_3
   1193          
   1194                  // Attached state:
   1195                  //      MCK + UDPCK off
   1196                  //      Pull-Up must be disconnected
   1197                  //      Transceiver must be disabled
   1198          
   1199                  // Warning: MCK must be enabled to be able to write in UDP registers
   1200                  // It may have been disabled by the Suspend interrupt, so re-enable it
   1201                  UDP_EnableMCK(pUsb);
   \   0000007E   2000               MOVS     R0,R4
   \   00000080   ........           BL       UDP_EnableMCK
   1202          
   1203                  // Disable interrupts
   1204                  SET(pInterface->UDP_IDR, AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM
   1205                                         | AT91C_UDP_RXSUSP | AT91C_UDP_SOFINT);
   \   00000084   6869               LDR      R0,[R5, #+20]
   \   00000086   AC21               MOVS     R1,#+172
   \   00000088   8901               LSLS     R1,R1,#+6        ;; #+11008
   \   0000008A   0143               ORRS     R1,R1,R0
   \   0000008C   6961               STR      R1,[R5, #+20]
   1206          
   1207                  UDP_DisableEndpoints(pUsb);
   \   0000008E   2000               MOVS     R0,R4
   \   00000090   ........           BL       UDP_DisableEndpoints
   1208                  UDP_DisableTransceiver(pUsb);
   \   00000094   2000               MOVS     R0,R4
   \   00000096   ........           BL       UDP_DisableTransceiver
   1209          
   1210                  // Disconnect the pull-up if needed
   1211                  if (ISSET(USB_GetState(pUsb), USB_STATE_DEFAULT)) {
   \   0000009A   2000               MOVS     R0,R4
   \   0000009C   ........           BL       USB_GetState
   \   000000A0   4007               LSLS     R0,R0,#+29
   \   000000A2   08D5               BPL      ??UDP_Attach_4
   1212          
   1213                      USB_Disconnect(pUsb);
   \   000000A4   2000               MOVS     R0,R4
   \   000000A6   ........           BL       USB_Disconnect
   1214                      SET(*(pUsb->pState), UDP_STATE_SHOULD_RECONNECT);
   \   000000AA   6069               LDR      R0,[R4, #+20]
   \   000000AC   0100               MOVS     R1,R0
   \   000000AE   0968               LDR      R1,[R1, #+0]
   \   000000B0   F206               LSLS     R2,R6,#+27
   \   000000B2   0A43               ORRS     R2,R2,R1
   \   000000B4   0260               STR      R2,[R0, #+0]
   1215                  }
   1216          
   1217                  UDP_DisableMCK(pUsb);
   \                     ??UDP_Attach_4:
   \   000000B6   2000               MOVS     R0,R4
   \   000000B8   ........           BL       UDP_DisableMCK
   1218                  UDP_DisableUDPCK(pUsb);
   \   000000BC   2000               MOVS     R0,R4
   \   000000BE   ........           BL       UDP_DisableUDPCK
   1219          
   1220                  // The device leaves the all states except Attached
   1221                  CLEAR(*(pUsb->pState), USB_STATE_POWERED | USB_STATE_DEFAULT
   1222                        | USB_STATE_ADDRESS | USB_STATE_CONFIGURED | USB_STATE_SUSPENDED);
   \   000000C2   6069               LDR      R0,[R4, #+20]
   \   000000C4   0168               LDR      R1,[R0, #+0]
   \   000000C6   3E22               MOVS     R2,#+62
   \   000000C8   9143               BICS     R1,R1,R2
   \   000000CA   0160               STR      R1,[R0, #+0]
   1223          
   1224                  // Invoke the Suspend callback
   1225                  USB_SuspendCallback(pUsb);
   \   000000CC   2000               MOVS     R0,R4
   \   000000CE   ........           BL       USB_SuspendCallback
   1226              }
   1227          
   1228                                                                                          TRACE_DEBUG_L("%d) ", ISSET(USB_GetState(pUsb), USB_STATE_POWERED));
   1229          
   1230              return (bool)(ISSET(USB_GetState(pUsb), USB_STATE_POWERED));
   \                     ??UDP_Attach_3:
   \   000000D2   2000               MOVS     R0,R4
   \   000000D4   ........           BL       USB_GetState
   \   000000D8   0100               MOVS     R1,R0
   \   000000DA   4908               LSRS     R1,R1,#+1
   \   000000DC   0120               MOVS     R0,#+1
   \   000000DE   0840               ANDS     R0,R0,R1
   \   000000E0   70BC               POP      {R4-R6}
   \   000000E2   02BC               POP      {R1}
   \   000000E4   0847               BX       R1               ;; return
   \   000000E6   C046               Nop      
   \                     ??UDP_Attach_2:
   \   000000E8   FFFFFFEF           DC32     0xefffffff
   1231          }
   1232          
   1233          //------------------------------------------------------------------------------
   1234          // \brief  Sets or unsets the device address
   1235          //
   1236          //         This function directly accesses the S_usb_request instance located
   1237          //         in the S_usb structure to extract its new address.
   1238          // \param  pUsb Pointer to a S_usb instance
   1239          // \see    S_usb
   1240          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1241          void UDP_SetAddress(S_usb const *pUsb)
   1242          {
   \                     UDP_SetAddress:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1243              unsigned short wAddress = USB_GetSetup(pUsb)->wValue;
   \   00000004   ........           BL       USB_GetSetup
   \   00000008   4588               LDRH     R5,[R0, #+2]
   1244              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       UDP_GetDriverInterface
   1245          
   1246                                                                                          TRACE_DEBUG_L("SetAddr(%d) ", wAddress);
   1247          
   1248              // Set address
   1249              SET(pInterface->UDP_FADDR, AT91C_UDP_FEN | wAddress);
   \   00000010   8168               LDR      R1,[R0, #+8]
   \   00000012   8022               MOVS     R2,#+128
   \   00000014   5200               LSLS     R2,R2,#+1        ;; #+256
   \   00000016   2A43               ORRS     R2,R2,R5
   \   00000018   0A43               ORRS     R2,R2,R1
   \   0000001A   8260               STR      R2,[R0, #+8]
   1250          
   1251              if (wAddress == 0) {
   \   0000001C   002D               CMP      R5,#+0
   \   0000001E   4168               LDR      R1,[R0, #+4]
   \   00000020   06D1               BNE      ??UDP_SetAddress_0
   1252          
   1253                  SET(pInterface->UDP_GLBSTATE, 0);
   \   00000022   4160               STR      R1,[R0, #+4]
   1254          
   1255                  // Device enters the Default state
   1256                  CLEAR(*(pUsb->pState), USB_STATE_ADDRESS);
   \   00000024   6069               LDR      R0,[R4, #+20]
   \   00000026   0168               LDR      R1,[R0, #+0]
   \   00000028   0822               MOVS     R2,#+8
   \   0000002A   9143               BICS     R1,R1,R2
   \   0000002C   0160               STR      R1,[R0, #+0]
   \   0000002E   08E0               B        ??UDP_SetAddress_1
   1257              }
   1258              else {
   1259          
   1260                  SET(pInterface->UDP_GLBSTATE, AT91C_UDP_FADDEN);
   \                     ??UDP_SetAddress_0:
   \   00000030   0122               MOVS     R2,#+1
   \   00000032   0A43               ORRS     R2,R2,R1
   \   00000034   4260               STR      R2,[R0, #+4]
   1261          
   1262                  // The device enters the Address state
   1263                  SET(*(pUsb->pState), USB_STATE_ADDRESS);
   \   00000036   6069               LDR      R0,[R4, #+20]
   \   00000038   0100               MOVS     R1,R0
   \   0000003A   0968               LDR      R1,[R1, #+0]
   \   0000003C   0822               MOVS     R2,#+8
   \   0000003E   0A43               ORRS     R2,R2,R1
   \   00000040   0260               STR      R2,[R0, #+0]
   1264              }
   1265          }
   \                     ??UDP_SetAddress_1:
   \   00000042   38BC               POP      {R3-R5}
   \   00000044   01BC               POP      {R0}
   \   00000046   0047               BX       R0               ;; return
   1266          
   1267          //------------------------------------------------------------------------------
   1268          // \brief  Changes the device state from Address to Configured, or from
   1269          //         Configured to Address.
   1270          //
   1271          //         This method directly access the last received SETUP packet to
   1272          //         decide on what to do.
   1273          // \see    S_usb
   1274          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1275          void UDP_SetConfiguration(S_usb const *pUsb)
   1276          {
   \                     UDP_SetConfiguration:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1277              unsigned short wValue = USB_GetSetup(pUsb)->wValue;
   \   00000004   ........           BL       USB_GetSetup
   \   00000008   4588               LDRH     R5,[R0, #+2]
   1278              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   0000000A   2000               MOVS     R0,R4
   \   0000000C   ........           BL       UDP_GetDriverInterface
   1279          
   1280                                                                                          TRACE_DEBUG_L("SetCfg() ");
   1281          
   1282              // Check the request
   1283              if (wValue != 0) {
   \   00000010   002D               CMP      R5,#+0
   \   00000012   6169               LDR      R1,[R4, #+20]
   \   00000014   09D0               BEQ      ??UDP_SetConfiguration_0
   1284          
   1285                  // Enter Configured state
   1286                  SET(*(pUsb->pState), USB_STATE_CONFIGURED);
   \   00000016   0A00               MOVS     R2,R1
   \   00000018   1268               LDR      R2,[R2, #+0]
   \   0000001A   1023               MOVS     R3,#+16
   \   0000001C   1343               ORRS     R3,R3,R2
   \   0000001E   0B60               STR      R3,[R1, #+0]
   1287                  SET(pInterface->UDP_GLBSTATE, AT91C_UDP_CONFG);
   \   00000020   4168               LDR      R1,[R0, #+4]
   \   00000022   0222               MOVS     R2,#+2
   \   00000024   0A43               ORRS     R2,R2,R1
   \   00000026   4260               STR      R2,[R0, #+4]
   \   00000028   0AE0               B        ??UDP_SetConfiguration_1
   1288              }
   1289              else {
   1290          
   1291                  // Go back to Address state
   1292                  CLEAR(*(pUsb->pState), USB_STATE_CONFIGURED);
   \                     ??UDP_SetConfiguration_0:
   \   0000002A   0A68               LDR      R2,[R1, #+0]
   \   0000002C   1023               MOVS     R3,#+16
   \   0000002E   9A43               BICS     R2,R2,R3
   \   00000030   0A60               STR      R2,[R1, #+0]
   1293                  SET(pInterface->UDP_GLBSTATE, AT91C_UDP_FADDEN);
   \   00000032   4168               LDR      R1,[R0, #+4]
   \   00000034   0122               MOVS     R2,#+1
   \   00000036   0A43               ORRS     R2,R2,R1
   \   00000038   4260               STR      R2,[R0, #+4]
   1294          
   1295                  // Abort all transfers
   1296                  UDP_DisableEndpoints(pUsb);
   \   0000003A   2000               MOVS     R0,R4
   \   0000003C   ........           BL       UDP_DisableEndpoints
   1297              }
   1298          }
   \                     ??UDP_SetConfiguration_1:
   \   00000040   38BC               POP      {R3-R5}
   \   00000042   01BC               POP      {R0}
   \   00000044   0047               BX       R0               ;; return
   1299          
   1300          //------------------------------------------------------------------------------
   1301          // \brief  Enables the pull-up on the D+ line to connect the device to the USB.
   1302          // \param  pUsb Pointer to a S_usb instance
   1303          // \see    S_usb
   1304          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1305          void UDP_Connect(const S_usb *pUsb)
   1306          {
   \                     UDP_Connect:
   \   00000000   01B5               PUSH     {R0,LR}
   1307          #if defined(UDP_INTERNAL_PULLUP)
   1308              SET(UDP_GetDriverInterface(pUsb)->UDP_TXVC, AT91C_UDP_PUON);
   1309          
   1310          #elif defined(UDP_INTERNAL_PULLUP_BY_MATRIX)
   1311                                                                                          TRACE_DEBUG_L("PUON 1\n\r");
   1312              AT91C_BASE_MATRIX->MATRIX_USBPCR |= AT91C_MATRIX_USBPCR_PUON;
   1313          
   1314          #else
   1315              BRD_ConnectPullUp(UDP_GetDriverInterface(pUsb));
   \   00000002   ........           BL       UDP_GetDriverInterface
   \   00000006   ........           BL       BRD_ConnectPullUp
   1316          
   1317          #endif
   1318          }
   \   0000000A   08BC               POP      {R3}
   \   0000000C   01BC               POP      {R0}
   \   0000000E   0047               BX       R0               ;; return
   1319          
   1320          //------------------------------------------------------------------------------
   1321          // \brief  Disables the pull-up on the D+ line to disconnect the device from
   1322          //         the bus.
   1323          // \param  pUsb Pointer to a S_usb instance
   1324          // \see    S_usb
   1325          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1326          void UDP_Disconnect(const S_usb *pUsb)
   1327          {
   \                     UDP_Disconnect:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1328          #if defined(UDP_INTERNAL_PULLUP)
   1329              CLEAR(UDP_GetDriverInterface(pUsb)->UDP_TXVC, AT91C_UDP_PUON);
   1330          
   1331          #elif defined(UDP_INTERNAL_PULLUP_BY_MATRIX)
   1332                                                                                          TRACE_DEBUG_L("PUON 0\n\r");
   1333              AT91C_BASE_MATRIX->MATRIX_USBPCR &= ~AT91C_MATRIX_USBPCR_PUON;
   1334          
   1335          #else
   1336              BRD_DisconnectPullUp(UDP_GetDriverInterface(pUsb));
   \   00000004   ........           BL       UDP_GetDriverInterface
   \   00000008   ........           BL       BRD_DisconnectPullUp
   1337          
   1338          #endif
   1339              // Device leaves the Default state
   1340              CLEAR(*(pUsb->pState), USB_STATE_DEFAULT);
   \   0000000C   6069               LDR      R0,[R4, #+20]
   \   0000000E   0168               LDR      R1,[R0, #+0]
   \   00000010   0422               MOVS     R2,#+4
   \   00000012   9143               BICS     R1,R1,R2
   \   00000014   0160               STR      R1,[R0, #+0]
   1341          }
   \   00000016   10BC               POP      {R4}
   \   00000018   01BC               POP      {R0}
   \   0000001A   0047               BX       R0               ;; return
   1342          
   1343          //------------------------------------------------------------------------------
   1344          // \brief  Initializes the specified USB driver
   1345          //
   1346          //         This function initializes the current FIFO bank of endpoints,
   1347          //         configures the pull-up and VBus lines, disconnects the pull-up and
   1348          //         then trigger the Init callback.
   1349          // \param  pUsb Pointer to a S_usb instance
   1350          // \see    S_usb
   1351          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1352          void UDP_Init(const S_usb *pUsb)
   1353          {
   \                     UDP_Init:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1354              unsigned int dIndex;
   1355              AT91PS_UDP   pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   ........           BL       UDP_GetDriverInterface
   \   00000008   0500               MOVS     R5,R0
   1356          
   1357                                                                                          TRACE_DEBUG_L("Init()\n\r");
   1358          
   1359              // Init data banks
   1360              for (dIndex = 0; dIndex < pUsb->dNumEndpoints; dIndex++) {
   \   0000000A   0020               MOVS     R0,#+0
   \   0000000C   06E0               B        ??UDP_Init_0
   1361          
   1362                  pUsb->pEndpoints[dIndex].dFlag = AT91C_UDP_RX_DATA_BK0;
   \                     ??UDP_Init_1:
   \   0000000E   2821               MOVS     R1,#+40
   \   00000010   4143               MULS     R1,R0,R1
   \   00000012   6268               LDR      R2,[R4, #+4]
   \   00000014   5118               ADDS     R1,R2,R1
   \   00000016   0222               MOVS     R2,#+2
   \   00000018   CA61               STR      R2,[R1, #+28]
   1363              }
   \   0000001A   401C               ADDS     R0,R0,#+1
   \                     ??UDP_Init_0:
   \   0000001C   A168               LDR      R1,[R4, #+8]
   \   0000001E   8842               CMP      R0,R1
   \   00000020   F5D3               BCC      ??UDP_Init_1
   1364          
   1365              // External pull-up on D+
   1366              // Configure
   1367              BRD_ConfigurePullUp(pInterface);
   \   00000022   2800               MOVS     R0,R5
   \   00000024   ........           BL       BRD_ConfigurePullUp
   1368          
   1369              // Disable
   1370              UDP_Disconnect(pUsb);
   \   00000028   2000               MOVS     R0,R4
   \   0000002A   ........           BL       UDP_Disconnect
   1371          
   1372              // Device is in the Attached state
   1373              *(pUsb->pState) = USB_STATE_ATTACHED;
   \   0000002E   6069               LDR      R0,[R4, #+20]
   \   00000030   0121               MOVS     R1,#+1
   \   00000032   0160               STR      R1,[R0, #+0]
   1374          
   1375              // Disable the UDP transceiver and interrupts
   1376              UDP_EnableMCK(pUsb);
   \   00000034   2000               MOVS     R0,R4
   \   00000036   ........           BL       UDP_EnableMCK
   1377              SET(pInterface->UDP_IDR, AT91C_UDP_RXRSM);
   \   0000003A   6869               LDR      R0,[R5, #+20]
   \   0000003C   8021               MOVS     R1,#+128
   \   0000003E   8900               LSLS     R1,R1,#+2        ;; #+512
   \   00000040   0143               ORRS     R1,R1,R0
   \   00000042   6961               STR      R1,[R5, #+20]
   1378              UDP_Connect(pUsb);
   \   00000044   2000               MOVS     R0,R4
   \   00000046   ........           BL       UDP_Connect
   1379              UDP_DisableTransceiver(pUsb);
   \   0000004A   2000               MOVS     R0,R4
   \   0000004C   ........           BL       UDP_DisableTransceiver
   1380              UDP_DisableMCK(pUsb);
   \   00000050   2000               MOVS     R0,R4
   \   00000052   ........           BL       UDP_DisableMCK
   1381              UDP_Disconnect(pUsb);
   \   00000056   2000               MOVS     R0,R4
   \   00000058   ........           BL       UDP_Disconnect
   1382          
   1383              // Configure interrupts
   1384              USB_InitCallback(pUsb);
   \   0000005C   2000               MOVS     R0,R4
   \   0000005E   ........           BL       USB_InitCallback
   1385          }
   \   00000062   38BC               POP      {R3-R5}
   \   00000064   01BC               POP      {R0}
   \   00000066   0047               BX       R0               ;; return
   1386          
   1387          //------------------------------------------------------------------------------
   1388          //      Global variables
   1389          //------------------------------------------------------------------------------
   1390          
   1391          // \brief Low-level driver methods to use with the UDP USB controller
   1392          // \see S_driver_methods

   \                                 In section .rodata, align 4
   1393          const S_driver_methods sUDPMethods = {
   \                     sUDPMethods:
   \   00000000   ............       DC32 UDP_Init, UDP_Write, UDP_Read, UDP_Stall, UDP_Halt
   \              ............
   \              ............
   \              ....        
   \   00000014   ............       DC32 UDP_RemoteWakeUp, UDP_ConfigureEndpoint, UDP_Attach
   \              ............
   \   00000020   ............       DC32 UDP_SetAddress, UDP_SetConfiguration, UDP_Handler, UDP_Connect
   \              ............
   \              ........    
   \   00000030   ........           DC32 UDP_Disconnect
   1394          
   1395              UDP_Init,
   1396              UDP_Write,
   1397              UDP_Read,
   1398              UDP_Stall,
   1399              UDP_Halt,
   1400              UDP_RemoteWakeUp,
   1401              UDP_ConfigureEndpoint,
   1402              UDP_Attach,
   1403              UDP_SetAddress,
   1404              UDP_SetConfiguration,
   1405              UDP_Handler,
   1406              UDP_Connect,
   1407              UDP_Disconnect
   1408          };
   1409          
   1410          // \brief  Default driver when an UDP controller is present on a chip

   \                                 In section .rodata, align 4
   1411          const S_usb_driver sDefaultDriver = {
   \                     sDefaultDriver:
   \   00000000   0000FBFF0000       DC32 0FFFB0000H, 0H, 0H, 11, 128, sUDPMethods
   \              000000000000
   \              0B0000008000
   \              0000........
   1412          
   1413              AT91C_BASE_UDP,
   1414              0,
   1415              0,
   1416              AT91C_ID_UDP,
   1417              AT91C_PMC_UDP,
   1418              &sUDPMethods
   1419          };
   1420          
   1421          #endif // UDP
   1422          
   1423          

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     UDP_Attach                   16
     UDP_ClearRXFlag              24
     UDP_ConfigureEndpoint        32
     UDP_Connect                   8
     UDP_DisableEndpoints         16
     UDP_DisableMCK                8
     UDP_DisableTransceiver       16
     UDP_DisableUDPCK             16
     UDP_Disconnect                8
     UDP_EnableMCK                 8
     UDP_EnableTransceiver         8
     UDP_EnableUDPCK              16
     UDP_EndOfTransfer             8
     UDP_EndpointHandler          32
     UDP_GetDriverInterface        0
     UDP_GetPayload               24
     UDP_GetSetup                 16
     UDP_Halt                     32
     UDP_Handler                  24
     UDP_Init                     16
     UDP_Read                     32
     UDP_RemoteWakeUp             16
     UDP_ResetEndpoints           16
     UDP_SetAddress               16
     UDP_SetConfiguration         16
     UDP_Stall                    24
     UDP_Write                    40
     UDP_WritePayload             16
     USB_Connect                   8
     USB_Disconnect                8
     USB_GetDriverID               0
     USB_GetDriverPMC              0
     USB_GetEndpoint               8
     USB_GetSetup                  0
     USB_GetState                  0
     USB_InitCallback              8
     USB_NewRequestCallback        8
     USB_ResetCallback             8
     USB_ResumeCallback            8
     USB_StartOfFrameCallback      8
     USB_SuspendCallback           8
     lastSetBit                    8
     min                           0


   Section sizes:

     Function/Label           Bytes
     --------------           -----
     min                         8
     lastSetBit                 96
     USB_GetEndpoint            26
     USB_GetSetup                4
     USB_GetDriverID             6
     USB_GetDriverPMC            6
     USB_InitCallback           24
     USB_ResetCallback          24
     USB_SuspendCallback        24
     USB_ResumeCallback         24
     USB_NewRequestCallback     24
     USB_StartOfFrameCallback   16
     USB_Connect                18
     USB_Disconnect             18
     USB_GetState               10
     UDP_GetDriverInterface      6
     UDP_EnableMCK              24
     UDP_DisableMCK             24
     UDP_EnableUDPCK            24
     UDP_DisableUDPCK           24
     UDP_EnableTransceiver      24
     UDP_DisableTransceiver     32
     UDP_EndOfTransfer          48
     UDP_ClearRXFlag            78
     UDP_WritePayload           74
     UDP_GetPayload             84
     UDP_GetSetup               38
     UDP_ResetEndpoints         54
     UDP_DisableEndpoints       46
     UDP_EndpointHandler       660
     UDP_ConfigureEndpoint     228
     UDP_Handler               420
     UDP_Write                 176
     UDP_Read                   74
     UDP_Halt                  210
     UDP_Stall                  74
     UDP_RemoteWakeUp           50
     UDP_Attach                236
     UDP_SetAddress             72
     UDP_SetConfiguration       70
     UDP_Connect                16
     UDP_Disconnect             28
     UDP_Init                  104
     sUDPMethods                52
     sDefaultDriver             24
      Others                     4

 
    76 bytes in section .rodata
 3 330 bytes in section Debug.txt
 
 2 928 bytes of CODE  memory (+ 402 bytes shared)
    76 bytes of CONST memory

Errors: none
Warnings: none
