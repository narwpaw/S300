###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           04/Jun/2013  20:18:35 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\cdc\serial_driver.c                           #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\cdc\serial_driver.c" -D AT91SAM7S256 -D       #
#                    AT91SAM7SEK -D iH -D __ALARM -D __WIFI_MODULE -D S300i   #
#                    -lC "D:\Zeuron\Projekty\S300\S300-program v1.3 -         #
#                    04.06.2013\S300i\List\" --diag_suppress Pa082 -o         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\S300i\Obj\" --debug --endian little --cpu     #
#                    ARM7TDMI -e --fpu None --dlib_config "C:\Program Files   #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    5.0\ARM\INC\DLib_Config_Normal.h" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v1.3 - 04.06.2013\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v1.3 - 04.06.2013\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v1.3 - 04.06.2013\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\Framework\Configuration\" -I "C:\Program      #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\INC\" --section .text=Debug.txt --interwork      #
#                    --cpu_mode thumb -Oh                                     #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300i\List\serial_driver.lst                  #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300i\Obj\serial_driver.o                     #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\cdc\serial_driver.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support  -  ROUSSET  -
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2006, Atmel Corporation
      5          
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaiimer below.
     13           *
     14           * - Redistributions in binary form must reproduce the above copyright notice,
     15           * this list of conditions and the disclaimer below in the documentation and/or
     16           * other materials provided with the distribution.
     17           *
     18           * Atmel's name may not be used to endorse or promote products derived from
     19           * this software without specific prior written permission.
     20           *
     21           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     22           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     23           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     24           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     25           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     26           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     27           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     28           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     29           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     30           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31           * ----------------------------------------------------------------------------
     32           */
     33          
     34          /*
     35          $Id: serial_driver.c,v 1.1.2.1 2006/12/05 08:33:25 danielru Exp $
     36          */
     37          
     38          //------------------------------------------------------------------------------
     39          //      Includes
     40          //------------------------------------------------------------------------------
     41          
     42          #include "core/common.h"
     43          #include "core/device.h"
     44          #include "core/board.h"
     45          #include "core/trace.h"
     46          #include "core/usb.h"
     47          #include "core/standard.h"
     48          #include "cdc.h"
     49          #include "serial_driver.h"
     50          
     51          //------------------------------------------------------------------------------
     52          //      Global variables
     53          //------------------------------------------------------------------------------
     54          
     55          // Descriptors
     56          //------------------------------------------------------------------------------
     57          //! \brief  Standard USB device descriptor
     58          //! \see    S_usb_device_descriptor

   \                                 In section .rodata, align 4
     59          const S_usb_device_descriptor sDevice = {
   \                     sDevice:
   \   00000000   1201               DC8 18, 1
   \   00000002   1001               DC16 272
   \   00000004   02000008           DC8 2, 0, 0, 8
   \   00000008   EB0319610100       DC16 1003, 24857, 1
   \   0000000E   010203010000       DC8 1, 2, 3, 1, 0, 0
     60          
     61              sizeof(S_usb_device_descriptor), // Size of this descriptor
     62              USB_DEVICE_DESCRIPTOR,           // DEVICE Descriptor Type
     63              USB1_10,                         // USB 1.10 specification
     64              USB_CLASS_COMMUNICATION,         // USB Communication class code
     65              0x00,                            // No device subclass code
     66              0x00,                            // No device protocol code
     67              USB_ENDPOINT0_MAXPACKETSIZE,     // Maximum packet size for endpoint zero
     68              USB_VENDOR_ATMEL,                // ATMEL Vendor ID
     69              SER_PRODUCT_ID,                  // Product ID (6119)
     70              0x0001,                          // Device release number 0.01
     71              0x01,                            // Index of manufacturer description
     72              0x02,                            // Index of product description
     73              0x03,                            // Index of serial number description
     74              0x01                             // One possible configuration
     75          };
     76          
     77          //! \brief  Device configuration descriptor
     78          //! \see    S_ser_configuration_descriptor

   \                                 In section .rodata, align 4
     79          const S_ser_configuration_descriptor sConfiguration = {
   \                     sConfiguration:
   \   00000000   0902               DC8 9, 2
   \   00000002   4300               DC16 67
   \   00000004   020100E03209       DC8 2, 1, 0, 224, 50, 9, 4, 0, 0, 1, 2, 2, 1, 0, 5, 36, 0
   \              040000010202
   \              0100052400  
   \   00000015   1001               DC16 272
   \   00000017   052401010104       DC8 5, 36, 1, 1, 1, 4, 36, 2, 7, 5, 36, 6, 0, 1, 7, 5, 131, 3
   \              240207052406
   \              000107058303
   \   00000029   4000               DC16 64
   \   0000002B   100904010002       DC8 16, 9, 4, 1, 0, 2, 10, 0, 0, 0, 7, 5, 1, 2
   \              0A0000000705
   \              0102        
   \   00000039   4000               DC16 64
   \   0000003B   0007058202         DC8 0, 7, 5, 130, 2
   \   00000040   4000               DC16 64
   \   00000042   0000               DC8 0, 0
     80          
     81              // Standard configuration descriptor
     82              {
     83                  // Size of this descriptor
     84                  sizeof(S_usb_configuration_descriptor),
     85                  // CONFIGURATION descriptor type
     86                  USB_CONFIGURATION_DESCRIPTOR,
     87                  // Total size of this configuration (including other descriptors)
     88                  sizeof(S_ser_configuration_descriptor),
     89                  // Two interfaces are used by this configuration
     90                  0x02,
     91                  // Value 0x01 is used to select this configuration
     92                  0x01,
     93                  // No string is used to describe this configuration
     94                  0x00,
     95                  // Device is self-powered and does not support remote wakeup
     96                  USB_CONFIG_SELF_WAKEUP,
     97                  // Maximum power consumption of the device is 100mA
     98                  USB_POWER_MA(100)
     99              },
    100              // Communication class interface descriptor
    101              {
    102                  sizeof(S_usb_interface_descriptor), // Size of this descriptor in bytes
    103                  USB_INTERFACE_DESCRIPTOR,           // INTERFACE Descriptor Type
    104                  0x00,                               // Interface 0
    105                  0x00,                               // No alternate settings
    106                  0x01,                               // One endpoint used
    107                  CDC_INTERFACE_COMMUNICATION,        // Communication interface class
    108                  CDC_ABSTRACT_CONTROL_MODEL,         // Abstract control model subclass
    109                  0x01,                               // No protocol code
    110                  0x00                                // No associated string descriptor
    111              },
    112              // Header functional descriptor
    113              {
    114                  sizeof(S_cdc_header_descriptor), // Size of this descriptor in bytes
    115                  CDC_CS_INTERFACE,                // CS_INTERFACE descriptor type
    116                  CDC_HEADER,                      // Header functional descriptor
    117                  CDC1_10,                         // CDC version 1.10
    118              },
    119              // Call management functional descriptor
    120              {
    121                  sizeof(S_cdc_call_management_descriptor), // Size of this descriptor
    122                  CDC_CS_INTERFACE,                         // CS_INTERFACE type
    123                  CDC_CALL_MANAGEMENT,                      // Call management descriptor
    124                  0x01,                                     // Call management is
    125                                                            // handled by the device
    126                  0x01                                      // Data interface is 0x01
    127              },
    128              // Abstract control management functional descriptor
    129              {
    130                  // Size of this descriptor in bytes
    131                  sizeof(S_cdc_abstract_control_management_descriptor),
    132                  // CS_INTERFACE descriptor type
    133                  CDC_CS_INTERFACE,
    134                  // Abstract control management functional descriptor
    135                  CDC_ABSTRACT_CONTROL_MANAGEMENT,
    136                  // Every notification/request except NetworkConnection supported
    137                  0x07
    138              },
    139              // Union functional descriptor with one slave interface
    140              {
    141                  // Union functional descriptor
    142                  {
    143                      sizeof(S_cdc_union_descriptor)+1, // Size of this descriptor
    144                      CDC_CS_INTERFACE,                 // CS_INTERFACE descriptor type
    145                      CDC_UNION,                        // Union functional descriptor
    146                      0x00,                             // Master interface is 0x00
    147                  },                                    // (Communication class interface)
    148                  0x01                                  // First slave interface is 0x01
    149              },                                        // (Data class interface)
    150              // Notification endpoint descriptor
    151              {
    152                  sizeof(S_usb_endpoint_descriptor),  // Size of this descriptor in bytes
    153                  USB_ENDPOINT_DESCRIPTOR,            // ENDPOINT descriptor type
    154                  USB_ENDPOINT_IN | SER_EPT_NOTIFICATION, // IN endpoint, address = 0x03
    155                  ENDPOINT_TYPE_INTERRUPT,            // INTERRUPT endpoint type
    156                  64,                                 // Maximum packet size is 64 bytes
    157                  0x10                                // Endpoint polled every 10ms
    158              },
    159              // Data class interface descriptor
    160              {
    161                  sizeof(S_usb_interface_descriptor), // Size of this descriptor in bytes
    162                  USB_INTERFACE_DESCRIPTOR,           // INTERFACE descriptor type
    163                  0x01,                               // Interface 0x01
    164                  0x00,                               // No alternate settings
    165                  0x02,                               // Two endpoints used
    166                  CDC_INTERFACE_DATA,                 // Data class code
    167                  0x00,                               // No subclass code
    168                  0x00,                               // No protocol code
    169                  0x00                                // No description string
    170              },
    171              // Bulk-OUT endpoint descriptor
    172              {
    173                  sizeof(S_usb_endpoint_descriptor), // Size of this descriptor in bytes
    174                  USB_ENDPOINT_DESCRIPTOR,           // ENDPOINT descriptor type
    175                  USB_ENDPOINT_OUT | SER_EPT_DATA_OUT,   // OUT endpoint, address = 0x01
    176                  ENDPOINT_TYPE_BULK,                // Bulk endpoint
    177                  64,                                // Endpoint size is 64 bytes
    178                  0x00                               // Must be 0x00 for full-speed bulk
    179              },                                     // endpoints
    180              // Bulk-IN endpoint descriptor
    181              {
    182                  sizeof(S_usb_endpoint_descriptor), // Size of this descriptor in bytes
    183                  USB_ENDPOINT_DESCRIPTOR,           // ENDPOINT descriptor type
    184                  USB_ENDPOINT_IN | SER_EPT_DATA_IN,     // IN endpoint, address = 0x02
    185                  ENDPOINT_TYPE_BULK,                // Bulk endpoint
    186                  64,                                // Endpoint size is 64 bytes
    187                  0x00                               // Must be 0x00 for full-speed bulk
    188              },                                     // endpoints
    189          };
    190          
    191          //! \brief  Language ID string descriptor

   \                                 In section .rodata, align 4
    192          const S_usb_language_id sLanguageID = {
   \                     sLanguageID:
   \   00000000   0403               DC8 4, 3
   \   00000002   0904               DC16 1033
    193          
    194              USB_STRING_DESCRIPTOR_SIZE(1),
    195              USB_STRING_DESCRIPTOR,
    196              USB_LANGUAGE_ENGLISH_US
    197          };
    198          
    199          //! \brief  Manufacturer string descriptor

   \                                 In section .rodata, align 4
    200          const char pManufacturer[] = {
   \                     pManufacturer:
   \   00000000   0C0341005400       DC8 12, 3, 65, 0, 84, 0, 77, 0, 69, 0, 76, 0
   \              4D0045004C00
    201          
    202              USB_STRING_DESCRIPTOR_SIZE(5),
    203              USB_STRING_DESCRIPTOR,
    204              USB_UNICODE('A'),
    205              USB_UNICODE('T'),
    206              USB_UNICODE('M'),
    207              USB_UNICODE('E'),
    208              USB_UNICODE('L')
    209          };
    210          
    211          //! \brief  Product string descriptor

   \                                 In section .rodata, align 4
    212          const char pProduct[] = {
   \                     pProduct:
   \   00000000   1C0341005400       DC8 28, 3, 65, 0, 84, 0, 57, 0, 49, 0, 85, 0, 83, 0, 66, 0, 83, 0, 101
   \              390031005500
   \              530042005300
   \              65          
   \   00000013   007200690061       DC8 0, 114, 0, 105, 0, 97, 0, 108, 0
   \              006C00      
    213          
    214              USB_STRING_DESCRIPTOR_SIZE(13),
    215              USB_STRING_DESCRIPTOR,
    216              USB_UNICODE('A'),
    217              USB_UNICODE('T'),
    218              USB_UNICODE('9'),
    219              USB_UNICODE('1'),
    220              USB_UNICODE('U'),
    221              USB_UNICODE('S'),
    222              USB_UNICODE('B'),
    223              USB_UNICODE('S'),
    224              USB_UNICODE('e'),
    225              USB_UNICODE('r'),
    226              USB_UNICODE('i'),
    227              USB_UNICODE('a'),
    228              USB_UNICODE('l')
    229          };
    230          
    231          //! \brief  Serial number string descriptor

   \                                 In section .rodata, align 4
    232          const char pSerialNumber[] = {
   \                     pSerialNumber:
   \   00000000   1A0330003100       DC8 26, 3, 48, 0, 49, 0, 50, 0, 51, 0, 52, 0, 53, 0, 54, 0, 55, 0, 56
   \              320033003400
   \              350036003700
   \              38          
   \   00000013   003900410046       DC8 0, 57, 0, 65, 0, 70, 0, 0, 0
   \              000000      
    233          
    234              USB_STRING_DESCRIPTOR_SIZE(12),
    235              USB_STRING_DESCRIPTOR,
    236              USB_UNICODE('0'),
    237              USB_UNICODE('1'),
    238              USB_UNICODE('2'),
    239              USB_UNICODE('3'),
    240              USB_UNICODE('4'),
    241              USB_UNICODE('5'),
    242              USB_UNICODE('6'),
    243              USB_UNICODE('7'),
    244              USB_UNICODE('8'),
    245              USB_UNICODE('9'),
    246              USB_UNICODE('A'),
    247              USB_UNICODE('F')
    248          };
    249          
    250          //! \brief  List of string descriptors

   \                                 In section .data, align 4
    251          const char *pStrings[] = {
   \                     pStrings:
   \   00000000   ............       DC32 sLanguageID, pManufacturer, pProduct, pSerialNumber
   \              ............
   \              ........    
    252          
    253              (char *) &sLanguageID,
    254              pManufacturer,
    255              pProduct,
    256              pSerialNumber
    257          };
    258          
    259          //! \brief List of endpoint descriptors

   \                                 In section .data, align 4
    260          const S_usb_endpoint_descriptor *pEndpoints[] = {
   \                     pEndpoints:
   \   00000000   ............       DC32 sConfiguration + 35H, sConfiguration + 3CH, sConfiguration + 25H
   \              ............
    261          
    262              &(sConfiguration.sDataOut),
    263              &(sConfiguration.sDataIn),
    264              &(sConfiguration.sNotification)
    265          };
    266          
    267          //! \brief  Standard descriptors list

   \                                 In section .rodata, align 4
    268          const S_std_descriptors sDescriptors = {
   \                     sDescriptors:
   \   00000000   ............       DC32 sDevice, sConfiguration, pStrings, pEndpoints
   \              ............
   \              ........    
    269          
    270              &sDevice,
    271              (S_usb_configuration_descriptor *) &sConfiguration,
    272              pStrings,
    273              pEndpoints
    274          };
    275          
    276          //------------------------------------------------------------------------------
    277          //      Internal functions
    278          //------------------------------------------------------------------------------
    279          //------------------------------------------------------------------------------
    280          //! \brief  Sets asynchronous line-character formatting properties
    281          //!
    282          //!         This function is used as a callback when receiving the data part
    283          //!         of a SET_LINE_CODING request.
    284          //! \param  pSer         Pointer to a S_ser instance
    285          //! \see    S_ser
    286          //! \see    usbcdc11.pdf - Section 6.2.12
    287          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    288          static void ACM_SetLineCoding(const S_ser *pSer)
    289          {
   \                     ACM_SetLineCoding:
   \   00000000   10B5               PUSH     {R4,LR}
    290              USB_SendZLP0(pSer->sClass.pUsb, 0, 0);
   \   00000002   0468               LDR      R4,[R0, #+0]
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   03B4               PUSH     {R0,R1}
   \   0000000A   0300               MOVS     R3,R0
   \   0000000C   0200               MOVS     R2,R0
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   2468               LDR      R4,[R4, #+0]
   \   00000012   6469               LDR      R4,[R4, #+20]
   \   00000014   6468               LDR      R4,[R4, #+4]
   \   00000016   ........           BL       __iar_via_R4
   \   0000001A   02B0               ADD      SP,SP,#+8
    291          }
   \   0000001C   10BC               POP      {R4}
   \   0000001E   01BC               POP      {R0}
   \   00000020   0047               BX       R0               ;; return
    292          
    293          //------------------------------------------------------------------------------
    294          //! \brief  Sends the currently configured line coding to the host
    295          //! \param  pSer               Pointer to a S_ser instance
    296          //! \see    S_ser
    297          //! \see    usbcdc11.pdf - Section 6.2.13
    298          //------------------------------------------------------------------------------
    299          static void ACM_GetLineCoding(const S_ser *pSer)
    300          {
    301              USB_Write(pSer->sClass.pUsb,
    302                        0,
    303                        (void *) &(pSer->sLineCoding),
    304                        sizeof(S_cdc_line_coding),
    305                        0,
    306                        0);
    307          }
    308          
    309          //------------------------------------------------------------------------------
    310          //! \brief  Sets the state of control line parameters.
    311          //! \param  pSer              Pointer to a S_ser instance
    312          //! \param  isActivateCarrier Indicates if the device should activate
    313          //!                           its carrier
    314          //! \param  isDTEPresent      Indicates if the terminal is present
    315          //! \see    S_ser
    316          //! \see    usbcdc11.pdf - Section 6.2.14
    317          //------------------------------------------------------------------------------
    318          static void ACM_SetControlLineState(S_ser *pSer,
    319                                              bool  isActivateCarrier,
    320                                              bool  isDTEPresent)
    321          {
    322              pSer->isCarrierActivated = isActivateCarrier;
    323              USB_SendZLP0(pSer->sClass.pUsb, 0, 0);
    324          }
    325          
    326          //------------------------------------------------------------------------------
    327          //      Exported functions
    328          //------------------------------------------------------------------------------
    329          //------------------------------------------------------------------------------
    330          //! \brief  SETUP request handler for an Abstract Control Model device
    331          //! \param  pSer Pointer to a S_ser instance
    332          //! \see    S_ser
    333          //! \see    usbcdc11.pdf - Section 6.2
    334          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    335          void SER_RequestHandler(S_ser *pSer)
    336          {
   \                     SER_RequestHandler:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0200               MOVS     R2,R0
    337              S_usb_request *pSetup = USB_GetSetup(pSer->sClass.pUsb);
   \   00000004   1468               LDR      R4,[R2, #+0]
   \   00000006   2069               LDR      R0,[R4, #+16]
    338          
    339              //TRACE_DEBUG_M("NewReq ");
    340          
    341              // Handle the request
    342              switch (pSetup->bRequest) {
   \   00000008   4178               LDRB     R1,[R0, #+1]
   \   0000000A   2029               CMP      R1,#+32
   \   0000000C   04D0               BEQ      ??SER_RequestHandler_0
   \   0000000E   2129               CMP      R1,#+33
   \   00000010   10D0               BEQ      ??SER_RequestHandler_1
   \   00000012   2229               CMP      R1,#+34
   \   00000014   1AD0               BEQ      ??SER_RequestHandler_2
   \   00000016   2CE0               B        ??SER_RequestHandler_3
    343          
    344              //-----------------------
    345              case CDC_SET_LINE_CODING:
    346              //-----------------------
    347                  //TRACE_DEBUG_M("sLineCoding ");
    348          
    349                  // Start the read operation with ACM_SetLineCoding as the callback
    350                  USB_Read(pSer->sClass.pUsb,
    351                           0,
    352                           (void *) &(pSer->sLineCoding),
    353                           sizeof(S_cdc_line_coding),
    354                           (Callback_f) ACM_SetLineCoding,
    355                           pSer);
   \                     ??SER_RequestHandler_0:
   \   00000018   1100               MOVS     R1,R2
   \   0000001A   1948               LDR      R0,??SER_RequestHandler_4  ;; ACM_SetLineCoding
   \   0000001C   03B4               PUSH     {R0,R1}
   \   0000001E   0723               MOVS     R3,#+7
   \   00000020   0C32               ADDS     R2,R2,#+12
   \   00000022   0021               MOVS     R1,#+0
   \   00000024   2000               MOVS     R0,R4
   \   00000026   2468               LDR      R4,[R4, #+0]
   \   00000028   6469               LDR      R4,[R4, #+20]
   \   0000002A   A468               LDR      R4,[R4, #+8]
   \   0000002C   ........           BL       __iar_via_R4
   \                     ??SER_RequestHandler_5:
   \   00000030   02B0               ADD      SP,SP,#+8
   \   00000032   21E0               B        ??SER_RequestHandler_6
    356          
    357                  break;
    358          
    359              //-----------------------
    360              case CDC_GET_LINE_CODING:
    361              //-----------------------
    362                  TRACE_DEBUG_M("gLineCoding ");
    363                  ACM_GetLineCoding(pSer);
   \                     ??SER_RequestHandler_1:
   \   00000034   0021               MOVS     R1,#+0
   \   00000036   0020               MOVS     R0,#+0
   \   00000038   03B4               PUSH     {R0,R1}
   \   0000003A   0723               MOVS     R3,#+7
   \   0000003C   0C32               ADDS     R2,R2,#+12
   \   0000003E   2000               MOVS     R0,R4
   \   00000040   2468               LDR      R4,[R4, #+0]
   \   00000042   6469               LDR      R4,[R4, #+20]
   \   00000044   6468               LDR      R4,[R4, #+4]
   \   00000046   ........           BL       __iar_via_R4
   \   0000004A   F1E7               B.N      ??SER_RequestHandler_5
    364          
    365                  break;
    366          
    367              //------------------------------
    368              case CDC_SET_CONTROL_LINE_STATE:
    369              //------------------------------
    370                  {
    371                      bool isActivateCarrier = false;
   \                     ??SER_RequestHandler_2:
   \   0000004C   0021               MOVS     R1,#+0
    372                      bool isDTEPresent = false;
    373          
    374                      //TRACE_DEBUG_M("sControlLineState(");
    375          
    376                      if (ISSET(pSetup->wValue, CDC_DTE_PRESENT)) {
    377          
    378                          isDTEPresent = true;
    379                      }
    380          
    381                      if (ISSET(pSetup->wValue, CDC_ACTIVATE_CARRIER)) {
   \   0000004E   4088               LDRH     R0,[R0, #+2]
   \   00000050   8007               LSLS     R0,R0,#+30
   \   00000052   00D5               BPL      ??SER_RequestHandler_7
    382          
    383                          isActivateCarrier = true;
   \   00000054   0121               MOVS     R1,#+1
    384                      }
    385          
    386                      //TRACE_DEBUG_M("%d,%d) ", isDTEPresent, isActivateCarrier);
    387          
    388                      ACM_SetControlLineState(pSer, isActivateCarrier, isDTEPresent);
   \                     ??SER_RequestHandler_7:
   \   00000056   D174               STRB     R1,[R2, #+19]
   \   00000058   0021               MOVS     R1,#+0
   \   0000005A   0020               MOVS     R0,#+0
   \   0000005C   03B4               PUSH     {R0,R1}
   \   0000005E   0300               MOVS     R3,R0
   \   00000060   0200               MOVS     R2,R0
   \   00000062   2000               MOVS     R0,R4
   \   00000064   2468               LDR      R4,[R4, #+0]
   \   00000066   6469               LDR      R4,[R4, #+20]
   \   00000068   6468               LDR      R4,[R4, #+4]
   \   0000006A   ........           BL       __iar_via_R4
   \   0000006E   02B0               ADD      SP,SP,#+8
   \   00000070   02E0               B        ??SER_RequestHandler_6
    389                  }
    390                  break;
    391          
    392              //------
    393              default:
    394              //------
    395                  // Forward request to standard request handler
    396                  STD_RequestHandler((S_std_class *) pSer);
   \                     ??SER_RequestHandler_3:
   \   00000072   1000               MOVS     R0,R2
   \   00000074   ........           BL       STD_RequestHandler
    397          
    398                  break;
    399              }
    400          }
   \                     ??SER_RequestHandler_6:
   \   00000078   10BC               POP      {R4}
   \   0000007A   01BC               POP      {R0}
   \   0000007C   0047               BX       R0               ;; return
   \   0000007E   C046               Nop      
   \                     ??SER_RequestHandler_4:
   \   00000080   ........           DC32     ACM_SetLineCoding
    401          
    402          //------------------------------------------------------------------------------
    403          //! \brief  Initializes a CDC serial driver
    404          //!
    405          //!         This method sets the standard descriptors of the device and the
    406          //!         default CDC configuration.
    407          //! \param  pSer Pointer to a S_ser instance
    408          //! \param  pUsb Pointer to the S_usb driver instance to use
    409          //! \see    S_ser
    410          //! \see    S_usb
    411          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    412          void SER_Init(S_ser *pSer, const S_usb *pUsb)
    413          {
   \                     SER_Init:
   \   00000000   01B5               PUSH     {R0,LR}
    414              // Initialize standard class attributes
    415              pSer->sClass.pUsb = pUsb;
   \   00000002   0160               STR      R1,[R0, #+0]
    416              pSer->sClass.pDescriptors = &sDescriptors;
   \   00000004   084A               LDR      R2,??SER_Init_0  ;; sDescriptors
   \   00000006   4260               STR      R2,[R0, #+4]
    417          
    418              // Initialize ACM attributes
    419              // Line coding
    420              pSer->sLineCoding.dwDTERate = 0;
   \   00000008   0022               MOVS     R2,#+0
   \   0000000A   C260               STR      R2,[R0, #+12]
    421              pSer->sLineCoding.bCharFormat = 0;
   \   0000000C   0274               STRB     R2,[R0, #+16]
    422              pSer->sLineCoding.bParityType = 0;
   \   0000000E   4274               STRB     R2,[R0, #+17]
    423              pSer->sLineCoding.bDataBits = 0;
   \   00000010   8274               STRB     R2,[R0, #+18]
    424          
    425              // Carrier
    426              pSer->isCarrierActivated = false;
   \   00000012   C274               STRB     R2,[R0, #+19]
    427          
    428              // Initialize the USB driver
    429              USB_Init(pUsb);
   \   00000014   0800               MOVS     R0,R1
   \   00000016   0968               LDR      R1,[R1, #+0]
   \   00000018   4969               LDR      R1,[R1, #+20]
   \   0000001A   0968               LDR      R1,[R1, #+0]
   \   0000001C   ........           BL       __iar_via_R1
    430          }
   \   00000020   08BC               POP      {R3}
   \   00000022   01BC               POP      {R0}
   \   00000024   0047               BX       R0               ;; return
   \   00000026   C046               Nop      
   \                     ??SER_Init_0:
   \   00000028   ........           DC32     sDescriptors
    431          
    432          //------------------------------------------------------------------------------
    433          //! \brief  Reads data from the Data OUT endpoint
    434          //! \param  pSer      Pointer to a S_ser instance
    435          //! \param  pBuffer   Buffer in which to store the received data
    436          //! \param  dLength   Length of data buffer
    437          //! \param  fCallback Optional callback function
    438          //! \param  pArgument Optional parameter for the callback function
    439          //! \return SER_STATUS_SUCCESS if transfer has started successfully;
    440          //!         SER_STATUS_LOCKED if endpoint is currently in use;
    441          //!         SER_STATUS_ERROR if transfer cannot be started.
    442          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    443          unsigned char SER_Read(S_ser *pSer,
    444                                 void *pBuffer,
    445                                 unsigned int dLength,
    446                                 Callback_f fCallback,
    447                                 void *pArgument)
    448          {
   \                     SER_Read:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0C00               MOVS     R4,R1
   \   00000004   0499               LDR      R1,[SP, #+16]
    449              return USB_Read(pSer->sClass.pUsb, SER_EPT_DATA_OUT, pBuffer,
    450                              dLength, fCallback, pArgument);
   \   00000006   0568               LDR      R5,[R0, #+0]
   \   00000008   1800               MOVS     R0,R3
   \   0000000A   03B4               PUSH     {R0,R1}
   \   0000000C   1300               MOVS     R3,R2
   \   0000000E   2200               MOVS     R2,R4
   \   00000010   0121               MOVS     R1,#+1
   \   00000012   2800               MOVS     R0,R5
   \   00000014   2C68               LDR      R4,[R5, #+0]
   \   00000016   6469               LDR      R4,[R4, #+20]
   \   00000018   A468               LDR      R4,[R4, #+8]
   \   0000001A   ........           BL       __iar_via_R4
   \   0000001E   02B0               ADD      SP,SP,#+8
   \   00000020   38BC               POP      {R3-R5}
   \   00000022   02BC               POP      {R1}
   \   00000024   0847               BX       R1               ;; return
    451          }
    452          
    453          //------------------------------------------------------------------------------
    454          //! \brief  Sends data through the Data IN endpoint
    455          //! \param  pSer      Pointer to a S_ser instance
    456          //! \param  pBuffer   Buffer holding the data to transmit
    457          //! \param  dLength   Length of data buffer
    458          //! \param  fCallback Optional callback function
    459          //! \param  pArgument Optional parameter for the callback function
    460          //! \return SER_STATUS_SUCCESS if transfer has started successfully;
    461          //!         SER_STATUS_LOCKED if endpoint is currently in use;
    462          //!         SER_STATUS_ERROR if transfer cannot be started.
    463          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    464          unsigned char SER_Write(S_ser *pSer,
    465                                  void *pBuffer,
    466                                  unsigned int dLength,
    467                                  Callback_f fCallback,
    468                                  void *pArgument)
    469          {
   \                     SER_Write:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0C00               MOVS     R4,R1
   \   00000004   0499               LDR      R1,[SP, #+16]
    470              return USB_Write(pSer->sClass.pUsb, SER_EPT_DATA_IN, pBuffer,
    471                               dLength, fCallback, pArgument);
   \   00000006   0568               LDR      R5,[R0, #+0]
   \   00000008   1800               MOVS     R0,R3
   \   0000000A   03B4               PUSH     {R0,R1}
   \   0000000C   1300               MOVS     R3,R2
   \   0000000E   2200               MOVS     R2,R4
   \   00000010   0221               MOVS     R1,#+2
   \   00000012   2800               MOVS     R0,R5
   \   00000014   2C68               LDR      R4,[R5, #+0]
   \   00000016   6469               LDR      R4,[R4, #+20]
   \   00000018   6468               LDR      R4,[R4, #+4]
   \   0000001A   ........           BL       __iar_via_R4
   \   0000001E   02B0               ADD      SP,SP,#+8
   \   00000020   38BC               POP      {R3-R5}
   \   00000022   02BC               POP      {R1}
   \   00000024   0847               BX       R1               ;; return
    472          }

   Maximum stack usage in bytes:

     Function           .cstack
     --------           -------
     ACM_SetLineCoding      16
     SER_Init                8
     SER_Read               24
     SER_RequestHandler     16
     SER_Write              24


   Section sizes:

     Function/Label     Bytes
     --------------     -----
     sDevice              20
     sConfiguration       68
     sLanguageID           4
     pManufacturer        12
     pProduct             28
     pSerialNumber        28
     pStrings             16
     pEndpoints           12
     sDescriptors         16
     ACM_SetLineCoding    34
     SER_RequestHandler  132
     SER_Init             44
     SER_Read             38
     SER_Write            38
      Others               4

 
  28 bytes in section .data
 176 bytes in section .rodata
 290 bytes in section Debug.txt
 
 286 bytes of CODE  memory (+ 4 bytes shared)
 176 bytes of CONST memory
  28 bytes of DATA  memory

Errors: none
Warnings: none
