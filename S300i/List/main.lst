###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           04/Sep/2013  19:34:32 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v1.4 -              #
#                    12.06.2013\Framework\main.c                              #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\Framework\main.c" -D AT91SAM7S256 -D          #
#                    AT91SAM7SEK -D iH -D __ALARM -D __WIFI_MODULE -D S300i   #
#                    -lC "D:\Zeuron\Projekty\S300\S300-program v1.4 -         #
#                    12.06.2013\S300i\List\" --diag_suppress Pa082 -o         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\S300i\Obj\" --debug --endian little --cpu     #
#                    ARM7TDMI -e --fpu None --dlib_config "C:\Program Files   #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    5.0\ARM\INC\DLib_Config_Normal.h" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v1.4 - 12.06.2013\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v1.4 - 12.06.2013\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v1.4 - 12.06.2013\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\Framework\Configuration\" -I "C:\Program      #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\INC\" --section .text=Debug.txt --interwork      #
#                    --cpu_mode thumb -Oh                                     #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v1.4 -              #
#                    12.06.2013\S300i\List\main.lst                           #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v1.4 -              #
#                    12.06.2013\S300i\Obj\main.o                              #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\main.c
      1          //****************************************************************************//
      2          //*--------------------------------------------------------------------------*//
      3          //*                                 CEURON                                   *//                     
      4          //*--------------------------------------------------------------------------*//
      5          //*--------------------------------------------------------------------------*//
      6          //*  Nazwa pliku                  : main.c                                   *//
      7          //*  Opis                         : G³ówny plik programu                     *//
      8          //*  Autor                        : Pawe³ Narwojsz                           *//
      9          //*  Data utrzorzenia             : 10.09.2007                               *//
     10          //*  Data ostatniej modyfikacji   : --.--.----                               *//
     11          //*--------------------------------------------------------------------------*//
     12          //*                                                                          *//
     13          //*--------------------------------------------------------------------------*//
     14          //* Rejestr zmian  (data - opis):                                            *//
     15          //*                                                                          *//
     16          //*                               Brak zmian                                 *//
     17          //*                                                                          *//
     18          //*__________________________________________________________________________*// 
     19          //****************************************************************************//
     20          //****************************************************************************//
     21            
     22          
     23          
     24          //Sta³e ------------------------------------------------------------------------
     25          #ifdef S300
     26              const char identyfikacja[]="S300 ";                                          //nazwa urz¹dzeni 
     27          #endif
     28          #ifdef S300i

   \                                 In section .rodata, align 4
     29              const char identyfikacja[]="S300-i ";                                          //nazwa urz¹dzeni 
   \                     identyfikacja:
   \   00000000   533330302D69       DC8 "S300-i "
   \              2000        
     30          #endif
     31          #ifdef S300iMax
     32              const char identyfikacja[]="S300-iMax ";                                          //nazwa urz¹dzeni 
     33          #endif
     34          #ifdef S300iOld
     35              const char identyfikacja[]="S300-i(Old) ";                                          //nazwa urz¹dzeni 
     36          #endif
     37              

   \                                 In section .rodata, align 4
     38              const char system[]="1.4";                                                  //nazwa urz¹dzeni 
   \                     system:
   \   00000000   312E3400           DC8 "1.4"
     39              
     40          //____________________________Koniec sta³ych ___________________________________
     41          
     42          
     43          
     44          //Konfiguracja -----------------------------------------------------------------
     45              #define LightLCD_Time              20                                       //czas (s sek.) wygaszania podœwietlenia
     46          //___________________________Koniec konfiguracji________________________________
     47          
     48          
     49          
     50          
     51          //Definicje --------------------------------------------------------------------
     52              #define MSG_SIZE 	                1000                                    
     53              #define TAB_SIZE                    1000                                    
     54              #define USB_BUFFER_SIZE             300                                     //bufor odbiorczy USB  
     55             
     56             // #define NOTRACES              `                                              //Wy³¹cza debagowania poprzez US1
     57              
     58          //___________________________Koniec definicji___________________________________
     59          
     60          
     61          
     62          // Pliki do³¹czane -------------------------------------------------------------
     63          
     64               #include "main_H.h"

                                          
                                          ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\Configuration\InterruptPriority.h",59  Warning[Pe001]: 
          last line of file ends without a newline
     65               #include "WizFi.h"

   
   ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\WizFi.h",172  Warning[Pe001]: 
          last line of file ends without a newline
     66          
     67          
     68          
     69          //-----------------------Koniec plików do³¹czanych -----------------------------
     70          
     71          
     72          
     73          
     74          
     75          
     76          
     77          
     78          
     79          

   \                                 In section .bss, align 1
     80          char APC;
   \                     APC:
   \   00000000                      DS8 1
     81          
     82          
     83          
     84          
     85          
     86          //Zmienne globalne -------------------------------------------------------------

   \                                 In section .data, align 1
     87              char g_czas_petli = 10;                                                     //  Czas przebiegu pêtli programu w ms
   \                     g_czas_petli:
   \   00000000   0A                 DC8 10

   \                                 In section .bss, align 4
     88              unsigned int komunikacja_ok=0;                                              //1-ok, 0-brak
   \                     komunikacja_ok:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     89              int  rej_prog[10];
   \                     rej_prog:
   \   00000000                      DS8 40

   \                                 In section .bss, align 4
     90              int LifeCouter = 0, LifeCouterMax = 0;                                      // Zmienne funkcji LifeBlinking
   \                     LifeCouter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   \                     LifeCouterMax:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
     91              byte USB_busy;
   \                     USB_busy:
   \   00000000                      DS8 1
     92              int FlashProgramOfset =  256;                                               //0-wykonywany program A, 
     93              int FlashProgramReserveOfset =  256+UseProgramSize;                         //0-wykonywany program A, 

   \                                 In section .bss, align 4
     94              int  advY =0;                                                                  //chwilowa wspolzedna Y TP
   \                     advY:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     95              int  advX =0;                                                                  //chwilowa wspolzedna X TP
   \                     advX:
   \   00000000                      DS8 4
     96               signed short  Y_down  =-1;                                                           //wspolzedna Y TP (naciœniêcie)
     97               signed short  X_down  =-1;                                                           //wspolzedna X TP (naciœniêcie)
     98               signed short  Y_up    =-1;                                                           //wspolzedna Y TP (puszczenie)
     99               signed short  X_up    =-1;                                                           //wspolzedna X TP (puszczenie)

   \                                 In section .bss, align 4
    100              int  g_leng  =0;                                                            //jêzyk 1-polski, 2 angielski
   \                     g_leng:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    101              char g_level =0;                                                            //poziom dostêpu 0-ograniczony, 1- operator, 2-administrator
   \                     g_level:
   \   00000000                      DS8 1
    102              char g_Password_1[8]={"1111"};                                              //haslo poziomu 1  
    103              char g_Password_2[8]={"2222"};                                              //haslo poziomu 1  

   \                                 In section .bss, align 4
    104              long int g_Message =0;                                                             //1-wiadomosc ekranowa
   \                     g_Message:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    105              int g_info=0;                                                                   
   \                     g_info:
   \   00000000                      DS8 4
    106              char g_PC_Connected;                                                       //1-pod³aczony komputer
    107              unsigned long long  g_counter;                                              //globalny licznik milisekundowy od w³¹czenia/restartu sterownika
    108              unsigned long       g_seconds_counter;                                      //globalny licznik sekundowy od w³¹czenia/restartu sterownika
    109              
    110          //    static char US0_Buffer[US_BUFFER_SIZE];                                    //bufor odbiorczy USART 0
    111          //    static char US0_Buffer2[US_BUFFER_SIZE];                                   //zapasowy bufor odbiorczy USART 0
    112              char AdressModbus = 1;                                                      //Adres urz¹dzenia dla protoko³u modbus
    113              int g_LightCouterLCD = 0;                                                   //licznik podœwietlenia lcd
    114              char g_LightLCDEnable = 0;                                                   //podœwietlenia lcd
    115              char g_ScreenSever_On;                                                      //1-Wygaszacz aktywny
    116              char g_ScreenSever_Time_On;                                                 //godzina w³¹czenia wygaszacz
    117              char g_ScreenSever_Time_Off;                                                //godzina wy³¹czenia wygaszacza
    118              char g_SlaveConnect=0;                                                   //
    119              char g_Stop_Program = 0;                                                    //1- zatrzymuje program
    120              char g_Restart_Program = 1;                                                 //1- restartuje program
    121              unsigned long long g_NextTimeProgram = 0;                                                    //
    122              char g_NeedPass=0;  //wymóg has³a
    123              char AlarmOn=0;                                                             //1=alarm dzwiêkowy
    124              char Speaker[SPK_Amount];                                                   //sygna³ dŸwiêkowy
    125              _AlarmScreenActionType AlarmScreenAction;
    126              char ChangeingIdMode=0;                                                     //tryb zmiany ID blokuje ustanawianie po³¹czeñ mostowych

   \                                 In section .bss, align 8
    127              _Net NET; 
   \                     NET:
   \   00000000                      DS8 448
    128              char WypMaxJasnosci;                                                        //jasnoœc ekranu przy aktywnym ekranie
    129              char WypMinJasnosci;                                                        //jasnoœc ekranu przy nieaktywnym ekranie
    130              char gWypMinJasnosciTest;                                                   //test wygl¹du ekranu z  jsnoœci¹ WypMinJasnosci   
    131              long long FuseLastWiFiDataIn;                                               //zabezpieczenie przed blokad¹ DMA USART. FuseLastWiFiDataIn zawiera czas ostatniej odpowiedzi od usarta. Je¿eli WiFi jest w³¹czone a USART milczy od 30s to restartuj mikroprocesor
    132              unsigned char ChangeStageFlag=10;                                           //ile razy (maksymalnie) sterownik ma wys³aæ zmiane stanu wyjœcia
    133              //___________________________Koniec zmiennych globalnych________________________
    134          
    135          
    136          
    137          
    138          
    139          //Zmienne lokalne -------------------------------------------------------------

   \                                 In section .bss, align 1
    140              char LightLCD_OFF_Counter;                                                  //zmiena œciemniacza LCD
   \                     LightLCD_OFF_Counter:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    141              char LightLCD_OFF_Counter2;                                                 //zmiena œciemniacza LCD
   \                     LightLCD_OFF_Counter2:
   \   00000000                      DS8 1

   \                                 In section .bss, align 1
    142              char LightLCD_OFF_Curent;                                                   //zmiena œciemniacza LCD
   \                     LightLCD_OFF_Curent:
   \   00000000                      DS8 1
    143              volatile char SlaveMode=0;
    144             // volatile char SwitchToMasterBlock;

   \                                 In section .bss, align 8
    145              volatile long long TimeInMasterMode;                                         //zmienna dla kontroli czasu w trybie slave
   \                     TimeInMasterMode:
   \   00000000                      DS8 8

   \                                 In section .bss, align 1
    146              volatile char ReciveFrameToMe=0;                                            //zmienna u¿ywana do prze³¹czania w tryb tymczasowy master po odebraniu ramki pobrania statusu z poprawnym id a nastêpnie ramki do obcego lub ponownym odebraniu ramki z poprawnym id i rozkazem pobrania statusu. Ramka pobrania statusu (odczyt rej. 0) zawsze wystêpuje na pocz¹tku kolejki ramek do pojedyñczego wêz³a 
   \                     ReciveFrameToMe:
   \   00000000                      DS8 1
    147          //___________________________Koniec zmiennych lplkalnych________________________
    148          
    149          
    150              
    151               
    152          
    153              
    154          
    155          //Zmienne zewnêtrzne -------------------------------------------------------------    
    156              extern char       LCD_Canvas[8][128];
    157              extern char       Label_move;
    158              extern int        MenuLevel;      //poziom menu
    159              extern int        Suw_poz_analog;  
    160              extern int        ScrollMenu_poz;
    161              extern char       g_US0_Connect_OK;
    162              extern char       g_US1_Connect_OK;
    163              extern char       g_US0_Comm_TIMEOUT;
    164              extern _ZD_MODBUS ZD_MODBUS_0[ZD_MODBUS_Tab_Max];
    165              extern char       g_Ans_ZD_MODBUS_0;
    166              extern char       g_Current_ZD_MODBUS_0;
    167              extern char       g_ERR_ZD_MODBUS_0;
    168              extern int        g_US0_Comm_MinCykle;
    169              extern char       US0_MasterMODBUS_ENABLE;
    170              extern char       g_US1_Comm_TIMEOUT;
    171              extern _ZD_MODBUS ZD_MODBUS_1[ZD_MODBUS_Tab_Max];
    172              extern char       g_Ans_ZD_MODBUS_1;
    173              extern char       g_Current_ZD_MODBUS_1;
    174              extern char       g_ERR_ZD_MODBUS_1;
    175              extern int        g_US1_Comm_MinCykle;
    176              extern char       US1_MasterMODBUS_ENABLE;
    177              extern char       Busy_program;
    178              extern _Trap      Trap;
    179              extern _Correct korekta_Y;
    180              extern _Correct korekta_X;
    181              extern  char Synchronizacja;
    182              extern char         RF_CurrentTask;
    183              //extern unsigned char  SPI_Buffer_Rx[SPI_Read_BUFFER_SIZE];                         //bufor odbiorczy SPI
    184              //extern unsigned char  SPI_Buffer_Tx[SPI_Write_BUFFER_SIZE];                        //bufor odbiorczy SPI
    185              extern void ReadWriteSpi (unsigned char* pReadBuffer, int nReadLen, unsigned char* pWriteBuffer, int nWriteLen, bool bHoldCS);
    186              extern void SPI_init(void) ;
    187              
    188              extern _MainStage  MainStage; 
    189              extern _ProgramTab gProg;
    190              extern void RF_Init(void);
    191              extern _RF_Status RF_Status;
    192              extern char g_RF_TimeOutCounter;
    193              extern   _RF_TaskTab  RF_TaskTab;
    194              extern _TransQuality TransQuality;
    195              extern _DateTime  *pDateTime;
    196              extern char Variables[];
    197              extern unsigned int CyklPerSek;
    198              extern char Buff_TX_1[];
    199              AT91PS_MEM pAT91C_IFLASH_MEM=AT91C_IFLASH_MEM;
    200              extern short int VariablesAnal[];
    201              extern char Variables[];
    202              extern unsigned char  US1_Buffer[];
    203              extern  unsigned  short  TimeToSwithToMaster;
    204              extern _NeuronsListUnit NeuronsList[];
    205              extern  const unsigned int NODE_ID;
    206          //___________________________Koniec zmiennych zewnêtrznych________________________    
    207              
    208              
    209              
    210          //Zmienne tymczasowe -----------------------------------------------------------

   \                                 In section .bss, align 1
    211              char tmp_i =0; 
   \                     tmp_i:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
    212              float licznik = 0.0;
   \                     licznik:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    213              int licznik2 = 0;
   \                     licznik2:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    214              int licznik3 = 0;
   \                     licznik3:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    215              char *memory;
   \                     memory:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    216              unsigned long sss;
   \                     sss:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    217              int int1 =0;
   \                     int1:
   \   00000000                      DS8 4
    218              
    219          
    220              _DateTime DateTime;
    221              
    222               
    223              //___________________________Koniec zmiennych tymczasowych______________________
    224          
    225          
    226              
    227          
    228          //Funkcje zewnêtrzne -----------------------------------------------------------
    229              extern RAM ram;
    230              extern ConversFC Convers_DW_B;
    231              extern void InitFlash(void);
    232              extern void Program (_ProgramTab *ProgTab);
    233              extern void at91flashWriteDW(int sektor, int nr_DW, unsigned long wartDW );
    234              extern void ScreenEvent(void);
    235              extern int Suw_poz;
    236              extern void MenuPaint(void);
    237              extern void at91flashWrite();
    238              extern void ConfigureIrBus(void);
    239              extern void MenuRefresh();
    240              //extern unsigned short crc16(unsigned char* modbusframe,int Length);
    241              //extern unsigned char ModBus_CommS(unsigned char* modbusframe);
    242              //extern void ModBus_CommS_US0();
    243              extern void US0_init(void);
    244              extern void US1_init(void);
    245              extern char ModBus_MASTER_TX(char US_Nr);
    246              extern void ReadTP(_TPoint *Point);
    247              //extern BYTE ModBus_MASTER_Return(BYTE* modbusframe);
    248          //_______________________ Koniec funkcji zewnêtrznych __________________________
    249              
    250          
    251          /*
    252          $Id: serial_example.c,v 1.1.2.1 2006/12/05 08:33:25 danielru Exp $
    253          */
    254          
    255          
    256          
    257          
    258          //------------------------------------------------------------------------------
    259          //      Prototypes
    260          //------------------------------------------------------------------------------
    261          
    262          //! \brief  Initialization callback
    263          static void CBK_Init(const S_usb *pUsb);
    264          
    265          //! \brief  Suspend callback
    266          static void CBK_Suspend(const S_usb *pUsb);
    267          
    268          //! \brief  Resume callback
    269          static void CBK_Resume(const S_usb *pUsb);
    270          
    271          //! \brief  New request callback
    272          static void CBK_NewRequest(const S_usb *pUsb);
    273          
    274          //! \brief  New reset callback
    275          //static void CBK_Reset(const S_usb *pUsb);
    276          
    277          //! \brief  New SOF callback
    278          //static void CBK_SOF(const S_usb *pUsb);
    279          
    280          //------------------------------------------------------------------------------
    281          //      Internal variables
    282          //------------------------------------------------------------------------------
    283          
    284          //! \brief  List of endpoints (including endpoint 0) used by the device.
    285          //! \see    S_usb_endpoint
    286          static S_usb_endpoint pEndpoints[] = {
    287          
    288              USB_ENDPOINT_SINGLEBANK, // Control endpoint 0
    289              USB_ENDPOINT_DUALBANK,   // Data out endpoint
    290              USB_ENDPOINT_DUALBANK,   // Data in endpoint
    291              USB_ENDPOINT_SINGLEBANK, // Notification endpoint
    292          };
    293          
    294          //! \brief  Variable used to store the last received SETUP packet.
    295          //! \see    S_usb_request
    296          //! \see    S_usb

   \                                 In section .bss, align 4
    297          static S_usb_request sSetup;
   \                     sSetup:
   \   00000000                      DS8 8
    298          
    299          //! \brief  Variable used to store the current device state
    300          //! \see    S_usb
    301          static unsigned int dState;
    302          
    303          //! \brief  List of implemented callbacks
    304          //! \see    S_usb_callbacks
    305          //! \see    S_usb

   \                                 In section .rodata, align 4
    306          static const S_usb_callbacks sCallbacks = {
   \                     sCallbacks:
   \   00000000   ........0000       DC32 CBK_Init, 0H, 0H, CBK_Resume, CBK_NewRequest, 0H
   \              000000000000
   \              ............
   \              ....00000000
    307          
    308              CBK_Init,
    309              0, // CBK_Reset
    310              0, //CBK_Suspend,
    311              CBK_Resume,
    312              CBK_NewRequest,
    313              0  // CBK_SOF
    314          };
    315          
    316          //! \brief  USB driver instance
    317          //! \see    S_usb

   \                                 In section .rodata, align 4
    318          static const S_usb sUsb = {
   \                     sUsb:
   \   00000000   ............       DC32 sDefaultDriver, pEndpoints, 4, sCallbacks, sSetup, dState
   \              ....04000000
   \              ............
   \              ............
    319          
    320              &sDefaultDriver,
    321              pEndpoints,
    322              SER_NUM_ENDPOINTS,
    323              &sCallbacks,
    324              &sSetup,
    325              &dState
    326          };
    327          
    328          //! \brief  CDC serial class driver instance
    329          //! \see    S_ser
    330          static S_ser sSer;
    331          
    332          // Buffer for receiving data from the USB
    333          static unsigned char pUsbBuffer[USB_BUFFER_SIZE];
    334          
    335          
    336          //------------------------------------------------------------------------------
    337          //      Internal Functions
    338          //------------------------------------------------------------------------------
    339          
    340          // Interrupt Service Routines
    341          //------------------------------------------------------------------------------
    342          
    343          //------------------------------------------------------------------------------
    344          //! \brief  Handler for the USB controller interrupt
    345          //!
    346          //!         Defers the call to the USB_Handler function.
    347          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    348          void ISR_Driver(void)
    349          {
   \                     ISR_Driver:
   \   00000000   01B5               PUSH     {R0,LR}
    350              USB_Handler(&sUsb);
   \   00000002   ....               LDR      R0,??DataTable2  ;; sUsb
   \   00000004   ....               LDR      R1,??DataTable9  ;; sDefaultDriver + 20
   \   00000006   0968               LDR      R1,[R1, #+0]
   \   00000008   896A               LDR      R1,[R1, #+40]
   \   0000000A   ........           BL       __iar_via_R1
    351          }//_______________________ Koniec funkcji ISR_Driver ____________________________
   \   0000000E   08BC               POP      {R3}
   \   00000010   01BC               POP      {R0}
   \   00000012   0047               BX       R0               ;; return
    352          
    353          
    354          
    355          
    356          //------------------------------------------------------------------------------
    357          //! \brief  Handler for the VBus state change interrupt
    358          //!
    359          //! This method calls the USB_Attach function to perform the necessary
    360          //! operations.
    361          //------------------------------------------------------------------------------
    362          //#if !defined(USB_BUS_POWERED)
    363          char ForwardUSB2Serialferst=0;
    364          
    365          
    366           
    367          

   \                                 In section Debug.txt, align 4, keep-with-next
    368          void ISR_VBus(void)
    369          {
   \                     ISR_VBus:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   ....               LDR      R4,??DataTable2  ;; sUsb
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ....               LDR      R1,??DataTable9  ;; sDefaultDriver + 20
   \   00000008   0968               LDR      R1,[R1, #+0]
   \   0000000A   C969               LDR      R1,[R1, #+28]
    370            
    371            
    372            USB_Attach(&sUsb);
   \   0000000C   ........           BL       __iar_via_R1
    373          
    374            if ((( AT91C_BASE_PIOA->PIO_PDSR) & AT91C_VBUS)>0)
   \   00000010   0220               MOVS     R0,#+2
   \   00000012   0025               MOVS     R5,#+0
   \   00000014   ....               LDR      R6,??DataTable22  ;; DateTime
   \   00000016   ....               LDR      R1,??DataTable5  ;; 0xfffff43c
   \   00000018   0968               LDR      R1,[R1, #+0]
   \   0000001A   0142               TST      R1,R0
   \   0000001C   31D0               BEQ      ??ISR_VBus_0
    375            {
    376              g_PC_Connected=1;
   \   0000001E   0127               MOVS     R7,#+1
   \   00000020   3773               STRB     R7,[R6, #+12]
    377              g_Stop_Program=1;
   \   00000022   7774               STRB     R7,[R6, #+17]
    378              
    379              if (ISSET(USB_GetState(&sUsb), USB_STATE_POWERED)) 
   \   00000024   B16D               LDR      R1,[R6, #+88]
   \   00000026   0142               TST      R1,R0
   \   00000028   14D0               BEQ      ??ISR_VBus_1
    380              {
    381                MenuLevel=1;
   \   0000002A   ....               LDR      R0,??DataTable6  ;; MenuLevel
   \   0000002C   0760               STR      R7,[R0, #+0]
    382                g_PC_Connected=1;
    383                MenuPaint();
   \   0000002E   ........           BL       MenuPaint
    384                RepaintLCD();
   \   00000032   ........           BL       RepaintLCD
    385                RepaintLCD();
   \   00000036   ........           BL       RepaintLCD
    386               
    387                USB_Connect(&sUsb);   
   \   0000003A   2000               MOVS     R0,R4
   \   0000003C   ....               LDR      R1,??DataTable9  ;; sDefaultDriver + 20
   \   0000003E   0968               LDR      R1,[R1, #+0]
   \   00000040   C96A               LDR      R1,[R1, #+44]
   \   00000042   ........           BL       __iar_via_R1
    388                
    389          
    390               // if (ForwardUSB2Serialferst!=1)
    391               // {
    392                  ForwardUSB2Serialferst=1; 
   \   00000046   B776               STRB     R7,[R6, #+26]
    393               // }
    394                
    395                g_LightCouterLCD = 0;     //W³¹cza podœwietlenie wyœwietlacza LCD
   \   00000048   3565               STR      R5,[R6, #+80]
    396                if (g_LightLCDEnable==0) g_LightLCDEnable=1;
   \   0000004A   707B               LDRB     R0,[R6, #+13]
   \   0000004C   0028               CMP      R0,#+0
   \   0000004E   15D1               BNE      ??ISR_VBus_2
   \   00000050   7773               STRB     R7,[R6, #+13]
   \   00000052   13E0               B        ??ISR_VBus_2
    397          
    398              }
    399                else
    400              {
    401          
    402                USB_Disconnect(&sUsb);  
   \                     ??ISR_VBus_1:
   \   00000054   2000               MOVS     R0,R4
   \   00000056   ....               LDR      R1,??DataTable9  ;; sDefaultDriver + 20
   \   00000058   0968               LDR      R1,[R1, #+0]
   \   0000005A   096B               LDR      R1,[R1, #+48]
   \   0000005C   ........           BL       __iar_via_R1
    403                g_PC_Connected=0;
   \   00000060   3573               STRB     R5,[R6, #+12]
    404                MenuPaint();
   \   00000062   ........           BL       MenuPaint
    405                g_LightCouterLCD = 0;     //W³¹cza podœwietlenie wyœwietlacza LCD
   \   00000066   3565               STR      R5,[R6, #+80]
    406                if (g_LightLCDEnable==0) g_LightLCDEnable=1;
   \   00000068   707B               LDRB     R0,[R6, #+13]
   \   0000006A   0028               CMP      R0,#+0
   \   0000006C   00D1               BNE      ??ISR_VBus_3
   \   0000006E   7773               STRB     R7,[R6, #+13]
    407                Trap.Enable=0;
   \                     ??ISR_VBus_3:
   \   00000070   1048               LDR      R0,??ISR_VBus_4  ;; Trap
   \   00000072   0570               STRB     R5,[R0, #+0]
    408                Trap.Row=0;
   \   00000074   4570               STRB     R5,[R0, #+1]
    409                Trap.Col=0;
   \   00000076   8570               STRB     R5,[R0, #+2]
    410                Trap.Activ=0;
   \   00000078   C570               STRB     R5,[R0, #+3]
    411                g_Stop_Program=0;
   \   0000007A   7574               STRB     R5,[R6, #+17]
    412                
    413          
    414              }
    415              MenuPaint();
   \                     ??ISR_VBus_2:
   \   0000007C   ........           BL       MenuPaint
   \   00000080   14E0               B        ??ISR_VBus_5
    416            }
    417            else
    418            {
    419              USB_Disconnect(&sUsb);  
   \                     ??ISR_VBus_0:
   \   00000082   2000               MOVS     R0,R4
   \   00000084   ....               LDR      R1,??DataTable9  ;; sDefaultDriver + 20
   \   00000086   0968               LDR      R1,[R1, #+0]
   \   00000088   096B               LDR      R1,[R1, #+48]
   \   0000008A   ........           BL       __iar_via_R1
    420              g_PC_Connected=0;
   \   0000008E   3573               STRB     R5,[R6, #+12]
    421              g_Stop_Program=0;
   \   00000090   7574               STRB     R5,[R6, #+17]
    422              MenuPaint();
   \   00000092   ........           BL       MenuPaint
    423              g_LightCouterLCD = 0;     //W³¹cza podœwietlenie wyœwietlacza LCD
   \   00000096   3565               STR      R5,[R6, #+80]
    424              if (g_LightLCDEnable==0) g_LightLCDEnable=1;
   \   00000098   707B               LDRB     R0,[R6, #+13]
   \   0000009A   0028               CMP      R0,#+0
   \   0000009C   01D1               BNE      ??ISR_VBus_6
   \   0000009E   0120               MOVS     R0,#+1
   \   000000A0   7073               STRB     R0,[R6, #+13]
    425              
    426              Trap.Enable=0;
   \                     ??ISR_VBus_6:
   \   000000A2   0448               LDR      R0,??ISR_VBus_4  ;; Trap
   \   000000A4   0570               STRB     R5,[R0, #+0]
    427              Trap.Row=0;
   \   000000A6   4570               STRB     R5,[R0, #+1]
    428              Trap.Col=0;
   \   000000A8   8570               STRB     R5,[R0, #+2]
    429              Trap.Activ=0;
   \   000000AA   C570               STRB     R5,[R0, #+3]
    430              
    431          
    432            } 
    433          
    434          }//_____________________________________________________________________________
   \                     ??ISR_VBus_5:
   \   000000AC   F8BC               POP      {R3-R7}
   \   000000AE   01BC               POP      {R0}
   \   000000B0   0047               BX       R0               ;; return
   \   000000B2   C046               Nop      
   \                     ??ISR_VBus_4:
   \   000000B4   ........           DC32     Trap
    435          //#endif // !defined(USB_BUS_POWERED)
    436          
    437          
    438          
    439          
    440          
    441          // Callbacks
    442          //------------------------------------------------------------------------------
    443          //------------------------------------------------------------------------------
    444          //! \brief  Callback invoked during the initialization of the USB driver
    445          //!
    446          //!         Configures and enables USB controller and VBus monitoring interrupts
    447          //! \param  pUsb    Pointer to a S_usb instance
    448          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    449          static void CBK_Init(const S_usb *pUsb)
    450          {
   \                     CBK_Init:
   \   00000000   10B5               PUSH     {R4,LR}
    451          
    452            TRACE_INFO("\n\rInicjalizacja przerwania VBUS od podlaczenia USB  \n\r" ); 
    453              
    454              // Configure and enable the USB controller interrupt
    455              AT91F_AIC_ConfigureIt(AT91C_BASE_AIC,
    456                                    USB_GetDriverID(pUsb),
    457                                    USB_CON_PRIOR,
    458                                    0, //AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL,
    459                                    ISR_Driver);
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   C368               LDR      R3,[R0, #+12]
   \   00000006   9900               LSLS     R1,R3,#+2
   \   00000008   104A               LDR      R2,??CBK_Init_0  ;; 0xfffff000
   \   0000000A   5118               ADDS     R1,R2,R1
   \   0000000C   0C00               MOVS     R4,R1
   \   0000000E   8034               ADDS     R4,R4,#+128
   \   00000010   2268               LDR      R2,[R4, #+0]
   \   00000012   0122               MOVS     R2,#+1
   \   00000014   9A40               LSLS     R2,R2,R3
   \   00000016   ....               LDR      R3,??DataTable10  ;; 0xfffff124
   \   00000018   1A60               STR      R2,[R3, #+0]
   \   0000001A   0D4B               LDR      R3,??CBK_Init_0+0x4  ;; ISR_Driver
   \   0000001C   2360               STR      R3,[R4, #+0]
   \   0000001E   0523               MOVS     R3,#+5
   \   00000020   0B60               STR      R3,[R1, #+0]
   \   00000022   ....               LDR      R1,??DataTable11  ;; 0xfffff128
   \   00000024   0A60               STR      R2,[R1, #+0]
    460          
    461              AT91F_AIC_EnableIt(AT91C_BASE_AIC, USB_GetDriverID(pUsb));
   \   00000026   ....               LDR      R1,??DataTable12  ;; 0xfffff120
   \   00000028   0122               MOVS     R2,#+1
   \   0000002A   C368               LDR      R3,[R0, #+12]
   \   0000002C   9A40               LSLS     R2,R2,R3
   \   0000002E   0A60               STR      R2,[R1, #+0]
    462          
    463          //#ifndef USB_BUS_POWERED
    464             
    465              AT91F_PIO_CfgInput(AT91C_BASE_PIOA,AT91C_VBUS);
   \   00000030   0221               MOVS     R1,#+2
   \   00000032   ....               LDR      R2,??DataTable13  ;; 0xfffff414
   \   00000034   1160               STR      R1,[R2, #+0]
   \   00000036   ....               LDR      R2,??DataTable14  ;; 0xfffff400
   \   00000038   1160               STR      R1,[R2, #+0]
    466              AT91C_BASE_PIOA->PIO_PPUDR = AT91C_VBUS;
   \   0000003A   ....               LDR      R2,??DataTable15  ;; 0xfffff460
   \   0000003C   1160               STR      R1,[R2, #+0]
    467             
    468              // Configure VBus monitoring
    469              BRD_ConfigureVBus(USB_GetDriverInterface(pUsb));
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   ........           BL       BRD_ConfigureVBus
    470          
    471              
    472              
    473              
    474              
    475            /*  
    476              // Configure and enable the Vbus detection interrupt
    477              AT91F_AIC_ConfigureIt(AT91C_BASE_AIC,
    478                                    AT91C_ID_VBUS,
    479                                    USB_CON_PRIOR, //AT91C_AIC_PRIOR_LOWEST,
    480                                    0,//AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL,
    481                                    ISR_VBus);
    482          
    483              
    484              AT91F_PIO_InterruptEnable(AT91C_PIO_VBUS, AT91C_VBUS);
    485              AT91F_AIC_EnableIt(AT91C_BASE_AIC, AT91C_ID_VBUS);
    486            
    487             
    488              
    489              
    490              
    491              
    492              */
    493              
    494              
    495          /*
    496          #else
    497              // Power up the USB controller
    498              USB_Attach(pUsb);
    499            
    500          #endif
    501          */
    502          
    503          }//_____________________________________________________________________________
   \   00000044   10BC               POP      {R4}
   \   00000046   01BC               POP      {R0}
   \   00000048   0047               BX       R0               ;; return
   \   0000004A   C046               Nop      
   \                     ??CBK_Init_0:
   \   0000004C   00F0FFFF           DC32     0xfffff000
   \   00000050   ........           DC32     ISR_Driver
    504          
    505          
    506          
    507          
    508          
    509          
    510          
    511          
    512          
    513          
    514          
    515          
    516          
    517          
    518          
    519          
    520          
    521          
    522          
    523          
    524          
    525          
    526          
    527          //------------------------------------------------------------------------------
    528          //! \brief  Callback invoked when the device becomes suspended
    529          //!
    530          //!         Disables LEDs (if they are used) and then puts the device into
    531          //!         low-power mode. When traces are used, the device does not enter
    532          //!         low-power mode to avoid losing some outputs.
    533          //! \param  pUsb    Pointer to a S_usb instance
    534          //------------------------------------------------------------------------------
    535          static void CBK_Suspend(const S_usb *pUsb)
    536          {
    537          
    538          #if defined(NOTRACES)
    539              DEV_Suspend();
    540          #endif
    541          }//_____________________________________________________________________________
    542          
    543          
    544          
    545          
    546          
    547          
    548          //------------------------------------------------------------------------------
    549          //! \brief  Callback invoked when the device leaves the suspended state
    550          //!
    551          //!         The device is first returned to a normal operating mode and LEDs are
    552          //!         re-enabled. When traces are used, the device does not enter
    553          //!         low-power mode to avoid losing some outputs.
    554          //! \param  pUsb    Pointer to a S_usb instance
    555          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    556          static void CBK_Resume(const S_usb *pUsb)
    557          {
   \                     CBK_Resume:
   \   00000000   01B5               PUSH     {R0,LR}
    558          #if defined(NOTRACES)
    559              DEV_Resume();
   \   00000002   ........           BL       DEV_Resume
    560          #endif
    561          
    562          }//_____________________________________________________________________________
   \   00000006   08BC               POP      {R3}
   \   00000008   01BC               POP      {R0}
   \   0000000A   0047               BX       R0               ;; return
    563          
    564          
    565          
    566          
    567          
    568          
    569          //------------------------------------------------------------------------------
    570          //! \brief  Callback invoked when a new SETUP request is received
    571          //!
    572          //!         The new request if forwarded to the standard request handler,
    573          //!         which performs the enumeration of the device.
    574          //! \param  pUsb   Pointer to a S_usb instance
    575          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    576          static void CBK_NewRequest(const S_usb *pUsb)
    577          {
   \                     CBK_NewRequest:
   \   00000000   01B5               PUSH     {R0,LR}
    578              SER_RequestHandler(&sSer);
   \   00000002   ....               LDR      R0,??DataTable17  ;; DateTime + 128
   \   00000004   ........           BL       SER_RequestHandler
    579          }//_____________________________________________________________________________
   \   00000008   08BC               POP      {R3}
   \   0000000A   01BC               POP      {R0}
   \   0000000C   0047               BX       R0               ;; return
    580          
    581          
    582          
    583          
    584          
    585          
    586          //------------------------------------------------------------------------------
    587          //! \brief  Callback invoked when a Reset request is received
    588          //!
    589          //! \param  pUsb   Pointer to a S_usb instance
    590          //------------------------------------------------------------------------------
    591          //static void CBK_Reset(const S_usb *pUsb)
    592          //{
    593              // Put your reset handler here
    594          //}//_____________________________________________________________________________
    595          
    596          
    597          
    598          
    599          //------------------------------------------------------------------------------
    600          //! \brief  Callback invoked when a SOF is received
    601          //!
    602          //! \param  pUsb   Pointer to a S_usb instance
    603          //------------------------------------------------------------------------------
    604          //static void CBK_SOF(const S_usb *pUsb)
    605          //{
    606              // Put your SOF handler here
    607          //}//_____________________________________________________________________________
    608          
    609          
    610          
    611          

   \                                 In section Debug.txt, align 4, keep-with-next
    612          void SendViaUSB(unsigned char *Buff, unsigned short Size)
    613          {
   \                     SendViaUSB:
   \   00000000   01B5               PUSH     {R0,LR}
    614            SER_Write(&sSer, Buff,Size,0, 0); 
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   0092               STR      R2,[SP, #+0]
   \   00000008   0023               MOVS     R3,#+0
   \   0000000A   0A00               MOVS     R2,R1
   \   0000000C   0100               MOVS     R1,R0
   \   0000000E   ....               LDR      R0,??DataTable17  ;; DateTime + 128
   \   00000010   ........           BL       SER_Write
   \   00000014   02B0               ADD      SP,SP,#+8
    615          }
   \   00000016   08BC               POP      {R3}
   \   00000018   01BC               POP      {R0}
   \   0000001A   0047               BX       R0               ;; return
    616          
    617          
    618          // Other functions
    619          //------------------------------------------------------------------------------
    620          //------------------------------------------------------------------------------
    621          //! \brief  Forwards data receiving from the USB host through the USART
    622          //!
    623          //!         This function operates asynchronously.
    624          //! \param  pBuffer           Must be 0 when function is first called
    625          //! \param  bStatus           Same as above
    626          //! \param  dBytesTransferred Same as above
    627          //! \param  dBytesRemaining   Same as above
    628          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    629          static void ForwardUSB2Serial(unsigned char *pBuffer,
    630                                        unsigned char bStatus,
    631                                        unsigned int dBytesTransferred,
    632                                        unsigned int dBytesRemaining)
    633          {
   \                     ForwardUSB2Serial:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    634              //Zmienne lokalne ----------------------------------------------------
    635                      static char buff_tx[900];                                          //Bufor danych wysy³anych do USB
    636                   
    637                      unsigned int rozmiar_tx=0;                                          //Iloœæ danych do wys³ania przez USB
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   0093               STR      R3,[SP, #+0]
    638                    //---------------------koniec zmiennych lokalnych--------------------
    639                  
    640          
    641              if (pBuffer != 0) {                                                                   
   \   00000006   0028               CMP      R0,#+0
   \   00000008   15D0               BEQ      ??ForwardUSB2Serial_0
    642                  if (bStatus != SER_STATUS_SUCCESS) 
   \   0000000A   0029               CMP      R1,#+0
   \   0000000C   13D1               BNE      ??ForwardUSB2Serial_0
    643                  {
    644                    
    645                    TRACE_WARNING("\n\r W: ForwardUSB2Serial: B³¹d transmisji USB\n\r");
    646                  }
    647                  else 
    648                  {
    649          
    650                      pBuffer[dBytesTransferred] = 0;
   \   0000000E   8354               STRB     R3,[R0, R2]
    651                     komunikcja_RSwin((char *)pBuffer,buff_tx,&rozmiar_tx);
   \   00000010   ....               LDR      R4,??DataTable22  ;; DateTime
   \   00000012   E021               MOVS     R1,#+224
   \   00000014   4900               LSLS     R1,R1,#+1        ;; #+448
   \   00000016   6518               ADDS     R5,R4,R1
   \   00000018   6A46               MOV      R2,SP
   \   0000001A   2900               MOVS     R1,R5
   \   0000001C   ........           BL       komunikcja_RSwin
    652                     SER_Write(&sSer, buff_tx,rozmiar_tx,0, 0);                                                                        
   \   00000020   82B0               SUB      SP,SP,#+8
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   0090               STR      R0,[SP, #+0]
   \   00000026   0023               MOVS     R3,#+0
   \   00000028   029A               LDR      R2,[SP, #+8]
   \   0000002A   2900               MOVS     R1,R5
   \   0000002C   8034               ADDS     R4,R4,#+128
   \   0000002E   2000               MOVS     R0,R4
   \   00000030   ........           BL       SER_Write
   \   00000034   02B0               ADD      SP,SP,#+8
    653                  }
    654              }
    655          
    656          
    657              do {
    658          
    659                  bStatus = SER_Read(&sSer,
    660                                     pUsbBuffer,
    661              
    662                                     USB_BUFFER_SIZE,
    663                                     (Callback_f) ForwardUSB2Serial,
    664                                     pUsbBuffer);
    665              }
    666              while (bStatus != SER_STATUS_SUCCESS);
   \                     ??ForwardUSB2Serial_0:
   \   00000036   ....               LDR      R4,??DataTable22  ;; DateTime
   \   00000038   2100               MOVS     R1,R4
   \   0000003A   9431               ADDS     R1,R1,#+148
   \   0000003C   82B0               SUB      SP,SP,#+8
   \   0000003E   0091               STR      R1,[SP, #+0]
   \   00000040   064B               LDR      R3,??ForwardUSB2Serial_1  ;; ForwardUSB2Serial
   \   00000042   9622               MOVS     R2,#+150
   \   00000044   5200               LSLS     R2,R2,#+1        ;; #+300
   \   00000046   8034               ADDS     R4,R4,#+128
   \   00000048   2000               MOVS     R0,R4
   \   0000004A   ........           BL       SER_Read
   \   0000004E   02B0               ADD      SP,SP,#+8
   \   00000050   0028               CMP      R0,#+0
   \   00000052   F0D1               BNE      ??ForwardUSB2Serial_0
    667           
    668          }//_____________________________________________________________________________
   \   00000054   38BC               POP      {R3-R5}
   \   00000056   01BC               POP      {R0}
   \   00000058   0047               BX       R0               ;; return
   \   0000005A   C046               Nop      
   \                     ??ForwardUSB2Serial_1:
   \   0000005C   ........           DC32     ForwardUSB2Serial
    669          
    670          
    671          
    672          
    673          
    674          
    675          //-----------------------------------------------------------------------------
    676          //!  Nazwa funkcji :    Delay
    677          //!  Funkcja opóŸnienia
    678          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    679          void Delay (unsigned long a) 
    680          { 
   \                     Delay:
   \   00000000   01B5               PUSH     {R0,LR}
    681              while (--a!=0);   AT91F_WDTRestart(AT91C_BASE_WDTC);
   \                     ??Delay_0:
   \   00000002   401E               SUBS     R0,R0,#+1
   \   00000004   FDD1               BNE      ??Delay_0
   \   00000006   ....               LDR      R0,??DataTable20  ;; 0xfffffd40
   \   00000008   ....               LDR      R1,??DataTable21  ;; 0xa5000001
   \   0000000A   0160               STR      R1,[R0, #+0]
    682          }//_______________________ Koniec funkcji opóŸnienia ____________________________
   \   0000000C   08BC               POP      {R3}
   \   0000000E   01BC               POP      {R0}
   \   00000010   0047               BX       R0               ;; return
    683          
    684          
    685          
    686          

   \                                 In section .bss, align 4
    687          char *memory_read;
   \                     memory_read:
   \   00000000                      DS8 4
    688          
    689          //-----------------------------------------------------------------------------
    690          //! Nazwa funkcji :    InitFramework
    691          //! Funkcja ustawieñ wstêpnych systemu
    692          //-----------------------------------------------------------------------------
    693          int tProgramTabSize=ProgramTabSize;
    694          char *SourRam;
    695          unsigned int  stop=2000;
    696          unsigned int  siz;

   \                                 In section Debug.txt, align 4, keep-with-next
    697          void InitFramework (void) 
    698          { 
   \                     InitFramework:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
    699             
    700           //  TRACE_INFO("\n\ InitFramework \n\r");
    701              
    702          
    703          
    704                                            FlashProgramOfset=FlashProgram_A_Ofset;
   \   00000002   ....               LDR      R1,??DataTable22  ;; DateTime
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   8A64               STR      R2,[R1, #+72]
    705                                 
    706                                            
    707                                          //  TRACE_INFO("\n\r---  Strona flash = A  \n\r" ); 
    708          
    709              
    710              
    711          //    TRACE_INFO(" ---  Przepisuje program z FLASH do RAM     -Ofset : %d\n\r",AT91C_IFLASH_MEM->FlashProgram+FlashProgramReserveOfset);
    712              //przepisz program z flash do ram
    713              char *memory_read_prog;
    714              memory_read_prog=(char*)(AT91C_IFLASH_MEM->FlashProgram+FlashProgramOfset);
    715          
    716            
    717               SourRam= (char*)&gProg;
   \   00000008   ....               LDR      R0,??DataTable23  ;; gProg
   \   0000000A   C865               STR      R0,[R1, #+92]
    718          
    719             
    720              siz=sizeof(gProg);
   \   0000000C   ....               LDR      R3,??DataTable24  ;; 0xc670
   \   0000000E   0B66               STR      R3,[R1, #+96]
    721              for (unsigned int k = 0 ; k <siz; k++) 
   \   00000010   0023               MOVS     R3,#+0
    722              {      
    723                    SourRam[k]=memory_read_prog[k]; 
   \                     ??InitFramework_0:
   \   00000012   CC6D               LDR      R4,[R1, #+92]
   \   00000014   ....               LDR      R5,??DataTable25  ;; 0x130100
   \   00000016   ED5C               LDRB     R5,[R5, R3]
   \   00000018   E554               STRB     R5,[R4, R3]
    724              }
   \   0000001A   5B1C               ADDS     R3,R3,#+1
   \   0000001C   0C6E               LDR      R4,[R1, #+96]
   \   0000001E   A342               CMP      R3,R4
   \   00000020   F7D3               BCC      ??InitFramework_0
    725              
    726             
    727            
    728              for (char i=0; i<ScreenNr; i++) 
   \   00000022   ....               LDR      R3,??DataTable26  ;; 0xbc2a
   \   00000024   C318               ADDS     R3,R0,R3
   \   00000026   0824               MOVS     R4,#+8
   \   00000028   6D46               MOV      R5,SP
   \   0000002A   CE78               LDRB     R6,[R1, #+3]
   \   0000002C   2E70               STRB     R6,[R5, #+0]
   \   0000002E   8D79               LDRB     R5,[R1, #+6]
    729             {
    730               //je¿eli ustawienie automatyczne temperatury
    731               if (gProg.Screen[i].Thermo.AutoOn) 
   \                     ??InitFramework_1:
   \   00000030   1E1F               SUBS     R6,R3,#+4
   \   00000032   3778               LDRB     R7,[R6, #+0]
   \   00000034   002F               CMP      R7,#+0
   \   00000036   1DD0               BEQ      ??InitFramework_2
    732               {
    733                 
    734                   //je¿eli dzieñ typu pierwszego
    735                   if (((gProg.Screen[i].Thermo.Week>>DateTime.DayOfWeek) & 0x1)==1)       
   \   00000038   F678               LDRB     R6,[R6, #+3]
   \   0000003A   2E41               ASRS     R6,R6,R5
   \   0000003C   F607               LSLS     R6,R6,#+31
   \   0000003E   19D5               BPL      ??InitFramework_2
    736                   {
    737                      if (((gProg.Screen[i].Thermo.Chart[0]>>DateTime.Hour) & 0x1)==1)
   \   00000040   9B1C               ADDS     R3,R3,#+2
   \   00000042   5E68               LDR      R6,[R3, #+4]
   \   00000044   9B1E               SUBS     R3,R3,#+2
   \   00000046   6F46               MOV      R7,SP
   \   00000048   3F78               LDRB     R7,[R7, #+0]
   \   0000004A   FE40               LSRS     R6,R6,R7
   \   0000004C   F607               LSLS     R6,R6,#+31
   \   0000004E   09D5               BPL      ??InitFramework_3
    738                      {                 
    739                        //ustaw wy¿sz¹ temperaturê
    740                        if (gProg.Screen[i].Thermo.Temperature[0]>gProg.Screen[i].Thermo.Temperature[1])
   \   00000050   0226               MOVS     R6,#+2
   \   00000052   9E5F               LDRSH    R6,[R3, R6]
   \   00000054   0027               MOVS     R7,#+0
   \   00000056   DF5F               LDRSH    R7,[R3, R7]
   \   00000058   BE42               CMP      R6,R7
   \   0000005A   01DA               BGE      ??InitFramework_4
    741                        {
    742                          gProg.Screen[i].Thermo.SetTemperature=gProg.Screen[i].Thermo.Temperature[0]; 
   \   0000005C   1E88               LDRH     R6,[R3, #+0]
   \   0000005E   08E0               B.N      ??InitFramework_5
    743                        }else{
    744                          gProg.Screen[i].Thermo.SetTemperature=gProg.Screen[i].Thermo.Temperature[1]; 
   \                     ??InitFramework_4:
   \   00000060   5E88               LDRH     R6,[R3, #+2]
   \   00000062   06E0               B.N      ??InitFramework_5
    745                        }
    746                      }else{
    747                        //ustaw ni¿sz¹ temperaturê
    748                        if (gProg.Screen[i].Thermo.Temperature[0]>gProg.Screen[i].Thermo.Temperature[1])
   \                     ??InitFramework_3:
   \   00000064   0026               MOVS     R6,#+0
   \   00000066   9E5F               LDRSH    R6,[R3, R6]
   \   00000068   0227               MOVS     R7,#+2
   \   0000006A   DF5F               LDRSH    R7,[R3, R7]
   \   0000006C   B742               CMP      R7,R6
   \   0000006E   00DA               BGE      ??InitFramework_5
    749                        {
    750                          gProg.Screen[i].Thermo.SetTemperature=gProg.Screen[i].Thermo.Temperature[1]; 
   \   00000070   5E88               LDRH     R6,[R3, #+2]
    751                        }else{
    752                          gProg.Screen[i].Thermo.SetTemperature=gProg.Screen[i].Thermo.Temperature[0]; 
   \                     ??InitFramework_5:
   \   00000072   9E80               STRH     R6,[R3, #+4]
    753                        }
    754                      }
    755                   }
    756               }
    757             }
   \                     ??InitFramework_2:
   \   00000074   A033               ADDS     R3,R3,#+160
   \   00000076   641E               SUBS     R4,R4,#+1
   \   00000078   DAD1               BNE      ??InitFramework_1
    758           
    759              
    760           
    761              //koniec
    762             
    763             
    764             
    765             
    766             //czyszczenie zmiennych programowych
    767                for (int LineNr=0; LineNr<MaxPrcLines; LineNr++)
   \   0000007A   2A30               ADDS     R0,R0,#+42
   \   0000007C   C823               MOVS     R3,#+200
   \   0000007E   5B00               LSLS     R3,R3,#+1        ;; #+400
   \   00000080   0025               MOVS     R5,#+0
    768                {
    769                  for (int PrcInLine=0; PrcInLine<MaxPrcInLine; PrcInLine++)
    770                  {
    771                    gProg.Line[LineNr].Proc[PrcInLine].LastIn=0;
   \                     ??InitFramework_6:
   \   00000082   841E               SUBS     R4,R0,#+2
   \   00000084   2570               STRB     R5,[R4, #+0]
    772                    gProg.Line[LineNr].Proc[PrcInLine].Out=0;
   \   00000086   0280               STRH     R2,[R0, #+0]
   \   00000088   8275               STRB     R2,[R0, #+22]
   \   0000008A   0283               STRH     R2,[R0, #+24]
   \   0000008C   0400               MOVS     R4,R0
   \   0000008E   2E34               ADDS     R4,R4,#+46
   \   00000090   2570               STRB     R5,[R4, #+0]
   \   00000092   6580               STRH     R5,[R4, #+2]
   \   00000094   2576               STRB     R5,[R4, #+24]
   \   00000096   6583               STRH     R5,[R4, #+26]
   \   00000098   0400               MOVS     R4,R0
   \   0000009A   5E34               ADDS     R4,R4,#+94
   \   0000009C   2570               STRB     R5,[R4, #+0]
   \   0000009E   6580               STRH     R5,[R4, #+2]
    773                  }
   \   000000A0   7830               ADDS     R0,R0,#+120
    774                }
   \   000000A2   5B1E               SUBS     R3,R3,#+1
   \   000000A4   EDD1               BNE      ??InitFramework_6
    775           
    776          
    777                //Ustawienie wartoœci analogowych wêz³ów na niewiarygodne (0x8AAA)
    778                for (char NN=1; NN<NumberNeurons; NN++)
   \   000000A6   ....               LDR      R0,??DataTable27  ;; MainStage + 182
   \   000000A8   2222               MOVS     R2,#+34
   \   000000AA   ....               LDR      R3,??DataTable28  ;; 0xffff8aaa
    779                {
    780                  for (char NR=0; NR<NumberReg; NR++)
    781                  {
    782                    MainStage.StageI[NN].Value[NR]=0x8AAA;
   \                     ??InitFramework_7:
   \   000000AC   0380               STRH     R3,[R0, #+0]
   \   000000AE   0400               MOVS     R4,R0
   \   000000B0   A41C               ADDS     R4,R4,#+2
   \   000000B2   0225               MOVS     R5,#+2
   \                     ??InitFramework_8:
   \   000000B4   2380               STRH     R3,[R4, #+0]
   \   000000B6   6380               STRH     R3,[R4, #+2]
   \   000000B8   A380               STRH     R3,[R4, #+4]
   \   000000BA   E380               STRH     R3,[R4, #+6]
   \   000000BC   2381               STRH     R3,[R4, #+8]
    783                  }
   \   000000BE   0A34               ADDS     R4,R4,#+10
   \   000000C0   6D1E               SUBS     R5,R5,#+1
   \   000000C2   F7D1               BNE      ??InitFramework_8
    784                }
   \   000000C4   1630               ADDS     R0,R0,#+22
   \   000000C6   521E               SUBS     R2,R2,#+1
   \   000000C8   F0D1               BNE      ??InitFramework_7
    785              
    786              
    787                 //przepisanie wartoœci konfiguracyjnych
    788              WypMaxJasnosci=pAT91C_IFLASH_MEM->Config.ScreenBrightActive;
   \   000000CA   0948               LDR      R0,??InitFramework_9  ;; 0xd80e
   \   000000CC   4A6D               LDR      R2,[R1, #+84]
   \   000000CE   1018               ADDS     R0,R2,R0
   \   000000D0   0278               LDRB     R2,[R0, #+0]
   \   000000D2   4A75               STRB     R2,[R1, #+21]
    789              WypMinJasnosci=pAT91C_IFLASH_MEM->Config.ScreenBrightInactive;
   \   000000D4   4078               LDRB     R0,[R0, #+1]
    790              if ((WypMaxJasnosci<10) || (WypMaxJasnosci>100)) WypMaxJasnosci=100;
   \   000000D6   0A2A               CMP      R2,#+10
   \   000000D8   01D3               BCC      ??InitFramework_10
   \   000000DA   652A               CMP      R2,#+101
   \   000000DC   01D3               BCC      ??InitFramework_11
   \                     ??InitFramework_10:
   \   000000DE   6422               MOVS     R2,#+100
   \   000000E0   4A75               STRB     R2,[R1, #+21]
    791              if (WypMinJasnosci==0) WypMinJasnosci=14;
   \                     ??InitFramework_11:
   \   000000E2   0028               CMP      R0,#+0
   \   000000E4   00D1               BNE      ??InitFramework_12
   \   000000E6   0E20               MOVS     R0,#+14
   \                     ??InitFramework_12:
   \   000000E8   8875               STRB     R0,[R1, #+22]
    792               
    793          }//_______________________ Koniec funkcji InitFramework ____________________________
   \   000000EA   F8BC               POP      {R3-R7}
   \   000000EC   01BC               POP      {R0}
   \   000000EE   0047               BX       R0               ;; return
   \                     ??InitFramework_9:
   \   000000F0   0ED80000           DC32     0xd80e
    794          
    795          
    796          
    797          
    798          
    799          
    800          //char gLcdLightDuty=2;

   \                                 In section Debug.txt, align 4, keep-with-next
    801          void Timer_10us(void)                        //timer isr 
    802          { 
    803              unsigned int dummy0 = AT91C_BASE_TC1->TC_SR;      
   \                     Timer_10us:
   \   00000000   0148               LDR      R0,??Timer_10us_0  ;; 0xfffa0060
   \   00000002   0068               LDR      R0,[R0, #+0]
    804            
    805           /*
    806            
    807            //PWM podœwietlenia
    808            static char LcdLightCounterPWM=6;        //licznik podœwietlenia
    809            
    810            
    811          AT91F_PIO_SetOutput(LCD_PIO,(unsigned int)LightLCD); 
    812            
    813            /*
                   ^
Warning[Pe009]: nested comment is not allowed
    814            static long long ScreenSaverCounter=0;
    815            if (g_LightLCDEnable)
    816            {
    817              AT91F_PIO_SetOutput(LCD_PIO,(unsigned int)LightLCD);    
    818              ScreenSaverCounter=0;
    819            }else{
    820            
    821              if (LcdLightCounterPWM<6)
    822            {
    823              LcdLightCounterPWM++;
    824             
    825            }else{
    826              LcdLightCounterPWM=0; 
    827              
    828              if ((ScreenSaverCounter<500000) && (g_ScreenSever_On) ) 
    829              {
    830                ScreenSaverCounter++;  
    831                AT91F_PIO_SetOutput(LCD_PIO,(unsigned int)LightLCD);
    832              }
    833              if ((!g_ScreenSever_On) || (g_ScreenSever_On && !((g_ScreenSever_Time_On<=DateTime.Hour) || (g_ScreenSever_Time_Off>DateTime.Hour))))   AT91F_PIO_SetOutput(LCD_PIO,(unsigned int)LightLCD);
    834            }
    835            if  (LcdLightCounterPWM==gLcdLightDuty) AT91F_PIO_ClearOutput(LCD_PIO,(unsigned int)LightLCD);
    836            }
    837            */
    838            
    839          
    840            //----koniec PWM podœwietlenia ------
    841            
    842          
    843            
    844          }//_____________________________________________________________________________
   \   00000004   7047               BX       LR               ;; return
   \   00000006   C046               Nop      
   \                     ??Timer_10us_0:
   \   00000008   6000FAFF           DC32     0xfffa0060
    845          
    846          
    847          
    848          
    849          
    850          
    851          
    852          
    853          //-----------------------------------------------------------------------------
    854          //!  Nazwa funkcji :    Timer_1_Setup
    855          //!  Funkcja inicjalizacji Timer1 - 1ms
    856          //-----------------------------------------------------------------------------
    857          //! 
    858          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    859          void Timer_10us_Setup(void) 
    860          { 
    861          
    862            
    863           //AT91C_BASE_PIOA->PIO_PDR = P_TIOA0;   //disable PIOA 
    864           //AT91C_BASE_PIOA->PIO_BSR = P_TIOA0;   //select peripheral B 
    865           AT91C_BASE_AIC->AIC_SVR[AT91C_ID_TC1] = (unsigned int)Timer_10us;  //set AIC             
   \                     Timer_10us_Setup:
   \   00000000   1148               LDR      R0,??Timer_10us_Setup_0  ;; 0xfffff0b4
   \   00000002   1249               LDR      R1,??Timer_10us_Setup_0+0x4  ;; Timer_10us
   \   00000004   0160               STR      R1,[R0, #+0]
    866           AT91C_BASE_AIC->AIC_SMR[AT91C_ID_TC1] = (AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL | TIMER_10US_PRIOR); 
   \   00000006   1248               LDR      R0,??Timer_10us_Setup_0+0x8  ;; 0xfffff034
   \   00000008   0121               MOVS     R1,#+1
   \   0000000A   0160               STR      R1,[R0, #+0]
    867           AT91C_BASE_PMC->PMC_PCER = (1<<AT91C_ID_TC1);      //enable clock 
   \   0000000C   4803               LSLS     R0,R1,#+13
   \   0000000E   1149               LDR      R1,??Timer_10us_Setup_0+0xC  ;; 0xfffffc10
   \   00000010   0860               STR      R0,[R1, #+0]
    868           AT91C_BASE_TCB->TCB_BCR = 0;                  //no SYNC trigger 
   \   00000012   1149               LDR      R1,??Timer_10us_Setup_0+0x10  ;; 0xfffa00c0
   \   00000014   0022               MOVS     R2,#+0
   \   00000016   0A60               STR      R2,[R1, #+0]
    869           //no external clocks 
    870           AT91C_BASE_TCB->TCB_BMR = AT91C_TCB_TC0XC0S_NONE | AT91C_TCB_TC1XC1S_NONE | AT91C_TCB_TC2XC2S_NONE; 
   \   00000018   1049               LDR      R1,??Timer_10us_Setup_0+0x14  ;; 0xfffa00c4
   \   0000001A   1522               MOVS     R2,#+21
   \   0000001C   0A60               STR      R2,[R1, #+0]
    871           AT91C_BASE_TC1->TC_CCR = AT91C_TC_SWTRG | AT91C_TC_CLKEN;                   //enable and start clock 
   \   0000001E   1049               LDR      R1,??Timer_10us_Setup_0+0x18  ;; 0xfffa0040
   \   00000020   0522               MOVS     R2,#+5
   \   00000022   0A60               STR      R2,[R1, #+0]
    872           AT91C_BASE_TC1->TC_CMR = AT91C_TC_ACPC_TOGGLE | AT91C_TC_WAVE  | AT91C_TC_WAVESEL_UP_AUTO  | AT91C_TC_CLKS_TIMER_DIV2_CLOCK;//CPC 
   \   00000024   0F49               LDR      R1,??Timer_10us_Setup_0+0x1C  ;; 0xfffa0044
   \   00000026   104A               LDR      R2,??Timer_10us_Setup_0+0x20  ;; 0xcc001
   \   00000028   0A60               STR      R2,[R1, #+0]
    873           //clock: MCK/1024  = 48054841/ DIV
    874           //AT91C_BASE_TC0->TC_RC = 46928;    => 1 sec 
    875           //! DIV5 - 1024
    876           //! DIV4 - 128
    877           //! DIV3 - 32
    878           //! DIV2 - 8
    879           
    880           //AT91C_BASE_TC3->TC_RC = 5090;                  //1ms  (z wyliczeñ 6007)
    881           //AT91C_BASE_TC0->TC_RC = 5286;                    //880us 
    882           AT91C_BASE_TC1->TC_RC = 200;                    //440us  
   \   0000002A   1049               LDR      R1,??Timer_10us_Setup_0+0x24  ;; 0xfffa005c
   \   0000002C   C822               MOVS     R2,#+200
   \   0000002E   0A60               STR      R2,[R1, #+0]
    883           AT91C_BASE_TC1->TC_IER = AT91C_TC_CPCS;          //enable RC compare int 
   \   00000030   0F49               LDR      R1,??Timer_10us_Setup_0+0x28  ;; 0xfffa0064
   \   00000032   1022               MOVS     R2,#+16
   \   00000034   0A60               STR      R2,[R1, #+0]
    884           AT91C_BASE_TC1->TC_IDR = ~AT91C_TC_CPCS;         //disable other 
   \   00000036   0F49               LDR      R1,??Timer_10us_Setup_0+0x2C  ;; 0xfffa0068
   \   00000038   D243               MVNS     R2,R2            ;; #-17
   \   0000003A   0A60               STR      R2,[R1, #+0]
    885           AT91C_BASE_AIC->AIC_IECR = (1<<AT91C_ID_TC1);       //enable int 
   \   0000003C   0E49               LDR      R1,??Timer_10us_Setup_0+0x30  ;; 0xfffff120
   \   0000003E   0860               STR      R0,[R1, #+0]
    886           AT91C_BASE_AIC->AIC_ICCR = (1<<AT91C_ID_TC1);       //clear int 
   \   00000040   0E49               LDR      R1,??Timer_10us_Setup_0+0x34  ;; 0xfffff128
   \   00000042   0860               STR      R0,[R1, #+0]
    887           
    888           
    889           //AT91C_BASE_TC1->TC_CMR |= 1<<6;
    890          }//_____________________________________________________________________________
   \   00000044   7047               BX       LR               ;; return
   \   00000046   C046               Nop      
   \                     ??Timer_10us_Setup_0:
   \   00000048   B4F0FFFF           DC32     0xfffff0b4
   \   0000004C   ........           DC32     Timer_10us
   \   00000050   34F0FFFF           DC32     0xfffff034
   \   00000054   10FCFFFF           DC32     0xfffffc10
   \   00000058   C000FAFF           DC32     0xfffa00c0
   \   0000005C   C400FAFF           DC32     0xfffa00c4
   \   00000060   4000FAFF           DC32     0xfffa0040
   \   00000064   4400FAFF           DC32     0xfffa0044
   \   00000068   01C00C00           DC32     0xcc001
   \   0000006C   5C00FAFF           DC32     0xfffa005c
   \   00000070   6400FAFF           DC32     0xfffa0064
   \   00000074   6800FAFF           DC32     0xfffa0068
   \   00000078   20F1FFFF           DC32     0xfffff120
   \   0000007C   28F1FFFF           DC32     0xfffff128
    891          
    892          
    893          
    894          

   \                                 In section Debug.txt, align 4, keep-with-next
    895          void TimetableExecute(void)
    896          {
   \                     TimetableExecute:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   85B0               SUB      SP,SP,#+20
    897          
    898            
    899            volatile static __Timetable *Timetable=AT91C_IFLASH_MEM->Config.Timetable;
    900            
    901            static  char Out[ScreenNr][TimetableTasks];
    902            char Hour;
    903            for (char sc=0; sc<ScreenNr; sc++)
   \   00000004   5048               LDR      R0,??TimetableExecute_0  ;; ??Out
   \   00000006   0090               STR      R0,[SP, #+0]
   \   00000008   504D               LDR      R5,??TimetableExecute_0+0x4  ;; 0x13d831
   \   0000000A   514C               LDR      R4,??TimetableExecute_0+0x8  ;; gProg + 48165
   \   0000000C   0820               MOVS     R0,#+8
   \   0000000E   0190               STR      R0,[SP, #+4]
   \   00000010   5048               LDR      R0,??TimetableExecute_0+0xC  ;; MainStage
   \   00000012   5149               LDR      R1,??TimetableExecute_0+0x10  ;; 0x6eb
   \   00000014   4118               ADDS     R1,R0,R1
   \   00000016   0291               STR      R1,[SP, #+8]
   \   00000018   4F49               LDR      R1,??TimetableExecute_0+0x10  ;; 0x6eb
   \   0000001A   4118               ADDS     R1,R0,R1
   \   0000001C   0291               STR      R1,[SP, #+8]
   \   0000001E   4F49               LDR      R1,??TimetableExecute_0+0x14  ;; 0x3a2
   \   00000020   4118               ADDS     R1,R0,R1
   \   00000022   0391               STR      R1,[SP, #+12]
   \   00000024   4D49               LDR      R1,??TimetableExecute_0+0x14  ;; 0x3a2
   \   00000026   4018               ADDS     R0,R0,R1
   \   00000028   0390               STR      R0,[SP, #+12]
    904            {
    905               for (char tn=0; tn<4; tn++)
   \                     ??TimetableExecute_1:
   \   0000002A   0426               MOVS     R6,#+4
    906               {
    907                   
    908          
    909                  
    910                   if (Timetable[sc].Task[tn].Enable==1) 
   \                     ??TimetableExecute_2:
   \   0000002C   2878               LDRB     R0,[R5, #+0]
   \   0000002E   0128               CMP      R0,#+1
   \   00000030   4CD1               BNE      ??TimetableExecute_3
    911                   {    
    912                     
    913                             if (gProg.Screen[sc].Timetable.Min1h)
   \   00000032   A078               LDRB     R0,[R4, #+2]
   \   00000034   0028               CMP      R0,#+0
   \   00000036   A878               LDRB     R0,[R5, #+2]
   \   00000038   05D0               BEQ      ??TimetableExecute_4
    914                             {
    915                               if(Timetable[sc].Task[tn].Hour>0) {
   \   0000003A   0028               CMP      R0,#+0
   \   0000003C   02D0               BEQ      ??TimetableExecute_5
    916                                 Hour=Timetable[sc].Task[tn].Hour-1;
   \   0000003E   A878               LDRB     R0,[R5, #+2]
   \   00000040   401E               SUBS     R0,R0,#+1
   \   00000042   00E0               B        ??TimetableExecute_4
    917                               }else{
    918                                 Hour=23;
   \                     ??TimetableExecute_5:
   \   00000044   1720               MOVS     R0,#+23
    919                               }
    920                             }else{
    921                               Hour=Timetable[sc].Task[tn].Hour;
    922                             }
    923                  
    924                     
    925                       if ((Hour==DateTime.Hour)&& (Timetable[sc].Task[tn].Minute==DateTime.Minute) && ((Timetable[sc].Task[tn].Week) & (1<<DateTime.DayOfWeek-1))  && (DateTime.Second==0))
   \                     ??TimetableExecute_4:
   \   00000046   4649               LDR      R1,??TimetableExecute_0+0x18  ;; DateTime + 3
   \   00000048   0978               LDRB     R1,[R1, #+0]
   \   0000004A   0006               LSLS     R0,R0,#+24
   \   0000004C   000E               LSRS     R0,R0,#+24
   \   0000004E   8842               CMP      R0,R1
   \   00000050   72D1               BNE      ??TimetableExecute_6
   \   00000052   E878               LDRB     R0,[R5, #+3]
   \   00000054   4349               LDR      R1,??TimetableExecute_0+0x1C  ;; DateTime + 4
   \   00000056   0978               LDRB     R1,[R1, #+0]
   \   00000058   8842               CMP      R0,R1
   \   0000005A   6DD1               BNE      ??TimetableExecute_6
   \   0000005C   6878               LDRB     R0,[R5, #+1]
   \   0000005E   0121               MOVS     R1,#+1
   \   00000060   414A               LDR      R2,??TimetableExecute_0+0x20  ;; DateTime + 6
   \   00000062   1278               LDRB     R2,[R2, #+0]
   \   00000064   521E               SUBS     R2,R2,#+1
   \   00000066   9140               LSLS     R1,R1,R2
   \   00000068   0842               TST      R0,R1
   \   0000006A   65D0               BEQ      ??TimetableExecute_6
   \   0000006C   3F48               LDR      R0,??TimetableExecute_0+0x24  ;; DateTime + 5
   \   0000006E   0078               LDRB     R0,[R0, #+0]
   \   00000070   0028               CMP      R0,#+0
   \   00000072   61D1               BNE      ??TimetableExecute_6
    926                       {
    927                         if (gProg.Screen[sc].Timetable.ActionType==2)
   \   00000074   0098               LDR      R0,[SP, #+0]
   \   00000076   0078               LDRB     R0,[R0, #+0]
   \   00000078   6178               LDRB     R1,[R4, #+1]
   \   0000007A   0229               CMP      R1,#+2
   \   0000007C   36D1               BNE      ??TimetableExecute_7
    928                         {
    929                           if (Out[sc][tn])
   \   0000007E   0028               CMP      R0,#+0
   \   00000080   24D0               BEQ      ??TimetableExecute_3
    930                           {
    931                             if (gProg.Screen[sc].Timetable.ActorNode<0)  //je¿eli zmienna
   \                     ??TimetableExecute_8:
   \   00000082   671E               SUBS     R7,R4,#+1
   \   00000084   0020               MOVS     R0,#+0
   \   00000086   3856               LDRSB    R0,[R7, R0]
   \   00000088   0028               CMP      R0,#+0
   \   0000008A   0CD5               BPL      ??TimetableExecute_9
    932                             {
    933                                Variables[gProg.Screen[sc].Timetable.ActorPort/8]&= ~(1<<(gProg.Screen[sc].Timetable.ActorPort%8));
   \   0000008C   2078               LDRB     R0,[R4, #+0]
   \   0000008E   C110               ASRS     R1,R0,#+3
   \   00000090   374A               LDR      R2,??TimetableExecute_0+0x28  ;; Variables
   \   00000092   5118               ADDS     R1,R2,R1
   \   00000094   0A78               LDRB     R2,[R1, #+0]
   \   00000096   0123               MOVS     R3,#+1
   \   00000098   C708               LSRS     R7,R0,#+3
   \   0000009A   FF00               LSLS     R7,R7,#+3
   \   0000009C   C01B               SUBS     R0,R0,R7
   \   0000009E   8340               LSLS     R3,R3,R0
   \   000000A0   9A43               BICS     R2,R2,R3
   \   000000A2   0A70               STRB     R2,[R1, #+0]
   \   000000A4   0FE0               B        ??TimetableExecute_10
    934                             }else{  //je¿eli wêze³
    935                                PortStageSet(&(MainStage.StageQ[gProg.Screen[sc].Timetable.ActorNode].Port), gProg.Screen[sc].Timetable.ActorPort, 0);  
                                                    ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \                     ??TimetableExecute_9:
   \   000000A6   0022               MOVS     R2,#+0
   \   000000A8   2178               LDRB     R1,[R4, #+0]
   \   000000AA   0020               MOVS     R0,#+0
   \   000000AC   3856               LDRSB    R0,[R7, R0]
   \   000000AE   1623               MOVS     R3,#+22
   \   000000B0   5843               MULS     R0,R3,R0
   \   000000B2   039B               LDR      R3,[SP, #+12]
   \   000000B4   1818               ADDS     R0,R3,R0
   \   000000B6   ........           BL       PortStageSet
    936                                MainStage.SendStageChange[gProg.Screen[sc].Timetable.ActorNode]=ChangeStageFlag;
   \   000000BA   0020               MOVS     R0,#+0
   \   000000BC   3856               LDRSB    R0,[R7, R0]
   \   000000BE   0299               LDR      R1,[SP, #+8]
   \   000000C0   2C4A               LDR      R2,??TimetableExecute_0+0x2C  ;; DateTime + 24
   \   000000C2   1278               LDRB     R2,[R2, #+0]
   \   000000C4   0A54               STRB     R2,[R1, R0]
    937                             }
    938                             Out[sc][tn]=0;
   \                     ??TimetableExecute_10:
   \   000000C6   0098               LDR      R0,[SP, #+0]
   \   000000C8   0021               MOVS     R1,#+0
   \                     ??TimetableExecute_11:
   \   000000CA   0170               STRB     R1,[R0, #+0]
    939                           }
    940                         }else{
   \                     ??TimetableExecute_3:
   \   000000CC   2D1D               ADDS     R5,R5,#+4
   \   000000CE   0098               LDR      R0,[SP, #+0]
   \   000000D0   401C               ADDS     R0,R0,#+1
   \   000000D2   0090               STR      R0,[SP, #+0]
   \   000000D4   761E               SUBS     R6,R6,#+1
   \   000000D6   A9D1               BNE      ??TimetableExecute_2
   \   000000D8   A034               ADDS     R4,R4,#+160
   \   000000DA   6D1C               ADDS     R5,R5,#+1
   \   000000DC   0198               LDR      R0,[SP, #+4]
   \   000000DE   401E               SUBS     R0,R0,#+1
   \   000000E0   0190               STR      R0,[SP, #+4]
   \   000000E2   A2D1               BNE      ??TimetableExecute_1
    941                           
    942                           if (Out[sc][tn]==0) {
    943                             if (gProg.Screen[sc].Timetable.ActorNode<0)  //je¿eli zmienna
    944                             {
    945                                Variables[gProg.Screen[sc].Timetable.ActorPort/8] |= 1<<(gProg.Screen[sc].Timetable.ActorPort%8);
    946                             }else{  //je¿eli wêze³
    947                              PortStageSet(&(MainStage.StageQ[gProg.Screen[sc].Timetable.ActorNode].Port), gProg.Screen[sc].Timetable.ActorPort, 1);  
                                                  ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
    948                              MainStage.SendStageChange[gProg.Screen[sc].Timetable.ActorNode]=ChangeStageFlag;}
    949                             }
    950                           Out[sc][tn]=1;
    951                           
    952                         }
    953                       }else{
    954                         if ((gProg.Screen[sc].Timetable.ActionType==0) && (Out[sc][tn]==1)) 
    955                         {
    956                           if (gProg.Screen[sc].Timetable.ActorNode<0)  //je¿eli zmienna
    957                             {
    958                               Variables[gProg.Screen[sc].Timetable.ActorPort/8]&= ~(1<<(gProg.Screen[sc].Timetable.ActorPort%8));
    959                             }else{  //je¿eli wêze³
    960                              PortStageSet(&(MainStage.StageQ[gProg.Screen[sc].Timetable.ActorNode].Port), gProg.Screen[sc].Timetable.ActorPort, 0);
                                                  ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
    961                              MainStage.SendStageChange[gProg.Screen[sc].Timetable.ActorNode]=ChangeStageFlag;
    962                             }
    963                         }
    964                         Out[sc][tn]=0;
    965                         
    966                       }
    967                   
    968                   }
    969                   
    970                   
    971               }
    972               
    973            }
    974          }
   \   000000E4   05B0               ADD      SP,SP,#+20
   \   000000E6   F0BC               POP      {R4-R7}
   \   000000E8   01BC               POP      {R0}
   \   000000EA   0047               BX       R0               ;; return
   \                     ??TimetableExecute_7:
   \   000000EC   0028               CMP      R0,#+0
   \   000000EE   20D1               BNE      ??TimetableExecute_12
   \   000000F0   671E               SUBS     R7,R4,#+1
   \   000000F2   3856               LDRSB    R0,[R7, R0]
   \   000000F4   0028               CMP      R0,#+0
   \   000000F6   0CD5               BPL      ??TimetableExecute_13
   \   000000F8   2078               LDRB     R0,[R4, #+0]
   \   000000FA   C110               ASRS     R1,R0,#+3
   \   000000FC   1C4A               LDR      R2,??TimetableExecute_0+0x28  ;; Variables
   \   000000FE   5118               ADDS     R1,R2,R1
   \   00000100   0A78               LDRB     R2,[R1, #+0]
   \   00000102   0123               MOVS     R3,#+1
   \   00000104   C708               LSRS     R7,R0,#+3
   \   00000106   FF00               LSLS     R7,R7,#+3
   \   00000108   C01B               SUBS     R0,R0,R7
   \   0000010A   8340               LSLS     R3,R3,R0
   \   0000010C   1343               ORRS     R3,R3,R2
   \   0000010E   0B70               STRB     R3,[R1, #+0]
   \   00000110   0FE0               B        ??TimetableExecute_12
   \                     ??TimetableExecute_13:
   \   00000112   0122               MOVS     R2,#+1
   \   00000114   2178               LDRB     R1,[R4, #+0]
   \   00000116   0020               MOVS     R0,#+0
   \   00000118   3856               LDRSB    R0,[R7, R0]
   \   0000011A   1623               MOVS     R3,#+22
   \   0000011C   5843               MULS     R0,R3,R0
   \   0000011E   039B               LDR      R3,[SP, #+12]
   \   00000120   1818               ADDS     R0,R3,R0
   \   00000122   ........           BL       PortStageSet
   \   00000126   0020               MOVS     R0,#+0
   \   00000128   3856               LDRSB    R0,[R7, R0]
   \   0000012A   0299               LDR      R1,[SP, #+8]
   \   0000012C   114A               LDR      R2,??TimetableExecute_0+0x2C  ;; DateTime + 24
   \   0000012E   1278               LDRB     R2,[R2, #+0]
   \   00000130   0A54               STRB     R2,[R1, R0]
   \                     ??TimetableExecute_12:
   \   00000132   0098               LDR      R0,[SP, #+0]
   \   00000134   0121               MOVS     R1,#+1
   \   00000136   C8E7               B.N      ??TimetableExecute_11
   \                     ??TimetableExecute_6:
   \   00000138   6078               LDRB     R0,[R4, #+1]
   \   0000013A   0028               CMP      R0,#+0
   \   0000013C   C3D1               BNE      ??TimetableExecute_10
   \   0000013E   0098               LDR      R0,[SP, #+0]
   \   00000140   0078               LDRB     R0,[R0, #+0]
   \   00000142   0128               CMP      R0,#+1
   \   00000144   BFD1               BNE      ??TimetableExecute_10
   \   00000146   9CE7               B        ??TimetableExecute_8
   \                     ??TimetableExecute_0:
   \   00000148   ........           DC32     ??Out
   \   0000014C   31D81300           DC32     0x13d831
   \   00000150   ........           DC32     gProg + 48165
   \   00000154   ........           DC32     MainStage
   \   00000158   EB060000           DC32     0x6eb
   \   0000015C   A2030000           DC32     0x3a2
   \   00000160   ........           DC32     DateTime + 3
   \   00000164   ........           DC32     DateTime + 4
   \   00000168   ........           DC32     DateTime + 6
   \   0000016C   ........           DC32     DateTime + 5
   \   00000170   ........           DC32     Variables
   \   00000174   ........           DC32     DateTime + 24

   \                                 In section .bss, align 4
   \                     ??Out:
   \   00000000                      DS8 32
    975          
    976          
    977          

   \                                 In section Debug.txt, align 4, keep-with-next
    978          void ThermostatsTimeChartExecute(void)
    979          {
   \                     ThermostatsTimeChartExecute:
   \   00000000   F7B5               PUSH     {R0-R2,R4-R7,LR}
    980            
    981            signed   short H_Tmp;
    982            signed   short L_Tmp;
    983            signed   short New_Temp;
    984            static  signed short LastTemp[ScreenNr];
    985              
    986            for (signed int sc=0; sc<ScreenNr; )
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   2549               LDR      R1,??ThermostatsTimeChartExecute_0  ;; ??LastTemp
   \   00000006   264C               LDR      R4,??ThermostatsTimeChartExecute_0+0x4  ;; gProg
   \   00000008   264A               LDR      R2,??ThermostatsTimeChartExecute_0+0x8  ;; 0xbc2a
   \   0000000A   A218               ADDS     R2,R4,R2
   \   0000000C   264B               LDR      R3,??ThermostatsTimeChartExecute_0+0xC  ;; DateTime
   \   0000000E   6D46               MOV      R5,SP
   \   00000010   9E79               LDRB     R6,[R3, #+6]
   \   00000012   761E               SUBS     R6,R6,#+1
   \   00000014   2E70               STRB     R6,[R5, #+0]
   \   00000016   DB78               LDRB     R3,[R3, #+3]
   \   00000018   244D               LDR      R5,??ThermostatsTimeChartExecute_0+0x10  ;; 0xbb98
   \   0000001A   6419               ADDS     R4,R4,R5
   \   0000001C   0194               STR      R4,[SP, #+4]
   \   0000001E   01E0               B        ??ThermostatsTimeChartExecute_1
    987            {
    988              if (((sc==0) && (gProg.Screen[sc].PaternDesign==MainScreenTermo)) || 
    989                  ((sc) && (gProg.Screen[sc].PaternDesign==SubScreenTermo)))
   \                     ??ThermostatsTimeChartExecute_2:
   \   00000020   0028               CMP      R0,#+0
   \   00000022   04D1               BNE      ??ThermostatsTimeChartExecute_3
   \                     ??ThermostatsTimeChartExecute_1:
   \   00000024   019C               LDR      R4,[SP, #+4]
   \   00000026   2478               LDRB     R4,[R4, #+0]
   \   00000028   082C               CMP      R4,#+8
   \   0000002A   2FD1               BNE      ??ThermostatsTimeChartExecute_4
   \   0000002C   04E0               B        ??ThermostatsTimeChartExecute_5
   \                     ??ThermostatsTimeChartExecute_3:
   \   0000002E   1400               MOVS     R4,R2
   \   00000030   923C               SUBS     R4,R4,#+146
   \   00000032   2478               LDRB     R4,[R4, #+0]
   \   00000034   052C               CMP      R4,#+5
   \   00000036   29D1               BNE      ??ThermostatsTimeChartExecute_4
    990              {
    991                     //je¿eli ustawienie automatyczne temperatury
    992                     if (gProg.Screen[sc].Thermo.AutoOn) 
   \                     ??ThermostatsTimeChartExecute_5:
   \   00000038   141F               SUBS     R4,R2,#+4
   \   0000003A   2578               LDRB     R5,[R4, #+0]
   \   0000003C   002D               CMP      R5,#+0
   \   0000003E   23D0               BEQ      ??ThermostatsTimeChartExecute_6
    993                     {                       
    994                          if (gProg.Screen[sc].Thermo.Temperature[0]>gProg.Screen[sc].Thermo.Temperature[1])
   \   00000040   0225               MOVS     R5,#+2
   \   00000042   555F               LDRSH    R5,[R2, R5]
   \   00000044   0026               MOVS     R6,#+0
   \   00000046   965F               LDRSH    R6,[R2, R6]
   \   00000048   B542               CMP      R5,R6
   \   0000004A   02DA               BGE      ??ThermostatsTimeChartExecute_7
    995                              {
    996                                H_Tmp=gProg.Screen[sc].Thermo.Temperature[0]; 
   \   0000004C   3500               MOVS     R5,R6
    997                                L_Tmp=gProg.Screen[sc].Thermo.Temperature[1]; 
   \   0000004E   0226               MOVS     R6,#+2
   \   00000050   02E0               B.N      ??ThermostatsTimeChartExecute_8
    998                              }else{
    999                                H_Tmp=gProg.Screen[sc].Thermo.Temperature[1];
   \                     ??ThermostatsTimeChartExecute_7:
   \   00000052   0225               MOVS     R5,#+2
   \   00000054   555F               LDRSH    R5,[R2, R5]
   1000                                L_Tmp=gProg.Screen[sc].Thermo.Temperature[0]; 
   \   00000056   0026               MOVS     R6,#+0
   \                     ??ThermostatsTimeChartExecute_8:
   \   00000058   965F               LDRSH    R6,[R2, R6]
   1001                              }
   1002                          
   1003                         //je¿eli dzieñ wykresu pierwszego
   1004                         if (((gProg.Screen[sc].Thermo.Week>>(DateTime.DayOfWeek-1)) & 0x1)==1)       
   \   0000005A   E478               LDRB     R4,[R4, #+3]
   \   0000005C   6F46               MOV      R7,SP
   \   0000005E   3F78               LDRB     R7,[R7, #+0]
   \   00000060   3C41               ASRS     R4,R4,R7
   \   00000062   E407               LSLS     R4,R4,#+31
   \   00000064   02D5               BPL      ??ThermostatsTimeChartExecute_9
   1005                         {
   1006          
   1007                           
   1008                              if (((gProg.Screen[sc].Thermo.Chart[0]>>DateTime.Hour) & 0x1)==1)
   \   00000066   921C               ADDS     R2,R2,#+2
   \   00000068   5468               LDR      R4,[R2, #+4]
   \   0000006A   01E0               B.N      ??ThermostatsTimeChartExecute_10
   1009                              {                 
   1010                                //ustaw wy¿sz¹ temperaturê
   1011                                  New_Temp=H_Tmp; 
   1012                              }else{
   1013                                //ustaw ni¿sz¹ temperaturê
   1014                                  New_Temp=L_Tmp;
   1015                              }
   1016                         }else{
   1017          
   1018                              if (((gProg.Screen[sc].Thermo.Chart[1]>>DateTime.Hour) & 0x1)==1)
   \                     ??ThermostatsTimeChartExecute_9:
   \   0000006C   921C               ADDS     R2,R2,#+2
   \   0000006E   9468               LDR      R4,[R2, #+8]
   \                     ??ThermostatsTimeChartExecute_10:
   \   00000070   921E               SUBS     R2,R2,#+2
   \   00000072   DC40               LSRS     R4,R4,R3
   \   00000074   E407               LSLS     R4,R4,#+31
   \   00000076   00D4               BMI      ??ThermostatsTimeChartExecute_11
   1019                              {                 
   1020                                //ustaw wy¿sz¹ temperaturê
   1021                                  New_Temp=H_Tmp; 
   1022                              }else{
   1023                                //ustaw ni¿sz¹ temperaturê
   1024                                  New_Temp=L_Tmp;
   \   00000078   3500               MOVS     R5,R6
   1025                              }
   1026                         }
   1027                         if (LastTemp[sc]!=New_Temp)  
   \                     ??ThermostatsTimeChartExecute_11:
   \   0000007A   0024               MOVS     R4,#+0
   \   0000007C   0C5F               LDRSH    R4,[R1, R4]
   \   0000007E   AC42               CMP      R4,R5
   \   00000080   04D0               BEQ      ??ThermostatsTimeChartExecute_4
   1028                            {
   1029                                gProg.Screen[sc].Thermo.SetTemperature=New_Temp;
   \   00000082   9580               STRH     R5,[R2, #+4]
   1030                                LastTemp[sc]=gProg.Screen[sc].Thermo.SetTemperature;
   \   00000084   9488               LDRH     R4,[R2, #+4]
   \   00000086   00E0               B.N      ??ThermostatsTimeChartExecute_12
   1031                            }
   1032                     }else{
   1033                        LastTemp[sc]=-9999;
   \                     ??ThermostatsTimeChartExecute_6:
   \   00000088   094C               LDR      R4,??ThermostatsTimeChartExecute_0+0x14  ;; 0xffffd8f1
   \                     ??ThermostatsTimeChartExecute_12:
   \   0000008A   0C80               STRH     R4,[R1, #+0]
   1034                     }
   1035               }
   1036              sc++;
   \                     ??ThermostatsTimeChartExecute_4:
   \   0000008C   401C               ADDS     R0,R0,#+1
   \   0000008E   A032               ADDS     R2,R2,#+160
   \   00000090   891C               ADDS     R1,R1,#+2
   1037            }
   \   00000092   0828               CMP      R0,#+8
   \   00000094   C4DB               BLT      ??ThermostatsTimeChartExecute_2
   1038          }
   \   00000096   FEBC               POP      {R1-R7}
   \   00000098   01BC               POP      {R0}
   \   0000009A   0047               BX       R0               ;; return
   \                     ??ThermostatsTimeChartExecute_0:
   \   0000009C   ........           DC32     ??LastTemp
   \   000000A0   ........           DC32     gProg
   \   000000A4   2ABC0000           DC32     0xbc2a
   \   000000A8   ........           DC32     DateTime
   \   000000AC   98BB0000           DC32     0xbb98
   \   000000B0   F1D8FFFF           DC32     0xffffd8f1

   \                                 In section .bss, align 4
   \                     ??LastTemp:
   \   00000000                      DS8 16
   1039          
   1040          
   1041           // int MainScreenTermo=ScreenSetTab_0_Nr;
   1042           // int SubScreenTermo=ScreenSetTab_1_Nr;
   1043            //int MainScreenTimetable=ScreenSetTab_0_Nr+1;
   1044            //int SubScreenTimetable=ScreenSetTab_1_Nr+1;

   \                                 In section Debug.txt, align 4, keep-with-next
   1045          void ThermostatsExecute(void)
   1046          {
   \                     ThermostatsExecute:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   85B0               SUB      SP,SP,#+20
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   4B48               LDR      R0,??ThermostatsExecute_0  ;; ??Hysteresis
   \   00000008   0090               STR      R0,[SP, #+0]
   \   0000000A   4B4D               LDR      R5,??ThermostatsExecute_0+0x4  ;; gProg + 48165
   \   0000000C   4B48               LDR      R0,??ThermostatsExecute_0+0x8  ;; MainStage
   \   0000000E   4C49               LDR      R1,??ThermostatsExecute_0+0xC  ;; 0x6eb
   \   00000010   4118               ADDS     R1,R0,R1
   \   00000012   0191               STR      R1,[SP, #+4]
   \   00000014   4A49               LDR      R1,??ThermostatsExecute_0+0xC  ;; 0x6eb
   \   00000016   4118               ADDS     R1,R0,R1
   \   00000018   0191               STR      R1,[SP, #+4]
   \   0000001A   4A49               LDR      R1,??ThermostatsExecute_0+0x10  ;; 0x3a2
   \   0000001C   4118               ADDS     R1,R0,R1
   \   0000001E   0291               STR      R1,[SP, #+8]
   \   00000020   4849               LDR      R1,??ThermostatsExecute_0+0x10  ;; 0x3a2
   \   00000022   4118               ADDS     R1,R0,R1
   \   00000024   0291               STR      R1,[SP, #+8]
   \   00000026   A030               ADDS     R0,R0,#+160
   \   00000028   0390               STR      R0,[SP, #+12]
   \   0000002A   01E0               B        ??ThermostatsExecute_1
   1047            short  SensorNodeValue;
   1048           
   1049            static char Hysteresis[ScreenNr];
   1050            
   1051            for (char sc=0; sc<ScreenNr; sc++)
   1052            {
   1053              if (((sc==0) && (gProg.Screen[sc].PaternDesign==MainScreenTermo)) || 
   1054                  ((sc) && (gProg.Screen[sc].PaternDesign==SubScreenTermo)))
   \                     ??ThermostatsExecute_2:
   \   0000002C   2006               LSLS     R0,R4,#+24
   \   0000002E   04D1               BNE      ??ThermostatsExecute_3
   \                     ??ThermostatsExecute_1:
   \   00000030   2800               MOVS     R0,R5
   \   00000032   8D38               SUBS     R0,R0,#+141
   \   00000034   0078               LDRB     R0,[R0, #+0]
   \   00000036   0828               CMP      R0,#+8
   \   00000038   06D0               BEQ      ??ThermostatsExecute_4
   \                     ??ThermostatsExecute_3:
   \   0000003A   2006               LSLS     R0,R4,#+24
   \   0000003C   6CD0               BEQ      ??ThermostatsExecute_5
   \   0000003E   2800               MOVS     R0,R5
   \   00000040   8D38               SUBS     R0,R0,#+141
   \   00000042   0078               LDRB     R0,[R0, #+0]
   \   00000044   0528               CMP      R0,#+5
   \   00000046   67D1               BNE      ??ThermostatsExecute_5
   1055              {
   1056                     SensorNodeValue=0;
   1057                     if (gProg.Screen[sc].Thermo.SensorNode<0) //je¿eli zmienna
   \                     ??ThermostatsExecute_4:
   \   00000048   0220               MOVS     R0,#+2
   \   0000004A   2856               LDRSB    R0,[R5, R0]
   \   0000004C   0028               CMP      R0,#+0
   \   0000004E   03D5               BPL      ??ThermostatsExecute_6
   1058                     {
   1059                       SensorNodeValue=VariablesAnal[gProg.Screen[sc].Thermo.SensorReg];
   \   00000050   E878               LDRB     R0,[R5, #+3]
   \   00000052   4000               LSLS     R0,R0,#+1
   \   00000054   3C49               LDR      R1,??ThermostatsExecute_0+0x14  ;; VariablesAnal
   \   00000056   07E0               B.N      ??ThermostatsExecute_7
   1060                     }else{
   1061                       SensorNodeValue=MainStage.StageI[gProg.Screen[sc].Thermo.SensorNode].Value[gProg.Screen[sc].Thermo.SensorReg];
   \                     ??ThermostatsExecute_6:
   \   00000058   0220               MOVS     R0,#+2
   \   0000005A   2856               LDRSB    R0,[R5, R0]
   \   0000005C   1621               MOVS     R1,#+22
   \   0000005E   4843               MULS     R0,R1,R0
   \   00000060   E978               LDRB     R1,[R5, #+3]
   \   00000062   4900               LSLS     R1,R1,#+1
   \   00000064   039A               LDR      R2,[SP, #+12]
   \   00000066   5118               ADDS     R1,R2,R1
   \                     ??ThermostatsExecute_7:
   \   00000068   0E5E               LDRSH    R6,[R1, R0]
   1062                     }
   1063                
   1064                     //zeruje stan wyjœcia je¿eli temperatura wy¿sza od za³o¿onej 
   1065                     if (SensorNodeValue>=gProg.Screen[sc].Thermo.SetTemperature)
   \   0000006A   0920               MOVS     R0,#+9
   \   0000006C   285E               LDRSH    R0,[R5, R0]
   \   0000006E   8642               CMP      R6,R0
   \   00000070   24DB               BLT      ??ThermostatsExecute_8
   1066                     {
   1067                       if (gProg.Screen[sc].Thermo.ActorNode<0)  //je¿eli zmienna
   \   00000072   6F1E               SUBS     R7,R5,#+1
   \   00000074   0020               MOVS     R0,#+0
   \   00000076   3856               LDRSB    R0,[R7, R0]
   \   00000078   0028               CMP      R0,#+0
   \   0000007A   0CD5               BPL      ??ThermostatsExecute_9
   1068                       {
   1069                          Variables[gProg.Screen[sc].Thermo.ActorPort/8] &= ~(1<<(gProg.Screen[sc].Thermo.ActorPort%8));
   \   0000007C   2878               LDRB     R0,[R5, #+0]
   \   0000007E   C110               ASRS     R1,R0,#+3
   \   00000080   324A               LDR      R2,??ThermostatsExecute_0+0x18  ;; Variables
   \   00000082   5118               ADDS     R1,R2,R1
   \   00000084   0A78               LDRB     R2,[R1, #+0]
   \   00000086   0123               MOVS     R3,#+1
   \   00000088   C708               LSRS     R7,R0,#+3
   \   0000008A   FF00               LSLS     R7,R7,#+3
   \   0000008C   C01B               SUBS     R0,R0,R7
   \   0000008E   8340               LSLS     R3,R3,R0
   \   00000090   9A43               BICS     R2,R2,R3
   \   00000092   0A70               STRB     R2,[R1, #+0]
   \   00000094   0FE0               B        ??ThermostatsExecute_10
   1070                       }else{
   1071                          PortStageSet(&(MainStage.StageQ[gProg.Screen[sc].Thermo.ActorNode].Port), gProg.Screen[sc].Thermo.ActorPort, 0);  
                                              ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \                     ??ThermostatsExecute_9:
   \   00000096   0022               MOVS     R2,#+0
   \   00000098   2978               LDRB     R1,[R5, #+0]
   \   0000009A   0020               MOVS     R0,#+0
   \   0000009C   3856               LDRSB    R0,[R7, R0]
   \   0000009E   1623               MOVS     R3,#+22
   \   000000A0   5843               MULS     R0,R3,R0
   \   000000A2   029B               LDR      R3,[SP, #+8]
   \   000000A4   1818               ADDS     R0,R3,R0
   \   000000A6   ........           BL       PortStageSet
   1072                          MainStage.SendStageChange[gProg.Screen[sc].Thermo.ActorNode]=ChangeStageFlag;
   \   000000AA   0020               MOVS     R0,#+0
   \   000000AC   3856               LDRSB    R0,[R7, R0]
   \   000000AE   0199               LDR      R1,[SP, #+4]
   \   000000B0   274A               LDR      R2,??ThermostatsExecute_0+0x1C  ;; DateTime + 24
   \   000000B2   1278               LDRB     R2,[R2, #+0]
   \   000000B4   0A54               STRB     R2,[R1, R0]
   1073                       }
   1074                       Hysteresis[sc]=ThermostatHysteresis; //ustawia histerezê
   \                     ??ThermostatsExecute_10:
   \   000000B6   0098               LDR      R0,[SP, #+0]
   \   000000B8   0221               MOVS     R1,#+2
   \   000000BA   0170               STRB     R1,[R0, #+0]
   1075                     }
   1076                     
   1077                     //ustawia na 1 stan wyjœcia je¿eli temperatura ni¿sza od za³o¿onej - histereza
   1078                     if (SensorNodeValue>0)
   \                     ??ThermostatsExecute_8:
   \   000000BC   012E               CMP      R6,#+1
   \   000000BE   2BDB               BLT      ??ThermostatsExecute_5
   1079                     if (SensorNodeValue<=gProg.Screen[sc].Thermo.SetTemperature-Hysteresis[sc])
   \   000000C0   0920               MOVS     R0,#+9
   \   000000C2   285E               LDRSH    R0,[R5, R0]
   \   000000C4   0099               LDR      R1,[SP, #+0]
   \   000000C6   0978               LDRB     R1,[R1, #+0]
   \   000000C8   401A               SUBS     R0,R0,R1
   \   000000CA   B042               CMP      R0,R6
   \   000000CC   24DB               BLT      ??ThermostatsExecute_5
   1080                     {
   1081                       Hysteresis[sc]=0;
   \   000000CE   0098               LDR      R0,[SP, #+0]
   \   000000D0   0021               MOVS     R1,#+0
   \   000000D2   0170               STRB     R1,[R0, #+0]
   1082                       if (gProg.Screen[sc].Thermo.ActorNode<0)  //je¿eli zmienna
   \   000000D4   6F1E               SUBS     R7,R5,#+1
   \   000000D6   0020               MOVS     R0,#+0
   \   000000D8   3856               LDRSB    R0,[R7, R0]
   \   000000DA   0028               CMP      R0,#+0
   \   000000DC   0CD5               BPL      ??ThermostatsExecute_11
   1083                       {
   1084                          Variables[gProg.Screen[sc].Thermo.ActorPort/8] |= 1<<(gProg.Screen[sc].Thermo.ActorPort%8);
   \   000000DE   2878               LDRB     R0,[R5, #+0]
   \   000000E0   C110               ASRS     R1,R0,#+3
   \   000000E2   1A4A               LDR      R2,??ThermostatsExecute_0+0x18  ;; Variables
   \   000000E4   5118               ADDS     R1,R2,R1
   \   000000E6   0B78               LDRB     R3,[R1, #+0]
   \   000000E8   0122               MOVS     R2,#+1
   \   000000EA   C608               LSRS     R6,R0,#+3
   \   000000EC   F600               LSLS     R6,R6,#+3
   \   000000EE   801B               SUBS     R0,R0,R6
   \   000000F0   8240               LSLS     R2,R2,R0
   \   000000F2   1A43               ORRS     R2,R2,R3
   \   000000F4   0A70               STRB     R2,[R1, #+0]
   \   000000F6   0FE0               B        ??ThermostatsExecute_5
   1085                       }else{
   1086                          PortStageSet(&(MainStage.StageQ[gProg.Screen[sc].Thermo.ActorNode].Port), gProg.Screen[sc].Thermo.ActorPort, 1);   
                                              ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \                     ??ThermostatsExecute_11:
   \   000000F8   0122               MOVS     R2,#+1
   \   000000FA   2978               LDRB     R1,[R5, #+0]
   \   000000FC   0020               MOVS     R0,#+0
   \   000000FE   3856               LDRSB    R0,[R7, R0]
   \   00000100   1623               MOVS     R3,#+22
   \   00000102   5843               MULS     R0,R3,R0
   \   00000104   029B               LDR      R3,[SP, #+8]
   \   00000106   1818               ADDS     R0,R3,R0
   \   00000108   ........           BL       PortStageSet
   1087                          MainStage.SendStageChange[gProg.Screen[sc].Thermo.ActorNode]=ChangeStageFlag;
   \   0000010C   0020               MOVS     R0,#+0
   \   0000010E   3856               LDRSB    R0,[R7, R0]
   \   00000110   0199               LDR      R1,[SP, #+4]
   \   00000112   0F4A               LDR      R2,??ThermostatsExecute_0+0x1C  ;; DateTime + 24
   \   00000114   1278               LDRB     R2,[R2, #+0]
   \   00000116   0A54               STRB     R2,[R1, R0]
   1088                       }
   1089                     }
   1090                     
   1091                     
   1092              }
   1093            }
   \                     ??ThermostatsExecute_5:
   \   00000118   641C               ADDS     R4,R4,#+1
   \   0000011A   A035               ADDS     R5,R5,#+160
   \   0000011C   0098               LDR      R0,[SP, #+0]
   \   0000011E   401C               ADDS     R0,R0,#+1
   \   00000120   0090               STR      R0,[SP, #+0]
   \   00000122   2006               LSLS     R0,R4,#+24
   \   00000124   000E               LSRS     R0,R0,#+24
   \   00000126   0828               CMP      R0,#+8
   \   00000128   00D2               BCS      .+4
   \   0000012A   7FE7               B        ??ThermostatsExecute_2
   1094          }
   \   0000012C   05B0               ADD      SP,SP,#+20
   \   0000012E   F0BC               POP      {R4-R7}
   \   00000130   01BC               POP      {R0}
   \   00000132   0047               BX       R0               ;; return
   \                     ??ThermostatsExecute_0:
   \   00000134   ........           DC32     ??Hysteresis
   \   00000138   ........           DC32     gProg + 48165
   \   0000013C   ........           DC32     MainStage
   \   00000140   EB060000           DC32     0x6eb
   \   00000144   A2030000           DC32     0x3a2
   \   00000148   ........           DC32     VariablesAnal
   \   0000014C   ........           DC32     Variables
   \   00000150   ........           DC32     DateTime + 24

   \                                 In section .bss, align 4
   \                     ??Hysteresis:
   \   00000000                      DS8 8
   1095          
   1096          
   1097          
   1098          char out[10]={1,1,1,1,1,1,1,1,1,1};

   \                                 In section Debug.txt, align 4, keep-with-next
   1099          void AlarmExecute(void)
   1100          {
   \                     AlarmExecute:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   87B0               SUB      SP,SP,#+28
   \   00000004   0026               MOVS     R6,#+0
   \   00000006   6B48               LDR      R0,??AlarmExecute_0  ;; AlarmScreenAction
   \   00000008   0700               MOVS     R7,R0
   \   0000000A   1037               ADDS     R7,R7,#+16
   \   0000000C   0490               STR      R0,[SP, #+16]
   \   0000000E   0100               MOVS     R1,R0
   \   00000010   2031               ADDS     R1,R1,#+32
   \   00000012   0091               STR      R1,[SP, #+0]
   \   00000014   0100               MOVS     R1,R0
   \   00000016   6031               ADDS     R1,R1,#+96
   \   00000018   0191               STR      R1,[SP, #+4]
   \   0000001A   674C               LDR      R4,??AlarmExecute_0+0x4  ;; gProg + 48164
   \   0000001C   6030               ADDS     R0,R0,#+96
   \   0000001E   0590               STR      R0,[SP, #+20]
   \   00000020   6648               LDR      R0,??AlarmExecute_0+0x8  ;; MainStage
   \   00000022   6749               LDR      R1,??AlarmExecute_0+0xC  ;; 0x6eb
   \   00000024   4118               ADDS     R1,R0,R1
   \   00000026   0291               STR      R1,[SP, #+8]
   \   00000028   6549               LDR      R1,??AlarmExecute_0+0xC  ;; 0x6eb
   \   0000002A   4118               ADDS     R1,R0,R1
   \   0000002C   0291               STR      R1,[SP, #+8]
   \   0000002E   6449               LDR      R1,??AlarmExecute_0+0xC  ;; 0x6eb
   \   00000030   4118               ADDS     R1,R0,R1
   \   00000032   0291               STR      R1,[SP, #+8]
   \   00000034   6349               LDR      R1,??AlarmExecute_0+0x10  ;; 0x3a2
   \   00000036   4118               ADDS     R1,R0,R1
   \   00000038   0391               STR      R1,[SP, #+12]
   \   0000003A   6249               LDR      R1,??AlarmExecute_0+0x10  ;; 0x3a2
   \   0000003C   4118               ADDS     R1,R0,R1
   \   0000003E   0391               STR      R1,[SP, #+12]
   \   00000040   6049               LDR      R1,??AlarmExecute_0+0x10  ;; 0x3a2
   \   00000042   4118               ADDS     R1,R0,R1
   \   00000044   0391               STR      R1,[SP, #+12]
   \   00000046   A030               ADDS     R0,R0,#+160
   \   00000048   0690               STR      R0,[SP, #+24]
   \   0000004A   01E0               B        ??AlarmExecute_1
   1101          
   1102          static long long AlarmOnTime[ScreenNr];  //czas do odliczania dla alarmu
   1103          static long long AlarmOffTime[ScreenNr];
   1104            
   1105            for (char sc=0; sc<ScreenNr; sc++)
   1106            {
   1107              if ((((sc==0) && (gProg.Screen[sc].PaternDesign==MainScreenAlarm)) || 
   1108                  ((sc) && (gProg.Screen[sc].PaternDesign==SubScreenAlarm))))
   \                     ??AlarmExecute_2:
   \   0000004C   3006               LSLS     R0,R6,#+24
   \   0000004E   04D1               BNE      ??AlarmExecute_3
   \                     ??AlarmExecute_1:
   \   00000050   2000               MOVS     R0,R4
   \   00000052   8C38               SUBS     R0,R0,#+140
   \   00000054   0078               LDRB     R0,[R0, #+0]
   \   00000056   0A28               CMP      R0,#+10
   \   00000058   08D0               BEQ      ??AlarmExecute_4
   \                     ??AlarmExecute_3:
   \   0000005A   3006               LSLS     R0,R6,#+24
   \   0000005C   00D1               BNE      .+4
   \   0000005E   94E0               B        ??AlarmExecute_5
   \   00000060   2000               MOVS     R0,R4
   \   00000062   8C38               SUBS     R0,R0,#+140
   \   00000064   0078               LDRB     R0,[R0, #+0]
   \   00000066   0728               CMP      R0,#+7
   \   00000068   00D0               BEQ      .+4
   \   0000006A   8EE0               B        ??AlarmExecute_5
   1109              {
   1110                if (AlarmScreenAction[sc].Active) 
   \                     ??AlarmExecute_4:
   \   0000006C   0498               LDR      R0,[SP, #+16]
   \   0000006E   0078               LDRB     R0,[R0, #+0]
   \   00000070   0028               CMP      R0,#+0
   \   00000072   72D0               BEQ      ??AlarmExecute_6
   1111                {
   1112                           //zeruje stan wyjœcia je¿eli zda¿enie od czujnika             
   1113                      if (PortStageRead(MainStage.StageI[gProg.Screen[sc].Alarm.SensorNode].Port, gProg.Screen[sc].Alarm.SensorPort)==0x1)  
   \   00000074   E178               LDRB     R1,[R4, #+3]
   \   00000076   0220               MOVS     R0,#+2
   \   00000078   2056               LDRSB    R0,[R4, R0]
   \   0000007A   1622               MOVS     R2,#+22
   \   0000007C   5043               MULS     R0,R2,R0
   \   0000007E   069A               LDR      R2,[SP, #+24]
   \   00000080   105A               LDRH     R0,[R2, R0]
   \   00000082   0004               LSLS     R0,R0,#+16
   \   00000084   0014               ASRS     R0,R0,#+16
   \   00000086   ........           BL       PortStageRead
   \   0000008A   0128               CMP      R0,#+1
   \   0000008C   7DD1               BNE      ??AlarmExecute_5
   1114                           {
   1115                             if (AlarmOnTime[sc]==0) {AlarmOnTime[sc]=g_counter;}
   \   0000008E   0098               LDR      R0,[SP, #+0]
   \   00000090   03C8               LDM      R0!,{R0,R1}
   \   00000092   0029               CMP      R1,#+0
   \   00000094   05D1               BNE      ??AlarmExecute_7
   \   00000096   0028               CMP      R0,#+0
   \   00000098   03D1               BNE      ??AlarmExecute_7
   \   0000009A   009A               LDR      R2,[SP, #+0]
   \   0000009C   4A48               LDR      R0,??AlarmExecute_0+0x14  ;; DateTime + 48
   \   0000009E   03C8               LDM      R0!,{R0,R1}
   \   000000A0   03C2               STM      R2!,{R0,R1}
   1116                             if ((g_counter>AlarmOnTime[sc]+AlarmTimeToActive*1000) && (out[sc]==0))
   \                     ??AlarmExecute_7:
   \   000000A2   4A4D               LDR      R5,??AlarmExecute_0+0x18  ;; DateTime
   \   000000A4   0098               LDR      R0,[SP, #+0]
   \   000000A6   03C8               LDM      R0!,{R0,R1}
   \   000000A8   0200               MOVS     R2,R0
   \   000000AA   0B00               MOVS     R3,R1
   \   000000AC   4848               LDR      R0,??AlarmExecute_0+0x1C  ;; 0xea60
   \   000000AE   0021               MOVS     R1,#+0
   \   000000B0   8018               ADDS     R0,R0,R2
   \   000000B2   5941               ADCS     R1,R1,R3
   \   000000B4   0200               MOVS     R2,R0
   \   000000B6   0B00               MOVS     R3,R1
   \   000000B8   2800               MOVS     R0,R5
   \   000000BA   3030               ADDS     R0,R0,#+48
   \   000000BC   03C8               LDM      R0!,{R0,R1}
   \   000000BE   8B42               CMP      R3,R1
   \   000000C0   1BD8               BHI      ??AlarmExecute_8
   \   000000C2   01D3               BCC      ??AlarmExecute_9
   \   000000C4   8242               CMP      R2,R0
   \   000000C6   18D2               BCS      ??AlarmExecute_8
   \                     ??AlarmExecute_9:
   \   000000C8   3878               LDRB     R0,[R7, #+0]
   \   000000CA   0028               CMP      R0,#+0
   \   000000CC   15D1               BNE      ??AlarmExecute_8
   1117                             {
   1118                                PortStageSet(&(MainStage.StageQ[gProg.Screen[sc].Alarm.ActorNode].Port), gProg.Screen[sc].Alarm.ActorPort, 0);
                                                    ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   000000CE   0022               MOVS     R2,#+0
   \   000000D0   6178               LDRB     R1,[R4, #+1]
   \   000000D2   2056               LDRSB    R0,[R4, R0]
   \   000000D4   1623               MOVS     R3,#+22
   \   000000D6   5843               MULS     R0,R3,R0
   \   000000D8   039B               LDR      R3,[SP, #+12]
   \   000000DA   1818               ADDS     R0,R3,R0
   \   000000DC   ........           BL       PortStageSet
   1119                                MainStage.SendStageChange[gProg.Screen[sc].Alarm.ActorNode]=ChangeStageFlag;
   \   000000E0   0020               MOVS     R0,#+0
   \   000000E2   2056               LDRSB    R0,[R4, R0]
   \   000000E4   0299               LDR      R1,[SP, #+8]
   \   000000E6   2A7E               LDRB     R2,[R5, #+24]
   \   000000E8   0A54               STRB     R2,[R1, R0]
   1120                                AlarmOn=1; 
   \   000000EA   0120               MOVS     R0,#+1
   \   000000EC   E874               STRB     R0,[R5, #+19]
   1121                                out[sc]=1;
   \   000000EE   3870               STRB     R0,[R7, #+0]
   1122                                AlarmOffTime[sc]=g_counter;
   \   000000F0   019A               LDR      R2,[SP, #+4]
   \   000000F2   2800               MOVS     R0,R5
   \   000000F4   3030               ADDS     R0,R0,#+48
   \   000000F6   03C8               LDM      R0!,{R0,R1}
   \   000000F8   03C2               STM      R2!,{R0,R1}
   1123                             }
   1124                             if ((AlarmOffTime>0) && (g_counter>AlarmOffTime[sc]+AlarmSirenTime*1000) && (out[sc]==1))
   \                     ??AlarmExecute_8:
   \   000000FA   0598               LDR      R0,[SP, #+20]
   \   000000FC   0028               CMP      R0,#+0
   \   000000FE   44D0               BEQ      ??AlarmExecute_5
   \   00000100   0198               LDR      R0,[SP, #+4]
   \   00000102   03C8               LDM      R0!,{R0,R1}
   \   00000104   0200               MOVS     R2,R0
   \   00000106   0B00               MOVS     R3,R1
   \   00000108   3248               LDR      R0,??AlarmExecute_0+0x20  ;; 0x493e0
   \   0000010A   0021               MOVS     R1,#+0
   \   0000010C   8018               ADDS     R0,R0,R2
   \   0000010E   5941               ADCS     R1,R1,R3
   \   00000110   0200               MOVS     R2,R0
   \   00000112   0B00               MOVS     R3,R1
   \   00000114   2800               MOVS     R0,R5
   \   00000116   3030               ADDS     R0,R0,#+48
   \   00000118   03C8               LDM      R0!,{R0,R1}
   \   0000011A   8B42               CMP      R3,R1
   \   0000011C   35D8               BHI      ??AlarmExecute_5
   \   0000011E   01D3               BCC      ??AlarmExecute_10
   \   00000120   8242               CMP      R2,R0
   \   00000122   32D2               BCS      ??AlarmExecute_5
   \                     ??AlarmExecute_10:
   \   00000124   3878               LDRB     R0,[R7, #+0]
   \   00000126   0128               CMP      R0,#+1
   \   00000128   2FD1               BNE      ??AlarmExecute_5
   1125                             {
   1126                                PortStageSet(&(MainStage.StageQ[gProg.Screen[sc].Alarm.ActorNode].Port), gProg.Screen[sc].Alarm.ActorPort, 1); 
                                                    ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   0000012A   0122               MOVS     R2,#+1
   \   0000012C   6178               LDRB     R1,[R4, #+1]
   \   0000012E   0020               MOVS     R0,#+0
   \   00000130   2056               LDRSB    R0,[R4, R0]
   \   00000132   1623               MOVS     R3,#+22
   \   00000134   5843               MULS     R0,R3,R0
   \   00000136   039B               LDR      R3,[SP, #+12]
   \   00000138   1818               ADDS     R0,R3,R0
   \   0000013A   ........           BL       PortStageSet
   1127                                MainStage.SendStageChange[gProg.Screen[sc].Alarm.ActorNode]=ChangeStageFlag;
   \   0000013E   0020               MOVS     R0,#+0
   \   00000140   2056               LDRSB    R0,[R4, R0]
   \   00000142   0299               LDR      R1,[SP, #+8]
   \   00000144   2A7E               LDRB     R2,[R5, #+24]
   \   00000146   0A54               STRB     R2,[R1, R0]
   1128                                AlarmOn=0; 
   \   00000148   0020               MOVS     R0,#+0
   \   0000014A   E874               STRB     R0,[R5, #+19]
   1129                                out[sc]=1;
   \   0000014C   0120               MOVS     R0,#+1
   \   0000014E   3870               STRB     R0,[R7, #+0]
   1130                                AlarmOffTime[sc]=0;
   \   00000150   019A               LDR      R2,[SP, #+4]
   \   00000152   0020               MOVS     R0,#+0
   \   00000154   0021               MOVS     R1,#+0
   \   00000156   03C2               STM      R2!,{R0,R1}
   \   00000158   17E0               B        ??AlarmExecute_5
   1131           
   1132                             }
   1133                             
   1134                            
   1135                             
   1136                           }
   1137                }else{
   1138                  if (out[sc]==1)
   \                     ??AlarmExecute_6:
   \   0000015A   3878               LDRB     R0,[R7, #+0]
   \   0000015C   0128               CMP      R0,#+1
   \   0000015E   14D1               BNE      ??AlarmExecute_5
   1139                  {
   1140                      out[sc]=0;
   \   00000160   0020               MOVS     R0,#+0
   \   00000162   3870               STRB     R0,[R7, #+0]
   1141                      AlarmOnTime[sc]=0;
   \   00000164   009A               LDR      R2,[SP, #+0]
   \   00000166   0021               MOVS     R1,#+0
   \   00000168   03C2               STM      R2!,{R0,R1}
   1142                      AlarmOn=0; 
   \   0000016A   184D               LDR      R5,??AlarmExecute_0+0x18  ;; DateTime
   \   0000016C   E874               STRB     R0,[R5, #+19]
   1143                      PortStageSet(&(MainStage.StageQ[gProg.Screen[sc].Alarm.ActorNode].Port), gProg.Screen[sc].Alarm.ActorPort, 1);
                                          ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   0000016E   0122               MOVS     R2,#+1
   \   00000170   6178               LDRB     R1,[R4, #+1]
   \   00000172   2056               LDRSB    R0,[R4, R0]
   \   00000174   1623               MOVS     R3,#+22
   \   00000176   5843               MULS     R0,R3,R0
   \   00000178   039B               LDR      R3,[SP, #+12]
   \   0000017A   1818               ADDS     R0,R3,R0
   \   0000017C   ........           BL       PortStageSet
   1144                      MainStage.SendStageChange[gProg.Screen[sc].Alarm.ActorNode]=ChangeStageFlag;
   \   00000180   0020               MOVS     R0,#+0
   \   00000182   2056               LDRSB    R0,[R4, R0]
   \   00000184   0299               LDR      R1,[SP, #+8]
   \   00000186   2A7E               LDRB     R2,[R5, #+24]
   \   00000188   0A54               STRB     R2,[R1, R0]
   1145                  }
   1146                }
   1147                     
   1148              }
   1149            }
   \                     ??AlarmExecute_5:
   \   0000018A   761C               ADDS     R6,R6,#+1
   \   0000018C   A034               ADDS     R4,R4,#+160
   \   0000018E   0198               LDR      R0,[SP, #+4]
   \   00000190   0830               ADDS     R0,R0,#+8
   \   00000192   0190               STR      R0,[SP, #+4]
   \   00000194   0098               LDR      R0,[SP, #+0]
   \   00000196   0830               ADDS     R0,R0,#+8
   \   00000198   0090               STR      R0,[SP, #+0]
   \   0000019A   0498               LDR      R0,[SP, #+16]
   \   0000019C   801C               ADDS     R0,R0,#+2
   \   0000019E   0490               STR      R0,[SP, #+16]
   \   000001A0   7F1C               ADDS     R7,R7,#+1
   \   000001A2   3006               LSLS     R0,R6,#+24
   \   000001A4   000E               LSRS     R0,R0,#+24
   \   000001A6   0828               CMP      R0,#+8
   \   000001A8   00D2               BCS      .+4
   \   000001AA   4FE7               B        ??AlarmExecute_2
   1150          }
   \   000001AC   07B0               ADD      SP,SP,#+28
   \   000001AE   F0BC               POP      {R4-R7}
   \   000001B0   01BC               POP      {R0}
   \   000001B2   0047               BX       R0               ;; return
   \                     ??AlarmExecute_0:
   \   000001B4   ........           DC32     AlarmScreenAction
   \   000001B8   ........           DC32     gProg + 48164
   \   000001BC   ........           DC32     MainStage
   \   000001C0   EB060000           DC32     0x6eb
   \   000001C4   A2030000           DC32     0x3a2
   \   000001C8   ........           DC32     DateTime + 48
   \   000001CC   ........           DC32     DateTime
   \   000001D0   60EA0000           DC32     0xea60
   \   000001D4   E0930400           DC32     0x493e0
   1151          
   1152          
   1153          
   1154          
   1155          
   1156          
   1157          
   1158          //-----------------------------------------------------------------------------
   1159          //! Nazwa funkcji :    Timer_1h  
   1160          //! Okres: 1 godzina
   1161          //-----------------------------------------------------------------------------
   1162          //  
   1163          //----------------------------------------------------------------------------- 

   \                                 In section Debug.txt, align 4, keep-with-next
   1164          void Timer_1h(void)                  
   1165          { 
   \                     Timer_1h:
   \   00000000   01B5               PUSH     {R0,LR}
   1166              ThermostatsTimeChartExecute();
   \   00000002   ........           BL       ThermostatsTimeChartExecute
   1167          }//_____________________________________________________________________________
   \   00000006   08BC               POP      {R3}
   \   00000008   01BC               POP      {R0}
   \   0000000A   0047               BX       R0               ;; return
   1168          
   1169          
   1170          
   1171          //-----------------------------------------------------------------------------
   1172          //! Nazwa funkcji :    Timer_1min  
   1173          //! Okres: 1min
   1174          //-----------------------------------------------------------------------------
   1175          //  
   1176          //----------------------------------------------------------------------------- 

   \                                 In section Debug.txt, align 4, keep-with-next
   1177          void Timer_1min(void)                  
   1178          { 
   \                     Timer_1min:
   \   00000000   01B5               PUSH     {R0,LR}
   1179             TimetableExecute();
   \   00000002   ........           BL       TimetableExecute
   1180             ThermostatsExecute();
   \   00000006   ........           BL       ThermostatsExecute
   1181             
   1182          }//_____________________________________________________________________________
   \   0000000A   08BC               POP      {R3}
   \   0000000C   01BC               POP      {R0}
   \   0000000E   0047               BX       R0               ;; return
   1183          
   1184          
   1185          
   1186          
   1187          
   1188          
   1189          //-----------------------------------------------------------------------------
   1190          //! Nazwa funkcji :    Timer_1s  
   1191          //! Okres: 1s
   1192          //! Funkcja obs³ugi przerwania USART 0
   1193          //-----------------------------------------------------------------------------
   1194          //  
   1195          //----------------------------------------------------------------------------- 

   \                                 In section .bss, align 4
   1196          int XY_Tab[11];
   \                     XY_Tab:
   \   00000000                      DS8 44
   1197          int LiczOds = 0;
   1198          #define x_offset 1
   1199          #define y_offset 6

   \                                 In section .bss, align 1
   1200          char display_cykl =0;
   \                     display_cykl:
   \   00000000                      DS8 1
   1201          int X_up_old =-1;
   1202          int Y_up_old =-1;
   1203          int X_down_old =-1;
   1204          int Y_down_old =-1;
   1205          char g_PC_Connected_timeout=5;
   1206          
   1207          
   1208          unsigned int CyklPerSekCount=0; 
   1209          unsigned int TransLoopTime=0;
   1210          unsigned int CyklPerSek=1;
   1211          int MenuLevel_old; //tmp
   1212           char FlagChangeTime=0;
   1213          
   1214          
   1215          

   \                                 In section Debug.txt, align 4, keep-with-next
   1216          void Timer_1s(void)                        //timer isr 
   1217          { 
   \                     Timer_1s:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   8BB0               SUB      SP,SP,#+44
   1218           static char TryIndirect, TryIndirectSlow;   //zmienna s³u¿y do usuwania trybu indirect w przypadku braku nawi¹zania po³¹czenia w okreœlonym czasie
   1219             
   1220            
   1221            if ((AlarmOn) || (Speaker[1]==1)) 
   \   00000004   B14C               LDR      R4,??Timer_1s_1  ;; DateTime
   \   00000006   E07C               LDRB     R0,[R4, #+19]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   02D1               BNE      ??Timer_1s_2
   \   0000000C   607A               LDRB     R0,[R4, #+9]
   \   0000000E   0128               CMP      R0,#+1
   \   00000010   0DD1               BNE      ??Timer_1s_3
   1222            {
   1223                ButtonBipCounter=g_counter+500;
   \                     ??Timer_1s_2:
   \   00000012   AF4D               LDR      R5,??Timer_1s_1+0x4  ;; ButtonBipCounter
   \   00000014   2000               MOVS     R0,R4
   \   00000016   3030               ADDS     R0,R0,#+48
   \   00000018   0CC8               LDM      R0!,{R2,R3}
   \   0000001A   FA20               MOVS     R0,#+250
   \   0000001C   4000               LSLS     R0,R0,#+1        ;; #+500
   \   0000001E   0021               MOVS     R1,#+0
   \   00000020   8018               ADDS     R0,R0,R2
   \   00000022   5941               ADCS     R1,R1,R3
   \   00000024   03C5               STM      R5!,{R0,R1}
   1224                AT91C_BASE_PIOA->PIO_SODR =SpeakerPin; 
                                                  ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   00000026   AB48               LDR      R0,??Timer_1s_1+0x8  ;; 0xfffff430
   \   00000028   8021               MOVS     R1,#+128
   \   0000002A   0906               LSLS     R1,R1,#+24       ;; #-2147483648
   \   0000002C   0160               STR      R1,[R0, #+0]
   1225            }
   1226          
   1227             g_seconds_counter++;
   \                     ??Timer_1s_3:
   \   0000002E   E06C               LDR      R0,[R4, #+76]
   \   00000030   401C               ADDS     R0,R0,#+1
   \   00000032   E064               STR      R0,[R4, #+76]
   1228          
   1229            
   1230            if (CyklPerSekCount>0)
   \   00000034   A56E               LDR      R5,[R4, #+104]
   \   00000036   002D               CMP      R5,#+0
   \   00000038   06D0               BEQ      ??Timer_1s_4
   1231            {
   1232             TransLoopTime=(1000/CyklPerSekCount);     //czas obiegu programu w ms
   \   0000003A   FA20               MOVS     R0,#+250
   \   0000003C   8000               LSLS     R0,R0,#+2        ;; #+1000
   \   0000003E   2900               MOVS     R1,R5
   \   00000040   ........           BL       __aeabi_uidivmod
   1233             CyklPerSek=CyklPerSekCount;               //iloœæ cykli na sekunde
   \   00000044   2567               STR      R5,[R4, #+112]
   \   00000046   00E0               B        ??Timer_1s_5
   1234            }else{
   1235             TransLoopTime=0;
   \                     ??Timer_1s_4:
   \   00000048   0020               MOVS     R0,#+0
   \                     ??Timer_1s_5:
   \   0000004A   E066               STR      R0,[R4, #+108]
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   A066               STR      R0,[R4, #+104]
   1236            }
   1237            CyklPerSekCount=0;
   1238          
   1239               
   1240            
   1241            int ChangeStageFlagTMP=CHANGE_STAGE_TIME*CyklPerSek;
   \   00000050   206F               LDR      R0,[R4, #+112]
   \   00000052   4000               LSLS     R0,R0,#+1
   1242            if (ChangeStageFlagTMP>0xFF) ChangeStageFlagTMP=0xFF;
   \   00000054   FF28               CMP      R0,#+255
   \   00000056   01DD               BLE      ??Timer_1s_6
   \   00000058   FF20               MOVS     R0,#+255
   \   0000005A   02E0               B        ??Timer_1s_7
   1243            if (ChangeStageFlagTMP<10) ChangeStageFlagTMP=10;
   \                     ??Timer_1s_6:
   \   0000005C   0A28               CMP      R0,#+10
   \   0000005E   00DA               BGE      ??Timer_1s_7
   \   00000060   0A20               MOVS     R0,#+10
   1244             ChangeStageFlag=ChangeStageFlagTMP;
   \                     ??Timer_1s_7:
   \   00000062   2076               STRB     R0,[R4, #+24]
   1245            
   1246             //Wy³¹czanie podœwietlenia wyœwietlacza
   1247            
   1248            if (g_LightCouterLCD==0) 
   \   00000064   206D               LDR      R0,[R4, #+80]
   \   00000066   0028               CMP      R0,#+0
   \   00000068   05D1               BNE      ??Timer_1s_8
   1249            {
   1250              if (g_LightLCDEnable==0) g_LightLCDEnable=1;
   \   0000006A   617B               LDRB     R1,[R4, #+13]
   \   0000006C   0029               CMP      R1,#+0
   \   0000006E   04D1               BNE      ??Timer_1s_9
   \   00000070   0121               MOVS     R1,#+1
   \   00000072   6173               STRB     R1,[R4, #+13]
   \   00000074   01E0               B        ??Timer_1s_9
   1251            }
   1252            if ((g_LightCouterLCD < LightLCD_Time) && (g_PC_Connected==0))
   \                     ??Timer_1s_8:
   \   00000076   1428               CMP      R0,#+20
   \   00000078   04DA               BGE      ??Timer_1s_10
   \                     ??Timer_1s_9:
   \   0000007A   217B               LDRB     R1,[R4, #+12]
   \   0000007C   0029               CMP      R1,#+0
   \   0000007E   08D1               BNE      ??Timer_1s_11
   1253            {
   1254                g_LightCouterLCD++;
   \   00000080   401C               ADDS     R0,R0,#+1
   \   00000082   2065               STR      R0,[R4, #+80]
   1255                  
   1256            } 
   1257            
   1258            
   1259            if ((g_LightCouterLCD >= LightLCD_Time) && (g_PC_Connected==0))
   \                     ??Timer_1s_10:
   \   00000084   206D               LDR      R0,[R4, #+80]
   \   00000086   1428               CMP      R0,#+20
   \   00000088   03DB               BLT      ??Timer_1s_11
   \   0000008A   207B               LDRB     R0,[R4, #+12]
   \   0000008C   0028               CMP      R0,#+0
   \   0000008E   00D1               BNE      ??Timer_1s_11
   1260          
   1261            {
   1262             g_LightLCDEnable=0; 
   \   00000090   6073               STRB     R0,[R4, #+13]
   1263            }
   1264          
   1265            
   1266            if ((DateTime.DayOfWeek)==0) DateTime.DayOfWeek=Monday;
   \                     ??Timer_1s_11:
   \   00000092   A079               LDRB     R0,[R4, #+6]
   \   00000094   0028               CMP      R0,#+0
   \   00000096   01D1               BNE      ??Timer_1s_12
   \   00000098   0120               MOVS     R0,#+1
   \   0000009A   A071               STRB     R0,[R4, #+6]
   1267            
   1268            if (DateTime.Second<59) {DateTime.Second++;} else {DateTime.Second=0; DateTime.Minute++;};
   \                     ??Timer_1s_12:
   \   0000009C   6079               LDRB     R0,[R4, #+5]
   \   0000009E   0100               MOVS     R1,R0
   \   000000A0   3B28               CMP      R0,#+59
   \   000000A2   01D2               BCS      ??Timer_1s_13
   \   000000A4   491C               ADDS     R1,R1,#+1
   \   000000A6   03E0               B        ??Timer_1s_14
   \                     ??Timer_1s_13:
   \   000000A8   0021               MOVS     R1,#+0
   \   000000AA   2079               LDRB     R0,[R4, #+4]
   \   000000AC   401C               ADDS     R0,R0,#+1
   \   000000AE   2071               STRB     R0,[R4, #+4]
   \                     ??Timer_1s_14:
   \   000000B0   6171               STRB     R1,[R4, #+5]
   1269            if (DateTime.Minute>59) {
   \   000000B2   2079               LDRB     R0,[R4, #+4]
   \   000000B4   3C28               CMP      R0,#+60
   \   000000B6   33D3               BCC      ??Timer_1s_15
   1270                DateTime.Minute=0; 
   \   000000B8   0020               MOVS     R0,#+0
   \   000000BA   2071               STRB     R0,[R4, #+4]
   1271                DateTime.Hour++;
   \   000000BC   E078               LDRB     R0,[R4, #+3]
   \   000000BE   401C               ADDS     R0,R0,#+1
   \   000000C0   E070               STRB     R0,[R4, #+3]
   1272                   //zmiana czasu z zimowego na letni
   1273                 if ((DateTime.Mounth==3) &&  (DateTime.Day>=25) && (DateTime.DayOfWeek==Sunday) && (DateTime.Hour==2) && (DateTime.Second==0))
   \   000000C2   6178               LDRB     R1,[R4, #+1]
   \   000000C4   0329               CMP      R1,#+3
   \   000000C6   10D1               BNE      ??Timer_1s_16
   \   000000C8   A178               LDRB     R1,[R4, #+2]
   \   000000CA   1929               CMP      R1,#+25
   \   000000CC   28D3               BCC      ??Timer_1s_15
   \   000000CE   A179               LDRB     R1,[R4, #+6]
   \   000000D0   0729               CMP      R1,#+7
   \   000000D2   25D1               BNE      ??Timer_1s_15
   \   000000D4   0006               LSLS     R0,R0,#+24
   \   000000D6   000E               LSRS     R0,R0,#+24
   \   000000D8   0228               CMP      R0,#+2
   \   000000DA   21D1               BNE      ??Timer_1s_15
   \   000000DC   6079               LDRB     R0,[R4, #+5]
   \   000000DE   0028               CMP      R0,#+0
   \   000000E0   1ED1               BNE      ??Timer_1s_15
   1274                 {
   1275                   DateTime.Hour=3;
   \   000000E2   0320               MOVS     R0,#+3
   \   000000E4   E070               STRB     R0,[R4, #+3]
   1276                   SetRTC_DateTime();  //Ustawinie: sekundy, minuty,  godziny, dzieñ tyg, dnia, miesi¹ca, roku
   \   000000E6   ........           BL       SetRTC_DateTime
   1277          
   1278                 }
   1279                 //zmiana czasu z letniego na zimowy
   1280                 if ((DateTime.Mounth==10) &&  (DateTime.Day>=25) && (DateTime.DayOfWeek==Sunday) && (DateTime.Hour==3) && (DateTime.Second==0))
   \                     ??Timer_1s_16:
   \   000000EA   6078               LDRB     R0,[R4, #+1]
   \   000000EC   0A28               CMP      R0,#+10
   \   000000EE   17D1               BNE      ??Timer_1s_15
   \   000000F0   A078               LDRB     R0,[R4, #+2]
   \   000000F2   1928               CMP      R0,#+25
   \   000000F4   14D3               BCC      ??Timer_1s_15
   \   000000F6   A079               LDRB     R0,[R4, #+6]
   \   000000F8   0728               CMP      R0,#+7
   \   000000FA   11D1               BNE      ??Timer_1s_15
   \   000000FC   E078               LDRB     R0,[R4, #+3]
   \   000000FE   0328               CMP      R0,#+3
   \   00000100   0ED1               BNE      ??Timer_1s_15
   \   00000102   6079               LDRB     R0,[R4, #+5]
   \   00000104   0028               CMP      R0,#+0
   \   00000106   0BD1               BNE      ??Timer_1s_15
   1281                 {
   1282                   if (FlagChangeTime==0)
   \   00000108   E07E               LDRB     R0,[R4, #+27]
   \   0000010A   0028               CMP      R0,#+0
   \   0000010C   06D1               BNE      ??Timer_1s_17
   1283                   {
   1284                      FlagChangeTime=1; 
   \   0000010E   0120               MOVS     R0,#+1
   \   00000110   E076               STRB     R0,[R4, #+27]
   1285                      DateTime.Hour=2;
   \   00000112   0220               MOVS     R0,#+2
   \   00000114   E070               STRB     R0,[R4, #+3]
   1286                      SetRTC_DateTime();  //Ustawinie: sekundy, minuty,  godziny, dzieñ tyg, dnia, miesi¹ca, roku
   \   00000116   ........           BL       SetRTC_DateTime
   \   0000011A   01E0               B        ??Timer_1s_15
   1287                   }else{
   1288                      FlagChangeTime=0; 
   \                     ??Timer_1s_17:
   \   0000011C   0020               MOVS     R0,#+0
   \   0000011E   E076               STRB     R0,[R4, #+27]
   1289                   }
   1290                 }
   1291            }
   1292            
   1293            if (DateTime.Hour>23)   {
   \                     ??Timer_1s_15:
   \   00000120   A678               LDRB     R6,[R4, #+2]
   \   00000122   A579               LDRB     R5,[R4, #+6]
   \   00000124   E078               LDRB     R0,[R4, #+3]
   \   00000126   1828               CMP      R0,#+24
   \   00000128   03D3               BCC      ??Timer_1s_18
   1294              DateTime.Hour=0;     
   \   0000012A   0020               MOVS     R0,#+0
   \   0000012C   E070               STRB     R0,[R4, #+3]
   1295              DateTime.DayOfWeek++; DateTime.Day++;
   \   0000012E   6D1C               ADDS     R5,R5,#+1
   \   00000130   761C               ADDS     R6,R6,#+1
   1296          
   1297            }
   1298            
   1299            
   1300            switch (DateTime.Mounth)
   \                     ??Timer_1s_18:
   \   00000132   6078               LDRB     R0,[R4, #+1]
   \   00000134   0700               MOVS     R7,R0
   \   00000136   401E               SUBS     R0,R0,#+1
   \   00000138   0B28               CMP      R0,#+11
   \   0000013A   39D8               BHI      ??Timer_1s_19
   \   0000013C   01A1               ADR      R1,??Timer_1s_0
   \   0000013E   095C               LDRB     R1,[R1, R0]
   \   00000140   8F44               ADD      PC,PC,R1
   \   00000142   C046               Nop      
   \                     ??Timer_1s_0:
   \   00000144   0C1A0C50           DC8      +12,+26,+12,+80
   \   00000148   0C500C0C           DC8      +12,+80,+12,+12
   \   0000014C   500C505A           DC8      +80,+12,+80,+90
   1301                  {
   1302                    case 1  : if (DateTime.Day>31) {DateTime.Day=1; DateTime.Mounth++;} break;
   \                     ??Timer_1s_20:
   \   00000150   3606               LSLS     R6,R6,#+24
   \   00000152   360E               LSRS     R6,R6,#+24
   \   00000154   202E               CMP      R6,#+32
   \   00000156   2BD3               BCC      ??Timer_1s_19
   \                     ??Timer_1s_21:
   \   00000158   0126               MOVS     R6,#+1
   \   0000015A   7F1C               ADDS     R7,R7,#+1
   \   0000015C   28E0               B        ??Timer_1s_19
   \                     ??Timer_1s_22:
   \   0000015E   2078               LDRB     R0,[R4, #+0]
   \   00000160   8108               LSRS     R1,R0,#+2
   \   00000162   8900               LSLS     R1,R1,#+2
   \   00000164   401A               SUBS     R0,R0,R1
   \   00000166   05D1               BNE      ??Timer_1s_23
   \   00000168   2078               LDRB     R0,[R4, #+0]
   \   0000016A   6421               MOVS     R1,#+100
   \   0000016C   ........           BL       __aeabi_idivmod
   \   00000170   0029               CMP      R1,#+0
   \   00000172   06D1               BNE      ??Timer_1s_24
   \                     ??Timer_1s_23:
   \   00000174   2078               LDRB     R0,[R4, #+0]
   \   00000176   C821               MOVS     R1,#+200
   \   00000178   4900               LSLS     R1,R1,#+1        ;; #+400
   \   0000017A   ........           BL       __aeabi_idivmod
   \   0000017E   0029               CMP      R1,#+0
   \   00000180   04D1               BNE      ??Timer_1s_25
   1303                    case 2  : if ((DateTime.Year%4 == 0) && (DateTime.Year%100 != 0) || (DateTime.Year%400 == 0))  //je¿eli rok przestêpny
   1304                                  {if (DateTime.Day>29) {DateTime.Day=1; DateTime.Mounth++;}     
   \                     ??Timer_1s_24:
   \   00000182   3606               LSLS     R6,R6,#+24
   \   00000184   360E               LSRS     R6,R6,#+24
   \   00000186   1E2E               CMP      R6,#+30
   \                     ??Timer_1s_26:
   \   00000188   12D3               BCC      ??Timer_1s_19
   \   0000018A   E5E7               B        ??Timer_1s_21
   1305                                  }else{if (DateTime.Day>28) {DateTime.Day=1; DateTime.Mounth++;}
   \                     ??Timer_1s_25:
   \   0000018C   3606               LSLS     R6,R6,#+24
   \   0000018E   360E               LSRS     R6,R6,#+24
   \   00000190   1D2E               CMP      R6,#+29
   \   00000192   F9E7               B.N      ??Timer_1s_26
   1306                                  }
   1307                    break;
   1308                    case 3  : if (DateTime.Day>31) {DateTime.Day=1; DateTime.Mounth++;} break;
   1309                    case 4  : if (DateTime.Day>30) {DateTime.Day=1; DateTime.Mounth++;} break;
   \                     ??Timer_1s_27:
   \   00000194   3606               LSLS     R6,R6,#+24
   \   00000196   360E               LSRS     R6,R6,#+24
   \   00000198   1F2E               CMP      R6,#+31
   \   0000019A   09D3               BCC      ??Timer_1s_19
   \   0000019C   DCE7               B        ??Timer_1s_21
   1310                    case 5  : if (DateTime.Day>31) {DateTime.Day=1; DateTime.Mounth++;} break;
   1311                    case 6  : if (DateTime.Day>30) {DateTime.Day=1; DateTime.Mounth++;} break;
   1312                    case 7  : if (DateTime.Day>31) {DateTime.Day=1; DateTime.Mounth++;} break;
   1313                    case 8  : if (DateTime.Day>31) {DateTime.Day=1; DateTime.Mounth++;} break;
   1314                    case 9  : if (DateTime.Day>30) {DateTime.Day=1; DateTime.Mounth++;} break;
   1315                    case 10 : if (DateTime.Day>31) {DateTime.Day=1; DateTime.Mounth++;} break;
   1316                    case 11 : if (DateTime.Day>30) {DateTime.Day=1; DateTime.Mounth++;} break;
   1317                    case 12 : if (DateTime.Day>31) 
   \                     ??Timer_1s_28:
   \   0000019E   3606               LSLS     R6,R6,#+24
   \   000001A0   360E               LSRS     R6,R6,#+24
   \   000001A2   202E               CMP      R6,#+32
   \   000001A4   04D3               BCC      ??Timer_1s_19
   1318                    {
   1319                      DateTime.Day=1; DateTime.Mounth=1; DateTime.Year++;
   \   000001A6   0127               MOVS     R7,#+1
   \   000001A8   0126               MOVS     R6,#+1
   \   000001AA   2078               LDRB     R0,[R4, #+0]
   \   000001AC   401C               ADDS     R0,R0,#+1
   \   000001AE   2070               STRB     R0,[R4, #+0]
   \                     ??Timer_1s_19:
   \   000001B0   A670               STRB     R6,[R4, #+2]
   \   000001B2   6770               STRB     R7,[R4, #+1]
   1320                    } break;
   1321                    
   1322            
   1323            
   1324            }  
   1325            if (DateTime.DayOfWeek>Sunday) DateTime.DayOfWeek=Monday;
   \   000001B4   2D06               LSLS     R5,R5,#+24
   \   000001B6   2D0E               LSRS     R5,R5,#+24
   \   000001B8   082D               CMP      R5,#+8
   \   000001BA   00D3               BCC      ??Timer_1s_29
   \   000001BC   0125               MOVS     R5,#+1
   \                     ??Timer_1s_29:
   \   000001BE   A571               STRB     R5,[R4, #+6]
   1326            
   1327          
   1328            
   1329            
   1330            
   1331          
   1332              
   1333            if (MenuLevel_old!=MenuLevel)
   \   000001C0   4548               LDR      R0,??Timer_1s_1+0xC  ;; MenuLevel
   \   000001C2   0068               LDR      R0,[R0, #+0]
   \   000001C4   616F               LDR      R1,[R4, #+116]
   \   000001C6   8142               CMP      R1,R0
   \   000001C8   00D0               BEQ      ??Timer_1s_30
   1334            {
   1335              MenuLevel_old=MenuLevel;    //na koniec usun¹c MenuLevel_old
   \   000001CA   6067               STR      R0,[R4, #+116]
   1336            }
   1337            
   1338             char czas_tmp[9];
   1339            
   1340            TimeToStr(DateTime.Hour, DateTime.Minute, DateTime.Second, czas_tmp);
   \                     ??Timer_1s_30:
   \   000001CC   08AB               ADD      R3,SP,#+32
   \   000001CE   6279               LDRB     R2,[R4, #+5]
   \   000001D0   2179               LDRB     R1,[R4, #+4]
   \   000001D2   E078               LDRB     R0,[R4, #+3]
   \   000001D4   ........           BL       TimeToStr
   1341            czas_tmp[8]=13;
   \   000001D8   08A8               ADD      R0,SP,#+32
   \   000001DA   0D21               MOVS     R1,#+13
   \   000001DC   0172               STRB     R1,[R0, #+8]
   1342          
   1343            
   1344            //zeruj wskaŸniki poprawnoœci po³aczeñ
   1345            if (g_US0_Connect_OK) g_US0_Connect_OK--;
   \   000001DE   3F48               LDR      R0,??Timer_1s_1+0x10  ;; g_US0_Connect_OK
   \   000001E0   0178               LDRB     R1,[R0, #+0]
   \   000001E2   0029               CMP      R1,#+0
   \   000001E4   01D0               BEQ      ??Timer_1s_31
   \   000001E6   491E               SUBS     R1,R1,#+1
   \   000001E8   0170               STRB     R1,[R0, #+0]
   1346            if (g_US1_Connect_OK) g_US1_Connect_OK--;
   \                     ??Timer_1s_31:
   \   000001EA   3D48               LDR      R0,??Timer_1s_1+0x14  ;; g_US1_Connect_OK
   \   000001EC   0178               LDRB     R1,[R0, #+0]
   \   000001EE   0029               CMP      R1,#+0
   \   000001F0   01D0               BEQ      ??Timer_1s_32
   \   000001F2   491E               SUBS     R1,R1,#+1
   \   000001F4   0170               STRB     R1,[R0, #+0]
   1347            
   1348          
   1349            //synchronizacja RTC
   1350          if ((DateTime.Hour==2) && (DateTime.Minute==57) && (DateTime.Second==0)) GetDateTimeFromRTC(); 
   \                     ??Timer_1s_32:
   \   000001F6   E078               LDRB     R0,[R4, #+3]
   \   000001F8   0228               CMP      R0,#+2
   \   000001FA   07D1               BNE      ??Timer_1s_33
   \   000001FC   2079               LDRB     R0,[R4, #+4]
   \   000001FE   3928               CMP      R0,#+57
   \   00000200   04D1               BNE      ??Timer_1s_33
   \   00000202   6079               LDRB     R0,[R4, #+5]
   \   00000204   0028               CMP      R0,#+0
   \   00000206   01D1               BNE      ??Timer_1s_33
   \   00000208   ........           BL       GetDateTimeFromRTC
   1351          //if (DateTime.Second=30) GetDateTimeFromRTC(); 
   1352          
   1353            //przesuniêcie bitowe dle pomiaru jakoœci po³¹czenia z Node`ami z okresowoœci¹ 1min
   1354            static char CountMin=0;
   1355            if (CountMin<60)
   \                     ??Timer_1s_33:
   \   0000020C   A07F               LDRB     R0,[R4, #+30]
   \   0000020E   3C28               CMP      R0,#+60
   \   00000210   02D2               BCS      ??Timer_1s_34
   1356            {
   1357              CountMin++; 
   \   00000212   401C               ADDS     R0,R0,#+1
   \   00000214   A077               STRB     R0,[R4, #+30]
   \   00000216   B0E0               B        ??Timer_1s_35
   1358            }else{
   1359              CountMin=0;
   \                     ??Timer_1s_34:
   \   00000218   0020               MOVS     R0,#+0
   \   0000021A   A077               STRB     R0,[R4, #+30]
   \   0000021C   BD48               LDR      R0,??Timer_1s_36  ;; TransQuality + 1
   \   0000021E   0078               LDRB     R0,[R0, #+0]
   \   00000220   0728               CMP      R0,#+7
   \   00000222   03D2               BCS      ??Timer_1s_37
   1360            
   1361              if (TransQuality.SlowMensurIndex<7)
   1362              {
   1363                TransQuality.SlowMensurIndex++; 
   \   00000224   BB49               LDR      R1,??Timer_1s_36  ;; TransQuality + 1
   \   00000226   401C               ADDS     R0,R0,#+1
   \   00000228   0870               STRB     R0,[R1, #+0]
   \   0000022A   02E0               B        ??Timer_1s_38
   1364              }else{
   1365                TransQuality.SlowMensurIndex=0;
   \                     ??Timer_1s_37:
   \   0000022C   B948               LDR      R0,??Timer_1s_36  ;; TransQuality + 1
   \   0000022E   0021               MOVS     R1,#+0
   \   00000230   0170               STRB     R1,[R0, #+0]
   1366              }
   1367              
   1368              for(char NN=1; NN<NumberNeurons; NN++)   TransQuality.SlowMensur[NN] &= ~(1<<TransQuality.SlowMensurIndex);
   \                     ??Timer_1s_38:
   \   00000232   B948               LDR      R0,??Timer_1s_36+0x4  ;; TransQuality + 4
   \   00000234   1121               MOVS     R1,#+17
   \                     ??Timer_1s_39:
   \   00000236   0278               LDRB     R2,[R0, #+0]
   \   00000238   0123               MOVS     R3,#+1
   \   0000023A   B64D               LDR      R5,??Timer_1s_36  ;; TransQuality + 1
   \   0000023C   2D78               LDRB     R5,[R5, #+0]
   \   0000023E   AB40               LSLS     R3,R3,R5
   \   00000240   9A43               BICS     R2,R2,R3
   \   00000242   0270               STRB     R2,[R0, #+0]
   \   00000244   4278               LDRB     R2,[R0, #+1]
   \   00000246   0123               MOVS     R3,#+1
   \   00000248   B24D               LDR      R5,??Timer_1s_36  ;; TransQuality + 1
   \   0000024A   2D78               LDRB     R5,[R5, #+0]
   \   0000024C   AB40               LSLS     R3,R3,R5
   \   0000024E   9A43               BICS     R2,R2,R3
   \   00000250   4270               STRB     R2,[R0, #+1]
   \   00000252   801C               ADDS     R0,R0,#+2
   \   00000254   491E               SUBS     R1,R1,#+1
   \   00000256   EED1               BNE      ??Timer_1s_39
   1369              
   1370              char TryIndirectTmp, TryIndirectSlowTmp;
   1371              
   1372              TryIndirectTmp=TryIndirect;
   \   00000258   6846               MOV      R0,SP
   \   0000025A   217F               LDRB     R1,[R4, #+28]
   \   0000025C   0170               STRB     R1,[R0, #+0]
   1373              TryIndirectSlowTmp=TryIndirectSlow;
   \   0000025E   617F               LDRB     R1,[R4, #+29]
   \   00000260   4170               STRB     R1,[R0, #+1]
   1374                
   1375                    //Sprawdzenie wiarygodnoœci wêz³ów na podstawie d³ugotrwa³ego pomiaru jakoœci
   1376                for (char NN=1; NN<NumberNeurons; NN++)
   \   00000262   0127               MOVS     R7,#+1
   \   00000264   0126               MOVS     R6,#+1
   \   00000266   AD48               LDR      R0,??Timer_1s_36+0x8  ;; TransQuality + 3
   \   00000268   0390               STR      R0,[SP, #+12]
   \   0000026A   AD48               LDR      R0,??Timer_1s_36+0xC  ;; NeuronsList
   \   0000026C   0190               STR      R0,[SP, #+4]
   \   0000026E   AD48               LDR      R0,??Timer_1s_36+0x10  ;; MainStage + 182
   \   00000270   0490               STR      R0,[SP, #+16]
   1377                {
   1378                  if (TransQuality.SlowMensur[NN-1]==0)
   \                     ??Timer_1s_40:
   \   00000272   0398               LDR      R0,[SP, #+12]
   \   00000274   0078               LDRB     R0,[R0, #+0]
   \   00000276   0028               CMP      R0,#+0
   \   00000278   6AD1               BNE      ??Timer_1s_41
   1379                  {
   1380                      for (char NR=0; NR<NumberReg; NR++)
   \   0000027A   0498               LDR      R0,[SP, #+16]
   \   0000027C   0290               STR      R0,[SP, #+8]
   \   0000027E   0B25               MOVS     R5,#+11
   1381                      {
   1382                        MainStage.StageI[NN].Value[NR]=0x8AAA;
   \                     ??Timer_1s_42:
   \   00000280   0298               LDR      R0,[SP, #+8]
   \   00000282   A949               LDR      R1,??Timer_1s_36+0x14  ;; 0xffff8aaa
   \   00000284   0180               STRH     R1,[R0, #+0]
   1383                        
   1384                            if (ChangeingIdMode==0)
   \   00000286   207D               LDRB     R0,[R4, #+20]
   \   00000288   0028               CMP      R0,#+0
   \   0000028A   5CD1               BNE      ??Timer_1s_43
   1385                            {
   1386                                if (NeuronsList[NN-1].NeuronType==NodeRF)   //je¿eli wêze³ ze sta³¹ komunikacj¹
   \   0000028C   0198               LDR      R0,[SP, #+4]
   \   0000028E   0078               LDRB     R0,[R0, #+0]
   \   00000290   0328               CMP      R0,#+3
   \   00000292   27D1               BNE      ??Timer_1s_44
   1387                                {
   1388              
   1389                                      if (TryIndirect==0) //je¿eli rozkaz rozg³oœny nie dodany
   \   00000294   207F               LDRB     R0,[R4, #+28]
   \   00000296   0028               CMP      R0,#+0
   \   00000298   0ED1               BNE      ??Timer_1s_45
   1390                                      {
   1391                                        if ((!NeuronsList[NN-1].ReadSuspend) && (!AT91C_IFLASH_MEM->Config.SlaveMode))      AddRfTask_SearchNodeTask(NN);                //Dodaj rozkaz do tablicy zadañ RF - kto ma dostêp do wêz³a. Rozkaz dodawany jest po perwszej minucie pracy sterownika. Je¿eli wêze³ zerwie po³¹czenie to dodawany jest po 8 minutach
   \   0000029A   0198               LDR      R0,[SP, #+4]
   \   0000029C   007A               LDRB     R0,[R0, #+8]
   \   0000029E   4007               LSLS     R0,R0,#+29
   \   000002A0   07D4               BMI      ??Timer_1s_46
   \   000002A2   A248               LDR      R0,??Timer_1s_36+0x18  ;; 0x13d7e8
   \   000002A4   0078               LDRB     R0,[R0, #+0]
   \   000002A6   0028               CMP      R0,#+0
   \   000002A8   03D1               BNE      ??Timer_1s_46
   \   000002AA   3006               LSLS     R0,R6,#+24
   \   000002AC   000E               LSRS     R0,R0,#+24
   \   000002AE   ........           BL       AddRfTask_SearchNodeTask
   1392                                        TryIndirectTmp=1;
   \                     ??Timer_1s_46:
   \   000002B2   6846               MOV      R0,SP
   \   000002B4   0770               STRB     R7,[R0, #+0]
   \   000002B6   46E0               B        ??Timer_1s_43
   1393                                      }else if (TryIndirect==1){ //je¿eli rozkaz rozg³oœny dodany ale nikt nie znalaz³ wêz³a
   \                     ??Timer_1s_45:
   \   000002B8   0128               CMP      R0,#+1
   \   000002BA   44D1               BNE      ??Timer_1s_43
   1394                                        AddRfTask_RemoveSearchNodeTask(NN); 
   \   000002BC   3006               LSLS     R0,R6,#+24
   \   000002BE   000E               LSRS     R0,R0,#+24
   \   000002C0   ........           BL       AddRfTask_RemoveSearchNodeTask
   1395                                        TryIndirectTmp=2;
   \   000002C4   6846               MOV      R0,SP
   \   000002C6   0221               MOVS     R1,#+2
   \   000002C8   0170               STRB     R1,[R0, #+0]
   \   000002CA   3CE0               B        ??Timer_1s_43
   \                     ??Timer_1s_1:
   \   000002CC   ........           DC32     DateTime
   \   000002D0   ........           DC32     ButtonBipCounter
   \   000002D4   30F4FFFF           DC32     0xfffff430
   \   000002D8   ........           DC32     MenuLevel
   \   000002DC   ........           DC32     g_US0_Connect_OK
   \   000002E0   ........           DC32     g_US1_Connect_OK
   1396                                      }
   1397                                    
   1398                                
   1399                                }
   1400                                else if (NeuronsList[NN-1].NeuronType==NodeRF_Period) //je¿eli wêze³ z komunikacja d³ugo okresow¹ 
   \                     ??Timer_1s_44:
   \   000002E4   0528               CMP      R0,#+5
   \   000002E6   2ED1               BNE      ??Timer_1s_43
   1401                                {
   1402                                    if (g_counter>360000)
   \   000002E8   2000               MOVS     R0,R4
   \   000002EA   3030               ADDS     R0,R0,#+48
   \   000002EC   0CC8               LDM      R0!,{R2,R3}
   \   000002EE   9048               LDR      R0,??Timer_1s_36+0x1C  ;; 0x57e41
   \   000002F0   0021               MOVS     R1,#+0
   \   000002F2   8B42               CMP      R3,R1
   \   000002F4   27D3               BCC      ??Timer_1s_43
   \   000002F6   01D8               BHI      ??Timer_1s_47
   \   000002F8   8242               CMP      R2,R0
   \   000002FA   24D3               BCC      ??Timer_1s_43
   1403                                    {
   1404                                      if (TryIndirectSlow==0)  //je¿eli rozkaz rozg³oœny nie dodany
   \                     ??Timer_1s_47:
   \   000002FC   607F               LDRB     R0,[R4, #+29]
   \   000002FE   0028               CMP      R0,#+0
   \   00000300   12D1               BNE      ??Timer_1s_48
   1405                                      {
   1406                                        if ((TransQuality.SlowMensurIndex==0) && (!NeuronsList[NN-1].ReadSuspend) && (!AT91C_IFLASH_MEM->Config.SlaveMode))      AddRfTask_SearchNodeTask(NN);                //Dodaj rozkaz do tablicy zadañ RF - kto ma dostêp do wêz³a.  Rozkaz dodawany jest w ósmej minucie pracy sterownika. Je¿eli wêze³ zerwie po³¹czenie to dodawany jest po 8 minutach
   \   00000302   8448               LDR      R0,??Timer_1s_36  ;; TransQuality + 1
   \   00000304   0078               LDRB     R0,[R0, #+0]
   \   00000306   0028               CMP      R0,#+0
   \   00000308   0BD1               BNE      ??Timer_1s_49
   \   0000030A   0198               LDR      R0,[SP, #+4]
   \   0000030C   007A               LDRB     R0,[R0, #+8]
   \   0000030E   4007               LSLS     R0,R0,#+29
   \   00000310   07D4               BMI      ??Timer_1s_49
   \   00000312   8648               LDR      R0,??Timer_1s_36+0x18  ;; 0x13d7e8
   \   00000314   0078               LDRB     R0,[R0, #+0]
   \   00000316   0028               CMP      R0,#+0
   \   00000318   03D1               BNE      ??Timer_1s_49
   \   0000031A   3006               LSLS     R0,R6,#+24
   \   0000031C   000E               LSRS     R0,R0,#+24
   \   0000031E   ........           BL       AddRfTask_SearchNodeTask
   1407                                        TryIndirectSlowTmp=1;
   \                     ??Timer_1s_49:
   \   00000322   6846               MOV      R0,SP
   \   00000324   4770               STRB     R7,[R0, #+1]
   \   00000326   0EE0               B        ??Timer_1s_43
   1408                                      }else if ((TryIndirectSlow==1) && (g_counter>720000)) { //je¿eli rozkaz rozg³oœny dodany ale nikt nie znalaz³ wêz³a w dodatkowym czasie
   \                     ??Timer_1s_48:
   \   00000328   0128               CMP      R0,#+1
   \   0000032A   0CD1               BNE      ??Timer_1s_43
   \   0000032C   8148               LDR      R0,??Timer_1s_36+0x20  ;; 0xafc81
   \   0000032E   8B42               CMP      R3,R1
   \   00000330   09D3               BCC      ??Timer_1s_43
   \   00000332   01D8               BHI      ??Timer_1s_50
   \   00000334   8242               CMP      R2,R0
   \   00000336   06D3               BCC      ??Timer_1s_43
   1409                                        AddRfTask_RemoveSearchNodeTask(NN); 
   \                     ??Timer_1s_50:
   \   00000338   3006               LSLS     R0,R6,#+24
   \   0000033A   000E               LSRS     R0,R0,#+24
   \   0000033C   ........           BL       AddRfTask_RemoveSearchNodeTask
   1410                                        TryIndirectSlowTmp=2;
   \   00000340   6846               MOV      R0,SP
   \   00000342   0221               MOVS     R1,#+2
   \   00000344   4170               STRB     R1,[R0, #+1]
   1411                                      }
   1412                                    }
   1413                                }
   1414                            }
   1415               
   1416                      }
   \                     ??Timer_1s_43:
   \   00000346   0298               LDR      R0,[SP, #+8]
   \   00000348   801C               ADDS     R0,R0,#+2
   \   0000034A   0290               STR      R0,[SP, #+8]
   \   0000034C   6D1E               SUBS     R5,R5,#+1
   \   0000034E   97D1               BNE      ??Timer_1s_42
   1417                  }
   1418                }
   \                     ??Timer_1s_41:
   \   00000350   761C               ADDS     R6,R6,#+1
   \   00000352   0498               LDR      R0,[SP, #+16]
   \   00000354   1630               ADDS     R0,R0,#+22
   \   00000356   0490               STR      R0,[SP, #+16]
   \   00000358   0198               LDR      R0,[SP, #+4]
   \   0000035A   0C30               ADDS     R0,R0,#+12
   \   0000035C   0190               STR      R0,[SP, #+4]
   \   0000035E   0398               LDR      R0,[SP, #+12]
   \   00000360   401C               ADDS     R0,R0,#+1
   \   00000362   0390               STR      R0,[SP, #+12]
   \   00000364   3006               LSLS     R0,R6,#+24
   \   00000366   000E               LSRS     R0,R0,#+24
   \   00000368   2328               CMP      R0,#+35
   \   0000036A   00D2               BCS      .+4
   \   0000036C   81E7               B        ??Timer_1s_40
   1419                
   1420            TryIndirect=TryIndirectTmp;
   \   0000036E   6846               MOV      R0,SP
   \   00000370   0078               LDRB     R0,[R0, #+0]
   \   00000372   2077               STRB     R0,[R4, #+28]
   1421            TryIndirectSlow=TryIndirectSlowTmp;
   \   00000374   6846               MOV      R0,SP
   \   00000376   4078               LDRB     R0,[R0, #+1]
   \   00000378   6077               STRB     R0,[R4, #+29]
   1422                
   1423                
   1424            }
   1425          
   1426                               
   1427          
   1428            if (DateTime.Second==0) Timer_1min();
   \                     ??Timer_1s_35:
   \   0000037A   6079               LDRB     R0,[R4, #+5]
   \   0000037C   0028               CMP      R0,#+0
   \   0000037E   03D1               BNE      ??Timer_1s_51
   \   00000380   ........           BL       TimetableExecute
   \   00000384   ........           BL       ThermostatsExecute
   1429            if ((DateTime.Second==0) && (DateTime.Minute==0))  Timer_1h();
   \                     ??Timer_1s_51:
   \   00000388   6079               LDRB     R0,[R4, #+5]
   \   0000038A   0028               CMP      R0,#+0
   \   0000038C   04D1               BNE      ??Timer_1s_52
   \   0000038E   2079               LDRB     R0,[R4, #+4]
   \   00000390   0028               CMP      R0,#+0
   \   00000392   04D1               BNE      ??Timer_1s_53
   \   00000394   ........           BL       ThermostatsTimeChartExecute
   1430            if (DateTime.Second==0) TimetableExecute();
   \                     ??Timer_1s_52:
   \   00000398   6079               LDRB     R0,[R4, #+5]
   \   0000039A   0028               CMP      R0,#+0
   \   0000039C   01D1               BNE      ??Timer_1s_54
   \                     ??Timer_1s_53:
   \   0000039E   ........           BL       TimetableExecute
   1431               AlarmExecute();
   \                     ??Timer_1s_54:
   \   000003A2   ........           BL       AlarmExecute
   1432               
   1433               
   1434          
   1435             //sprawdzenie wy³adowania baterii i wyœwietlenie ostrzenia       
   1436              if ((DateTime.Hour==10) && (DateTime.Minute==0) && (DateTime.Second==0)   && (DateTime.DayOfWeek==Saturday))
   \   000003A6   E078               LDRB     R0,[R4, #+3]
   \   000003A8   0A28               CMP      R0,#+10
   \   000003AA   45D1               BNE      ??Timer_1s_55
   \   000003AC   2079               LDRB     R0,[R4, #+4]
   \   000003AE   0028               CMP      R0,#+0
   \   000003B0   42D1               BNE      ??Timer_1s_55
   \   000003B2   6079               LDRB     R0,[R4, #+5]
   \   000003B4   0028               CMP      R0,#+0
   \   000003B6   3FD1               BNE      ??Timer_1s_55
   \   000003B8   A079               LDRB     R0,[R4, #+6]
   \   000003BA   0628               CMP      R0,#+6
   \   000003BC   3CD1               BNE      ??Timer_1s_55
   1437              {
   1438             
   1439                 for (char i=0; i<NumberNeurons; i++)
   \   000003BE   5E4F               LDR      R7,??Timer_1s_36+0x24  ;; gProg + 49434
   \   000003C0   5E4E               LDR      R6,??Timer_1s_36+0x28  ;; MainStage + 160
   \   000003C2   2325               MOVS     R5,#+35
   1440                 {
   1441                   if ((MainStage.StageI[i].Port& 0x8000) && (((unsigned short)(MainStage.StageI[i].Port))!=0x8AAA))
   \                     ??Timer_1s_56:
   \   000003C4   3088               LDRH     R0,[R6, #+0]
   \   000003C6   0104               LSLS     R1,R0,#+16
   \   000003C8   32D5               BPL      ??Timer_1s_57
   \   000003CA   5D49               LDR      R1,??Timer_1s_36+0x2C  ;; 0x8aaa
   \   000003CC   8842               CMP      R0,R1
   \   000003CE   2FD0               BEQ      ??Timer_1s_57
   1442                   {
   1443                      char txt[NodeLabelLethers+1];
   1444                      for (char k=0; k<NodeLabelLethers; k++) txt[k]=gProg.NodeLabel[i-1][k];
   \   000003D0   05A8               ADD      R0,SP,#+20
   \   000003D2   3900               MOVS     R1,R7
   \   000003D4   0222               MOVS     R2,#+2
   \                     ??Timer_1s_58:
   \   000003D6   0B78               LDRB     R3,[R1, #+0]
   \   000003D8   0370               STRB     R3,[R0, #+0]
   \   000003DA   4B78               LDRB     R3,[R1, #+1]
   \   000003DC   4370               STRB     R3,[R0, #+1]
   \   000003DE   8B78               LDRB     R3,[R1, #+2]
   \   000003E0   8370               STRB     R3,[R0, #+2]
   \   000003E2   CB78               LDRB     R3,[R1, #+3]
   \   000003E4   C370               STRB     R3,[R0, #+3]
   \   000003E6   0B79               LDRB     R3,[R1, #+4]
   \   000003E8   0371               STRB     R3,[R0, #+4]
   \   000003EA   491D               ADDS     R1,R1,#+5
   \   000003EC   401D               ADDS     R0,R0,#+5
   \   000003EE   521E               SUBS     R2,R2,#+1
   \   000003F0   F1D1               BNE      ??Timer_1s_58
   1445                      txt[NodeLabelLethers]=0;
   \   000003F2   05A8               ADD      R0,SP,#+20
   \   000003F4   0021               MOVS     R1,#+0
   \   000003F6   8172               STRB     R1,[R0, #+10]
   1446          
   1447                      
   1448                      Message_Paint(2,"Wyladowana","bateria","   ","Wezel:", txt);         
   \   000003F8   05A9               ADD      R1,SP,#+20
   \   000003FA   5248               LDR      R0,??Timer_1s_36+0x30  ;; `?<Constant "Wyladowana">` + 20
   \   000003FC   03B4               PUSH     {R0,R1}
   \   000003FE   52A3               ADR      R3,??Timer_1s_36+0x34  ;; "   "
   \   00000400   524A               LDR      R2,??Timer_1s_36+0x38  ;; `?<Constant "Wyladowana">` + 12
   \   00000402   5349               LDR      R1,??Timer_1s_36+0x3C  ;; `?<Constant "Wyladowana">`
   \   00000404   0220               MOVS     R0,#+2
   \   00000406   ........           BL       Message_Paint
   \   0000040A   02B0               ADD      SP,SP,#+8
   1449          
   1450                      ButtonBipCounter=g_counter+8000;
   \   0000040C   514A               LDR      R2,??Timer_1s_36+0x40  ;; ButtonBipCounter
   \   0000040E   9446               MOV      R12,R2
   \   00000410   2000               MOVS     R0,R4
   \   00000412   3030               ADDS     R0,R0,#+48
   \   00000414   03C8               LDM      R0!,{R0,R1}
   \   00000416   0200               MOVS     R2,R0
   \   00000418   0B00               MOVS     R3,R1
   \   0000041A   FA20               MOVS     R0,#+250
   \   0000041C   4001               LSLS     R0,R0,#+5        ;; #+8000
   \   0000041E   0021               MOVS     R1,#+0
   \   00000420   8018               ADDS     R0,R0,R2
   \   00000422   5941               ADCS     R1,R1,R3
   \   00000424   6246               MOV      R2,R12
   \   00000426   03C2               STM      R2!,{R0,R1}
   1451                      AT91C_BASE_PIOA->PIO_SODR =SpeakerPin;  
                                                        ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   00000428   4B48               LDR      R0,??Timer_1s_36+0x44  ;; 0xfffff430
   \   0000042A   8021               MOVS     R1,#+128
   \   0000042C   0906               LSLS     R1,R1,#+24       ;; #-2147483648
   \   0000042E   0160               STR      R1,[R0, #+0]
   1452                   }
   1453          
   1454                 } 
   \                     ??Timer_1s_57:
   \   00000430   1636               ADDS     R6,R6,#+22
   \   00000432   0A37               ADDS     R7,R7,#+10
   \   00000434   6D1E               SUBS     R5,R5,#+1
   \   00000436   C5D1               BNE      ??Timer_1s_56
   1455                
   1456             }    
   1457              
   1458          
   1459             
   1460             
   1461             //wygaszacz ekranu
   1462             static char LCD_last_fill=100;
   1463             char WypMin;
   1464             if ((!g_ScreenSever_On) || (g_ScreenSever_On && !((g_ScreenSever_Time_On<=DateTime.Hour) || (g_ScreenSever_Time_Off>DateTime.Hour))))  
   \                     ??Timer_1s_55:
   \   00000438   A07B               LDRB     R0,[R4, #+14]
   \   0000043A   0028               CMP      R0,#+0
   \   0000043C   06D0               BEQ      ??Timer_1s_59
   \   0000043E   E078               LDRB     R0,[R4, #+3]
   \   00000440   E17B               LDRB     R1,[R4, #+15]
   \   00000442   8842               CMP      R0,R1
   \   00000444   04D2               BCS      ??Timer_1s_60
   \   00000446   217C               LDRB     R1,[R4, #+16]
   \   00000448   8842               CMP      R0,R1
   \   0000044A   01D3               BCC      ??Timer_1s_60
   1465             {  
   1466                WypMin=WypMinJasnosci;   //wype³nienie bez wygaszacza
   \                     ??Timer_1s_59:
   \   0000044C   A07D               LDRB     R0,[R4, #+22]
   \   0000044E   00E0               B        ??Timer_1s_61
   1467             }else{
   1468                WypMin=4;    //wype³nienie przy wygaszaczu
   \                     ??Timer_1s_60:
   \   00000450   0420               MOVS     R0,#+4
   1469             }
   1470               if (gWypMinJasnosciTest)
   \                     ??Timer_1s_61:
   \   00000452   E17D               LDRB     R1,[R4, #+23]
   \   00000454   0029               CMP      R1,#+0
   \   00000456   06D0               BEQ      ??Timer_1s_62
   1471               {
   1472                  AT91C_BASE_PWMC->PWMC_DIS = 0x1;
   \   00000458   0127               MOVS     R7,#+1
   \   0000045A   4048               LDR      R0,??Timer_1s_36+0x48  ;; 0xfffcc008
   \   0000045C   0760               STR      R7,[R0, #+0]
   1473                  Set_LCD_Light_PWM_Fill(WypMinJasnosci); 
                         ^
Warning[Pe223]: function "Set_LCD_Light_PWM_Fill" declared implicitly
   \   0000045E   A07D               LDRB     R0,[R4, #+22]
   \   00000460   ........           BL       Set_LCD_Light_PWM_Fill
   1474                  AT91C_BASE_PWMC->PWMC_ENA = 0x1;
   \   00000464   20E0               B.N      ??Timer_1s_63
   1475               }
   1476               else if (g_LightLCDEnable==1)
   \                     ??Timer_1s_62:
   \   00000466   E17F               LDRB     R1,[R4, #+31]
   \   00000468   627B               LDRB     R2,[R4, #+13]
   \   0000046A   012A               CMP      R2,#+1
   \   0000046C   0CD1               BNE      ??Timer_1s_64
   1477               {
   1478                 if (LCD_last_fill!=WypMaxJasnosci)
   \   0000046E   607D               LDRB     R0,[R4, #+21]
   \   00000470   8142               CMP      R1,R0
   \   00000472   1BD0               BEQ      ??Timer_1s_65
   1479                 {
   1480                    AT91C_BASE_PWMC->PWMC_DIS = 0x1;
   \   00000474   0127               MOVS     R7,#+1
   \   00000476   3949               LDR      R1,??Timer_1s_36+0x48  ;; 0xfffcc008
   \   00000478   0F60               STR      R7,[R1, #+0]
   1481                    Set_LCD_Light_PWM_Fill(WypMaxJasnosci);  //maksymalne wype³nienie
                           ^
Warning[Pe223]: function "Set_LCD_Light_PWM_Fill" declared implicitly
   \   0000047A   ........           BL       Set_LCD_Light_PWM_Fill
   1482                    AT91C_BASE_PWMC->PWMC_ENA = 0x1;
   \   0000047E   3848               LDR      R0,??Timer_1s_36+0x4C  ;; 0xfffcc004
   \   00000480   0760               STR      R7,[R0, #+0]
   1483                    LCD_last_fill=WypMaxJasnosci;
   \   00000482   607D               LDRB     R0,[R4, #+21]
   \   00000484   E077               STRB     R0,[R4, #+31]
   \   00000486   11E0               B        ??Timer_1s_65
   1484                 }
   1485               }else {
   1486                 if (LCD_last_fill>WypMin)
   \                     ??Timer_1s_64:
   \   00000488   8842               CMP      R0,R1
   \   0000048A   0FD2               BCS      ??Timer_1s_65
   1487                 {
   1488                    if (LCD_last_fill>60) LCD_last_fill=61;
   \   0000048C   3D29               CMP      R1,#+61
   \   0000048E   01D3               BCC      ??Timer_1s_66
   \   00000490   3D20               MOVS     R0,#+61
   \   00000492   E077               STRB     R0,[R4, #+31]
   1489                    LCD_last_fill-=2;
   \                     ??Timer_1s_66:
   \   00000494   E07F               LDRB     R0,[R4, #+31]
   \   00000496   801E               SUBS     R0,R0,#+2
   \   00000498   E077               STRB     R0,[R4, #+31]
   1490                    AT91C_BASE_PWMC->PWMC_DIS = 0x1;
   \   0000049A   0127               MOVS     R7,#+1
   \   0000049C   2F49               LDR      R1,??Timer_1s_36+0x48  ;; 0xfffcc008
   \   0000049E   0F60               STR      R7,[R1, #+0]
   1491                    Set_LCD_Light_PWM_Fill(LCD_last_fill); 
                           ^
Warning[Pe223]: function "Set_LCD_Light_PWM_Fill" declared implicitly
   \   000004A0   0006               LSLS     R0,R0,#+24
   \   000004A2   000E               LSRS     R0,R0,#+24
   \   000004A4   ........           BL       Set_LCD_Light_PWM_Fill
   1492                    AT91C_BASE_PWMC->PWMC_ENA = 0x1;
   \                     ??Timer_1s_63:
   \   000004A8   2D48               LDR      R0,??Timer_1s_36+0x4C  ;; 0xfffcc004
   \   000004AA   0760               STR      R7,[R0, #+0]
   1493                 }
   1494              }
   1495              
   1496              
   1497              if ((RF_Status.RfFuse>0) && (RF_Status.RfFuse<100)) RF_Status.RfFuse++;
   \                     ??Timer_1s_65:
   \   000004AC   2D4A               LDR      R2,??Timer_1s_36+0x50  ;; RF_Status
   \   000004AE   507C               LDRB     R0,[R2, #+17]
   \   000004B0   0028               CMP      R0,#+0
   \   000004B2   03D0               BEQ      ??Timer_1s_67
   \   000004B4   6428               CMP      R0,#+100
   \   000004B6   01D2               BCS      ??Timer_1s_67
   \   000004B8   401C               ADDS     R0,R0,#+1
   \   000004BA   5074               STRB     R0,[R2, #+17]
   1498             
   1499             
   1500             
   1501             //bezpiecznik przed zablokowaniem siê DMA USARTA lub WiFi 
   1502             if (NET.WiFi.On)
   \                     ??Timer_1s_67:
   \   000004BC   2A48               LDR      R0,??Timer_1s_36+0x54  ;; NET + 80
   \   000004BE   0078               LDRB     R0,[R0, #+0]
   \   000004C0   0028               CMP      R0,#+0
   \   000004C2   04D1               BNE      ??Timer_1s_68
   1503             {
   1504               (FuseLastWiFiDataIn<g_counter-30000);   //zabezpieczenie przed blokad¹ DMA USART. FuseLastWiFiDataIn zawiera czas ostatniej odpowiedzi od usarta. Je¿eli WiFi jest w³¹czone a USART milczy od 30s to restartuj mikroprocesor
                      ^
Warning[Pe174]: expression has no effect
   1505             }else{
   1506                FuseLastWiFiDataIn=g_counter;
   \   000004C4   2000               MOVS     R0,R4
   \   000004C6   3030               ADDS     R0,R0,#+48
   \   000004C8   03C8               LDM      R0!,{R0,R1}
   \   000004CA   2064               STR      R0,[R4, #+64]
   \   000004CC   6164               STR      R1,[R4, #+68]
   1507             }
   1508             
   1509             
   1510             //wyczyszczenie po³¹czeñ mostowych z którymi nie mam kontaktu po up³yniêciu czasu MAX_TIME_TO_REM_BRIDGE_NO_CON
   1511              if (RF_Status.TimeToRemBridgeNoCom) 
   \                     ??Timer_1s_68:
   \   000004CE   907C               LDRB     R0,[R2, #+18]
   \   000004D0   0028               CMP      R0,#+0
   \   000004D2   1AD0               BEQ      ??Timer_1s_69
   1512              {
   1513                if (RF_Status.TimeToRemBridgeNoCom==1)
   \   000004D4   0128               CMP      R0,#+1
   \   000004D6   15D1               BNE      ??Timer_1s_70
   1514                {
   1515                          for (char ND=0; ND<NumberNeurons-1; ND++)
   \   000004D8   2448               LDR      R0,??Timer_1s_36+0x58  ;; TransQuality + 38
   \   000004DA   2549               LDR      R1,??Timer_1s_36+0x5C  ;; NeuronsList + 8
   \   000004DC   2223               MOVS     R3,#+34
   \   000004DE   EF24               MOVS     R4,#+239
   \   000004E0   0026               MOVS     R6,#+0
   1516                              {
   1517                                if ((NeuronsList[ND].Bridge) &&  (TransQuality.QuickMensur[ND]==0))
   \                     ??Timer_1s_71:
   \   000004E2   0D78               LDRB     R5,[R1, #+0]
   \   000004E4   ED06               LSLS     R5,R5,#+27
   \   000004E6   09D5               BPL      ??Timer_1s_72
   \   000004E8   0578               LDRB     R5,[R0, #+0]
   \   000004EA   002D               CMP      R5,#+0
   \   000004EC   06D1               BNE      ??Timer_1s_72
   1518                                {
   1519                                   NeuronsList[ND].NeuronType=0;
                                                                    ^
Warning[Pe188]: enumerated type mixed with another type
   \   000004EE   0D00               MOVS     R5,R1
   \   000004F0   083D               SUBS     R5,R5,#+8
   \   000004F2   2E70               STRB     R6,[R5, #+0]
   1520                                   NeuronsList[ND].NeuronID=0;
   \   000004F4   6E60               STR      R6,[R5, #+4]
   1521                                   NeuronsList[ND].Bridge=0;
   \   000004F6   0D78               LDRB     R5,[R1, #+0]
   \   000004F8   2540               ANDS     R5,R5,R4
   \   000004FA   0D70               STRB     R5,[R1, #+0]
   1522                                }
   1523                              }
   \                     ??Timer_1s_72:
   \   000004FC   0C31               ADDS     R1,R1,#+12
   \   000004FE   401C               ADDS     R0,R0,#+1
   \   00000500   5B1E               SUBS     R3,R3,#+1
   \   00000502   EED1               BNE      ??Timer_1s_71
   1524                }
   1525                RF_Status.TimeToRemBridgeNoCom--;
   \                     ??Timer_1s_70:
   \   00000504   907C               LDRB     R0,[R2, #+18]
   \   00000506   401E               SUBS     R0,R0,#+1
   \   00000508   9074               STRB     R0,[R2, #+18]
   1526              }
   1527          
   1528          }
   \                     ??Timer_1s_69:
   \   0000050A   0BB0               ADD      SP,SP,#+44
   \   0000050C   F0BC               POP      {R4-R7}
   \   0000050E   01BC               POP      {R0}
   \   00000510   0047               BX       R0               ;; return
   \   00000512   C046               Nop      
   \                     ??Timer_1s_36:
   \   00000514   ........           DC32     TransQuality + 1
   \   00000518   ........           DC32     TransQuality + 4
   \   0000051C   ........           DC32     TransQuality + 3
   \   00000520   ........           DC32     NeuronsList
   \   00000524   ........           DC32     MainStage + 182
   \   00000528   AA8AFFFF           DC32     0xffff8aaa
   \   0000052C   E8D71300           DC32     0x13d7e8
   \   00000530   417E0500           DC32     0x57e41
   \   00000534   81FC0A00           DC32     0xafc81
   \   00000538   ........           DC32     gProg + 49434
   \   0000053C   ........           DC32     MainStage + 160
   \   00000540   AA8A0000           DC32     0x8aaa
   \   00000544   ........           DC32     `?<Constant "Wyladowana">` + 20
   \   00000548   20202000           DC8      "   "
   \   0000054C   ........           DC32     `?<Constant "Wyladowana">` + 12
   \   00000550   ........           DC32     `?<Constant "Wyladowana">`
   \   00000554   ........           DC32     ButtonBipCounter
   \   00000558   30F4FFFF           DC32     0xfffff430
   \   0000055C   08C0FCFF           DC32     0xfffcc008
   \   00000560   04C0FCFF           DC32     0xfffcc004
   \   00000564   ........           DC32     RF_Status
   \   00000568   ........           DC32     NET + 80
   \   0000056C   ........           DC32     TransQuality + 38
   \   00000570   ........           DC32     NeuronsList + 8
   1529          
   1530          
   1531          
   1532          
   1533          //-----------------------------------------------------------------------------
   1534          //! Nazwa funkcji :    Timer_10ms
   1535          //! Okres: 10ms
   1536          //! Timer zale¿ny od Timer_1ms
   1537          //-----------------------------------------------------------------------------
   1538          //  
   1539          //----------------------------------------------------------------------------- 

   \                                 In section Debug.txt, align 4, keep-with-next
   1540          void Timer_10ms(void)                      
   1541          { 
   \                     Timer_10ms:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   1542            unsigned int dummy = AT91C_BASE_TC0->TC_SR;                                   // Odczyt statusu  
   \   00000002   3848               LDR      R0,??Timer_10ms_0  ;; 0xfffa0020
   \   00000004   0068               LDR      R0,[R0, #+0]
   1543          
   1544           X_up=-1;
   \   00000006   384C               LDR      R4,??Timer_10ms_0+0x4  ;; DateTime
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   C043               MVNS     R0,R0            ;; #-1
   \   0000000C   E085               STRH     R0,[R4, #+46]
   1545           Y_up=-1;
   \   0000000E   A085               STRH     R0,[R4, #+44]
   1546          
   1547           X_down=-1;
   \   00000010   6085               STRH     R0,[R4, #+42]
   1548           Y_down=-1;
   \   00000012   2085               STRH     R0,[R4, #+40]
   1549          
   1550          
   1551            GetTouchPoint(&X_down, &Y_down, &X_up, &Y_up);
   \   00000014   2300               MOVS     R3,R4
   \   00000016   2C33               ADDS     R3,R3,#+44
   \   00000018   2200               MOVS     R2,R4
   \   0000001A   2E32               ADDS     R2,R2,#+46
   \   0000001C   2100               MOVS     R1,R4
   \   0000001E   2831               ADDS     R1,R1,#+40
   \   00000020   2000               MOVS     R0,R4
   \   00000022   2A30               ADDS     R0,R0,#+42
   \   00000024   ........           BL       GetTouchPoint
   1552          
   1553           
   1554             //Akcja przycisku up
   1555            if ((X_up>0)&&(Y_up>0)) 
   \   00000028   2E20               MOVS     R0,#+46
   \   0000002A   205E               LDRSH    R0,[R4, R0]
   \   0000002C   0128               CMP      R0,#+1
   \   0000002E   0CDB               BLT      ??Timer_10ms_1
   \   00000030   2C20               MOVS     R0,#+44
   \   00000032   205E               LDRSH    R0,[R4, R0]
   \   00000034   0128               CMP      R0,#+1
   \   00000036   08DB               BLT      ??Timer_10ms_1
   1556            {
   1557               ScreenEvent();
   \   00000038   ........           BL       ScreenEvent
   1558               g_LightCouterLCD = 0;     //W³¹cza podœwietlenie wyœwietlacza LCD
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   2065               STR      R0,[R4, #+80]
   1559               if (g_LightLCDEnable==0) g_LightLCDEnable=1;
   \   00000040   607B               LDRB     R0,[R4, #+13]
   \   00000042   0028               CMP      R0,#+0
   \   00000044   01D1               BNE      ??Timer_10ms_1
   \   00000046   0120               MOVS     R0,#+1
   \   00000048   6073               STRB     R0,[R4, #+13]
   1560            }
   1561            
   1562            if (LiczOds>=5) {
   \                     ??Timer_10ms_1:
   \   0000004A   606E               LDR      R0,[R4, #+100]
   \   0000004C   0528               CMP      R0,#+5
   \   0000004E   15DB               BLT      ??Timer_10ms_2
   1563            
   1564                      //Akcja przycisku down
   1565                if ((X_down>0)&&(Y_down>0) /*&& (g_LightLCDEnable==0)*/) 
   \   00000050   2A20               MOVS     R0,#+42
   \   00000052   205E               LDRSH    R0,[R4, R0]
   \   00000054   0128               CMP      R0,#+1
   \   00000056   09DB               BLT      ??Timer_10ms_3
   \   00000058   2820               MOVS     R0,#+40
   \   0000005A   205E               LDRSH    R0,[R4, R0]
   \   0000005C   0128               CMP      R0,#+1
   \   0000005E   05DB               BLT      ??Timer_10ms_3
   1566                {
   1567                   ScreenEvent();
   \   00000060   ........           BL       ScreenEvent
   1568                   g_LightCouterLCD = 0;     //W³¹cza podœwietlenie wyœwietlacza LCD
   \   00000064   0020               MOVS     R0,#+0
   \   00000066   2065               STR      R0,[R4, #+80]
   1569                   g_LightLCDEnable=1;
   \   00000068   0120               MOVS     R0,#+1
   \   0000006A   6073               STRB     R0,[R4, #+13]
   1570                }  
   1571                
   1572                MenuRefresh(); 
   \                     ??Timer_10ms_3:
   \   0000006C   ........           BL       MenuRefresh
   1573          
   1574              
   1575          
   1576              
   1577              RepaintLCD();
   \   00000070   ........           BL       RepaintLCD
   1578              RepaintLCD();
   \   00000074   ........           BL       RepaintLCD
   1579          
   1580              
   1581              LiczOds=0;
   \   00000078   0020               MOVS     R0,#+0
   \   0000007A   00E0               B.N      ??Timer_10ms_4
   1582          
   1583            }
   1584            
   1585            else 
   1586            {
   1587              LiczOds++; 
   \                     ??Timer_10ms_2:
   \   0000007C   401C               ADDS     R0,R0,#+1
   \                     ??Timer_10ms_4:
   \   0000007E   6066               STR      R0,[R4, #+100]
   1588            }
   1589            
   1590              
   1591            
   1592            static int Spek2_Counter;
   1593            if (Spek2_Counter<202)Spek2_Counter++;
   \   00000080   A26F               LDR      R2,[R4, #+120]
   \   00000082   CA2A               CMP      R2,#+202
   \   00000084   00DA               BGE      ??Timer_10ms_5
   \   00000086   521C               ADDS     R2,R2,#+1
   1594            if ((Speaker[2]==1) && (Spek2_Counter>150)) 
   \                     ??Timer_10ms_5:
   \   00000088   A07A               LDRB     R0,[R4, #+10]
   \   0000008A   0128               CMP      R0,#+1
   \   0000008C   0ED1               BNE      ??Timer_10ms_6
   \   0000008E   972A               CMP      R2,#+151
   \   00000090   0CDB               BLT      ??Timer_10ms_6
   1595            {
   1596                Spek2_Counter=0;
   \   00000092   0022               MOVS     R2,#+0
   1597                ButtonBipCounter=g_counter+150;
   \   00000094   154B               LDR      R3,??Timer_10ms_0+0x8  ;; ButtonBipCounter
   \   00000096   2000               MOVS     R0,R4
   \   00000098   3030               ADDS     R0,R0,#+48
   \   0000009A   03C8               LDM      R0!,{R0,R1}
   \   0000009C   0025               MOVS     R5,#+0
   \   0000009E   9630               ADDS     R0,R0,#+150
   \   000000A0   6941               ADCS     R1,R1,R5
   \   000000A2   03C3               STM      R3!,{R0,R1}
   1598                AT91C_BASE_PIOA->PIO_SODR =SpeakerPin; 
                                                  ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   000000A4   1248               LDR      R0,??Timer_10ms_0+0xC  ;; 0xfffff430
   \   000000A6   8021               MOVS     R1,#+128
   \   000000A8   0906               LSLS     R1,R1,#+24       ;; #-2147483648
   \   000000AA   0160               STR      R1,[R0, #+0]
   1599            }
   1600          
   1601            if ((Speaker[3]==1) && (Spek2_Counter==150)) 
   \                     ??Timer_10ms_6:
   \   000000AC   E07A               LDRB     R0,[R4, #+11]
   \   000000AE   0128               CMP      R0,#+1
   \   000000B0   10D1               BNE      ??Timer_10ms_7
   \   000000B2   962A               CMP      R2,#+150
   \   000000B4   02D0               BEQ      ??Timer_10ms_8
   1602            {
   1603                ButtonBipCounter=g_counter+100;
   \                     ??Timer_10ms_9:
   \   000000B6   C92A               CMP      R2,#+201
   \   000000B8   0CDB               BLT      ??Timer_10ms_7
   1604                AT91C_BASE_PIOA->PIO_SODR =SpeakerPin; 
                                                  ^
Warning[Pe068]: integer conversion resulted in a change of sign
   1605            }  
   1606            if ((Speaker[3]==1) && (Spek2_Counter>200)) 
   1607            {
   1608                Spek2_Counter=0;
   \   000000BA   0022               MOVS     R2,#+0
   1609                ButtonBipCounter=g_counter+100;
   \                     ??Timer_10ms_8:
   \   000000BC   0B4B               LDR      R3,??Timer_10ms_0+0x8  ;; ButtonBipCounter
   \   000000BE   2000               MOVS     R0,R4
   \   000000C0   3030               ADDS     R0,R0,#+48
   \   000000C2   03C8               LDM      R0!,{R0,R1}
   \   000000C4   0025               MOVS     R5,#+0
   \   000000C6   6430               ADDS     R0,R0,#+100
   \   000000C8   6941               ADCS     R1,R1,R5
   \   000000CA   03C3               STM      R3!,{R0,R1}
   1610                AT91C_BASE_PIOA->PIO_SODR =SpeakerPin; 
                                                  ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   000000CC   0848               LDR      R0,??Timer_10ms_0+0xC  ;; 0xfffff430
   \   000000CE   8021               MOVS     R1,#+128
   \   000000D0   0906               LSLS     R1,R1,#+24       ;; #-2147483648
   \   000000D2   0160               STR      R1,[R0, #+0]
   \                     ??Timer_10ms_7:
   \   000000D4   A267               STR      R2,[R4, #+120]
   1611            }    
   1612          
   1613           AT91F_WDTRestart(AT91C_BASE_WDTC);
   \   000000D6   0748               LDR      R0,??Timer_10ms_0+0x10  ;; 0xfffffd40
   \   000000D8   0749               LDR      R1,??Timer_10ms_0+0x14  ;; 0xa5000001
   \   000000DA   0160               STR      R1,[R0, #+0]
   1614          
   1615          }
   \   000000DC   38BC               POP      {R3-R5}
   \   000000DE   01BC               POP      {R0}
   \   000000E0   0047               BX       R0               ;; return
   \   000000E2   C046               Nop      
   \                     ??Timer_10ms_0:
   \   000000E4   2000FAFF           DC32     0xfffa0020
   \   000000E8   ........           DC32     DateTime
   \   000000EC   ........           DC32     ButtonBipCounter
   \   000000F0   30F4FFFF           DC32     0xfffff430
   \   000000F4   40FDFFFF           DC32     0xfffffd40
   \   000000F8   010000A5           DC32     0xa5000001
   1616          
   1617          
   1618          
   1619          

   \                                 In section Debug.txt, align 4, keep-with-next
   1620          void Timer_10ms_Setup(void) 
   1621          { 
   1622          
   1623          
   1624           AT91C_BASE_AIC->AIC_SVR[AT91C_ID_TC0] = (unsigned int)Timer_10ms;  //set AIC             
   \                     Timer_10ms_Setup:
   \   00000000   0F48               LDR      R0,??Timer_10ms_Setup_0  ;; 0xfffff0b0
   \   00000002   1049               LDR      R1,??Timer_10ms_Setup_0+0x4  ;; Timer_10ms
   \   00000004   0160               STR      R1,[R0, #+0]
   1625           AT91C_BASE_AIC->AIC_SMR[AT91C_ID_TC0] = (AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL | TIMER_10mS_PRIOR ); 
   \   00000006   1048               LDR      R0,??Timer_10ms_Setup_0+0x8  ;; 0xfffff030
   \   00000008   0321               MOVS     R1,#+3
   \   0000000A   0160               STR      R1,[R0, #+0]
   1626           AT91C_BASE_PMC->PMC_PCER = (1<<AT91C_ID_TC0);      //enable clock 
   \   0000000C   8020               MOVS     R0,#+128
   \   0000000E   4001               LSLS     R0,R0,#+5        ;; #+4096
   \   00000010   0E49               LDR      R1,??Timer_10ms_Setup_0+0xC  ;; 0xfffffc10
   \   00000012   0860               STR      R0,[R1, #+0]
   1627           AT91C_BASE_TCB->TCB_BCR = 0;                  //no SYNC trigger 
   \   00000014   0E49               LDR      R1,??Timer_10ms_Setup_0+0x10  ;; 0xfffa00c0
   \   00000016   0022               MOVS     R2,#+0
   \   00000018   0A60               STR      R2,[R1, #+0]
   1628           //no external clocks 
   1629           AT91C_BASE_TCB->TCB_BMR = AT91C_TCB_TC0XC0S_NONE | AT91C_TCB_TC1XC1S_NONE | AT91C_TCB_TC2XC2S_NONE; 
   \   0000001A   0E49               LDR      R1,??Timer_10ms_Setup_0+0x14  ;; 0xfffa00c4
   \   0000001C   1522               MOVS     R2,#+21
   \   0000001E   0A60               STR      R2,[R1, #+0]
   1630           AT91C_BASE_TC0->TC_CCR = AT91C_TC_SWTRG | AT91C_TC_CLKEN;                   //enable and start clock 
   \   00000020   0D49               LDR      R1,??Timer_10ms_Setup_0+0x18  ;; 0xfffa0000
   \   00000022   0522               MOVS     R2,#+5
   \   00000024   0A60               STR      R2,[R1, #+0]
   1631           AT91C_BASE_TC0->TC_CMR = AT91C_TC_ACPC_TOGGLE | AT91C_TC_WAVE  | AT91C_TC_WAVESEL_UP_AUTO  | AT91C_TC_CLKS_TIMER_DIV5_CLOCK;//CPC 
   \   00000026   0D49               LDR      R1,??Timer_10ms_Setup_0+0x1C  ;; 0xfffa0004
   \   00000028   0D4A               LDR      R2,??Timer_10ms_Setup_0+0x20  ;; 0xcc004
   \   0000002A   0A60               STR      R2,[R1, #+0]
   1632            //! DIV5 - 1024
   1633           //! DIV4 - 128
   1634           //! DIV3 - 32
   1635           //! DIV2 - 8
   1636           //clock: MCK/1024  = 48054841/1024  =  46928 Hz 
   1637           //AT91C_BASE_TC0->TC_RC = 46928,55;    => 1 sec 
   1638                                   
   1639           AT91C_BASE_TC0->TC_RC = 469;                  //10ms 
   \   0000002C   0D49               LDR      R1,??Timer_10ms_Setup_0+0x24  ;; 0xfffa001c
   \   0000002E   FF22               MOVS     R2,#+255
   \   00000030   D632               ADDS     R2,R2,#+214      ;; #+469
   \   00000032   0A60               STR      R2,[R1, #+0]
   1640           AT91C_BASE_TC0->TC_IER = AT91C_TC_CPCS;         //enable RC compare int 
   \   00000034   0C49               LDR      R1,??Timer_10ms_Setup_0+0x28  ;; 0xfffa0024
   \   00000036   1022               MOVS     R2,#+16
   \   00000038   0A60               STR      R2,[R1, #+0]
   1641           AT91C_BASE_TC0->TC_IDR = ~AT91C_TC_CPCS;         //disable other 
   \   0000003A   0C49               LDR      R1,??Timer_10ms_Setup_0+0x2C  ;; 0xfffa0028
   \   0000003C   ....               B.N      ?Subroutine0
   \   0000003E   C046               Nop      
   \                     ??Timer_10ms_Setup_0:
   \   00000040   B0F0FFFF           DC32     0xfffff0b0
   \   00000044   ........           DC32     Timer_10ms
   \   00000048   30F0FFFF           DC32     0xfffff030
   \   0000004C   10FCFFFF           DC32     0xfffffc10
   \   00000050   C000FAFF           DC32     0xfffa00c0
   \   00000054   C400FAFF           DC32     0xfffa00c4
   \   00000058   0000FAFF           DC32     0xfffa0000
   \   0000005C   0400FAFF           DC32     0xfffa0004
   \   00000060   04C00C00           DC32     0xcc004
   \   00000064   1C00FAFF           DC32     0xfffa001c
   \   00000068   2400FAFF           DC32     0xfffa0024
   \   0000006C   2800FAFF           DC32     0xfffa0028
   1642           AT91C_BASE_AIC->AIC_IECR = (1<<AT91C_ID_TC0);       //enable int 
   1643           AT91C_BASE_AIC->AIC_ICCR = (1<<AT91C_ID_TC0);       //clear int 
   1644            
   1645          
   1646          }//_____________________________________________________________________________

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ?Subroutine0:
   \   00000000   D243               MVNS     R2,R2            ;; #-17
   \   00000002   0A60               STR      R2,[R1, #+0]
   \   00000004   ....               LDR      R1,??DataTable33  ;; 0xfffff120
   \   00000006   0860               STR      R0,[R1, #+0]
   \   00000008   ....               LDR      R1,??DataTable34  ;; 0xfffff128
   \   0000000A   0860               STR      R0,[R1, #+0]
   \   0000000C   7047               BX       LR               ;; return
   \   0000000E   C046               Nop      
   \                     ??Subroutine0_0:
   \   00000010   B8F0FFFF           DC32     0xfffff0b8
   \   00000014   ........           DC32     Timer_1ms
   \   00000018   38F0FFFF           DC32     0xfffff038
   \   0000001C   8000FAFF           DC32     0xfffa0080
   \   00000020   8400FAFF           DC32     0xfffa0084
   \   00000024   9C00FAFF           DC32     0xfffa009c
   \   00000028   77170000           DC32     0x1777
   \   0000002C   A400FAFF           DC32     0xfffa00a4
   \   00000030   A800FAFF           DC32     0xfffa00a8
   1647          
   1648          
   1649          
   1650          
   1651          
   1652          //-----------------------------------------------------------------------------
   1653          //! Nazwa funkcji :    Timer_1ms
   1654          //! Okres: 1ms
   1655          //! Funkcje:
   1656          //!         Funkcja obs³ugi przerwania USART 0  Czas 1 ms
   1657          //!         Triger Timer_10ms 
   1658          //-----------------------------------------------------------------------------
   1659          //  
   1660          //----------------------------------------------------------------------------- 
   1661          
   1662          

   \                                 In section .bss, align 4
   1663          int Counter=0;
   \                     Counter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   1664          int US0_Counter=0;
   \                     US0_Counter:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
   1665          int US1_Counter=0;
   \                     US1_Counter:
   \   00000000                      DS8 4
   1666          extern char SendModbusEnable;

   \                                 In section .bss, align 1
   1667          char CounterForTimer10ms=0;
   \                     CounterForTimer10ms:
   \   00000000                      DS8 1
   1668          short int CurTimeQual=0;
   1669          

   \                                 In section Debug.txt, align 4, keep-with-next
   1670          void Timer_1ms(void)                        //timer isr 
   1671          { 
   \                     Timer_1ms:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   1672            unsigned int dummy2 = AT91C_BASE_TC2->TC_SR;  
   \   00000002   7848               LDR      R0,??Timer_1ms_0  ;; 0xfffa00a0
   \   00000004   0068               LDR      R0,[R0, #+0]
   1673            
   1674            g_counter++;
   \   00000006   784D               LDR      R5,??Timer_1ms_0+0x4  ;; DateTime
   \   00000008   2800               MOVS     R0,R5
   \   0000000A   3030               ADDS     R0,R0,#+48
   \   0000000C   03C8               LDM      R0!,{R0,R1}
   \   0000000E   0022               MOVS     R2,#+0
   \   00000010   401C               ADDS     R0,R0,#+1
   \   00000012   5141               ADCS     R1,R1,R2
   \   00000014   2A00               MOVS     R2,R5
   \   00000016   3032               ADDS     R2,R2,#+48
   \   00000018   03C2               STM      R2!,{R0,R1}
   1675          
   1676            
   1677          
   1678            
   1679            
   1680            /*
   1681            
   1682          
   1683          
   1684            
   1685            //obs³uga US0
   1686            if (US0_MasterMODBUS_ENABLE)
   1687            {
   1688            if (US0_Counter>g_US0_Comm_MinCykle) 
   1689            {
   1690              
   1691                if (g_Ans_ZD_MODBUS_0 == g_US0_Comm_TIMEOUT)
   1692                {
   1693                    ZD_MODBUS_0[g_Current_ZD_MODBUS_0].Error ++;
   1694                }
   1695              
   1696                
   1697                if (g_Ans_ZD_MODBUS_0 >= g_US0_Comm_TIMEOUT)
   1698                {
   1699          
   1700                    //AT91C_BASE_PIOA->PIO_SODR = AT91C_PIO_PA4; AT91C_BASE_PIOA->PIO_CODR = AT91C_PIO_PA4;
   1701             
   1702                    g_Ans_ZD_MODBUS_0=0;
   1703                    SendModbusEnable=0;
   1704                  //  ModBus_MASTER_TX(0);
   1705                    
   1706                    US0_Counter=0;
   1707                }
   1708                else
   1709                {
   1710                    g_Ans_ZD_MODBUS_0++;
   1711          
   1712                }
   1713              
   1714            }
   1715            else
   1716            {
   1717              US0_Counter++; 
   1718            }
   1719            }
   1720            
   1721          
   1722          
   1723            if (US1_MasterMODBUS_ENABLE)
   1724            {
   1725            if (US1_Counter>g_US0_Comm_MinCykle) 
   1726            {
   1727              
   1728                if (g_Ans_ZD_MODBUS_1 == g_US1_Comm_TIMEOUT)
   1729                {
   1730                    ZD_MODBUS_1[g_Current_ZD_MODBUS_1].Error ++;
   1731                }
   1732                
   1733                if (g_Ans_ZD_MODBUS_1 >= g_US1_Comm_TIMEOUT)
   1734                {
   1735             
   1736                    g_Ans_ZD_MODBUS_1=0;
   1737                    ModBus_MASTER_TX(1);
   1738                    
   1739                    US0_Counter=1;
   1740                }
   1741                else
   1742                {
   1743                    g_Ans_ZD_MODBUS_1++;
   1744          
   1745                }
   1746              
   1747            }
   1748            else
   1749            {
   1750              US1_Counter++; 
   1751            }
   1752            }
   1753          */
   1754            
   1755            
   1756          
   1757          if (ButtonBipCounter<g_counter) AT91C_BASE_PIOA->PIO_CODR =SpeakerPin;
                                                                            ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   0000001A   744A               LDR      R2,??Timer_1ms_0+0x8  ;; ButtonBipCounter
   \   0000001C   0CCA               LDM      R2!,{R2,R3}
   \   0000001E   8B42               CMP      R3,R1
   \   00000020   06D8               BHI      ??Timer_1ms_1
   \   00000022   01D3               BCC      ??Timer_1ms_2
   \   00000024   8242               CMP      R2,R0
   \   00000026   03D2               BCS      ??Timer_1ms_1
   \                     ??Timer_1ms_2:
   \   00000028   7148               LDR      R0,??Timer_1ms_0+0xC  ;; 0xfffff434
   \   0000002A   8021               MOVS     R1,#+128
   \   0000002C   0906               LSLS     R1,R1,#+24       ;; #-2147483648
   \   0000002E   0160               STR      R1,[R0, #+0]
   1758          
   1759            
   1760            
   1761            static int RF_SlaveCounter;
   1762          
   1763            
   1764            
   1765          //TimeOut RF -----
   1766           
   1767            
   1768          if (RF_Status.AllReady)
   \                     ??Timer_1ms_1:
   \   00000030   704C               LDR      R4,??Timer_1ms_0+0x10  ;; RF_Status
   \   00000032   207C               LDRB     R0,[R4, #+16]
   \   00000034   0028               CMP      R0,#+0
   \   00000036   00D1               BNE      .+4
   \   00000038   93E0               B        ??Timer_1ms_3
   1769          {
   1770            
   1771            //Prze³¹czanie w tryb Master + zabezpieczenie przed utkniêciem w trybie slave na d³u¿ej ni¿ 400ms;
   1772            if (SlaveMode)                                        
   \   0000003A   687E               LDRB     R0,[R5, #+25]
   \   0000003C   0028               CMP      R0,#+0
   \   0000003E   1DD0               BEQ      ??Timer_1ms_4
   1773            {
   1774              if (RF_Status.SlaveModeTimeout>0) RF_Status.SlaveModeTimeout--;
   \   00000040   E07C               LDRB     R0,[R4, #+19]
   \   00000042   0028               CMP      R0,#+0
   \   00000044   01D0               BEQ      ??Timer_1ms_5
   \   00000046   401E               SUBS     R0,R0,#+1
   \   00000048   E074               STRB     R0,[R4, #+19]
   1775              if (RF_Status.TimeInSlaveMode<MAX_TIME_FOR_SLAVE_ASK+100) {RF_Status.TimeInSlaveMode++;}else {RF_Status.SlaveModeTimeout=0;}
   \                     ??Timer_1ms_5:
   \   0000004A   E08A               LDRH     R0,[R4, #+22]
   \   0000004C   E121               MOVS     R1,#+225
   \   0000004E   4900               LSLS     R1,R1,#+1        ;; #+450
   \   00000050   8842               CMP      R0,R1
   \   00000052   0ED2               BCS      ??Timer_1ms_6
   \   00000054   401C               ADDS     R0,R0,#+1
   \   00000056   E082               STRH     R0,[R4, #+22]
   1776              if (RF_Status.SlaveModeTimeout==0) 
   \   00000058   E07C               LDRB     R0,[R4, #+19]
   \   0000005A   0028               CMP      R0,#+0
   \   0000005C   0BD0               BEQ      ??Timer_1ms_7
   1777              {
   1778                SwitchToMaster();
   1779              }else{
   1780                if ((RF_Status.EnRx==0) && (RF_Status.InitRx==0))
   \   0000005E   6078               LDRB     R0,[R4, #+1]
   \   00000060   0028               CMP      R0,#+0
   \   00000062   10D1               BNE      ??Timer_1ms_8
   \   00000064   2079               LDRB     R0,[R4, #+4]
   \   00000066   0028               CMP      R0,#+0
   \   00000068   0DD1               BNE      ??Timer_1ms_8
   1781                {
   1782                  RF_Status.EnableRX();
   \   0000006A   A06A               LDR      R0,[R4, #+40]
   \   0000006C   ........           BL       __iar_via_R0
   \   00000070   09E0               B        ??Timer_1ms_8
   1783                }
   1784              }
   \                     ??Timer_1ms_6:
   \   00000072   0020               MOVS     R0,#+0
   \   00000074   E074               STRB     R0,[R4, #+19]
   \                     ??Timer_1ms_7:
   \   00000076   ........           BL       SwitchToMaster
   \   0000007A   04E0               B        ??Timer_1ms_8
   1785            }else{
   1786              if (RF_Status.TimeInMasterMode<0xFF) RF_Status.TimeInMasterMode++;
   \                     ??Timer_1ms_4:
   \   0000007C   A08A               LDRH     R0,[R4, #+20]
   \   0000007E   FF28               CMP      R0,#+255
   \   00000080   01D2               BCS      ??Timer_1ms_8
   \   00000082   401C               ADDS     R0,R0,#+1
   \   00000084   A082               STRH     R0,[R4, #+20]
   1787              
   1788            }
   1789                   
   1790            
   1791            static char PraboblySlaveConstChanel=0xFF;   //prawdopodobny kana³ slave (by³a wczeœniej na nim komunikacja) 0xff - brak kana³u
   1792            
   1793            if (RF_Status.MasterMode)
   \                     ??Timer_1ms_8:
   \   00000086   607B               LDRB     R0,[R4, #+13]
   \   00000088   0028               CMP      R0,#+0
   \   0000008A   0FD0               BEQ      ??Timer_1ms_9
   1794            {
   1795              if ((!SlaveMode) && (g_Stop_Program==0))
   \   0000008C   687E               LDRB     R0,[R5, #+25]
   \   0000008E   697C               LDRB     R1,[R5, #+17]
   \   00000090   0143               ORRS     R1,R1,R0
   \   00000092   66D1               BNE      ??Timer_1ms_3
   1796              if (g_RF_TimeOutCounter>0)
   \   00000094   5848               LDR      R0,??Timer_1ms_0+0x14  ;; g_RF_TimeOutCounter
   \   00000096   0178               LDRB     R1,[R0, #+0]
   \   00000098   0029               CMP      R1,#+0
   \   0000009A   02D0               BEQ      ??Timer_1ms_10
   1797              {
   1798                g_RF_TimeOutCounter--;
   \   0000009C   491E               SUBS     R1,R1,#+1
   \   0000009E   0170               STRB     R1,[R0, #+0]
   \   000000A0   5FE0               B        ??Timer_1ms_3
   1799          
   1800           
   1801              }else{
   1802                 g_RF_TimeOutCounter=RF_TimeOut; 
   \                     ??Timer_1ms_10:
   \   000000A2   0921               MOVS     R1,#+9
   \   000000A4   0170               STRB     R1,[R0, #+0]
   1803                 RF_MasterExecut();
   \   000000A6   ........           BL       RF_MasterExecut
   \   000000AA   5AE0               B        ??Timer_1ms_3
   1804              }
   1805            }else{
   1806                  
   1807                  RF_SlaveCounter++;
   \                     ??Timer_1ms_9:
   \   000000AC   534E               LDR      R6,??Timer_1ms_0+0x18  ;; g_SlaveConnect
   \   000000AE   B068               LDR      R0,[R6, #+8]
   \   000000B0   401C               ADDS     R0,R0,#+1
   \   000000B2   B060               STR      R0,[R6, #+8]
   1808               
   1809                  
   1810                    if (RF_Status.ConfResiveSlave==2) //je¿eli poprawnie odebrano dane 
   \   000000B4   217B               LDRB     R1,[R4, #+12]
   \   000000B6   0229               CMP      R1,#+2
   \   000000B8   07D1               BNE      ??Timer_1ms_11
   1811                    {
   1812                      PraboblySlaveConstChanel=RF_Status.ChSlave;
   \   000000BA   E07B               LDRB     R0,[R4, #+15]
   \   000000BC   7070               STRB     R0,[R6, #+1]
   1813                      RF_SlaveCounter=0;   //- zeruj licznik
   \   000000BE   0020               MOVS     R0,#+0
   \   000000C0   B060               STR      R0,[R6, #+8]
   1814                      RF_Status.ConfResiveSlave=1;
   \   000000C2   0120               MOVS     R0,#+1
   \   000000C4   2073               STRB     R0,[R4, #+12]
   1815                      g_SlaveConnect=1;    //ustawia flagê poprawnej transmisji slave
   \   000000C6   3070               STRB     R0,[R6, #+0]
   \   000000C8   4BE0               B        ??Timer_1ms_3
   1816                    }else{
   1817            
   1818                      short LongWait=1000;
   \                     ??Timer_1ms_11:
   \   000000CA   FA22               MOVS     R2,#+250
   \   000000CC   9200               LSLS     R2,R2,#+2        ;; #+1000
   1819                      if (PraboblySlaveConstChanel==RF_Status.ChSlave) LongWait=10000;
   \   000000CE   7378               LDRB     R3,[R6, #+1]
   \   000000D0   E57B               LDRB     R5,[R4, #+15]
   \   000000D2   AB42               CMP      R3,R5
   \   000000D4   00D1               BNE      ??Timer_1ms_12
   \   000000D6   4A4A               LDR      R2,??Timer_1ms_0+0x1C  ;; 0x2710
   1820                      
   1821                      if (((RF_SlaveCounter==100)  && (RF_Status.ConfResiveSlave==0)) //je¿eli nie odebrano danych w czasie 100ms
   1822                      || ((RF_SlaveCounter>=LongWait) && (RF_Status.ConfResiveSlave<2))  //je¿eli nie odebrano danych o w³aœciwym ID w czasie 1000ms
   1823                        )
   \                     ??Timer_1ms_12:
   \   000000D8   6428               CMP      R0,#+100
   \   000000DA   01D1               BNE      ??Timer_1ms_13
   \   000000DC   0029               CMP      R1,#+0
   \   000000DE   03D0               BEQ      ??Timer_1ms_14
   \                     ??Timer_1ms_13:
   \   000000E0   9042               CMP      R0,R2
   \   000000E2   3EDB               BLT      ??Timer_1ms_3
   \   000000E4   0229               CMP      R1,#+2
   \   000000E6   3CD2               BCS      ??Timer_1ms_3
   1824                      {
   1825          
   1826                           SPI_SendWord(0x8219,Cs_RF); 
                                  ^
Warning[Pe223]: function "SPI_SendWord" declared implicitly
   \                     ??Timer_1ms_14:
   \   000000E8   0221               MOVS     R1,#+2
   \   000000EA   4648               LDR      R0,??Timer_1ms_0+0x20  ;; 0x8219
   \   000000EC   ........           BL       SPI_SendWord
   1827                           RF_SlaveCounter=0;   //- zeruj licznik
   \   000000F0   0025               MOVS     R5,#+0
   \   000000F2   B560               STR      R5,[R6, #+8]
   1828                           RF_Status.ConfResiveSlave=0;
   \   000000F4   2573               STRB     R5,[R4, #+12]
   1829                           g_SlaveConnect=0; 
   \   000000F6   3570               STRB     R5,[R6, #+0]
   1830                           
   1831                           if (RF_Status.AllReady) if (RF_Status.ChSlave<RF_ChannelQuanti-1) {RF_Status.ChSlave++;} else {RF_Status.ChSlave=0;}
   \   000000F8   E07B               LDRB     R0,[R4, #+15]
   \   000000FA   217C               LDRB     R1,[R4, #+16]
   \   000000FC   0029               CMP      R1,#+0
   \   000000FE   04D0               BEQ      ??Timer_1ms_15
   \   00000100   2728               CMP      R0,#+39
   \   00000102   01D2               BCS      ??Timer_1ms_16
   \   00000104   401C               ADDS     R0,R0,#+1
   \   00000106   00E0               B        ??Timer_1ms_15
   \                     ??Timer_1ms_16:
   \   00000108   0020               MOVS     R0,#+0
   \                     ??Timer_1ms_15:
   \   0000010A   E073               STRB     R0,[R4, #+15]
   1832                           SPI_SendWord(0xA000 | RF_SetFreqReg(RF_Status.ChSlave),Cs_RF);  
   \   0000010C   0006               LSLS     R0,R0,#+24
   \   0000010E   000E               LSRS     R0,R0,#+24
   \   00000110   ........           BL       __aeabi_ui2d
   \   00000114   0200               MOVS     R2,R0
   \   00000116   0B00               MOVS     R3,R1
   \   00000118   3B48               LDR      R0,??Timer_1ms_0+0x24  ;; 0x33333333
   \   0000011A   3C49               LDR      R1,??Timer_1ms_0+0x28  ;; 0x3fd33333
   \   0000011C   ........           BL       __aeabi_dmul
   \   00000120   0200               MOVS     R2,R0
   \   00000122   0B00               MOVS     R3,R1
   \   00000124   3A48               LDR      R0,??Timer_1ms_0+0x2C  ;; 0x5c28f5c3
   \   00000126   3B49               LDR      R1,??Timer_1ms_0+0x30  ;; 0x408ae28f
   \   00000128   ........           BL       __aeabi_dadd
   \   0000012C   0200               MOVS     R2,R0
   \   0000012E   0B00               MOVS     R3,R1
   \   00000130   0020               MOVS     R0,#+0
   \   00000132   3949               LDR      R1,??Timer_1ms_0+0x34  ;; 0x40690000
   \   00000134   ........           BL       __aeabi_dmul
   \   00000138   0200               MOVS     R2,R0
   \   0000013A   0B00               MOVS     R3,R1
   \   0000013C   2800               MOVS     R0,R5
   \   0000013E   3749               LDR      R1,??Timer_1ms_0+0x38  ;; 0xc104ff00
   \   00000140   ........           BL       __aeabi_dadd
   \   00000144   ........           BL       __aeabi_d2iz
   \   00000148   0004               LSLS     R0,R0,#+16
   \   0000014A   0014               ASRS     R0,R0,#+16
   \   0000014C   A021               MOVS     R1,#+160
   \   0000014E   0902               LSLS     R1,R1,#+8        ;; #+40960
   \   00000150   0143               ORRS     R1,R1,R0
   \   00000152   0800               MOVS     R0,R1
   \   00000154   0221               MOVS     R1,#+2
   \   00000156   ........           BL       SPI_SendWord
   1833                           RF_Status.MasterMode=0;  
   \   0000015A   6573               STRB     R5,[R4, #+13]
   1834                           RF_Status.EnableRX();
   \   0000015C   A06A               LDR      R0,[R4, #+40]
   \   0000015E   ........           BL       __iar_via_R0
   1835                        
   1836                      }
   1837                    
   1838                    }
   1839                   
   1840                    
   1841            }
   1842          }          
   1843          
   1844            
   1845          
   1846            
   1847                //uruchomienie Timer_1s co 1000 cykli-------------------------------------------
   1848                static short CounterForTimer1s; 
   1849                if (CounterForTimer1s<1000)
   \                     ??Timer_1ms_3:
   \   00000162   264E               LDR      R6,??Timer_1ms_0+0x18  ;; g_SlaveConnect
   \   00000164   0420               MOVS     R0,#+4
   \   00000166   305E               LDRSH    R0,[R6, R0]
   \   00000168   FA21               MOVS     R1,#+250
   \   0000016A   8900               LSLS     R1,R1,#+2        ;; #+1000
   \   0000016C   8842               CMP      R0,R1
   \   0000016E   02DA               BGE      ??Timer_1ms_17
   1850                {
   1851                    CounterForTimer1s++;
   \   00000170   401C               ADDS     R0,R0,#+1
   \   00000172   B080               STRH     R0,[R6, #+4]
   \   00000174   03E0               B        ??Timer_1ms_18
   1852                }else{
   1853                    CounterForTimer1s=0;
   \                     ??Timer_1ms_17:
   \   00000176   0020               MOVS     R0,#+0
   \   00000178   B080               STRH     R0,[R6, #+4]
   1854                    Timer_1s();
   \   0000017A   ........           BL       Timer_1s
   1855                }
   1856          
   1857          
   1858          
   1859            
   1860            //przesuniêcie bitowe dle pomiaru jakoœci po³¹czenia z Node`ami z okresowoœci¹ TimeUnitQual
   1861            if (++CurTimeQual>=TimeUnitQual)
   \                     ??Timer_1ms_18:
   \   0000017E   0220               MOVS     R0,#+2
   \   00000180   305E               LDRSH    R0,[R6, R0]
   \   00000182   401C               ADDS     R0,R0,#+1
   \   00000184   7080               STRH     R0,[R6, #+2]
   \   00000186   9621               MOVS     R1,#+150
   \   00000188   8900               LSLS     R1,R1,#+2        ;; #+600
   \   0000018A   0004               LSLS     R0,R0,#+16
   \   0000018C   0014               ASRS     R0,R0,#+16
   \   0000018E   8842               CMP      R0,R1
   \   00000190   25DB               BLT      ??Timer_1ms_19
   1862            {
   1863              CurTimeQual=0;
   \   00000192   0025               MOVS     R5,#+0
   \   00000194   7580               STRH     R5,[R6, #+2]
   1864              if (TransQuality.MensurIndex<32)
   \   00000196   2248               LDR      R0,??Timer_1ms_0+0x3C  ;; TransQuality
   \   00000198   0178               LDRB     R1,[R0, #+0]
   \   0000019A   2029               CMP      R1,#+32
   \   0000019C   02D2               BCS      ??Timer_1ms_20
   1865              {
   1866                TransQuality.MensurIndex++; 
   \   0000019E   491C               ADDS     R1,R1,#+1
   \   000001A0   0170               STRB     R1,[R0, #+0]
   \   000001A2   00E0               B        ??Timer_1ms_21
   1867              }else{
   1868                TransQuality.MensurIndex=0;
   \                     ??Timer_1ms_20:
   \   000001A4   0570               STRB     R5,[R0, #+0]
   1869              }
   1870              if (TransQuality.QuickMensurIndex<4)
   \                     ??Timer_1ms_21:
   \   000001A6   8178               LDRB     R1,[R0, #+2]
   \   000001A8   0429               CMP      R1,#+4
   \   000001AA   02D2               BCS      ??Timer_1ms_22
   1871              {
   1872                TransQuality.QuickMensurIndex++; 
   \   000001AC   491C               ADDS     R1,R1,#+1
   \   000001AE   8170               STRB     R1,[R0, #+2]
   \   000001B0   00E0               B        ??Timer_1ms_23
   1873              }else{
   1874                TransQuality.QuickMensurIndex=0;
   \                     ??Timer_1ms_22:
   \   000001B2   8570               STRB     R5,[R0, #+2]
   1875              }
   1876          
   1877              for (char i=0; i<NumberNeurons; i++) 
   \                     ??Timer_1ms_23:
   \   000001B4   0100               MOVS     R1,R0
   \   000001B6   2631               ADDS     R1,R1,#+38
   \   000001B8   0200               MOVS     R2,R0
   \   000001BA   4C32               ADDS     R2,R2,#+76
   \   000001BC   2323               MOVS     R3,#+35
   1878              {
   1879                TransQuality.Mensur[i] &= ~(0x1 << TransQuality.MensurIndex);
   \                     ??Timer_1ms_24:
   \   000001BE   1468               LDR      R4,[R2, #+0]
   \   000001C0   0125               MOVS     R5,#+1
   \   000001C2   0678               LDRB     R6,[R0, #+0]
   \   000001C4   B540               LSLS     R5,R5,R6
   \   000001C6   AC43               BICS     R4,R4,R5
   \   000001C8   1460               STR      R4,[R2, #+0]
   1880                TransQuality.QuickMensur[i] &= ~(0x1 << TransQuality.QuickMensurIndex);
   \   000001CA   0C78               LDRB     R4,[R1, #+0]
   \   000001CC   0125               MOVS     R5,#+1
   \   000001CE   8678               LDRB     R6,[R0, #+2]
   \   000001D0   B540               LSLS     R5,R5,R6
   \   000001D2   AC43               BICS     R4,R4,R5
   \   000001D4   0C70               STRB     R4,[R1, #+0]
   1881              }                 
   \   000001D6   121D               ADDS     R2,R2,#+4
   \   000001D8   491C               ADDS     R1,R1,#+1
   \   000001DA   5B1E               SUBS     R3,R3,#+1
   \   000001DC   EFD1               BNE      ??Timer_1ms_24
   1882            }
   1883          
   1884            
   1885          
   1886                    
   1887                 
   1888          
   1889          
   1890          }//_____________________________________________________________________________
   \                     ??Timer_1ms_19:
   \   000001DE   70BC               POP      {R4-R6}
   \   000001E0   01BC               POP      {R0}
   \   000001E2   0047               BX       R0               ;; return
   \                     ??Timer_1ms_0:
   \   000001E4   A000FAFF           DC32     0xfffa00a0
   \   000001E8   ........           DC32     DateTime
   \   000001EC   ........           DC32     ButtonBipCounter
   \   000001F0   34F4FFFF           DC32     0xfffff434
   \   000001F4   ........           DC32     RF_Status
   \   000001F8   ........           DC32     g_RF_TimeOutCounter
   \   000001FC   ........           DC32     g_SlaveConnect
   \   00000200   10270000           DC32     0x2710
   \   00000204   19820000           DC32     0x8219
   \   00000208   33333333           DC32     0x33333333
   \   0000020C   3333D33F           DC32     0x3fd33333
   \   00000210   C3F5285C           DC32     0x5c28f5c3
   \   00000214   8FE28A40           DC32     0x408ae28f
   \   00000218   00006940           DC32     0x40690000
   \   0000021C   00FF04C1           DC32     0xc104ff00
   \   00000220   ........           DC32     TransQuality
   1891          
   1892          
   1893          
   1894          
   1895          
   1896          //-----------------------------------------------------------------------------
   1897          //!  Nazwa funkcji :    Timer_1_Setup
   1898          //!  Funkcja inicjalizacji Timer1 - 1ms
   1899          //-----------------------------------------------------------------------------
   1900          //! 
   1901          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1902          void Timer_1ms_Setup(void) 
   1903          { 
   1904            //TRACE_INFO("T2_setup");  
   1905            //TRACE_INFO("\n\r"); 
   1906            
   1907           //AT91C_BASE_PIOA->PIO_PDR = P_TIOA0;   //disable PIOA 
   1908           //AT91C_BASE_PIOA->PIO_BSR = P_TIOA0;   //select peripheral B 
   1909           AT91C_BASE_AIC->AIC_SVR[AT91C_ID_TC2] = (unsigned int)Timer_1ms;  //set AIC             
   \                     Timer_1ms_Setup:
   \   00000000   ....               LDR      R0,??Subroutine0_0  ;; 0xfffff0b8
   \   00000002   ....               LDR      R1,??Subroutine0_0+0x4  ;; Timer_1ms
   \   00000004   0160               STR      R1,[R0, #+0]
   1910           AT91C_BASE_AIC->AIC_SMR[AT91C_ID_TC2] = (AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL | TIMER_1mS_PRIOR ); 
   \   00000006   ....               LDR      R0,??Subroutine0_0+0x8  ;; 0xfffff038
   \   00000008   0421               MOVS     R1,#+4
   \   0000000A   0160               STR      R1,[R0, #+0]
   1911           AT91C_BASE_PMC->PMC_PCER = (1<<AT91C_ID_TC2);      //enable clock 
   \   0000000C   0803               LSLS     R0,R1,#+12
   \   0000000E   ....               LDR      R1,??DataTable29  ;; 0xfffffc10
   \   00000010   0860               STR      R0,[R1, #+0]
   1912           AT91C_BASE_TCB->TCB_BCR = 0;                  //no SYNC trigger 
   \   00000012   ....               LDR      R1,??DataTable30  ;; 0xfffa00c0
   \   00000014   0022               MOVS     R2,#+0
   \   00000016   0A60               STR      R2,[R1, #+0]
   1913           //no external clocks 
   1914           AT91C_BASE_TCB->TCB_BMR = AT91C_TCB_TC0XC0S_NONE | AT91C_TCB_TC1XC1S_NONE | AT91C_TCB_TC2XC2S_NONE; 
   \   00000018   ....               LDR      R1,??DataTable31  ;; 0xfffa00c4
   \   0000001A   1522               MOVS     R2,#+21
   \   0000001C   0A60               STR      R2,[R1, #+0]
   1915           AT91C_BASE_TC2->TC_CCR = AT91C_TC_SWTRG | AT91C_TC_CLKEN;                   //enable and start clock 
   \   0000001E   ....               LDR      R1,??Subroutine0_0+0xC  ;; 0xfffa0080
   \   00000020   0522               MOVS     R2,#+5
   \   00000022   0A60               STR      R2,[R1, #+0]
   1916           AT91C_BASE_TC2->TC_CMR = AT91C_TC_ACPC_TOGGLE | AT91C_TC_WAVE  | AT91C_TC_WAVESEL_UP_AUTO  | AT91C_TC_CLKS_TIMER_DIV2_CLOCK;//CPC 
   \   00000024   ....               LDR      R1,??Subroutine0_0+0x10  ;; 0xfffa0084
   \   00000026   ....               LDR      R2,??DataTable32  ;; 0xcc001
   \   00000028   0A60               STR      R2,[R1, #+0]
   1917           //clock: MCK/1024  = 48054841/ DIV
   1918           //AT91C_BASE_TC0->TC_RC = 46928;    => 1 sec 
   1919           //! DIV5 - 1024
   1920           //! DIV4 - 128
   1921           //! DIV3 - 32
   1922           //! DIV2 - 8
   1923           
   1924           AT91C_BASE_TC2->TC_RC = 6007;                  //1ms  (z wyliczeñ 6007)
   \   0000002A   ....               LDR      R1,??Subroutine0_0+0x14  ;; 0xfffa009c
   \   0000002C   ....               LDR      R2,??Subroutine0_0+0x18  ;; 0x1777
   \   0000002E   0A60               STR      R2,[R1, #+0]
   1925           AT91C_BASE_TC2->TC_IER = AT91C_TC_CPCS;         //enable RC compare int 
   \   00000030   ....               LDR      R1,??Subroutine0_0+0x1C  ;; 0xfffa00a4
   \   00000032   1022               MOVS     R2,#+16
   \   00000034   0A60               STR      R2,[R1, #+0]
   1926           AT91C_BASE_TC2->TC_IDR = ~AT91C_TC_CPCS;         //disable other 
   \   00000036   ....               LDR      R1,??Subroutine0_0+0x20  ;; 0xfffa00a8
   \   00000038                      REQUIRE ?Subroutine0
   \   00000038                      ;; // Fall through to label ?Subroutine0
   1927           AT91C_BASE_AIC->AIC_IECR = (1<<AT91C_ID_TC2);       //enable int 
   1928           AT91C_BASE_AIC->AIC_ICCR = (1<<AT91C_ID_TC2);       //clear int 
   1929          
   1930          
   1931          
   1932          }//_____________________________________________________________________________
   1933          
   1934          
   1935          
   1936          
   1937          
   1938          
   1939          
   1940          
   1941          
   1942          

   \                                 In section Debug.txt, align 4, keep-with-next
   1943          void RamToFlash(void)
   1944          {
   \                     RamToFlash:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   1945                    //if (g_PC_Connected==0)
   1946                    //{
   1947                      DispWait=DispWaitOn; 
   \   00000002   2F4C               LDR      R4,??RamToFlash_0  ;; DispWait
   \   00000004   0120               MOVS     R0,#+1
   \   00000006   2070               STRB     R0,[R4, #+0]
   1948                      Wait_Paint();
   \   00000008   ........           BL       Wait_Paint
   1949                    //} 
   1950                      gProg.Preambu=ProgPreambu;
   \   0000000C   2D4D               LDR      R5,??RamToFlash_0+0x4  ;; gProg
   \   0000000E   AA20               MOVS     R0,#+170
   \   00000010   2870               STRB     R0,[R5, #+0]
   1951                      gProg.ProgFormatTyp=_ProgFormatTyp;
   \   00000012   0220               MOVS     R0,#+2
   \   00000014   6870               STRB     R0,[R5, #+1]
   \   00000016   2C48               LDR      R0,??RamToFlash_0+0x8  ;; 0xc670
   \   00000018   6880               STRH     R0,[R5, #+2]
   1952                      gProg.Size=sizeof(gProg);
   1953                      gProg.ModyfiData[0]='2';gProg.ModyfiData[1]='0';
   \   0000001A   3220               MOVS     R0,#+50
   \   0000001C   2871               STRB     R0,[R5, #+4]
   \   0000001E   3020               MOVS     R0,#+48
   \   00000020   6871               STRB     R0,[R5, #+5]
   1954                      CharToStr(DateTime.Year, &(gProg.ModyfiData[2]), 2); 
   \   00000022   2A4E               LDR      R6,??RamToFlash_0+0xC  ;; DateTime
   \   00000024   0222               MOVS     R2,#+2
   \   00000026   2900               MOVS     R1,R5
   \   00000028   891D               ADDS     R1,R1,#+6
   \   0000002A   3078               LDRB     R0,[R6, #+0]
   \   0000002C   ........           BL       CharToStr
   1955                      gProg.ModyfiData[4]='-';
   \   00000030   2D27               MOVS     R7,#+45
   \   00000032   2F72               STRB     R7,[R5, #+8]
   1956                      CharToStr(DateTime.Mounth, &(gProg.ModyfiData[5]), 2);
   \   00000034   0222               MOVS     R2,#+2
   \   00000036   2900               MOVS     R1,R5
   \   00000038   0931               ADDS     R1,R1,#+9
   \   0000003A   7078               LDRB     R0,[R6, #+1]
   \   0000003C   ........           BL       CharToStr
   1957                      gProg.ModyfiData[7]='-'; 
   \   00000040   EF72               STRB     R7,[R5, #+11]
   1958                      CharToStr(DateTime.Day, &(gProg.ModyfiData[8]), 2); 
   \   00000042   0222               MOVS     R2,#+2
   \   00000044   2900               MOVS     R1,R5
   \   00000046   0C31               ADDS     R1,R1,#+12
   \   00000048   B078               LDRB     R0,[R6, #+2]
   \   0000004A   ........           BL       CharToStr
   1959                      gProg.ModyfiData[10]=' ';
   \   0000004E   2020               MOVS     R0,#+32
   \   00000050   A873               STRB     R0,[R5, #+14]
   1960                      CharToStr(DateTime.Hour, &(gProg.ModyfiData[11]), 2); 
   \   00000052   0222               MOVS     R2,#+2
   \   00000054   2900               MOVS     R1,R5
   \   00000056   0F31               ADDS     R1,R1,#+15
   \   00000058   F078               LDRB     R0,[R6, #+3]
   \   0000005A   ........           BL       CharToStr
   1961                      gProg.ModyfiData[13]=':';
   \   0000005E   3A27               MOVS     R7,#+58
   \   00000060   6F74               STRB     R7,[R5, #+17]
   1962                      CharToStr(DateTime.Minute, &(gProg.ModyfiData[14]), 2); 
   \   00000062   0222               MOVS     R2,#+2
   \   00000064   2900               MOVS     R1,R5
   \   00000066   1231               ADDS     R1,R1,#+18
   \   00000068   3079               LDRB     R0,[R6, #+4]
   \   0000006A   ........           BL       CharToStr
   1963                      gProg.ModyfiData[16]=':';
   \   0000006E   2F75               STRB     R7,[R5, #+20]
   1964                      CharToStr(DateTime.Second, &(gProg.ModyfiData[17]), 2); 
   \   00000070   0222               MOVS     R2,#+2
   \   00000072   2900               MOVS     R1,R5
   \   00000074   1531               ADDS     R1,R1,#+21
   \   00000076   7079               LDRB     R0,[R6, #+5]
   \   00000078   ........           BL       CharToStr
   1965                      for (char i=0; i<19; i++) if (gProg.ModyfiData[i]==0) gProg.ModyfiData[i]='0';
   \   0000007C   2800               MOVS     R0,R5
   \   0000007E   001D               ADDS     R0,R0,#+4
   \   00000080   1321               MOVS     R1,#+19
   \                     ??RamToFlash_1:
   \   00000082   0278               LDRB     R2,[R0, #+0]
   \   00000084   002A               CMP      R2,#+0
   \   00000086   01D1               BNE      ??RamToFlash_2
   \   00000088   3022               MOVS     R2,#+48
   \   0000008A   0270               STRB     R2,[R0, #+0]
   \                     ??RamToFlash_2:
   \   0000008C   401C               ADDS     R0,R0,#+1
   \   0000008E   491E               SUBS     R1,R1,#+1
   \   00000090   F7D1               BNE      ??RamToFlash_1
   1966          
   1967                        unsigned int Save = __get_interrupt_state();            
   \   00000092   ........           BL       __iar_get_interrupt_state
   \   00000096   0700               MOVS     R7,R0
   1968                        __disable_interrupt();
   \   00000098   ........           BL       __iar_disable_interrupt
   1969                        //CleanFlash(AT91C_IFLASH_MEM->FlashProgram,sizeof(gProg));
   1970                          FlashWrite((char*)(AT91C_IFLASH_MEM->FlashProgram+FlashProgramOfset), (char*)&gProg,sizeof(gProg)); //(char *ptrMem, char *value, int length)
                                 ^
Warning[Pe223]: function "FlashWrite" declared implicitly
   \   0000009C   0A4A               LDR      R2,??RamToFlash_0+0x8  ;; 0xc670
   \   0000009E   2900               MOVS     R1,R5
   \   000000A0   B06C               LDR      R0,[R6, #+72]
   \   000000A2   0B4B               LDR      R3,??RamToFlash_0+0x10  ;; 0x130100
   \   000000A4   1818               ADDS     R0,R3,R0
   \   000000A6   ........           BL       FlashWrite
   1971                        //at91flashWrite((int)AT91C_IFLASH_MEM->FlashProgram+FlashProgramOfset,0,(char*)&gProg,sizeof(gProg));
   1972                        __set_interrupt_state(Save);
   \   000000AA   3800               MOVS     R0,R7
   \   000000AC   ........           BL       __iar_set_interrupt_state
   1973                        __enable_interrupt(); 
   \   000000B0   ........           BL       __iar_enable_interrupt
   1974          
   1975           DispWait=DispWaitOff; 
   \   000000B4   0420               MOVS     R0,#+4
   \   000000B6   2070               STRB     R0,[R4, #+0]
   1976          
   1977          
   1978          
   1979          }
   \   000000B8   F8BC               POP      {R3-R7}
   \   000000BA   01BC               POP      {R0}
   \   000000BC   0047               BX       R0               ;; return
   \   000000BE   C046               Nop      
   \                     ??RamToFlash_0:
   \   000000C0   ........           DC32     DispWait
   \   000000C4   ........           DC32     gProg
   \   000000C8   70C60000           DC32     0xc670
   \   000000CC   ........           DC32     DateTime
   \   000000D0   00011300           DC32     0x130100
   1980          
   1981          
   1982          
   1983          
   1984          

   \                                 In section .bss, align 4
   1985          int testcount=0;
   \                     testcount:
   \   00000000                      DS8 4

   \                                 In section Debug.txt, align 4, keep-with-next
   1986          void TestHendel(void)
   1987          {
   \                     TestHendel:
   \   00000000   01B5               PUSH     {R0,LR}
   1988            AT91F_PIO_GetInterruptStatus(AT91C_PIO_VBUS);
   \   00000002   0648               LDR      R0,??TestHendel_0  ;; 0xfffff44c
   \   00000004   0068               LDR      R0,[R0, #+0]
   1989            if ((AT91C_BASE_PIOA->PIO_PDSR) & AT91C_VBUS) testcount++;
   \   00000006   0648               LDR      R0,??TestHendel_0+0x4  ;; 0xfffff43c
   \   00000008   0068               LDR      R0,[R0, #+0]
   \   0000000A   8007               LSLS     R0,R0,#+30
   \   0000000C   03D5               BPL      ??TestHendel_1
   \   0000000E   0548               LDR      R0,??TestHendel_0+0x8  ;; testcount
   \   00000010   0168               LDR      R1,[R0, #+0]
   \   00000012   491C               ADDS     R1,R1,#+1
   \   00000014   0160               STR      R1,[R0, #+0]
   1990              
   1991          
   1992          }
   \                     ??TestHendel_1:
   \   00000016   08BC               POP      {R3}
   \   00000018   01BC               POP      {R0}
   \   0000001A   0047               BX       R0               ;; return
   \                     ??TestHendel_0:
   \   0000001C   4CF4FFFF           DC32     0xfffff44c
   \   00000020   3CF4FFFF           DC32     0xfffff43c
   \   00000024   ........           DC32     testcount
   1993          
   1994          

   \                                 In section Debug.txt, align 4, keep-with-next
   1995          void TestInit(void)
   1996          {
   \                     TestInit:
   \   00000000   30B4               PUSH     {R4,R5}
   1997          //#ifndef USB_BUS_POWERED
   1998              AT91F_PIO_CfgInput(AT91C_BASE_PIOA,AT91C_VBUS);
   \   00000002   114A               LDR      R2,??TestInit_0  ;; 0xfffff414
   \   00000004   0220               MOVS     R0,#+2
   \   00000006   1060               STR      R0,[R2, #+0]
   \   00000008   104B               LDR      R3,??TestInit_0+0x4  ;; 0xfffff400
   \   0000000A   1860               STR      R0,[R3, #+0]
   1999              AT91C_BASE_PIOA->PIO_PPUDR = AT91C_VBUS;
   \   0000000C   104C               LDR      R4,??TestInit_0+0x8  ;; 0xfffff460
   \   0000000E   2060               STR      R0,[R4, #+0]
   2000              
   2001              // Configure VBus monitoring
   2002                  AT91F_PMC_EnablePeriphClock(AT91C_BASE_PMC, 1 << AT91C_ID_VBUS);
   \   00000010   0421               MOVS     R1,#+4
   \   00000012   104D               LDR      R5,??TestInit_0+0xC  ;; 0xfffffc10
   \   00000014   2960               STR      R1,[R5, #+0]
   2003              AT91F_PIO_CfgPullup(AT91C_PIO_VBUS, ~AT91C_VBUS);
   \   00000016   2060               STR      R0,[R4, #+0]
   \   00000018   0F4C               LDR      R4,??TestInit_0+0x10  ;; 0xfffff464
   \   0000001A   0225               MOVS     R5,#+2
   \   0000001C   ED43               MVNS     R5,R5            ;; #-3
   \   0000001E   2560               STR      R5,[R4, #+0]
   2004              AT91F_PIO_CfgInput(AT91C_PIO_VBUS, AT91C_VBUS);
   \   00000020   1060               STR      R0,[R2, #+0]
   \   00000022   1860               STR      R0,[R3, #+0]
   2005          
   2006              // Configure and enable the Vbus detection interrupt
   2007              AT91F_AIC_ConfigureIt(AT91C_BASE_AIC,
   2008                                    AT91C_ID_VBUS,
   2009                                    5, //AT91C_AIC_PRIOR_LOWEST,
   2010                                    0,//AT91C_AIC_SRCTYPE_INT_HIGH_LEVEL,
   2011                                    ISR_VBus);
   \   00000024   0D4A               LDR      R2,??TestInit_0+0x14  ;; 0xfffff088
   \   00000026   1368               LDR      R3,[R2, #+0]
   \   00000028   0D4B               LDR      R3,??TestInit_0+0x18  ;; 0xfffff124
   \   0000002A   1960               STR      R1,[R3, #+0]
   \   0000002C   0D4B               LDR      R3,??TestInit_0+0x1C  ;; ISR_VBus
   \   0000002E   1360               STR      R3,[R2, #+0]
   \   00000030   0D4A               LDR      R2,??TestInit_0+0x20  ;; 0xfffff008
   \   00000032   0523               MOVS     R3,#+5
   \   00000034   1360               STR      R3,[R2, #+0]
   \   00000036   0D4A               LDR      R2,??TestInit_0+0x24  ;; 0xfffff128
   \   00000038   1160               STR      R1,[R2, #+0]
   2012          
   2013              AT91F_PIO_InterruptEnable(AT91C_PIO_VBUS, AT91C_VBUS);
   \   0000003A   0D4A               LDR      R2,??TestInit_0+0x28  ;; 0xfffff440
   \   0000003C   1060               STR      R0,[R2, #+0]
   2014              AT91F_AIC_EnableIt(AT91C_BASE_AIC, AT91C_ID_VBUS);
   \   0000003E   0D48               LDR      R0,??TestInit_0+0x2C  ;; 0xfffff120
   \   00000040   0160               STR      R1,[R0, #+0]
   2015          }
   \   00000042   30BC               POP      {R4,R5}
   \   00000044   7047               BX       LR               ;; return
   \   00000046   C046               Nop      
   \                     ??TestInit_0:
   \   00000048   14F4FFFF           DC32     0xfffff414
   \   0000004C   00F4FFFF           DC32     0xfffff400
   \   00000050   60F4FFFF           DC32     0xfffff460
   \   00000054   10FCFFFF           DC32     0xfffffc10
   \   00000058   64F4FFFF           DC32     0xfffff464
   \   0000005C   88F0FFFF           DC32     0xfffff088
   \   00000060   24F1FFFF           DC32     0xfffff124
   \   00000064   ........           DC32     ISR_VBus
   \   00000068   08F0FFFF           DC32     0xfffff008
   \   0000006C   28F1FFFF           DC32     0xfffff128
   \   00000070   40F4FFFF           DC32     0xfffff440
   \   00000074   20F1FFFF           DC32     0xfffff120
   2016          
   2017          
   2018          
   2019          
   2020          
   2021          
   2022          //------------------------------------------------------------------------------
   2023          //!          Main
   2024          //------------------------------------------------------------------------------
   2025          
   2026          //char ekran_tab[8][128]; 
   2027          

   \                                 In section .bss, align 4
   2028          char string[25];
   \                     string:
   \   00000000                      DS8 28
   2029          

   \                                 In section Debug.txt, align 4, keep-with-next
   2030          void watchdogEnable(int millis)
   2031          {
   \                     watchdogEnable:
   \   00000000   01B5               PUSH     {R0,LR}
   2032            int period = (millis * 256) / 1000;
   \   00000002   0002               LSLS     R0,R0,#+8
   \   00000004   FA21               MOVS     R1,#+250
   \   00000006   8900               LSLS     R1,R1,#+2        ;; #+1000
   \   00000008   ........           BL       __aeabi_idivmod
   2033            AT91C_BASE_WDTC->WDTC_WDMR =  AT91C_WDTC_WDRSTEN |        // enable reset on timeout
   2034                                          AT91C_WDTC_WDDBGHLT |       // respect debug mode
   2035                                          AT91C_WDTC_WDIDLEHLT |      // respect idle mode
   2036                                          ((period << 16 ) & AT91C_WDTC_WDD) | // delta is as wide as the period, so we can restart anytime
   2037                                          (period & AT91C_WDTC_WDV);  // set the period
   \   0000000C   0649               LDR      R1,??watchdogEnable_0  ;; 0xfffffd44
   \   0000000E   0204               LSLS     R2,R0,#+16
   \   00000010   064B               LDR      R3,??watchdogEnable_0+0x4  ;; 0xfff0000
   \   00000012   1340               ANDS     R3,R3,R2
   \   00000014   0005               LSLS     R0,R0,#+20
   \   00000016   000D               LSRS     R0,R0,#+20
   \   00000018   1843               ORRS     R0,R0,R3
   \   0000001A   054A               LDR      R2,??watchdogEnable_0+0x8  ;; 0x30002000
   \   0000001C   0243               ORRS     R2,R2,R0
   \   0000001E   0A60               STR      R2,[R1, #+0]
   2038          }
   \   00000020   08BC               POP      {R3}
   \   00000022   01BC               POP      {R0}
   \   00000024   0047               BX       R0               ;; return
   \   00000026   C046               Nop      
   \                     ??watchdogEnable_0:
   \   00000028   44FDFFFF           DC32     0xfffffd44
   \   0000002C   0000FF0F           DC32     0xfff0000
   \   00000030   00200030           DC32     0x30002000

   \                                 In section .data, align 8
   \                     DateTime:
   \   00000000   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \                     Speaker:
   \   00000008   00000000           DC8 0, 0, 0, 0
   \                     g_PC_Connected:
   \   0000000C   00                 DC8 0
   \                     g_LightLCDEnable:
   \   0000000D   00                 DC8 0
   \                     g_ScreenSever_On:
   \   0000000E   00                 DC8 0
   \                     g_ScreenSever_Time_On:
   \   0000000F   00                 DC8 0
   \                     g_ScreenSever_Time_Off:
   \   00000010   00                 DC8 0
   \                     g_Stop_Program:
   \   00000011   00                 DC8 0
   \                     g_NeedPass:
   \   00000012   00                 DC8 0
   \                     AlarmOn:
   \   00000013   00                 DC8 0
   \                     ChangeingIdMode:
   \   00000014   00                 DC8 0
   \                     WypMaxJasnosci:
   \   00000015   00                 DC8 0
   \                     WypMinJasnosci:
   \   00000016   00                 DC8 0
   \                     gWypMinJasnosciTest:
   \   00000017   00                 DC8 0
   \                     ChangeStageFlag:
   \   00000018   0A                 DC8 10
   \                     SlaveMode:
   \   00000019   00                 DC8 0
   \                     ForwardUSB2Serialferst:
   \   0000001A   00                 DC8 0
   \                     FlagChangeTime:
   \   0000001B   00                 DC8 0
   \   0000001C   00                 DC8 0
   \   0000001D   00                 DC8 0
   \   0000001E   00                 DC8 0
   \   0000001F   64                 DC8 100
   \                     g_Password_1:
   \   00000020   3131313100         DC8 "1111"
   \   00000025   000000             DC8 0, 0, 0
   \                     Y_down:
   \   00000028   FFFF               DC16 -1
   \                     X_down:
   \   0000002A   FFFF               DC16 -1
   \                     Y_up:
   \   0000002C   FFFF               DC16 -1
   \                     X_up:
   \   0000002E   FFFF               DC16 -1
   \                     g_counter:
   \   00000030   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \                     g_NextTimeProgram:
   \   00000038   000000000000       DC32 0, 0
   \              0000        
   \                     FuseLastWiFiDataIn:
   \   00000040   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \                     FlashProgramOfset:
   \   00000048   00010000           DC32 256
   \                     g_seconds_counter:
   \   0000004C   00000000           DC8 0, 0, 0, 0
   \                     g_LightCouterLCD:
   \   00000050   00000000           DC32 0
   \                     pAT91C_IFLASH_MEM:
   \   00000054   00001300           DC32 130000H
   \                     dState:
   \   00000058   00000000           DC8 0, 0, 0, 0
   \                     SourRam:
   \   0000005C   00000000           DC8 0, 0, 0, 0
   \                     siz:
   \   00000060   00000000           DC8 0, 0, 0, 0
   \                     LiczOds:
   \   00000064   00000000           DC32 0
   \                     CyklPerSekCount:
   \   00000068   00000000           DC32 0
   \                     TransLoopTime:
   \   0000006C   00000000           DC32 0
   \                     CyklPerSek:
   \   00000070   01000000           DC32 1
   \                     MenuLevel_old:
   \   00000074   00000000           DC8 0, 0, 0, 0
   \   00000078   00000000           DC8 0, 0, 0, 0
   2039          
   2040          
   2041          
   2042          
   2043          
   2044          
   2045          
   2046          
   2047          
   2048          
   2049          #define WATCHDOG_KEY (0xA5 << 24)
   2050          
   2051          char TimeCompil[]= __TIME__;
   2052          char DateCompil[]= __DATE__;
   2053          
   2054          extern  char VBUS_old;
   2055          
   2056          
   2057          #ifdef _LIVE_RJESTR 
   2058          int LIVE_TAB_IDX=0;  
   2059          unsigned short LIVE_TAB[LIVE_TAB_SIZE];  //   | A-Odczyt, B-potwierdzenie odczytu, C-Zapis F-flaga priorytetu | Nr wêz³a |  wartoœæ | | 
   2060          #endif
   2061             
   2062          
   2063          AT91PS_MEM FLASH;  
   \                     FLASH:
   \   0000007C   00000000           DC8 0, 0, 0, 0
   \   00000080   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              0000        
   \   00000094   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000A4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000B4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000C4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000D4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000E4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000000F4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000104   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000114   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000124   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000134   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000144   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000154   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000164   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000174   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000184   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000194   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001A4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001B4   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \   000001C0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001D0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001E0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000001F0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000200   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000210   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000220   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000230   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000240   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000250   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000260   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000270   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000280   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000290   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000002A0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000002B0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000002C0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000002D0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000002E0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000002F0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000300   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000310   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000320   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000330   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000340   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000350   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000360   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000370   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000380   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000390   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000003A0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000003B0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000003C0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000003D0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000003E0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000003F0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000400   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000410   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000420   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000430   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000440   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000450   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000460   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000470   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000480   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000490   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000004A0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000004B0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000004C0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000004D0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000004E0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   000004F0   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000500   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000510   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000520   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000530   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              000000000000
   \              0000        

   \                                 In section .data, align 4
   \                     FlashProgramReserveOfset:
   \   00000000   D8D70000           DC32 55256

   \                                 In section .data, align 4
   \                     g_Password_2:
   \   00000000   3232323200         DC8 "2222"
   \   00000005   000000             DC8 0, 0, 0

   \                                 In section .data, align 1
   \                     AdressModbus:
   \   00000000   01                 DC8 1

   \                                 In section .data, align 4
   \                     g_SlaveConnect:
   \   00000000   00                 DC8 0
   \   00000001   FF                 DC8 255
   \                     CurTimeQual:
   \   00000002   0000               DC16 0
   \   00000004   0000               DC8 0, 0
   \   00000006   0000               DC8 0, 0
   \   00000008   00000000           DC8 0, 0, 0, 0

   \                                 In section .data, align 1
   \                     g_Restart_Program:
   \   00000000   01                 DC8 1

   \                                 In section .data, align 8
   \                     AlarmScreenAction:
   \   00000000   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     out:
   \   00000010   010101010101       DC8 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0
   \              010101010000
   \   0000001C   00000000           DC8 0, 0, 0, 0
   \   00000020   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000030   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000040   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000050   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000060   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000070   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000080   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \   00000090   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    

   \                                 In section .data, align 4
   \                     pEndpoints:
   \   00000000   000000000000       DC32 0H, 0, 0, 0, 0H, 0H, 0, 0
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \              0000        
   \   00000020   01000000           DC8 1, 0, 0, 0
   \   00000024   000000000000       DC32 0, 0H, 0, 0, 0, 0H, 0H, 0, 0
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \   00000048   02000000           DC8 2, 0, 0, 0
   \   0000004C   000000000000       DC32 0, 0H, 0, 0, 0, 0H, 0H, 0, 0
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \   00000070   02000000           DC8 2, 0, 0, 0
   \   00000074   000000000000       DC32 0, 0H, 0, 0, 0, 0H, 0H, 0, 0
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \              000000000000
   \   00000098   01000000           DC8 1, 0, 0, 0
   \   0000009C   00000000           DC32 0

   \                                 In section .data, align 4
   \                     tProgramTabSize:
   \   00000000   70C60000           DC32 50800

   \                                 In section .data, align 4
   \                     stop:
   \   00000000   D0070000           DC32 2000

   \                                 In section .data, align 4
   \                     X_up_old:
   \   00000000   FFFFFFFF           DC32 -1

   \                                 In section .data, align 4
   \                     Y_up_old:
   \   00000000   FFFFFFFF           DC32 -1

   \                                 In section .data, align 4
   \                     X_down_old:
   \   00000000   FFFFFFFF           DC32 -1

   \                                 In section .data, align 4
   \                     Y_down_old:
   \   00000000   FFFFFFFF           DC32 -1

   \                                 In section .data, align 1
   \                     g_PC_Connected_timeout:
   \   00000000   05                 DC8 5

   \                                 In section .data, align 4
   \                     TimeCompil:
   \   00000000   31393A33343A       DC8 "19:34:31"
   \              333100      
   \   00000009   000000             DC8 0, 0, 0

   \                                 In section .data, align 4
   \                     DateCompil:
   \   00000000   536570202034       DC8 "Sep  4 2013"
   \              203230313300
   2064          

   \                                 In section Debug.txt, align 4, keep-with-next
   2065          void main()
   2066          {
   \                     main:
   \   00000000   F7B5               PUSH     {R0-R2,R4-R7,LR}
   2067              FLASH=AT91C_IFLASH_MEM;  
   \   00000002   B54C               LDR      R4,??main_0      ;; DateTime
   \   00000004   9820               MOVS     R0,#+152
   \   00000006   4003               LSLS     R0,R0,#+13       ;; #+1245184
   \   00000008   E067               STR      R0,[R4, #+124]
   2068            
   2069              LCD_INIT();
   \   0000000A   0420               MOVS     R0,#+4
   \   0000000C   B349               LDR      R1,??main_0+0x4  ;; 0xfffffc10
   \   0000000E   0860               STR      R0,[R1, #+0]
   \   00000010   B34D               LDR      R5,??main_0+0x8  ;; 0xfffff400
   \   00000012   2860               STR      R0,[R5, #+0]
   \   00000014   B34E               LDR      R6,??main_0+0xC  ;; 0xfffff410
   \   00000016   3060               STR      R0,[R6, #+0]
   \   00000018   0007               LSLS     R0,R0,#+28
   \   0000001A   2860               STR      R0,[R5, #+0]
   \   0000001C   3060               STR      R0,[R6, #+0]
   \   0000001E   4008               LSRS     R0,R0,#+1
   \   00000020   2860               STR      R0,[R5, #+0]
   \   00000022   3060               STR      R0,[R6, #+0]
   \   00000024   4008               LSRS     R0,R0,#+1
   \   00000026   2860               STR      R0,[R5, #+0]
   \   00000028   3060               STR      R0,[R6, #+0]
   \   0000002A   4008               LSRS     R0,R0,#+1
   \   0000002C   2860               STR      R0,[R5, #+0]
   \   0000002E   3060               STR      R0,[R6, #+0]
   \   00000030   1020               MOVS     R0,#+16
   \   00000032   2860               STR      R0,[R5, #+0]
   \   00000034   3060               STR      R0,[R6, #+0]
   \   00000036   F030               ADDS     R0,R0,#+240
   \   00000038   2860               STR      R0,[R5, #+0]
   \   0000003A   3060               STR      R0,[R6, #+0]
   \   0000003C   8004               LSLS     R0,R0,#+18
   \   0000003E   2860               STR      R0,[R5, #+0]
   \   00000040   3060               STR      R0,[R6, #+0]
   \   00000042   4008               LSRS     R0,R0,#+1
   \   00000044   2860               STR      R0,[R5, #+0]
   \   00000046   3060               STR      R0,[R6, #+0]
   \   00000048   800A               LSRS     R0,R0,#+10
   \   0000004A   2860               STR      R0,[R5, #+0]
   \   0000004C   3060               STR      R0,[R6, #+0]
   \   0000004E   4000               LSLS     R0,R0,#+1
   \   00000050   2860               STR      R0,[R5, #+0]
   \   00000052   3060               STR      R0,[R6, #+0]
   \   00000054   C001               LSLS     R0,R0,#+7
   \   00000056   2860               STR      R0,[R5, #+0]
   \   00000058   3060               STR      R0,[R6, #+0]
   \   0000005A   0120               MOVS     R0,#+1
   \   0000005C   2860               STR      R0,[R5, #+0]
   \   0000005E   3060               STR      R0,[R6, #+0]
   \   00000060   A148               LDR      R0,??main_0+0x10  ;; 0xfffff430
   \   00000062   A249               LDR      R1,??main_0+0x14  ;; 0x7e00811c
   \   00000064   0160               STR      R1,[R0, #+0]
   2070              Init_LCD_TS();           //inicjalizacja Touchpanel`a
   \   00000066   ........           BL       Init_LCD_TS
   2071              CheckLCD();
   \   0000006A   ........           BL       CheckLCD
   2072              
   2073              CleanCanvas(); 
   \   0000006E   ........           BL       CleanCanvas
   2074              MenuPaint();    
   \   00000072   ........           BL       MenuPaint
   2075              RepaintLCD();
   \   00000076   ........           BL       RepaintLCD
   2076              RepaintLCD();     
   \   0000007A   ........           BL       RepaintLCD
   \   0000007E   9C48               LDR      R0,??main_0+0x18  ;; RF_Status
   \   00000080   0121               MOVS     R1,#+1
   \   00000082   0170               STRB     R1,[R0, #+0]
   \   00000084   6846               MOV      R0,SP
   \   00000086   0221               MOVS     R1,#+2
   \   00000088   0171               STRB     R1,[R0, #+4]
   2077            
   2078              RF_Status.Init=1;
   2079              
   2080              
   2081              _NodeInfo  NodeInfo;
   2082              #ifdef S300
   2083                NodeInfo.Model=mS300;
   2084              #endif
   2085              #ifdef S300i  
   2086                NodeInfo.Model=mS300i;
   2087              #endif
   2088              #ifdef S300iMax 
   2089                NodeInfo.Model=mS300iMax;  
   2090              #endif  
   2091              #ifdef S300iOld  
   2092                NodeInfo.Model=mS300i;
   2093              #endif  
   2094              
   2095              //char SysV=(system[0])-0x30;  
   2096              NodeInfo.SoftVersion=(system[0])-0x30;  
   2097              //SysV=(system[2])-0x30;  
   2098              NodeInfo.SoftSubVersion=(system[2])-0x30;  
   \   0000008A   01A8               ADD      R0,SP,#+4
   \   0000008C   4121               MOVS     R1,#+65
   \   0000008E   4170               STRB     R1,[R0, #+1]
   \   00000090   9848               LDR      R0,??main_0+0x1C  ;; MainStage + 950
   \   00000092   6946               MOV      R1,SP
   \   00000094   8988               LDRH     R1,[R1, #+4]
   \   00000096   0180               STRH     R1,[R0, #+0]
   2099              MainStage.StageQ[0].Value[0xA]=NodeInfo.NodeInfoWord;  
   2100              
   2101              
   2102              AT91F_PIO_CfgOutput(AT91C_BASE_PIOA, SpeakerPin);
                                                          ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   00000098   8020               MOVS     R0,#+128
   \   0000009A   0006               LSLS     R0,R0,#+24       ;; #-2147483648
   \   0000009C   2860               STR      R0,[R5, #+0]
   \   0000009E   3060               STR      R0,[R6, #+0]
   2103              AT91C_BASE_PIOA->PIO_CODR =SpeakerPin;
                                                ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   000000A0   9549               LDR      R1,??main_0+0x20  ;; 0xfffff434
   \   000000A2   0860               STR      R0,[R1, #+0]
   2104              
   2105              //uruchomienie Watchdog`a na 60s 
   2106              /*watchdogEnable(60000);  
   2107              AT91F_WDTRestart(AT91C_BASE_WDTC);
   2108              AT91C_BASE_WDTC->WDTC_WDMR=(unsigned int) AT91C_WDTC_WDV|AT91C_WDTC_WDRSTEN | AT91C_WDTC_WDD|0x0<<15;
   2109          
   2110              AT91C_BASE_WDTC->WDTC_WDMR=AT91C_WDTC_WDDIS; 
   2111              */
   2112             
   2113              
   2114              SpiMaster_Init();
   \   000000A4   ........           BL       SpiMaster_Init
   2115              
   2116              __enable_interrupt(); 
   \   000000A8   ........           BL       __iar_enable_interrupt
   2117          
   2118             InitRTC();  
   \   000000AC   ........           BL       InitRTC
   2119              GetDateTimeFromRTC(); 
   \   000000B0   ........           BL       GetDateTimeFromRTC
   2120           
   2121              InitFramework();
   \   000000B4   ........           BL       InitFramework
   \   000000B8   9049               LDR      R1,??main_0+0x24  ;; sUsb
   \   000000BA   2000               MOVS     R0,R4
   \   000000BC   8030               ADDS     R0,R0,#+128
   2122          
   2123              SER_Init(&sSer, &sUsb);  // Initialize the serial driver
   \   000000BE   ........           BL       SER_Init
   2124          
   2125              InitFlash();  
   \   000000C2   ........           BL       InitFlash
   2126            
   2127              
   2128              Init_LCD_Light_PWM(WypMaxJasnosci);
                     ^
Warning[Pe223]: function "Init_LCD_Light_PWM" declared implicitly
   \   000000C6   607D               LDRB     R0,[R4, #+21]
   \   000000C8   ........           BL       Init_LCD_Light_PWM
   2129              
   2130              __enable_interrupt();    
   \   000000CC   ........           BL       __iar_enable_interrupt
   2131           
   2132            
   2133                
   2134              #ifndef _DEBUG_
   2135              //******************************************************************************
   2136              //Ustawienia dla pierwszego uruchomienia starownika ****************************
   2137                if (pAT91C_IFLASH_MEM->Config.FerstRun!=0x0A)
   \   000000D0   8B48               LDR      R0,??main_0+0x28  ;; 0xd7e7
   \   000000D2   616D               LDR      R1,[R4, #+84]
   \   000000D4   085C               LDRB     R0,[R1, R0]
   \   000000D6   0A28               CMP      R0,#+10
   \   000000D8   11D0               BEQ      ??main_1
   2138                {
   2139                  char WriteTmp;
   2140                 //zapis ustawieñ do flasha 
   2141                
   2142                 unsigned int Save = __get_interrupt_state();            
   \   000000DA   ........           BL       __iar_get_interrupt_state
   \   000000DE   0500               MOVS     R5,R0
   2143                 __disable_interrupt();
   \   000000E0   ........           BL       __iar_disable_interrupt
   2144                     //uruchomiono sterownik  
   2145                     WriteTmp=0xA;    FlashWrite((char*)&(AT91C_IFLASH_MEM->Config.FerstRun),&WriteTmp,1);
                                             ^
Warning[Pe223]: function "FlashWrite" declared implicitly
   \   000000E4   6846               MOV      R0,SP
   \   000000E6   0A21               MOVS     R1,#+10
   \   000000E8   0170               STRB     R1,[R0, #+0]
   \   000000EA   0122               MOVS     R2,#+1
   \   000000EC   6946               MOV      R1,SP
   \   000000EE   8548               LDR      R0,??main_0+0x2C  ;; 0x13d7e7
   \   000000F0   ........           BL       FlashWrite
   2146                 __set_interrupt_state(Save);
   \   000000F4   2800               MOVS     R0,R5
   \   000000F6   ........           BL       __iar_set_interrupt_state
   2147                 __enable_interrupt(); 
   \   000000FA   ........           BL       __iar_enable_interrupt
   \                     ??main_1:
   \   000000FE   8248               LDR      R0,??main_0+0x30  ;; gProg
   2148            
   2149          
   2150                  }
   2151              #endif 
   2152           
   2153               
   2154                
   2155              //Koniec ustawieñ dla pierwszego uruchomienia starownika ***********************
   2156              //******************************************************************************
   2157          
   2158              ProgramChangeExecute(&gProg); 
   \   00000100   ........           BL       ProgramChangeExecute
   2159              ThermostatsTimeChartExecute();
   \   00000104   ........           BL       ThermostatsTimeChartExecute
   2160              
   2161              
   2162           //   US0_init();                                                                //inicjalizacja USART0
   2163             
   2164          #ifdef __WIFI_MODULE    
   2165              US1_init();                                                                 //inicjalizacja USART1
   \   00000108   ........           BL       US1_init
   2166          #endif
   2167              
   2168           //   Timer_10us_Setup();
   2169              Timer_1ms_Setup();
   \   0000010C   ........           BL       Timer_1ms_Setup
   2170              Timer_10ms_Setup();
   \   00000110   ........           BL       Timer_10ms_Setup
   2171              
   2172              //Timer_1s();   
   2173                
   2174              for (int aaa=0; aaa<0xEFFFFF; aaa++)
   \   00000114   7D48               LDR      R0,??main_0+0x34  ;; 0xefffff
   2175                      {
   2176                        asm( "nop" );
   \                     ??main_2:
   \   00000116   C046               nop              
   2177                      }       
   \   00000118   401E               SUBS     R0,R0,#+1
   \   0000011A   FCD1               BNE      ??main_2
   2178          
   2179              g_ScreenSever_On=pAT91C_IFLASH_MEM->Config.ScreenSever_On;
   \   0000011C   7C48               LDR      R0,??main_0+0x38  ;; 0xd7e6
   \   0000011E   616D               LDR      R1,[R4, #+84]
   \   00000120   0D18               ADDS     R5,R1,R0
   \   00000122   2879               LDRB     R0,[R5, #+4]
   \   00000124   A073               STRB     R0,[R4, #+14]
   2180              g_ScreenSever_Time_On=pAT91C_IFLASH_MEM->Config.ScreenSever_Time_On;
   \   00000126   6879               LDRB     R0,[R5, #+5]
   \   00000128   E073               STRB     R0,[R4, #+15]
   2181              g_ScreenSever_Time_Off=pAT91C_IFLASH_MEM->Config.ScreenSever_Time_Off;
   \   0000012A   A879               LDRB     R0,[R5, #+6]
   \   0000012C   2074               STRB     R0,[R4, #+16]
   2182              
   2183          
   2184          
   2185              
   2186              //odczyt NODE_ID
   2187              if ((AT91C_IFLASH_MEM->NODE_ID!=0) && (AT91C_IFLASH_MEM->NODE_ID!=0xFFFFFFFF))
   \   0000012E   7948               LDR      R0,??main_0+0x3C  ;; 0x13d95c
   \   00000130   0168               LDR      R1,[R0, #+0]
   \   00000132   0029               CMP      R1,#+0
   \   00000134   10D0               BEQ      ??main_3
   \   00000136   0168               LDR      R1,[R0, #+0]
   \   00000138   0022               MOVS     R2,#+0
   \   0000013A   D243               MVNS     R2,R2            ;; #-1
   \   0000013C   9142               CMP      R1,R2
   \   0000013E   0BD0               BEQ      ??main_3
   2188              {
   2189                RF_Status.RF_ID_R=AT91C_IFLASH_MEM->NODE_ID;//pe³ne id
   \   00000140   CD49               LDR      R1,??main_4      ;; RF_Status + 28
   \   00000142   0268               LDR      R2,[R0, #+0]
   \   00000144   0A60               STR      R2,[R1, #+0]
   2190                RF_Status.RF_ID=AT91C_IFLASH_MEM->NODE_ID-(AT91C_IFLASH_MEM->NODE_ID/1000000)*1000000;
   \   00000146   CD4E               LDR      R6,??main_4+0x4  ;; 0xf4240
   \   00000148   0768               LDR      R7,[R0, #+0]
   \   0000014A   3800               MOVS     R0,R7
   \   0000014C   3100               MOVS     R1,R6
   \   0000014E   ........           BL       __aeabi_idivmod
   \   00000152   7043               MULS     R0,R6,R0
   \   00000154   381A               SUBS     R0,R7,R0
   \   00000156   03E0               B        ??main_5
   2191              }else{
   2192                RF_Status.RF_ID_R=9999999; //pe³ne id
   \                     ??main_3:
   \   00000158   C748               LDR      R0,??main_4      ;; RF_Status + 28
   \   0000015A   C949               LDR      R1,??main_4+0x8  ;; 0x98967f
   \   0000015C   0160               STR      R1,[R0, #+0]
   2193                RF_Status.RF_ID=999999;  //skrócone id (rejestrowe)
   \   0000015E   C948               LDR      R0,??main_4+0xC  ;; 0xf423f
   \                     ??main_5:
   \   00000160   C949               LDR      R1,??main_4+0x10  ;; RF_Status + 24
   \   00000162   0860               STR      R0,[R1, #+0]
   2194              }
   2195              
   2196              
   2197           
   2198          //uruchomienie RF
   2199              
   2200              //odczyt kanalu z flasha ------------------------------ 
   2201              
   2202              SlaveMode=pAT91C_IFLASH_MEM->Config.SlaveMode;
   \   00000164   A878               LDRB     R0,[R5, #+2]
   \   00000166   6076               STRB     R0,[R4, #+25]
   2203              RF_Status.Ch=pAT91C_IFLASH_MEM->Config.RF_channel;
   \   00000168   2878               LDRB     R0,[R5, #+0]
   2204              if (RF_Status.Ch==0) RF_Status.Ch=1;
   \   0000016A   0028               CMP      R0,#+0
   \   0000016C   00D1               BNE      ??main_6
   \   0000016E   0120               MOVS     R0,#+1
   \                     ??main_6:
   \   00000170   C649               LDR      R1,??main_4+0x14  ;; RF_Status + 14
   \   00000172   0870               STRB     R0,[R1, #+0]
   2205              
   2206              
   2207              InitPioInterrupt();
                     ^
Warning[Pe223]: function "InitPioInterrupt" declared implicitly
   \   00000174   ........           BL       InitPioInterrupt
   2208              
   2209              RF_Init();
   \   00000178   ........           BL       RF_Init
   2210              
   2211              
   2212              char InitRF=1;
   2213              
   2214              while (InitRF==1)
   2215              { 
   2216                  InitRF=RF_Status.Init;
   \                     ??main_7:
   \   0000017C   5C48               LDR      R0,??main_0+0x18  ;; RF_Status
   \   0000017E   0578               LDRB     R5,[R0, #+0]
   2217                  Delay(0x1);
   \   00000180   0120               MOVS     R0,#+1
   \   00000182   ........           BL       Delay
   2218              };
   \   00000186   012D               CMP      R5,#+1
   \   00000188   F8D0               BEQ      ??main_7
   2219          
   2220              
   2221          
   2222              //sprawdzenie kana³u transmisji radiowej
   2223              if (!SlaveMode) //je¿eli master
   \   0000018A   607E               LDRB     R0,[R4, #+25]
   \   0000018C   0028               CMP      R0,#+0
   \   0000018E   63D1               BNE      ??main_8
   2224              {
   2225                  SPI_SendWord(0xA000 | RF_SetFreqReg(RF_Status.Ch),Cs_RF); 
                         ^
Warning[Pe223]: function "SPI_SendWord" declared implicitly
   \   00000190   A026               MOVS     R6,#+160
   \   00000192   3602               LSLS     R6,R6,#+8        ;; #+40960
   \   00000194   BD48               LDR      R0,??main_4+0x14  ;; RF_Status + 14
   \   00000196   0078               LDRB     R0,[R0, #+0]
   \   00000198   ........           BL       __aeabi_ui2d
   \   0000019C   0200               MOVS     R2,R0
   \   0000019E   0B00               MOVS     R3,R1
   \   000001A0   BB48               LDR      R0,??main_4+0x18  ;; 0x33333333
   \   000001A2   BC49               LDR      R1,??main_4+0x1C  ;; 0x3fd33333
   \   000001A4   ........           BL       __aeabi_dmul
   \   000001A8   0200               MOVS     R2,R0
   \   000001AA   0B00               MOVS     R3,R1
   \   000001AC   BA48               LDR      R0,??main_4+0x20  ;; 0x5c28f5c3
   \   000001AE   BB49               LDR      R1,??main_4+0x24  ;; 0x408ae28f
   \   000001B0   ........           BL       __aeabi_dadd
   \   000001B4   0200               MOVS     R2,R0
   \   000001B6   0B00               MOVS     R3,R1
   \   000001B8   0020               MOVS     R0,#+0
   \   000001BA   B949               LDR      R1,??main_4+0x28  ;; 0x40690000
   \   000001BC   ........           BL       __aeabi_dmul
   \   000001C0   0200               MOVS     R2,R0
   \   000001C2   0B00               MOVS     R3,R1
   \   000001C4   0020               MOVS     R0,#+0
   \   000001C6   B749               LDR      R1,??main_4+0x2C  ;; 0xc104ff00
   \   000001C8   ........           BL       __aeabi_dadd
   \   000001CC   ........           BL       __aeabi_d2iz
   \   000001D0   0004               LSLS     R0,R0,#+16
   \   000001D2   0014               ASRS     R0,R0,#+16
   \   000001D4   3043               ORRS     R0,R0,R6
   \   000001D6   0221               MOVS     R1,#+2
   \   000001D8   ........           BL       SPI_SendWord
   2226                  RF_Status.EnableRX();
   \   000001DC   B248               LDR      R0,??main_4+0x30  ;; RF_Status + 40
   \   000001DE   0068               LDR      R0,[R0, #+0]
   \   000001E0   ........           BL       __iar_via_R0
   2227                  Delay(0x100000);
   \   000001E4   8020               MOVS     R0,#+128
   \   000001E6   4003               LSLS     R0,R0,#+13       ;; #+1048576
   \   000001E8   ........           BL       Delay
   \   000001EC   26E0               B        ??main_9
   2228                  while (RF_CheckChannel())                                                                                            
   2229                  {
   2230                    
   2231                      if (RF_Status.Ch<RF_ChannelQuanti-1) {RF_Status.Ch++;} else {RF_Status.Ch=1;}
   \                     ??main_10:
   \   000001EE   0120               MOVS     R0,#+1
   \                     ??main_11:
   \   000001F0   A649               LDR      R1,??main_4+0x14  ;; RF_Status + 14
   \   000001F2   0870               STRB     R0,[R1, #+0]
   2232                      SPI_SendWord(0xA000 | RF_SetFreqReg(RF_Status.Ch),Cs_RF); 
   \   000001F4   0006               LSLS     R0,R0,#+24
   \   000001F6   000E               LSRS     R0,R0,#+24
   \   000001F8   ........           BL       __aeabi_ui2d
   \   000001FC   0200               MOVS     R2,R0
   \   000001FE   0B00               MOVS     R3,R1
   \   00000200   A348               LDR      R0,??main_4+0x18  ;; 0x33333333
   \   00000202   A449               LDR      R1,??main_4+0x1C  ;; 0x3fd33333
   \   00000204   ........           BL       __aeabi_dmul
   \   00000208   0200               MOVS     R2,R0
   \   0000020A   0B00               MOVS     R3,R1
   \   0000020C   A248               LDR      R0,??main_4+0x20  ;; 0x5c28f5c3
   \   0000020E   A349               LDR      R1,??main_4+0x24  ;; 0x408ae28f
   \   00000210   ........           BL       __aeabi_dadd
   \   00000214   0200               MOVS     R2,R0
   \   00000216   0B00               MOVS     R3,R1
   \   00000218   0020               MOVS     R0,#+0
   \   0000021A   A149               LDR      R1,??main_4+0x28  ;; 0x40690000
   \   0000021C   ........           BL       __aeabi_dmul
   \   00000220   0200               MOVS     R2,R0
   \   00000222   0B00               MOVS     R3,R1
   \   00000224   0020               MOVS     R0,#+0
   \   00000226   9F49               LDR      R1,??main_4+0x2C  ;; 0xc104ff00
   \   00000228   ........           BL       __aeabi_dadd
   \   0000022C   ........           BL       __aeabi_d2iz
   \   00000230   0004               LSLS     R0,R0,#+16
   \   00000232   0014               ASRS     R0,R0,#+16
   \   00000234   3043               ORRS     R0,R0,R6
   \   00000236   0221               MOVS     R1,#+2
   \   00000238   ........           BL       SPI_SendWord
   \                     ??main_9:
   \   0000023C   ........           BL       RF_CheckChannel
   \   00000240   0028               CMP      R0,#+0
   \   00000242   05D0               BEQ      ??main_12
   \   00000244   9148               LDR      R0,??main_4+0x14  ;; RF_Status + 14
   \   00000246   0078               LDRB     R0,[R0, #+0]
   \   00000248   2728               CMP      R0,#+39
   \   0000024A   D0D2               BCS      ??main_10
   \   0000024C   401C               ADDS     R0,R0,#+1
   \   0000024E   CFE7               B        ??main_11
   2233                  }  
   2234                  RF_Status.MasterMode=1;
   \                     ??main_12:
   \   00000250   9648               LDR      R0,??main_4+0x34  ;; RF_Status + 13
   \   00000252   0121               MOVS     R1,#+1
   \   00000254   0170               STRB     R1,[R0, #+0]
   \   00000256   0DE0               B        ??main_13
   2235              }else{  //je¿eli slave
   2236                
   2237                /*
   2238                  SPI_SendWord(0xA000 | RF_SetFreqReg(RF_Status.Ch),Cs_RF); 
   2239                  RF_Status.EnableRX();
   2240                  Delay(0x100000);
   2241                  while (RF_CheckChannel())                                                                                            
   2242                  {
   2243                    
   2244                      if (RF_Status.Ch<RF_ChannelQuanti-1) {RF_Status.Ch++;} else {RF_Status.Ch=1;}
   2245                      SPI_SendWord(0xA000 | RF_SetFreqReg(RF_Status.Ch),Cs_RF); 
   2246                  }  
   2247                */
   2248                
   2249                  RF_Status.ChSlave=1;
   \                     ??main_8:
   \   00000258   9548               LDR      R0,??main_4+0x38  ;; RF_Status + 15
   \   0000025A   0121               MOVS     R1,#+1
   \   0000025C   0170               STRB     R1,[R0, #+0]
   2250                  SPI_SendWord(0xA000 | RF_SetFreqReg(RF_Status.ChSlave),Cs_RF);  
                         ^
Warning[Pe223]: function "SPI_SendWord" declared implicitly
   \   0000025E   0221               MOVS     R1,#+2
   \   00000260   9448               LDR      R0,??main_4+0x3C  ;; 0xa07c
   \   00000262   ........           BL       SPI_SendWord
   2251                  RF_Status.MasterMode=0;  
   \   00000266   9148               LDR      R0,??main_4+0x34  ;; RF_Status + 13
   \   00000268   0021               MOVS     R1,#+0
   \   0000026A   0170               STRB     R1,[R0, #+0]
   2252                  RF_Status.EnableRX();
   \   0000026C   8E48               LDR      R0,??main_4+0x30  ;; RF_Status + 40
   \   0000026E   0068               LDR      R0,[R0, #+0]
   \   00000270   ........           BL       __iar_via_R0
   2253              }
   2254          
   2255              RF_Status.AllReady=1;
   \                     ??main_13:
   \   00000274   9048               LDR      R0,??main_4+0x40  ;; RF_Status + 16
   \   00000276   0121               MOVS     R1,#+1
   \   00000278   0170               STRB     R1,[R0, #+0]
   2256              
   2257              
   2258              
   2259          
   2260          
   2261              
   2262              
   2263              //odczyt has³a------------------------------------------    
   2264              if (pAT91C_IFLASH_MEM->Config.NeedPass1==0xEC)
   \   0000027A   616D               LDR      R1,[R4, #+84]
   \   0000027C   8F48               LDR      R0,??main_4+0x44  ;; 0xd7dc
   \   0000027E   085C               LDRB     R0,[R1, R0]
   \   00000280   EC28               CMP      R0,#+236
   \   00000282   13D1               BNE      ??main_14
   2265              {//je¿eli nie wymagane has³o
   2266               g_NeedPass=0; 
   \   00000284   0020               MOVS     R0,#+0
   \   00000286   A074               STRB     R0,[R4, #+18]
   2267               for (char i=0; i<8; i++) g_Password_1[i]=pAT91C_IFLASH_MEM->Config.Pass1[i];
   \   00000288   2000               MOVS     R0,R4
   \   0000028A   2030               ADDS     R0,R0,#+32
   \   0000028C   8C4A               LDR      R2,??main_4+0x48  ;; 0xd7dd
   \   0000028E   8918               ADDS     R1,R1,R2
   \   00000290   0222               MOVS     R2,#+2
   \                     ??main_15:
   \   00000292   0B78               LDRB     R3,[R1, #+0]
   \   00000294   0370               STRB     R3,[R0, #+0]
   \   00000296   4B78               LDRB     R3,[R1, #+1]
   \   00000298   4370               STRB     R3,[R0, #+1]
   \   0000029A   8B78               LDRB     R3,[R1, #+2]
   \   0000029C   8370               STRB     R3,[R0, #+2]
   \   0000029E   CB78               LDRB     R3,[R1, #+3]
   \   000002A0   C370               STRB     R3,[R0, #+3]
   \   000002A2   091D               ADDS     R1,R1,#+4
   \   000002A4   001D               ADDS     R0,R0,#+4
   \   000002A6   521E               SUBS     R2,R2,#+1
   \   000002A8   4ED0               BEQ      ??main_16
   \   000002AA   F2E7               B        ??main_15
   2268              }else if (pAT91C_IFLASH_MEM->Config.NeedPass1==0xEB)
   \                     ??main_14:
   \   000002AC   EB28               CMP      R0,#+235
   \   000002AE   33D1               BNE      ??main_17
   2269              {//je¿eli nie wymagane has³o
   2270               g_NeedPass=1; 
   \   000002B0   0120               MOVS     R0,#+1
   \   000002B2   A074               STRB     R0,[R4, #+18]
   2271               for (char i=0; i<8; i++) g_Password_1[i]=pAT91C_IFLASH_MEM->Config.Pass1[i];
   \   000002B4   2000               MOVS     R0,R4
   \   000002B6   2030               ADDS     R0,R0,#+32
   \   000002B8   814A               LDR      R2,??main_4+0x48  ;; 0xd7dd
   \   000002BA   8918               ADDS     R1,R1,R2
   \   000002BC   0222               MOVS     R2,#+2
   \                     ??main_18:
   \   000002BE   0B78               LDRB     R3,[R1, #+0]
   \   000002C0   0370               STRB     R3,[R0, #+0]
   \   000002C2   4B78               LDRB     R3,[R1, #+1]
   \   000002C4   4370               STRB     R3,[R0, #+1]
   \   000002C6   8B78               LDRB     R3,[R1, #+2]
   \   000002C8   8370               STRB     R3,[R0, #+2]
   \   000002CA   CB78               LDRB     R3,[R1, #+3]
   \   000002CC   C370               STRB     R3,[R0, #+3]
   \   000002CE   091D               ADDS     R1,R1,#+4
   \   000002D0   001D               ADDS     R0,R0,#+4
   \   000002D2   521E               SUBS     R2,R2,#+1
   \   000002D4   38D0               BEQ      ??main_16
   \   000002D6   F2E7               B        ??main_18
   \                     ??main_0:
   \   000002D8   ........           DC32     DateTime
   \   000002DC   10FCFFFF           DC32     0xfffffc10
   \   000002E0   00F4FFFF           DC32     0xfffff400
   \   000002E4   10F4FFFF           DC32     0xfffff410
   \   000002E8   30F4FFFF           DC32     0xfffff430
   \   000002EC   1C81007E           DC32     0x7e00811c
   \   000002F0   ........           DC32     RF_Status
   \   000002F4   ........           DC32     MainStage + 950
   \   000002F8   34F4FFFF           DC32     0xfffff434
   \   000002FC   ........           DC32     sUsb
   \   00000300   E7D70000           DC32     0xd7e7
   \   00000304   E7D71300           DC32     0x13d7e7
   \   00000308   ........           DC32     gProg
   \   0000030C   FFFFEF00           DC32     0xefffff
   \   00000310   E6D70000           DC32     0xd7e6
   \   00000314   5CD91300           DC32     0x13d95c
   2272              }else
   2273              {//jezeli nie zdefiniowano  - zdefiniuj i zapisz has³o domyœlne i ustaw jako nie wymagane
   2274               
   2275               //zapis has³a do flash
   2276               unsigned int Save = __get_interrupt_state();  
   \                     ??main_17:
   \   00000318   ........           BL       __iar_get_interrupt_state
   \   0000031C   0500               MOVS     R5,R0
   2277               __disable_interrupt();
   \   0000031E   ........           BL       __iar_disable_interrupt
   2278               //at91flashWrite((int*)(&(AT91C_IFLASH_MEM->Config.Pass1[0])),0,g_Password_1,9);
   2279               
   2280                FlashWrite((char*)(&(AT91C_IFLASH_MEM->Config.Pass1[0])), g_Password_1, 9);
                       ^
Warning[Pe223]: function "FlashWrite" declared implicitly
   \   00000322   0922               MOVS     R2,#+9
   \   00000324   2100               MOVS     R1,R4
   \   00000326   2031               ADDS     R1,R1,#+32
   \   00000328   6648               LDR      R0,??main_4+0x4C  ;; 0x13d7dd
   \   0000032A   ........           BL       FlashWrite
   2281               char NeedPassFlag=0xEC;
   \   0000032E   6846               MOV      R0,SP
   \   00000330   EC21               MOVS     R1,#+236
   \   00000332   0170               STRB     R1,[R0, #+0]
   2282               g_NeedPass=0; 
   \   00000334   0020               MOVS     R0,#+0
   \   00000336   A074               STRB     R0,[R4, #+18]
   2283               //at91flashWrite((int*)(&(AT91C_IFLASH_MEM->Config.NeedPass1)),0,&NeedPassFlag,1);
   2284               FlashWrite((char*)(&(AT91C_IFLASH_MEM->Config.NeedPass1)), &NeedPassFlag, 1);
   \   00000338   0122               MOVS     R2,#+1
   \   0000033A   6946               MOV      R1,SP
   \   0000033C   6248               LDR      R0,??main_4+0x50  ;; 0x13d7dc
   \   0000033E   ........           BL       FlashWrite
   2285               __set_interrupt_state(Save);
   \   00000342   2800               MOVS     R0,R5
   \   00000344   ........           BL       __iar_set_interrupt_state
   2286               //koniec zapisu do flash
   2287              }
   2288              //koniec odczytu has³a ---------------------------------------- 
   2289          
   2290          
   2291              
   2292              
   2293              
   2294              
   2295              USB_Connect(&sUsb);    
   \                     ??main_16:
   \   00000348   6048               LDR      R0,??main_4+0x54  ;; sUsb
   \   0000034A   6149               LDR      R1,??main_4+0x58  ;; sDefaultDriver + 20
   \   0000034C   0968               LDR      R1,[R1, #+0]
   \   0000034E   C96A               LDR      R1,[R1, #+44]
   \   00000350   ........           BL       __iar_via_R1
   2296             __enable_interrupt();   
   \   00000354   ........           BL       __iar_enable_interrupt
   \   00000358   5E49               LDR      R1,??main_4+0x5C  ;; NET
   \   0000035A   5F48               LDR      R0,??main_4+0x60  ;; 0xfffc4000
   2297             
   2298             
   2299           
   2300          #ifdef __WIFI_MODULE   
   2301             InitWizFi(AT91C_BASE_US1, &NET);
   \   0000035C   ........           BL       InitWizFi
   \   00000360   5E48               LDR      R0,??main_4+0x64  ;; MainStage + 1771
   \   00000362   0190               STR      R0,[SP, #+4]
   2302          #endif
   2303          
   2304             
   2305             
   2306              /*
   2307             //ustawienie wys³ania stanów  do wszystkich wêz³ów po restarcie
   2308              for (char i=0; i<NumberNeurons; i++)
   2309              {
   2310                MainStage.SendStageChange[i]=ChangeStageFlag; 
   2311              }
   2312             */
   2313             
   2314             
   2315              while (1) 
   2316              {
   2317                  AT91F_WDTRestart(AT91C_BASE_WDTC);
   \                     ??main_19:
   \   00000364   5E48               LDR      R0,??main_4+0x68  ;; 0xfffffd40
   \   00000366   5F49               LDR      R1,??main_4+0x6C  ;; 0xa5000001
   \   00000368   0160               STR      R1,[R0, #+0]
   2318                  
   2319                  
   2320                  if (ForwardUSB2Serialferst==1)
   \   0000036A   A07E               LDRB     R0,[R4, #+26]
   \   0000036C   0128               CMP      R0,#+1
   \   0000036E   07D1               BNE      ??main_20
   2321                  {
   2322                      // Start USB->Serial forward mechanism
   2323                      ForwardUSB2Serial(0, 0, 0, 0);
   \   00000370   0023               MOVS     R3,#+0
   \   00000372   0022               MOVS     R2,#+0
   \   00000374   1100               MOVS     R1,R2
   \   00000376   0800               MOVS     R0,R1
   \   00000378   ........           BL       ForwardUSB2Serial
   2324                      ForwardUSB2Serialferst=2;
   \   0000037C   0220               MOVS     R0,#+2
   \   0000037E   A076               STRB     R0,[R4, #+26]
   2325                  }
   2326                
   2327                 
   2328                  
   2329                 
   2330                 if ((!((AT91C_BASE_PIOA->PIO_PDSR) & AT91C_VBUS)) && (VBUS_old==1))
   \                     ??main_20:
   \   00000380   5948               LDR      R0,??main_4+0x70  ;; 0xfffff43c
   \   00000382   0068               LDR      R0,[R0, #+0]
   \   00000384   0221               MOVS     R1,#+2
   \   00000386   0842               TST      R0,R1
   \   00000388   08D1               BNE      ??main_21
   \   0000038A   5848               LDR      R0,??main_4+0x74  ;; VBUS_old
   \   0000038C   0078               LDRB     R0,[R0, #+0]
   \   0000038E   0128               CMP      R0,#+1
   \   00000390   04D1               BNE      ??main_21
   2331                 {
   2332                   VBUS_old=0;
   \   00000392   5648               LDR      R0,??main_4+0x74  ;; VBUS_old
   \   00000394   0021               MOVS     R1,#+0
   \   00000396   0170               STRB     R1,[R0, #+0]
   2333                   ISR_VBus();
   \   00000398   ........           BL       ISR_VBus
   2334                 }
   2335                 /*
   2336                 if (((AT91C_BASE_PIOA->PIO_PDSR) & AT91C_VBUS) && (VBUS_old==0))
   2337                 {
   2338                   VBUS_old=1;
   2339                   ISR_VBus();
   2340                 } 
   2341                 */
   2342                 
   2343                  
   2344                  
   2345                   
   2346                  if ((g_NextTimeProgram<=g_counter) || (g_NextTimeProgram>g_counter+ProgramPeriod))
   \                     ??main_21:
   \   0000039C   2000               MOVS     R0,R4
   \   0000039E   3830               ADDS     R0,R0,#+56
   \   000003A0   0CC8               LDM      R0!,{R2,R3}
   \   000003A2   2000               MOVS     R0,R4
   \   000003A4   3030               ADDS     R0,R0,#+48
   \   000003A6   C0C8               LDM      R0!,{R6,R7}
   \   000003A8   9F42               CMP      R7,R3
   \   000003AA   0CD8               BHI      ??main_22
   \   000003AC   01D3               BCC      ??main_23
   \   000003AE   9642               CMP      R6,R2
   \   000003B0   09D2               BCS      ??main_22
   \                     ??main_23:
   \   000003B2   AF20               MOVS     R0,#+175
   \   000003B4   4000               LSLS     R0,R0,#+1        ;; #+350
   \   000003B6   0021               MOVS     R1,#+0
   \   000003B8   8019               ADDS     R0,R0,R6
   \   000003BA   7941               ADCS     R1,R1,R7
   \   000003BC   9942               CMP      R1,R3
   \   000003BE   27D8               BHI      ??main_24
   \   000003C0   01D3               BCC      ??main_22
   \   000003C2   9042               CMP      R0,R2
   \   000003C4   24D2               BCS      ??main_24
   2347                   {
   2348                    
   2349                     
   2350                       char WaitingRF_WrTask=0;
   \                     ??main_22:
   \   000003C6   0025               MOVS     R5,#+0
   2351                       if (g_NextTimeProgram<g_counter+1000)    //blokowanie wykonania programu jezeli istnieje oczekuj¹ce ¿¹danie wys³ania stanu do któregokolwiek wêz³a. Blokowanie nie mo¿e przekroczyæ 1s. 
   \   000003C8   FA20               MOVS     R0,#+250
   \   000003CA   8000               LSLS     R0,R0,#+2        ;; #+1000
   \   000003CC   0021               MOVS     R1,#+0
   \   000003CE   8019               ADDS     R0,R0,R6
   \   000003D0   7941               ADCS     R1,R1,R7
   \   000003D2   8B42               CMP      R3,R1
   \   000003D4   11D8               BHI      ??main_25
   \   000003D6   01D3               BCC      ??main_26
   \   000003D8   8242               CMP      R2,R0
   \   000003DA   0ED2               BCS      ??main_25
   2352                       {
   2353                           char Nd=1;
   \                     ??main_26:
   \   000003DC   0120               MOVS     R0,#+1
   2354                           while ((Nd<NumberNeurons) && (WaitingRF_WrTask==0))
   2355                            {
   2356                                if ((MainStage.SendStageChange[Nd]>0))    
   \                     ??main_27:
   \   000003DE   0199               LDR      R1,[SP, #+4]
   \   000003E0   095C               LDRB     R1,[R1, R0]
   \   000003E2   0029               CMP      R1,#+0
   \   000003E4   00D0               BEQ      ??main_28
   2357                                {
   2358                                    WaitingRF_WrTask=1;
   \   000003E6   0125               MOVS     R5,#+1
   2359                                }
   2360                                Nd++;  
   \                     ??main_28:
   \   000003E8   401C               ADDS     R0,R0,#+1
   2361                            } 
   \   000003EA   0106               LSLS     R1,R0,#+24
   \   000003EC   090E               LSRS     R1,R1,#+24
   \   000003EE   2329               CMP      R1,#+35
   \   000003F0   01D2               BCS      ??main_29
   \   000003F2   2900               MOVS     R1,R5
   \   000003F4   F3D0               BEQ      ??main_27
   2362                       }
   2363          
   2364                      if (WaitingRF_WrTask==0)
   \                     ??main_29:
   \   000003F6   002D               CMP      R5,#+0
   \   000003F8   0AD1               BNE      ??main_24
   2365                      {
   2366                        g_NextTimeProgram=g_counter+ProgramPeriod;
   \                     ??main_25:
   \   000003FA   2200               MOVS     R2,R4
   \   000003FC   3832               ADDS     R2,R2,#+56
   \   000003FE   AF20               MOVS     R0,#+175
   \   00000400   4000               LSLS     R0,R0,#+1        ;; #+350
   \   00000402   0021               MOVS     R1,#+0
   \   00000404   8019               ADDS     R0,R0,R6
   \   00000406   7941               ADCS     R1,R1,R7
   \   00000408   03C2               STM      R2!,{R0,R1}
   2367                        Program(&gProg);
   \   0000040A   3948               LDR      R0,??main_4+0x78  ;; gProg
   \   0000040C   ........           BL       Program
   2368                      }
   2369                      
   2370                      
   2371                      
   2372                      
   2373                   }
   2374                   
   2375                  
   2376                  if ((g_counter>4000) && (MenuLevel==0)) 
   \                     ??main_24:
   \   00000410   2000               MOVS     R0,R4
   \   00000412   3030               ADDS     R0,R0,#+48
   \   00000414   03C8               LDM      R0!,{R0,R1}
   \   00000416   374A               LDR      R2,??main_4+0x7C  ;; 0xfa1
   \   00000418   0023               MOVS     R3,#+0
   \   0000041A   9942               CMP      R1,R3
   \   0000041C   0BD3               BCC      ??main_30
   \   0000041E   01D8               BHI      ??main_31
   \   00000420   9042               CMP      R0,R2
   \   00000422   08D3               BCC      ??main_30
   \                     ??main_31:
   \   00000424   3448               LDR      R0,??main_4+0x80  ;; MenuLevel
   \   00000426   0068               LDR      R0,[R0, #+0]
   \   00000428   0028               CMP      R0,#+0
   \   0000042A   04D1               BNE      ??main_30
   2377                  { 
   2378                      MenuLevel=1;   
   \   0000042C   3248               LDR      R0,??main_4+0x80  ;; MenuLevel
   \   0000042E   0121               MOVS     R1,#+1
   \   00000430   0160               STR      R1,[R0, #+0]
   2379                    #ifdef _TESTER_ 
   2380          
   2381                      MenuLevel=1134;
   2382                    #endif   
   2383                    MenuPaint();
   \   00000432   ........           BL       MenuPaint
   2384                  }
   2385                  
   2386          
   2387                    
   2388          #ifdef __WIFI_MODULE     
   2389                  if (NET.WiFi.On)
   \                     ??main_30:
   \   00000436   3148               LDR      R0,??main_4+0x84  ;; NET + 80
   \   00000438   0078               LDRB     R0,[R0, #+0]
   \   0000043A   0028               CMP      R0,#+0
   \   0000043C   14D0               BEQ      ??main_32
   2390                  {
   2391                      //wifi-------------------------------------------------------------------
   2392                      if ((g_counter>6000) /*&&  (g_counter%200==0)*/)
   \   0000043E   2000               MOVS     R0,R4
   \   00000440   3030               ADDS     R0,R0,#+48
   \   00000442   03C8               LDM      R0!,{R0,R1}
   \   00000444   2E4A               LDR      R2,??main_4+0x88  ;; 0x1771
   \   00000446   0023               MOVS     R3,#+0
   \   00000448   9942               CMP      R1,R3
   \   0000044A   07D3               BCC      ??main_33
   \   0000044C   01D8               BHI      ??main_34
   \   0000044E   9042               CMP      R0,R2
   \   00000450   04D3               BCC      ??main_33
   2393                      {
   2394                        CheckVarChangeHTTP(Buff_TX_1 ,AT91C_BASE_US1, &NET);
   \                     ??main_34:
   \   00000452   204A               LDR      R2,??main_4+0x5C  ;; NET
   \   00000454   2049               LDR      R1,??main_4+0x60  ;; 0xfffc4000
   \   00000456   2B48               LDR      R0,??main_4+0x8C  ;; Buff_TX_1
   \   00000458   ........           BL       CheckVarChangeHTTP
   2395                      }
   2396                  
   2397                      WiFi(US1_Buffer, Buff_TX_1 ,AT91C_BASE_US1, &NET);
                                  ^
Warning[Pe167]: argument of type "unsigned char *" is incompatible with
          parameter of type "char *"

  static void CBK_Suspend(const S_usb *pUsb)
              ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\main.c",535  Warning[Pe177]: 
          function "CBK_Suspend" was declared but never referenced
   \                     ??main_33:
   \   0000045C   1D4B               LDR      R3,??main_4+0x5C  ;; NET
   \   0000045E   1E4A               LDR      R2,??main_4+0x60  ;; 0xfffc4000
   \   00000460   2849               LDR      R1,??main_4+0x8C  ;; Buff_TX_1
   \   00000462   2948               LDR      R0,??main_4+0x90  ;; US1_Buffer
   \   00000464   ........           BL       WiFi
   2398                  }
   2399                  //CheckConnectionStatus();
   2400          #endif  
   2401            
   2402                  
   2403                  
   2404                  //bezpiecznik RF zabezpiecza przed zablokowaniem RFa
   2405                  if (RF_Status.RfFuse>=60) 
   \                     ??main_32:
   \   00000468   2848               LDR      R0,??main_4+0x94  ;; RF_Status + 17
   \   0000046A   0078               LDRB     R0,[R0, #+0]
   \   0000046C   3C28               CMP      R0,#+60
   \   0000046E   00D2               BCS      .+4
   \   00000470   78E7               B        ??main_19
   2406                  {
   2407                      #ifdef _DEBUG_
   2408                               MESSAGE("Bezpiecznik RF"); 
   2409                      #endif
   2410                                
   2411                      RF_Init();          
   \   00000472   ........           BL       RF_Init
   \   00000476   75E7               B        ??main_19
   \                     ??main_4:
   \   00000478   ........           DC32     RF_Status + 28
   \   0000047C   40420F00           DC32     0xf4240
   \   00000480   7F969800           DC32     0x98967f
   \   00000484   3F420F00           DC32     0xf423f
   \   00000488   ........           DC32     RF_Status + 24
   \   0000048C   ........           DC32     RF_Status + 14
   \   00000490   33333333           DC32     0x33333333
   \   00000494   3333D33F           DC32     0x3fd33333
   \   00000498   C3F5285C           DC32     0x5c28f5c3
   \   0000049C   8FE28A40           DC32     0x408ae28f
   \   000004A0   00006940           DC32     0x40690000
   \   000004A4   00FF04C1           DC32     0xc104ff00
   \   000004A8   ........           DC32     RF_Status + 40
   \   000004AC   ........           DC32     RF_Status + 13
   \   000004B0   ........           DC32     RF_Status + 15
   \   000004B4   7CA00000           DC32     0xa07c
   \   000004B8   ........           DC32     RF_Status + 16
   \   000004BC   DCD70000           DC32     0xd7dc
   \   000004C0   DDD70000           DC32     0xd7dd
   \   000004C4   DDD71300           DC32     0x13d7dd
   \   000004C8   DCD71300           DC32     0x13d7dc
   \   000004CC   ........           DC32     sUsb
   \   000004D0   ........           DC32     sDefaultDriver + 20
   \   000004D4   ........           DC32     NET
   \   000004D8   0040FCFF           DC32     0xfffc4000
   \   000004DC   ........           DC32     MainStage + 1771
   \   000004E0   40FDFFFF           DC32     0xfffffd40
   \   000004E4   010000A5           DC32     0xa5000001
   \   000004E8   3CF4FFFF           DC32     0xfffff43c
   \   000004EC   ........           DC32     VBUS_old
   \   000004F0   ........           DC32     gProg
   \   000004F4   A10F0000           DC32     0xfa1
   \   000004F8   ........           DC32     MenuLevel
   \   000004FC   ........           DC32     NET + 80
   \   00000500   71170000           DC32     0x1771
   \   00000504   ........           DC32     Buff_TX_1
   \   00000508   ........           DC32     US1_Buffer
   \   0000050C   ........           DC32     RF_Status + 17
   2412                  }   
   2413              }
   2414             
   2415              
   2416          }

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   ........           DC32     sUsb

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   3CF4FFFF           DC32     0xfffff43c

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     MenuLevel

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   ........           DC32     sDefaultDriver + 20

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   24F1FFFF           DC32     0xfffff124

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   28F1FFFF           DC32     0xfffff128

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   20F1FFFF           DC32     0xfffff120

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   14F4FFFF           DC32     0xfffff414

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   00F4FFFF           DC32     0xfffff400

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   60F4FFFF           DC32     0xfffff460

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   ........           DC32     DateTime + 128

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   40FDFFFF           DC32     0xfffffd40

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   010000A5           DC32     0xa5000001

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   ........           DC32     DateTime

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   ........           DC32     gProg

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   70C60000           DC32     0xc670

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   00011300           DC32     0x130100

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   2ABC0000           DC32     0xbc2a

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable27:
   \   00000000   ........           DC32     MainStage + 182

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable28:
   \   00000000   AA8AFFFF           DC32     0xffff8aaa

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable29:
   \   00000000   10FCFFFF           DC32     0xfffffc10

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable30:
   \   00000000   C000FAFF           DC32     0xfffa00c0

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable31:
   \   00000000   C400FAFF           DC32     0xfffa00c4

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable32:
   \   00000000   01C00C00           DC32     0xcc001

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable33:
   \   00000000   20F1FFFF           DC32     0xfffff120

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable34:
   \   00000000   28F1FFFF           DC32     0xfffff128

   \                                 In section .rodata, align 4
   \                     `?<Constant "Wyladowana">`:
   \   00000000   57796C61646F       DC8 "Wyladowana"
   \              77616E6100  
   \   0000000B   00                 DC8 0
   \   0000000C   626174657269       DC8 "bateria"
   \              6100        
   \   00000014   57657A656C3A       DC8 "Wezel:"
   \              00          
   \   0000001B   00                 DC8 0

   \                                 In section .rodata, align 4
   \   00000000   20202000           DC8 "   "
   2417          

   Maximum stack usage in bytes:

     Function                    .cstack
     --------                    -------
     AlarmExecute                    48
     CBK_Init                         8
     CBK_NewRequest                   8
     CBK_Resume                       8
     Delay                            8
     ForwardUSB2Serial               24
     ISR_Driver                       8
     ISR_VBus                        24
     InitFramework                   24
     RamToFlash                      24
     SendViaUSB                      16
     TestHendel                       8
     TestInit                         8
     ThermostatsExecute              40
     ThermostatsTimeChartExecute     32
     Timer_10ms                      16
     Timer_10ms_Setup                 0
     Timer_10us                       0
     Timer_10us_Setup                 0
     Timer_1h                         8
     Timer_1min                       8
     Timer_1ms                       16
     Timer_1ms_Setup                  0
     Timer_1s                        72
     TimetableExecute                40
     main                            32
     watchdogEnable                   8


   Section sizes:

     Function/Label              Bytes
     --------------              -----
     identyfikacja                  8
     system                         4
     APC                            1
     g_czas_petli                   1
     komunikacja_ok                 4
     rej_prog                      40
     LifeCouter                     4
     LifeCouterMax                  4
     USB_busy                       1
     advY                           4
     advX                           4
     g_leng                         4
     g_level                        1
     g_Message                      4
     g_info                         4
     NET                          448
     LightLCD_OFF_Counter           1
     LightLCD_OFF_Counter2          1
     LightLCD_OFF_Curent            1
     TimeInMasterMode               8
     ReciveFrameToMe                1
     tmp_i                          1
     licznik                        4
     licznik2                       4
     licznik3                       4
     memory                         4
     sss                            4
     int1                           4
     sSetup                         8
     sCallbacks                    24
     sUsb                          24
     ISR_Driver                    20
     ISR_VBus                     184
     CBK_Init                      84
     CBK_Resume                    12
     CBK_NewRequest                14
     SendViaUSB                    28
     ForwardUSB2Serial             96
     Delay                         18
     memory_read                    4
     InitFramework                244
     Timer_10us                    12
     Timer_10us_Setup             128
     TimetableExecute             376
     Out                           32
     ThermostatsTimeChartExecute  180
     LastTemp                      16
     ThermostatsExecute           340
     Hysteresis                     8
     AlarmExecute                 472
     Timer_1h                      12
     Timer_1min                    16
     XY_Tab                        44
     display_cykl                   1
     Timer_1s                    1396
     Timer_10ms                   252
     Timer_10ms_Setup             112
     ?Subroutine0                  52
     Counter                        4
     US0_Counter                    4
     US1_Counter                    4
     CounterForTimer10ms            1
     Timer_1ms                    548
     Timer_1ms_Setup               56
     RamToFlash                   212
     testcount                      4
     TestHendel                    40
     TestInit                     120
     string                        28
     watchdogEnable                52
     DateTime                    1348
     FlashProgramReserveOfset       4
     g_Password_2                   8
     AdressModbus                   1
     g_SlaveConnect                12
     g_Restart_Program              1
     AlarmScreenAction            160
     pEndpoints                   160
     tProgramTabSize                4
     stop                           4
     X_up_old                       4
     Y_up_old                       4
     X_down_old                     4
     Y_down_old                     4
     g_PC_Connected_timeout         1
     TimeCompil                    12
     DateCompil                    12
     main                        1296
     ??DataTable2                   4
     ??DataTable5                   4
     ??DataTable6                   4
     ??DataTable9                   4
     ??DataTable10                  4
     ??DataTable11                  4
     ??DataTable12                  4
     ??DataTable13                  4
     ??DataTable14                  4
     ??DataTable15                  4
     ??DataTable17                  4
     ??DataTable20                  4
     ??DataTable21                  4
     ??DataTable22                  4
     ??DataTable23                  4
     ??DataTable24                  4
     ??DataTable25                  4
     ??DataTable26                  4
     ??DataTable27                  4
     ??DataTable28                  4
     ??DataTable29                  4
     ??DataTable30                  4
     ??DataTable31                  4
     ??DataTable32                  4
     ??DataTable33                  4
     ??DataTable34                  4
     ?<Constant "Wyladowana">      28
     ?<Constant "   ">              4
      Others                       68

 
   718 bytes in section .bss
 1 744 bytes in section .data
    92 bytes in section .rodata
 6 544 bytes in section Debug.txt
 
 6 476 bytes of CODE  memory (+ 68 bytes shared)
    92 bytes of CONST memory
 2 462 bytes of DATA  memory

Errors: none
Warnings: 34
