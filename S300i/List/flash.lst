###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           04/Jun/2013  20:18:31 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\Framework\flash.c                             #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\Framework\flash.c" -D AT91SAM7S256 -D         #
#                    AT91SAM7SEK -D iH -D __ALARM -D __WIFI_MODULE -D S300i   #
#                    -lC "D:\Zeuron\Projekty\S300\S300-program v1.3 -         #
#                    04.06.2013\S300i\List\" --diag_suppress Pa082 -o         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\S300i\Obj\" --debug --endian little --cpu     #
#                    ARM7TDMI -e --fpu None --dlib_config "C:\Program Files   #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    5.0\ARM\INC\DLib_Config_Normal.h" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v1.3 - 04.06.2013\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v1.3 - 04.06.2013\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v1.3 - 04.06.2013\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\Framework\Configuration\" -I "C:\Program      #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\INC\" --section .text=Debug.txt --interwork      #
#                    --cpu_mode thumb -Oh                                     #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300i\List\flash.lst                          #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300i\Obj\flash.o                             #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c
      1          #include "flash.h"
      2          #include <intrinsics.h>
      3          
      4          
      5          
      6          

   \                                 In section Debug.txt, align 4, keep-with-next
      7          void InitFlash(void)
      8          {
      9          
     10            AT91C_BASE_MC->MC_FMR = (((0x48)<<16) | AT91C_MC_FWS_2FWS);     // konfiguracja MC_FMR
   \                     InitFlash:
   \   00000000   9F20               MOVS     R0,#+159
   \   00000002   C043               MVNS     R0,R0            ;; #-160
   \   00000004   0349               LDR      R1,??InitFlash_0  ;; 0x480200
   \   00000006   0160               STR      R1,[R0, #+0]
     11          
     12            SET(AT91C_BASE_MC->MC_FMR, ((AT91C_MASTER_CLOCK / 666666)) << 16);
   \   00000008   0168               LDR      R1,[R0, #+0]
   \   0000000A   9022               MOVS     R2,#+144
   \   0000000C   D203               LSLS     R2,R2,#+15       ;; #+4718592
   \   0000000E   0A43               ORRS     R2,R2,R1
   \   00000010   0260               STR      R2,[R0, #+0]
     13              
     14            
     15          }
   \   00000012   7047               BX       LR               ;; return
   \                     ??InitFlash_0:
   \   00000014   00024800           DC32     0x480200
     16          
     17          
     18          
     19          
     20          //*-----------------------------------------------------------------------------
     21          //* Nazwa funkcji :    at91flashWrite
     22          //* Funkcja zapisu do flash
     23          //*-----------------------------------------------------------------------------
     24          //*  ofset  - przesuniêcie
     25          //*  cell   - pierwsza komórka zapisu
     26          //*  value  - wartoœæ do zapisu
     27          //*  length - wielkoœæ danych
     28          //*----------------------------------------------------------------------------
     29          

   \                                 In section .textrw, align 4, keep-with-next
     30          __ramfunc void at91flashWrite(  unsigned int ofset, unsigned int cell, char *value,  int length)
     31           {
   \                     at91flashWrite:
   \   00000000   FCB5               PUSH     {R2-R7,LR}
   \   00000002   C1B0               SUB      SP,SP,#+260
     32             
     33             unsigned int Page=ofset+cell/256;
   \   00000004   0A0A               LSRS     R2,R1,#+8
   \   00000006   8218               ADDS     R2,R0,R2
     34             unsigned int komorka=ofset+cell%256;
   \   00000008   0906               LSLS     R1,R1,#+24
   \   0000000A   090E               LSRS     R1,R1,#+24
   \   0000000C   4018               ADDS     R0,R0,R1
   \   0000000E   0021               MOVS     R1,#+0
     35             int length_tmp;
     36             int data = 0; 
     37             unsigned long *memory;
     38             
     39          
     40             
     41            // TRACE_INFO("\n\r---  FlashWrite  --- Ofset: %d, Komorka: %d, Rozmar: %dB\n\r",ofset,cell,length );  
     42             
     43             union 
     44             {
     45                         char tab_B[256];
     46                unsigned long tab_DW[64];
     47             };
     48          
     49             do
     50             {
     51               if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
   \                     ??at91flashWrite_0:
   \   00000010   429B               LDR      R3,[SP, #+264]
   \   00000012   C318               ADDS     R3,R0,R3
   \   00000014   FF24               MOVS     R4,#+255
   \   00000016   A41C               ADDS     R4,R4,#+2        ;; #+257
   \   00000018   A342               CMP      R3,R4
   \   0000001A   02D3               BCC      ??at91flashWrite_1
   \   0000001C   631E               SUBS     R3,R4,#+1
   \   0000001E   1B1A               SUBS     R3,R3,R0
   \   00000020   00E0               B.N      ??at91flashWrite_2
   \                     ??at91flashWrite_1:
   \   00000022   429B               LDR      R3,[SP, #+264]
   \                     ??at91flashWrite_2:
   \   00000024   0093               STR      R3,[SP, #+0]
     52          
     53                memory=(unsigned long*) (Page*256);  //zmiana z memory=(unsigned long*) (ofset+page*256);
     54               for (unsigned int i=0; i<=63; i++)
   \   00000026   01AC               ADD      R4,SP,#+4
   \   00000028   1302               LSLS     R3,R2,#+8
   \   0000002A   1D00               MOVS     R5,R3
   \   0000002C   1026               MOVS     R6,#+16
     55                {  
     56                  tab_DW[i]=memory[i];     
   \                     ??at91flashWrite_3:
   \   0000002E   2F68               LDR      R7,[R5, #+0]
   \   00000030   2760               STR      R7,[R4, #+0]
   \   00000032   6F68               LDR      R7,[R5, #+4]
   \   00000034   6760               STR      R7,[R4, #+4]
   \   00000036   AF68               LDR      R7,[R5, #+8]
   \   00000038   A760               STR      R7,[R4, #+8]
   \   0000003A   EF68               LDR      R7,[R5, #+12]
   \   0000003C   E760               STR      R7,[R4, #+12]
     57                }  
   \   0000003E   1035               ADDS     R5,R5,#+16
   \   00000040   1034               ADDS     R4,R4,#+16
   \   00000042   761E               SUBS     R6,R6,#+1
   \   00000044   F3D1               BNE      ??at91flashWrite_3
     58               
     59               for (int i=komorka; i<=komorka+length_tmp-1; i++)
   \   00000046   009C               LDR      R4,[SP, #+0]
   \   00000048   0419               ADDS     R4,R0,R4
   \   0000004A   641E               SUBS     R4,R4,#+1
   \   0000004C   8442               CMP      R4,R0
   \   0000004E   0AD3               BCC      ??at91flashWrite_4
   \   00000050   419D               LDR      R5,[SP, #+260]
   \   00000052   6D18               ADDS     R5,R5,R1
   \   00000054   05E0               B        ??at91flashWrite_5
     60                {
     61                  tab_B[i]=(unsigned long)value[data];
   \                     ??at91flashWrite_6:
   \   00000056   01AE               ADD      R6,SP,#+4
   \   00000058   2F78               LDRB     R7,[R5, #+0]
   \   0000005A   3754               STRB     R7,[R6, R0]
     62                  data++;
   \   0000005C   491C               ADDS     R1,R1,#+1
     63                }
   \   0000005E   401C               ADDS     R0,R0,#+1
   \   00000060   6D1C               ADDS     R5,R5,#+1
   \                     ??at91flashWrite_5:
   \   00000062   8442               CMP      R4,R0
   \   00000064   F7D2               BCS      ??at91flashWrite_6
     64            
     65               for (unsigned int i=0; i<=63; i++)
   \                     ??at91flashWrite_4:
   \   00000066   9820               MOVS     R0,#+152
   \   00000068   4003               LSLS     R0,R0,#+13       ;; #+1245184
   \   0000006A   01AC               ADD      R4,SP,#+4
   \   0000006C   1025               MOVS     R5,#+16
     66                {
     67                  AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
   \                     ??at91flashWrite_7:
   \   0000006E   2668               LDR      R6,[R4, #+0]
   \   00000070   0660               STR      R6,[R0, #+0]
   \   00000072   6668               LDR      R6,[R4, #+4]
   \   00000074   4660               STR      R6,[R0, #+4]
   \   00000076   A668               LDR      R6,[R4, #+8]
   \   00000078   8660               STR      R6,[R0, #+8]
   \   0000007A   E668               LDR      R6,[R4, #+12]
   \   0000007C   C660               STR      R6,[R0, #+12]
     68                }  
   \   0000007E   1034               ADDS     R4,R4,#+16
   \   00000080   1030               ADDS     R0,R0,#+16
   \   00000082   6D1E               SUBS     R5,R5,#+1
   \   00000084   F3D1               BNE      ??at91flashWrite_7
     69             
     70               unsigned int Status = AT91C_BASE_MC->MC_FSR;
   \   00000086   9720               MOVS     R0,#+151
   \   00000088   C043               MVNS     R0,R0            ;; #-152
   \   0000008A   0068               LDR      R0,[R0, #+0]
     71          
     72               SET(AT91C_BASE_MC->MC_FCR,
     73                  AT91C_MC_CORRECT_KEY
     74                  | AT91C_MC_FCMD_START_PROG
     75                  | (((Page) << 8) & AT91C_MC_PAGEN));   //zmaina page+(ofset/256)
   \   0000008C   9B20               MOVS     R0,#+155
   \   0000008E   C043               MVNS     R0,R0            ;; #-156
   \   00000090   0468               LDR      R4,[R0, #+0]
   \   00000092   ....               LDR      R5,??DataTable6  ;; 0x3ff00
   \   00000094   1D40               ANDS     R5,R5,R3
   \   00000096   ....               LDR      R3,??DataTable7  ;; 0x5a000001
   \   00000098   2B43               ORRS     R3,R3,R5
   \   0000009A   2343               ORRS     R3,R3,R4
   \   0000009C   0360               STR      R3,[R0, #+0]
     76              
     77               while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);   
   \                     ??at91flashWrite_8:
   \   0000009E   9720               MOVS     R0,#+151
   \   000000A0   C043               MVNS     R0,R0            ;; #-152
   \   000000A2   0068               LDR      R0,[R0, #+0]
   \   000000A4   C007               LSLS     R0,R0,#+31
   \   000000A6   FAD5               BPL      ??at91flashWrite_8
     78              
     79               komorka = 0;
   \   000000A8   0020               MOVS     R0,#+0
     80               length = length-length_tmp;
   \   000000AA   429B               LDR      R3,[SP, #+264]
   \   000000AC   009C               LDR      R4,[SP, #+0]
   \   000000AE   1B1B               SUBS     R3,R3,R4
   \   000000B0   4293               STR      R3,[SP, #+264]
     81               Page++;
   \   000000B2   521C               ADDS     R2,R2,#+1
     82              
     83             }while (length>0); 
   \   000000B4   012B               CMP      R3,#+1
   \   000000B6   ABDA               BGE      ??at91flashWrite_0
     84              
     85          
     86          }
   \   000000B8   43B0               ADD      SP,SP,#+268
   \   000000BA   F0BC               POP      {R4-R7}
   \   000000BC   01BC               POP      {R0}
   \   000000BE   0047               BX       R0               ;; return
     87          
     88          
     89          
     90          
     91          
     92          
     93          
     94          
     95          
     96          
     97          
     98          
     99          #define FLASH_PAGE_SIZE_BYTE 512
    100          
    101          
    102          
    103          
    104          //*---------------------------------------------------------------------------- 
    105          //* \fn    AT91F_Flash_Ready 
    106          //* \brief Czekanie na zapis Flash'a 
    107          //*---------------------------------------------------------------------------- 

   \                                 In section .textrw, align 4, keep-with-next
    108          __ramfunc int AT91F_Flash_Ready (void) 
    109          { 
   \                     AT91F_Flash_Ready:
   \   00000000   01B5               PUSH     {R0,LR}
    110              unsigned int status; 
    111              status = 0; 
   \   00000002   9721               MOVS     R1,#+151
   \   00000004   C943               MVNS     R1,R1            ;; #-152
    112          
    113              // Wait the end of command 
    114                  while ((status & AT91C_MC_FRDY) != AT91C_MC_FRDY ) 
    115                  { 
    116                    status = AT91C_BASE_MC->MC_FSR; 
   \                     ??AT91F_Flash_Ready_0:
   \   00000006   0868               LDR      R0,[R1, #+0]
    117                  } 
   \   00000008   C207               LSLS     R2,R0,#+31
   \   0000000A   FCD5               BPL      ??AT91F_Flash_Ready_0
    118                  return status; 
   \   0000000C   08BC               POP      {R3}
   \   0000000E   02BC               POP      {R1}
   \   00000010   0847               BX       R1               ;; return
    119          } 
    120          
    121          
    122          

   \                                 In section .textrw, align 4, keep-with-next
    123          __ramfunc int AT91F_Flash_Write( unsigned int Flash_Address ,int size ,unsigned int * buff) 
    124          { 
   \                     AT91F_Flash_Write:
   \   00000000   70B5               PUSH     {R4-R6,LR}
    125              // set the Flash controller base address 
    126              AT91PS_MC ptMC = AT91C_BASE_MC; 
    127              unsigned int i, page, status; 
    128              unsigned int * Flash; 
    129              
    130              // init flash pointer 
    131              Flash = (unsigned int *) Flash_Address; 
    132              // Get the Flash page number 
    133              page = ((Flash_Address - (unsigned int)AT91C_IFLASH ) /FLASH_PAGE_SIZE_BYTE); 
   \   00000002   194B               LDR      R3,??AT91F_Flash_Write_0  ;; 0xfff00000
   \   00000004   C318               ADDS     R3,R0,R3
   \   00000006   5B0A               LSRS     R3,R3,#+9
    134              // copy the new value 
    135              
    136          
    137              
    138              
    139              for (i=0; (i < FLASH_PAGE_SIZE_BYTE) & (size > 0) ;i++, Flash++,buff++,size-=4 )
   \   00000008   0024               MOVS     R4,#+0
   \   0000000A   8025               MOVS     R5,#+128
   \   0000000C   AD00               LSLS     R5,R5,#+2        ;; #+512
   \                     ??AT91F_Flash_Write_1:
   \   0000000E   0129               CMP      R1,#+1
   \   00000010   07DB               BLT      ??AT91F_Flash_Write_2
    140              { 
    141              *Flash=*buff; 
   \   00000012   1668               LDR      R6,[R2, #+0]
   \   00000014   0660               STR      R6,[R0, #+0]
    142              } 
   \   00000016   641C               ADDS     R4,R4,#+1
   \   00000018   001D               ADDS     R0,R0,#+4
   \   0000001A   121D               ADDS     R2,R2,#+4
   \   0000001C   091F               SUBS     R1,R1,#+4
   \   0000001E   AC42               CMP      R4,R5
   \   00000020   F5D3               BCC      ??AT91F_Flash_Write_1
    143              
    144              
    145              __disable_interrupt();
   \                     ??AT91F_Flash_Write_2:
   \   00000022   ........           BL       __iar_disable_interrupt
    146              unsigned long ulIntrStat = AT91C_BASE_AIC->AIC_IMR; 
   \   00000026   1148               LDR      R0,??AT91F_Flash_Write_0+0x4  ;; 0xfffff110
   \   00000028   0068               LDR      R0,[R0, #+0]
    147              AT91C_BASE_AIC->AIC_IDCR = 0xFFFFFFFF; 
   \   0000002A   1149               LDR      R1,??AT91F_Flash_Write_0+0x8  ;; 0xfffff124
   \   0000002C   0022               MOVS     R2,#+0
   \   0000002E   D243               MVNS     R2,R2            ;; #-1
   \   00000030   0A60               STR      R2,[R1, #+0]
    148              
    149              // Write the write page command 
    150              ptMC->MC_FCR = AT91C_MC_CORRECT_KEY | AT91C_MC_FCMD_START_PROG | (AT91C_MC_PAGEN & (page <<8)) ; 
   \   00000032   9B21               MOVS     R1,#+155
   \   00000034   C943               MVNS     R1,R1            ;; #-156
   \   00000036   1A02               LSLS     R2,R3,#+8
   \   00000038   ....               LDR      R3,??DataTable6  ;; 0x3ff00
   \   0000003A   1340               ANDS     R3,R3,R2
   \   0000003C   ....               LDR      R2,??DataTable7  ;; 0x5a000001
   \   0000003E   1A43               ORRS     R2,R2,R3
   \   00000040   0A60               STR      R2,[R1, #+0]
    151              
    152              //for a certain ammount of time you cant do any operation over flash memory. 
    153              for(i=0;i<100000;i++) asm("nop"); 
   \   00000042   0C49               LDR      R1,??AT91F_Flash_Write_0+0xC  ;; 0x186a0
   \                     ??AT91F_Flash_Write_3:
   \   00000044   C046               nop              
   \   00000046   491E               SUBS     R1,R1,#+1
   \   00000048   FCD1               BNE      ??AT91F_Flash_Write_3
    154              
    155              //Enable ints 
    156              AT91C_BASE_AIC->AIC_IECR = ulIntrStat; 
   \   0000004A   0B49               LDR      R1,??AT91F_Flash_Write_0+0x10  ;; 0xfffff120
   \   0000004C   0860               STR      R0,[R1, #+0]
    157              
    158              // Wait the end of command 
    159              status = AT91F_Flash_Ready(); 
   \   0000004E   ........           BL       AT91F_Flash_Ready
    160              
    161               __enable_interrupt();
   \   00000052   ........           BL       __iar_enable_interrupt
    162              // Check the result 
    163              if ( (status & ( AT91C_MC_PROGE | AT91C_MC_LOCKE ))!=0) 
   \   00000056   0C21               MOVS     R1,#+12
   \   00000058   0140               ANDS     R1,R1,R0
   \   0000005A   481E               SUBS     R0,R1,#+1
   \   0000005C   8041               SBCS     R0,R0,R0
   \   0000005E   C00F               LSRS     R0,R0,#+31
    164              return false; 
    165              return true; 
   \   00000060   70BC               POP      {R4-R6}
   \   00000062   02BC               POP      {R1}
   \   00000064   0847               BX       R1               ;; return
   \   00000066   C046               Nop      
   \                     ??AT91F_Flash_Write_0:
   \   00000068   0000F0FF           DC32     0xfff00000
   \   0000006C   10F1FFFF           DC32     0xfffff110
   \   00000070   24F1FFFF           DC32     0xfffff124
   \   00000074   A0860100           DC32     0x186a0
   \   00000078   20F1FFFF           DC32     0xfffff120
    166          } 
    167          
    168          
    169          
    170          
    171             /*
    172          
    173          //__ramfunc int AT91F_Flash_Write( unsigned int Flash_Address ,int size ,unsigned int * buff) 
    174          __ramfunc  void FlashWrite(volatile char *ptrMem,volatile char *value,volatile int length)
    175          { 
    176            
    177          
    178              // set the Flash controller base address 
    179              AT91PS_MC ptMC = AT91C_BASE_MC; 
    180              unsigned int i, page, status; 
    181              unsigned int * Flash; 
    182              
    183              // init flash pointer 
    184              Flash = (unsigned int *) Flash_Address; 
    185              // Get the Flash page number 
    186              page = ((Flash_Address - (unsigned int)AT91C_IFLASH ) /FLASH_PAGE_SIZE_BYTE); 
    187              // copy the new value 
    188          
    189          
    190          
    191          
    192            volatile int page=     (int)ptrMem/256;
    193             volatile int komorka = (int)ptrMem%256;   
    194             volatile int PtrInt=(int)ptrMem;
    195             volatile int length_tmp;
    196             volatile int data = 0; 
    197             volatile int *UptrMem;
    198             volatile char* ptrMem2;
    199          
    200             if ((PtrInt>0x00140000) || (PtrInt<0x00120000) || (komorka>0xFF))
    201             {
    202                 char mess[]="Blad zapisu. Przekroczenie dozwolonego obszaru";
    203                 MESSAGE(mess); 
    204             }else{
    205           
    206                 union 
    207                 {
    208                             char B[256];
    209                    unsigned long DW[64];
    210                 }tab;
    211              
    212                 do
    213                 {
    214                   if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
    215                   
    216                   //przepisanie strony pamiêci do RAMu
    217                   ptrMem2=(char*)(page*256);
    218                   for (short i=0; i<256; i++)
    219                    {  
    220                      tab.B[i]=ptrMem2[i];     
    221                    }  
    222                   
    223                      //dodanie nowych danych
    224                      for (int i=komorka; i<=komorka+length_tmp-1; i++)
    225                      {
    226                        tab.B[i]=value[data];
    227                        data++;
    228                      }
    229                
    230                      //UptrMem=(int*)ptrMem;  
    231                      UptrMem=(int*)(page*256);
    232                        
    233                      //zapis do tymczasowego obszar
    234                      //for (unsigned int i=0; i<=63; i++) AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    235                      for (unsigned int i=0; i<=63; i++) UptrMem[i]=tab.DW[i];
    236                 
    237                      //oczekiwanie na flagê FRDY 
    238                      while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
    239                      //volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    240                      
    241                      //Zapis FCMD i PAGENB do MC_FCR
    242                      SET(AT91C_BASE_MC->MC_FCR,
    243                          AT91C_MC_CORRECT_KEY
    244                          | AT91C_MC_FCMD_START_PROG
    245                          | ((page << 8) & AT91C_MC_PAGEN)); 
    246                  
    247                      //oczekiwanie na flagê FRDY 
    248                      long long MaxCount=0;
    249                      while(((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY) || (MaxCount>0xFFFE)) {MaxCount++;};  
    250                      if (MaxCount==0xFFFF)  
    251                      {
    252                        char mess[]="Blad zapisu do flash";
    253                        MESSAGE(mess); 
    254                      }
    255                      //Sprawdzenie czy nie naruszona blokada regionu
    256                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_LOCKE) 
    257                      {
    258                         MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
    259                      }
    260                      
    261                      //Sprawdzenie czy zapis wykonany poprawnie
    262                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_PROGE) 
    263                      {
    264                        MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
    265                      }
    266                      
    267                   komorka = 0;
    268                   length = length-length_tmp;
    269                   page++;
    270                  
    271                 }while (length>0); 
    272             }
    273            
    274          }
    275          */    
    276              
    277              
    278          
    279          
    280          
    281          
    282          
    283          
    284          //*-----------------------------------------------------------------------------
    285          //* Nazwa funkcji :    FlashWrite
    286          //* Funkcja zapisu do flash
    287          //*-----------------------------------------------------------------------------
    288          //*  ofset  - przesuniêcie
    289          //*  cell   - pierwsza komórka zapisu
    290          //*  ptrMem - wskaŸnik na komórke pamiêci flash
    291          //*  value  - wartoœæ do zapisu
    292          //*  length - wielkoœæ danych
    293          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    294          void FlashWrite( char *ptrMem, char *value, int length)
    295           {
   \                     FlashWrite:
   \   00000000   1FB5               PUSH     {R0-R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0B00               MOVS     R3,R1
    296             volatile int page    = (int)ptrMem/256;
   \   00000006   C011               ASRS     R0,R0,#+7
   \   00000008   000E               LSRS     R0,R0,#+24
   \   0000000A   0019               ADDS     R0,R0,R4
   \   0000000C   0012               ASRS     R0,R0,#+8
   \   0000000E   0090               STR      R0,[SP, #+0]
    297             volatile int komorka = (int)ptrMem%256; 
   \   00000010   0002               LSLS     R0,R0,#+8
   \   00000012   201A               SUBS     R0,R4,R0
   \   00000014   0190               STR      R0,[SP, #+4]
    298             volatile int PtrInt  = (int)ptrMem;
   \   00000016   0294               STR      R4,[SP, #+8]
    299             
    300             FlashWriteExe(PtrInt, page, komorka, value, length);
   \   00000018   82B0               SUB      SP,SP,#+8
   \   0000001A   0092               STR      R2,[SP, #+0]
   \   0000001C   039A               LDR      R2,[SP, #+12]
   \   0000001E   0299               LDR      R1,[SP, #+8]
   \   00000020   0498               LDR      R0,[SP, #+16]
   \   00000022   ........           BL       FlashWriteExe
   \   00000026   02B0               ADD      SP,SP,#+8
    301           } 
   \   00000028   1FBC               POP      {R0-R4}
   \   0000002A   01BC               POP      {R0}
   \   0000002C   0047               BX       R0               ;; return
    302             
    303          
    304          

   \                                 In section .textrw, align 4, keep-with-next
    305          __ramfunc  void FlashWriteExe(volatile int  PtrInt,  volatile int  page, volatile int  komorka, char *value, int length)
    306           {
   \                     FlashWriteExe:
   \   00000000   FFB5               PUSH     {R0-R7,LR}
   \   00000002   CFB0               SUB      SP,SP,#+316
   \   00000004   589C               LDR      R4,[SP, #+352]
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   0190               STR      R0,[SP, #+4]
    307          
    308             volatile int length_tmp;
    309             volatile int data = 0; 
    310             volatile int *UptrMem;
    311             volatile char* ptrMem2;
    312          
    313             if ((PtrInt>(int)0x00140000) || (PtrInt<(int)0x00120000) || (komorka>0xFF))
   \   0000000A   4F98               LDR      R0,[SP, #+316]
   \   0000000C   4649               LDR      R1,??FlashWriteExe_0  ;; 0x140001
   \   0000000E   8842               CMP      R0,R1
   \   00000010   09DA               BGE      ??FlashWriteExe_1
   \   00000012   4F98               LDR      R0,[SP, #+316]
   \   00000014   9021               MOVS     R1,#+144
   \   00000016   4903               LSLS     R1,R1,#+13       ;; #+1179648
   \   00000018   8842               CMP      R0,R1
   \   0000001A   04DB               BLT      ??FlashWriteExe_1
   \   0000001C   8027               MOVS     R7,#+128
   \   0000001E   7F00               LSLS     R7,R7,#+1        ;; #+256
   \   00000020   5198               LDR      R0,[SP, #+324]
   \   00000022   B842               CMP      R0,R7
   \   00000024   08DB               BLT      ??FlashWriteExe_2
    314             {
    315                 char mess[]="Blad zapisu. Przekroczenie dozwolonego obszaru";
   \                     ??FlashWriteExe_1:
   \   00000026   42A8               ADD      R0,SP,#+264
   \   00000028   4049               LDR      R1,??FlashWriteExe_0+0x4  ;; `?<Constant "Blad zapisu. Przekroc...">`
   \   0000002A   3022               MOVS     R2,#+48
   \   0000002C   ........           BL       __aeabi_memcpy4
    316                 MESSAGE(mess); 
                        ^
Warning[Pe223]: function "MESSAGE" declared implicitly

         MESSAGE(mess); 
         ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",316  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function
   \   00000030   42A8               ADD      R0,SP,#+264
   \   00000032   ........           BL       MESSAGE
   \   00000036   73E0               B        ??FlashWriteExe_3
    317             }else{
   \                     ??FlashWriteExe_2:
   \   00000038   9726               MOVS     R6,#+151
   \   0000003A   F643               MVNS     R6,R6            ;; #-152
   \   0000003C   02AD               ADD      R5,SP,#+8
    318           
    319                 union 
    320                 {
    321                             char B[256];
    322                    unsigned long DW[64];
    323                 }tab;
    324              
    325                 do
    326                 {
    327                   if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
   \                     ??FlashWriteExe_4:
   \   0000003E   5198               LDR      R0,[SP, #+324]
   \   00000040   0019               ADDS     R0,R0,R4
   \   00000042   791C               ADDS     R1,R7,#+1
   \   00000044   8842               CMP      R0,R1
   \   00000046   03DB               BLT      ??FlashWriteExe_5
   \   00000048   5198               LDR      R0,[SP, #+324]
   \   0000004A   381A               SUBS     R0,R7,R0
   \   0000004C   0090               STR      R0,[SP, #+0]
   \   0000004E   00E0               B        ??FlashWriteExe_6
   \                     ??FlashWriteExe_5:
   \   00000050   0094               STR      R4,[SP, #+0]
    328                   
    329                   //przepisanie strony pamiêci do RAMu
    330                   ptrMem2=(char*)(page*256);
   \                     ??FlashWriteExe_6:
   \   00000052   5098               LDR      R0,[SP, #+320]
   \   00000054   0002               LSLS     R0,R0,#+8
    331                   for (short i=0; i<256; i++)
   \   00000056   0021               MOVS     R1,#+0
    332                    {  
    333                      tab.B[i]=ptrMem2[i];     
   \                     ??FlashWriteExe_7:
   \   00000058   0278               LDRB     R2,[R0, #+0]
   \   0000005A   6A54               STRB     R2,[R5, R1]
   \   0000005C   491C               ADDS     R1,R1,#+1
   \   0000005E   4278               LDRB     R2,[R0, #+1]
   \   00000060   6A54               STRB     R2,[R5, R1]
   \   00000062   491C               ADDS     R1,R1,#+1
   \   00000064   8278               LDRB     R2,[R0, #+2]
   \   00000066   6A54               STRB     R2,[R5, R1]
   \   00000068   491C               ADDS     R1,R1,#+1
   \   0000006A   C278               LDRB     R2,[R0, #+3]
   \   0000006C   6A54               STRB     R2,[R5, R1]
    334                    }  
   \   0000006E   491C               ADDS     R1,R1,#+1
   \   00000070   001D               ADDS     R0,R0,#+4
   \   00000072   B942               CMP      R1,R7
   \   00000074   F0DB               BLT      ??FlashWriteExe_7
    335                   
    336                      //dodanie nowych danych
    337                      for (int i=komorka; i<=komorka+length_tmp-1; i++)
   \   00000076   5198               LDR      R0,[SP, #+324]
   \   00000078   07E0               B        ??FlashWriteExe_8
    338                      {
    339                        tab.B[i]=value[data];
   \                     ??FlashWriteExe_9:
   \   0000007A   0199               LDR      R1,[SP, #+4]
   \   0000007C   529A               LDR      R2,[SP, #+328]
   \   0000007E   515C               LDRB     R1,[R2, R1]
   \   00000080   2954               STRB     R1,[R5, R0]
    340                        data++;
   \   00000082   0199               LDR      R1,[SP, #+4]
   \   00000084   491C               ADDS     R1,R1,#+1
   \   00000086   0191               STR      R1,[SP, #+4]
    341                      }
   \   00000088   401C               ADDS     R0,R0,#+1
   \                     ??FlashWriteExe_8:
   \   0000008A   0099               LDR      R1,[SP, #+0]
   \   0000008C   519A               LDR      R2,[SP, #+324]
   \   0000008E   8918               ADDS     R1,R1,R2
   \   00000090   491E               SUBS     R1,R1,#+1
   \   00000092   8142               CMP      R1,R0
   \   00000094   F1DA               BGE      ??FlashWriteExe_9
    342                
    343                      //UptrMem=(int*)ptrMem;  
    344                      UptrMem=(int*)(page*256);
   \   00000096   5098               LDR      R0,[SP, #+320]
   \   00000098   0202               LSLS     R2,R0,#+8
    345                        
    346                      //zapis do tymczasowego obszar
    347                      //for (unsigned int i=0; i<=63; i++) AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    348                      for (unsigned int i=0; i<=63; i++) UptrMem[i]=tab.DW[i];
   \   0000009A   02A8               ADD      R0,SP,#+8
   \   0000009C   1021               MOVS     R1,#+16
   \                     ??FlashWriteExe_10:
   \   0000009E   0368               LDR      R3,[R0, #+0]
   \   000000A0   1360               STR      R3,[R2, #+0]
   \   000000A2   4368               LDR      R3,[R0, #+4]
   \   000000A4   5360               STR      R3,[R2, #+4]
   \   000000A6   8368               LDR      R3,[R0, #+8]
   \   000000A8   9360               STR      R3,[R2, #+8]
   \   000000AA   C368               LDR      R3,[R0, #+12]
   \   000000AC   D360               STR      R3,[R2, #+12]
   \   000000AE   1030               ADDS     R0,R0,#+16
   \   000000B0   1032               ADDS     R2,R2,#+16
   \   000000B2   491E               SUBS     R1,R1,#+1
   \   000000B4   F3D1               BNE      ??FlashWriteExe_10
    349                 
    350                      //oczekiwanie na flagê FRDY 
    351                      while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
   \                     ??FlashWriteExe_11:
   \   000000B6   3068               LDR      R0,[R6, #+0]
   \   000000B8   C007               LSLS     R0,R0,#+31
   \   000000BA   FCD5               BPL      ??FlashWriteExe_11
    352                      //volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    353                      
    354                      //Zapis FCMD i PAGENB do MC_FCR
    355                      SET(AT91C_BASE_MC->MC_FCR,
    356                          AT91C_MC_CORRECT_KEY
    357                          | AT91C_MC_FCMD_START_PROG
    358                          | ((page << 8) & AT91C_MC_PAGEN)); 
   \   000000BC   9B20               MOVS     R0,#+155
   \   000000BE   C043               MVNS     R0,R0            ;; #-156
   \   000000C0   0168               LDR      R1,[R0, #+0]
   \   000000C2   509A               LDR      R2,[SP, #+320]
   \   000000C4   1302               LSLS     R3,R2,#+8
   \   000000C6   ....               LDR      R2,??DataTable6  ;; 0x3ff00
   \   000000C8   1A40               ANDS     R2,R2,R3
   \   000000CA   ....               LDR      R3,??DataTable7  ;; 0x5a000001
   \   000000CC   1343               ORRS     R3,R3,R2
   \   000000CE   0B43               ORRS     R3,R3,R1
   \   000000D0   0360               STR      R3,[R0, #+0]
    359                  
    360                      //oczekiwanie na flagê FRDY 
    361                      long long MaxCount=0;
   \   000000D2   0020               MOVS     R0,#+0
   \   000000D4   0021               MOVS     R1,#+0
   \   000000D6   02E0               B        ??FlashWriteExe_12
    362                      while(((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY) || (MaxCount>0xFFFE)) {MaxCount++;};  
   \                     ??FlashWriteExe_13:
   \   000000D8   0022               MOVS     R2,#+0
   \   000000DA   401C               ADDS     R0,R0,#+1
   \   000000DC   5141               ADCS     R1,R1,R2
   \                     ??FlashWriteExe_12:
   \   000000DE   3268               LDR      R2,[R6, #+0]
   \   000000E0   D207               LSLS     R2,R2,#+31
   \   000000E2   F9D5               BPL      ??FlashWriteExe_13
   \   000000E4   320C               LSRS     R2,R6,#+16
   \   000000E6   0023               MOVS     R3,#+0
   \   000000E8   9942               CMP      R1,R3
   \   000000EA   F5DC               BGT      ??FlashWriteExe_13
   \   000000EC   01DB               BLT      ??FlashWriteExe_14
   \   000000EE   9042               CMP      R0,R2
   \   000000F0   F2D2               BCS      ??FlashWriteExe_13
    363                      if (MaxCount==0xFFFF)  
    364                      {
    365                        char mess[]="Blad zapisu do flash";
    366                        MESSAGE(mess); 
                               ^
Warning[Pe223]: function "MESSAGE" declared implicitly

                MESSAGE(mess); 
                ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",366  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function
    367                      }
    368                      //Sprawdzenie czy nie naruszona blokada regionu
    369                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_LOCKE) 
   \                     ??FlashWriteExe_14:
   \   000000F2   3068               LDR      R0,[R6, #+0]
   \   000000F4   0421               MOVS     R1,#+4
   \   000000F6   0842               TST      R0,R1
   \   000000F8   02D0               BEQ      ??FlashWriteExe_15
    370                      {
    371                         MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
                                ^
Warning[Pe223]: function "MESSAGE" declared implicitly

                 MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
                 ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",371  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function
   \   000000FA   0D48               LDR      R0,??FlashWriteExe_0+0x8  ;; `?<Constant "Blad zapisu. Przekroc...">` + 72
   \   000000FC   ........           BL       MESSAGE
    372                      }
    373                      
    374                      //Sprawdzenie czy zapis wykonany poprawnie
    375                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_PROGE) 
   \                     ??FlashWriteExe_15:
   \   00000100   3068               LDR      R0,[R6, #+0]
   \   00000102   0821               MOVS     R1,#+8
   \   00000104   0842               TST      R0,R1
   \   00000106   02D0               BEQ      ??FlashWriteExe_16
    376                      {
    377                        MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
                               ^
Warning[Pe223]: function "MESSAGE" declared implicitly

                MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
                ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",377  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function

      __disable_interrupt();
      ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",145  Warning[Ta021]: 
          Library call (__iar_disable_interrupt) from within a __ramfunc
          function

       __enable_interrupt();
       ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",161  Warning[Ta021]: 
          Library call (__iar_enable_interrupt) from within a __ramfunc
          function

         char mess[]="Blad zapisu. Przekroczenie dozwolonego obszaru";
                    ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",315  Warning[Ta022]: 
          Possible rom access (<Constant "Blad zapisu. Przekroc...">) from
          within a __ramfunc function

                 MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
                 ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",371  Warning[Ta022]: 
          Possible rom access (<Constant "Blad zapisu. Przekroc...">) from
          within a __ramfunc function

                MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
                ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",377  Warning[Ta022]: 
          Possible rom access (<Constant "Blad zapisu. Przekroc...">) from
          within a __ramfunc function
   \   00000108   0A48               LDR      R0,??FlashWriteExe_0+0xC  ;; `?<Constant "Blad zapisu. Przekroc...">` + 116
   \   0000010A   ........           BL       MESSAGE
    378                      }
    379                      
    380                   komorka = 0;
   \                     ??FlashWriteExe_16:
   \   0000010E   0020               MOVS     R0,#+0
   \   00000110   5190               STR      R0,[SP, #+324]
    381                   length = length-length_tmp;
   \   00000112   0098               LDR      R0,[SP, #+0]
   \   00000114   241A               SUBS     R4,R4,R0
    382                   page++;
   \   00000116   5098               LDR      R0,[SP, #+320]
   \   00000118   401C               ADDS     R0,R0,#+1
   \   0000011A   5090               STR      R0,[SP, #+320]
    383                  
    384                 }while (length>0); 
   \   0000011C   012C               CMP      R4,#+1
   \   0000011E   8EDA               BGE      ??FlashWriteExe_4
    385             }
    386              
    387          }
   \                     ??FlashWriteExe_3:
   \   00000120   53B0               ADD      SP,SP,#+332
   \   00000122   F0BC               POP      {R4-R7}
   \   00000124   01BC               POP      {R0}
   \   00000126   0047               BX       R0               ;; return
   \                     ??FlashWriteExe_0:
   \   00000128   01001400           DC32     0x140001
   \   0000012C   ........           DC32     `?<Constant "Blad zapisu. Przekroc...">`
   \   00000130   ........           DC32     `?<Constant "Blad zapisu. Przekroc...">` + 72
   \   00000134   ........           DC32     `?<Constant "Blad zapisu. Przekroc...">` + 116
    388          
    389          
    390          
    391          
    392          
    393          
    394          

   \                                 In section .textrw, align 4, keep-with-next
    395          __ramfunc void CleanFlash(char *ptrMem, int length)
    396           {
   \                     CleanFlash:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   C3B0               SUB      SP,SP,#+268
    397             int page=     (int)ptrMem/256;
   \   00000004   C211               ASRS     R2,R0,#+7
   \   00000006   120E               LSRS     R2,R2,#+24
   \   00000008   1218               ADDS     R2,R2,R0
   \   0000000A   1212               ASRS     R2,R2,#+8
    398             int komorka = (int)ptrMem%256;   
   \   0000000C   1302               LSLS     R3,R2,#+8
   \   0000000E   C41A               SUBS     R4,R0,R3
   \   00000010   02AB               ADD      R3,SP,#+8
    399             int length_tmp;
    400             int data = 0; 
    401             int *UptrMem;
    402          
    403             union 
    404             {
    405                         char B[256];
    406                unsigned long DW[64];
    407             }tab;
    408          
    409             do
    410             {
    411               if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
   \                     ??CleanFlash_0:
   \   00000012   6018               ADDS     R0,R4,R1
   \   00000014   FF25               MOVS     R5,#+255
   \   00000016   AD1C               ADDS     R5,R5,#+2        ;; #+257
   \   00000018   A842               CMP      R0,R5
   \   0000001A   03DB               BLT      ??CleanFlash_1
   \   0000001C   681E               SUBS     R0,R5,#+1
   \   0000001E   001B               SUBS     R0,R0,R4
   \   00000020   0090               STR      R0,[SP, #+0]
   \   00000022   00E0               B        ??CleanFlash_2
   \                     ??CleanFlash_1:
   \   00000024   0091               STR      R1,[SP, #+0]
    412               
    413               //przepisanie strony pamiêci do RAMu
    414               ptrMem=(char*)(page*256);
    415               for (short i=0; i<256; i++)
   \                     ??CleanFlash_2:
   \   00000026   0025               MOVS     R5,#+0
   \   00000028   1002               LSLS     R0,R2,#+8
   \   0000002A   0190               STR      R0,[SP, #+4]
   \   0000002C   019E               LDR      R6,[SP, #+4]
    416                {  
    417                  tab.B[i]=ptrMem[i];     
   \                     ??CleanFlash_3:
   \   0000002E   3778               LDRB     R7,[R6, #+0]
   \   00000030   5F55               STRB     R7,[R3, R5]
   \   00000032   6D1C               ADDS     R5,R5,#+1
   \   00000034   7778               LDRB     R7,[R6, #+1]
   \   00000036   5F55               STRB     R7,[R3, R5]
   \   00000038   6D1C               ADDS     R5,R5,#+1
   \   0000003A   B778               LDRB     R7,[R6, #+2]
   \   0000003C   5F55               STRB     R7,[R3, R5]
   \   0000003E   6D1C               ADDS     R5,R5,#+1
   \   00000040   F778               LDRB     R7,[R6, #+3]
   \   00000042   5F55               STRB     R7,[R3, R5]
    418                }  
   \   00000044   6D1C               ADDS     R5,R5,#+1
   \   00000046   361D               ADDS     R6,R6,#+4
   \   00000048   FF2D               CMP      R5,#+255
   \   0000004A   F0DD               BLE      ??CleanFlash_3
    419               
    420                  //dodanie nowych danych
    421                  for (int i=komorka; i<=komorka+length_tmp-1; i++)
   \   0000004C   009D               LDR      R5,[SP, #+0]
   \   0000004E   6519               ADDS     R5,R4,R5
   \   00000050   6D1E               SUBS     R5,R5,#+1
   \   00000052   A542               CMP      R5,R4
   \   00000054   04DB               BLT      ??CleanFlash_4
    422                  {
    423                    tab.B[i]=0;
   \                     ??CleanFlash_5:
   \   00000056   0026               MOVS     R6,#+0
   \   00000058   1E55               STRB     R6,[R3, R4]
    424                    data++;
    425                  }
   \   0000005A   641C               ADDS     R4,R4,#+1
   \   0000005C   A542               CMP      R5,R4
   \   0000005E   FADA               BGE      ??CleanFlash_5
    426            
    427                  //UptrMem=(int*)ptrMem;  
    428                  UptrMem=(int*)(page*256);
    429                    
    430                  //zapis do tymczasowego obszar
    431                  //for (unsigned int i=0; i<=63; i++) AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    432                  for (unsigned int i=0; i<=63; i++) UptrMem[i]=tab.DW[i];
   \                     ??CleanFlash_4:
   \   00000060   019C               LDR      R4,[SP, #+4]
   \   00000062   02AD               ADD      R5,SP,#+8
   \   00000064   1026               MOVS     R6,#+16
   \                     ??CleanFlash_6:
   \   00000066   2F68               LDR      R7,[R5, #+0]
   \   00000068   2760               STR      R7,[R4, #+0]
   \   0000006A   6F68               LDR      R7,[R5, #+4]
   \   0000006C   6760               STR      R7,[R4, #+4]
   \   0000006E   AF68               LDR      R7,[R5, #+8]
   \   00000070   A760               STR      R7,[R4, #+8]
   \   00000072   EF68               LDR      R7,[R5, #+12]
   \   00000074   E760               STR      R7,[R4, #+12]
   \   00000076   1035               ADDS     R5,R5,#+16
   \   00000078   1034               ADDS     R4,R4,#+16
   \   0000007A   761E               SUBS     R6,R6,#+1
   \   0000007C   F3D1               BNE      ??CleanFlash_6
    433             
    434                  //oczekiwanie na flagê FRDY 
    435                  while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
   \                     ??CleanFlash_7:
   \   0000007E   9724               MOVS     R4,#+151
   \   00000080   E443               MVNS     R4,R4            ;; #-152
   \   00000082   2468               LDR      R4,[R4, #+0]
   \   00000084   E407               LSLS     R4,R4,#+31
   \   00000086   FAD5               BPL      ??CleanFlash_7
    436                  //volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    437                  
    438                  //Zapis FCMD i PAGENB do MC_FCR
    439                  SET(AT91C_BASE_MC->MC_FCR,
    440                      AT91C_MC_CORRECT_KEY
    441                      | AT91C_MC_FCMD_START_PROG
    442                      | ((page << 8) & AT91C_MC_PAGEN)); 
   \   00000088   9B24               MOVS     R4,#+155
   \   0000008A   E443               MVNS     R4,R4            ;; #-156
   \   0000008C   2568               LDR      R5,[R4, #+0]
   \   0000008E   ....               LDR      R6,??DataTable6  ;; 0x3ff00
   \   00000090   0640               ANDS     R6,R6,R0
   \   00000092   ....               LDR      R0,??DataTable7  ;; 0x5a000001
   \   00000094   3043               ORRS     R0,R0,R6
   \   00000096   2843               ORRS     R0,R0,R5
   \   00000098   2060               STR      R0,[R4, #+0]
    443              
    444                  //oczekiwanie na flagê FRDY 
    445                  while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
   \                     ??CleanFlash_8:
   \   0000009A   9720               MOVS     R0,#+151
   \   0000009C   C043               MVNS     R0,R0            ;; #-152
   \   0000009E   0068               LDR      R0,[R0, #+0]
   \   000000A0   C007               LSLS     R0,R0,#+31
   \   000000A2   FAD5               BPL      ??CleanFlash_8
    446                  
    447                  //Sprawdzenie czy nie naruszona blokada regionu
    448                  if (AT91C_BASE_MC->MC_FSR & AT91C_MC_LOCKE) 
   \   000000A4   9720               MOVS     R0,#+151
   \   000000A6   C043               MVNS     R0,R0            ;; #-152
   \   000000A8   0068               LDR      R0,[R0, #+0]
    449                  {
    450                    // MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
    451                  }
    452                  
    453                  //Sprawdzenie czy zapis wykonany poprawnie
    454                  if (AT91C_BASE_MC->MC_FSR & AT91C_MC_PROGE) 
   \   000000AA   9720               MOVS     R0,#+151
   \   000000AC   C043               MVNS     R0,R0            ;; #-152
   \   000000AE   0068               LDR      R0,[R0, #+0]
    455                  {
    456                    //MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
    457                  }
    458                  
    459               komorka = 0;
   \   000000B0   0024               MOVS     R4,#+0
    460               length = length-length_tmp;
   \   000000B2   0098               LDR      R0,[SP, #+0]
   \   000000B4   091A               SUBS     R1,R1,R0
    461               page++;
   \   000000B6   521C               ADDS     R2,R2,#+1
    462              
    463             }while (length>0); 
   \   000000B8   0129               CMP      R1,#+1
   \   000000BA   AADA               BGE      ??CleanFlash_0
    464          
    465              
    466          }
   \   000000BC   43B0               ADD      SP,SP,#+268
   \   000000BE   F0BC               POP      {R4-R7}
   \   000000C0   01BC               POP      {R0}
   \   000000C2   0047               BX       R0               ;; return
    467          
    468          
    469          
    470          /*
    471          __ramfunc void CleanFlash(int ofset,unsigned int cell, int length)
    472            {
    473             int page=     cell/256;
    474             int komorka = cell%256;
    475             int length_tmp;
    476             int data = 0; 
    477             unsigned long *memory;
    478             bool find; 
    479             int tmp_i =0;
    480             
    481             
    482           //  TRACE_INFO("\n\r---  CleanFlash  --- Ofset: %d, Komorka: %d, Rozmar: %dB\n\r",ofset,cell,length );
    483          
    484             
    485             union 
    486             {
    487                         char tab_B[256];
    488                unsigned long tab_DW[64];
    489             };
    490          
    491             do
    492             {
    493               if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
    494               
    495               
    496                memory=(unsigned long*) (ofset+page*256);
    497          
    498               find = false;
    499          
    500                tmp_i=0;
    501                do 
    502                {
    503                  if (memory[tmp_i]>0)
    504                  {
    505                    find = true;
    506                    break;
    507                  }
    508                  tmp_i++;
    509                } while (tmp_i<=63);
    510          
    511                
    512               if (find==true)    
    513               {
    514                  data=0;
    515                  for (int i=komorka; i<=komorka+length_tmp-1; i++)
    516                    {
    517                      tab_B[i]=0;
    518                      data++;
    519                    }
    520            
    521                  for (unsigned int i=0; i<=63; i++)
    522                    {
    523                      AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    524                    }  
    525             
    526                  volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    527          
    528                  SET(AT91C_BASE_MC->MC_FCR,
    529                      AT91C_MC_CORRECT_KEY
    530                      | AT91C_MC_FCMD_START_PROG
    531                      | (((page+(ofset/256)) << 8) & AT91C_MC_PAGEN)); 
    532              
    533                  while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);   
    534                }
    535               
    536               komorka = 0;
    537               length = length-length_tmp;
    538               page++;
    539              
    540             }while (length>0); 
    541              
    542           //  TRACE_INFO("\n\r ---Koniec  CleanFlash  --- \n\r");
    543          }
    544          
    545          */
    546          
    547          
    548          
    549          

   \                                 In section Debug.txt, align 4, keep-with-next
    550           void at91flashErase(void)
    551           {
   \                     at91flashErase:
   \   00000000   01B5               PUSH     {R0,LR}
    552             // erase flash
    553               AT91C_BASE_MC->MC_FCR =(0x5A<<24) | AT91C_MC_FCMD_ERASE_ALL;
   \   00000002   9B20               MOVS     R0,#+155
   \   00000004   C043               MVNS     R0,R0            ;; #-156
   \   00000006   0549               LDR      R1,??at91flashErase_0  ;; 0x5a000008
   \   00000008   0160               STR      R1,[R0, #+0]
   \   0000000A   9720               MOVS     R0,#+151
   \   0000000C   C043               MVNS     R0,R0            ;; #-152
    554               // wait for flash done/ready
    555               while(!(AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY));
   \                     ??at91flashErase_1:
   \   0000000E   0168               LDR      R1,[R0, #+0]
   \   00000010   C907               LSLS     R1,R1,#+31
   \   00000012   FCD5               BPL      ??at91flashErase_1
    556          
    557           }
   \   00000014   08BC               POP      {R3}
   \   00000016   01BC               POP      {R0}
   \   00000018   0047               BX       R0               ;; return
   \   0000001A   C046               Nop      
   \                     ??at91flashErase_0:
   \   0000001C   0800005A           DC32     0x5a000008

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   00FF0300           DC32     0x3ff00

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0100005A           DC32     0x5a000001

   \                                 In section .rodata, align 4
   \                     `?<Constant "Blad zapisu. Przekroc...">`:
   \   00000000   426C6164207A       DC8 "Blad zapisu. Przekroczenie dozwolonego obszaru"
   \              61706973752E
   \              2050727A656B
   \              726F637A656E
   \              696520646F7A
   \              776F6C6F6E65
   \              676F206F6273
   \              7A61727500  
   \   0000002F   00                 DC8 0
   \   00000030   426C6164207A       DC8 "Blad zapisu do flash"
   \              617069737520
   \              646F20666C61
   \              736800      
   \   00000045   000000             DC8 0, 0, 0
   \   00000048   42B3B964206E       DC8 "B³¹d naruszenia zablokowanego regionu flash"
   \              617275737A65
   \              6E6961207A61
   \              626C6F6B6F77
   \              616E65676F20
   \              726567696F6E
   \              7520666C6173
   \              6800        
   \   00000074   5AB379206B6C       DC8 "Z³y klucz lub b³edna komenda zapisu flash"
   \              75637A206C75
   \              622062B36564
   \              6E61206B6F6D
   \              656E6461207A
   \              617069737520
   \              666C61736800
   \   0000009E   0000               DC8 0, 0
    558          

   Maximum stack usage in bytes:

     Function          .cstack
     --------          -------
     AT91F_Flash_Ready      8
     AT91F_Flash_Write     16
     CleanFlash           288
     FlashWrite            32
     FlashWriteExe        352
     InitFlash              0
     at91flashErase         8
     at91flashWrite       288


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     InitFlash                        24
     at91flashWrite                  192
     AT91F_Flash_Ready                18
     AT91F_Flash_Write               124
     FlashWrite                       46
     FlashWriteExe                   312
     CleanFlash                      196
     at91flashErase                   32
     ??DataTable6                      4
     ??DataTable7                      4
     ?<Constant "Blad zapisu. Przekroc...">
                                     160
      Others                          32

 
 160 bytes in section .rodata
 850 bytes in section .textrw
 134 bytes in section Debug.txt
 
 952 bytes of CODE  memory (+ 32 bytes shared)
 160 bytes of CONST memory

Errors: none
Warnings: 13
