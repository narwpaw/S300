###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           04/Jun/2013  20:18:16 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\core\standard.c                               #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\core\standard.c" -D AT91SAM7S256 -D           #
#                    AT91SAM7SEK -D iH -D __ALARM -D __WIFI_MODULE -D S300i   #
#                    -lC "D:\Zeuron\Projekty\S300\S300-program v1.3 -         #
#                    04.06.2013\S300i\List\" --diag_suppress Pa082 -o         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\S300i\Obj\" --debug --endian little --cpu     #
#                    ARM7TDMI -e --fpu None --dlib_config "C:\Program Files   #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    5.0\ARM\INC\DLib_Config_Normal.h" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v1.3 - 04.06.2013\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v1.3 - 04.06.2013\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v1.3 - 04.06.2013\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\Framework\Configuration\" -I "C:\Program      #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\INC\" --section .text=Debug.txt --interwork      #
#                    --cpu_mode thumb -Oh                                     #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300i\List\standard.lst                       #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300i\Obj\standard.o                          #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\core\standard.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support  -  ROUSSET  -
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2006, Atmel Corporation
      5          
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaiimer below.
     13           *
     14           * - Redistributions in binary form must reproduce the above copyright notice,
     15           * this list of conditions and the disclaimer below in the documentation and/or
     16           * other materials provided with the distribution.
     17           *
     18           * Atmel's name may not be used to endorse or promote products derived from
     19           * this software without specific prior written permission.
     20           *
     21           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     22           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     23           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     24           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     25           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     26           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     27           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     28           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     29           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     30           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31           * ----------------------------------------------------------------------------
     32           */
     33          
     34          /*
     35          $Id: standard.c,v 1.1.2.1 2006/12/05 08:33:25 danielru Exp $
     36          */
     37          
     38          //------------------------------------------------------------------------------
     39          //      Includes
     40          //------------------------------------------------------------------------------
     41          
     42          #include "common.h"
     43          #include "device.h"
     44          #include "board.h"
     45          #include "trace.h"
     46          #include "usb.h"

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork void USB_SetAddress(S_usb const *)
   \                     USB_SetAddress:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0168               LDR      R1,[R0, #+0]
   \   00000004   4969               LDR      R1,[R1, #+20]
   \   00000006   096A               LDR      R1,[R1, #+32]
   \   00000008   ........           BL       __iar_via_R1
   \   0000000C   08BC               POP      {R3}
   \   0000000E   01BC               POP      {R0}
   \   00000010   0047               BX       R0               ;; return
     47          #include "standard.h"
     48          
     49          //------------------------------------------------------------------------------
     50          //      Internal functions
     51          //------------------------------------------------------------------------------
     52          //------------------------------------------------------------------------------
     53          // \brief  Callback for the STD_SetConfiguration function.
     54          //
     55          //         Configures the device and the endpoints
     56          // \param  pClass Pointer to a class driver instance
     57          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
     58          static void STD_ConfigureEndpoints(const S_std_class *pClass)
     59          {
   \                     STD_ConfigureEndpoints:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
     60              unsigned char i;
     61          
     62              // Enter the Configured state
     63              USB_SetConfiguration(pClass->pUsb);
   \   00000004   2068               LDR      R0,[R4, #+0]
   \   00000006   0168               LDR      R1,[R0, #+0]
   \   00000008   4969               LDR      R1,[R1, #+20]
   \   0000000A   496A               LDR      R1,[R1, #+36]
   \   0000000C   ........           BL       __iar_via_R1
     64          
     65              // Configure endpoints
     66              for (i = 0; i < (pClass->pUsb->dNumEndpoints-1); i++) {
   \   00000010   0025               MOVS     R5,#+0
   \   00000012   0BE0               B        ??STD_ConfigureEndpoints_0
     67          
     68                  USB_ConfigureEndpoint(pClass->pUsb,
     69                                        pClass->pDescriptors->pEndpoints[i]);
   \                     ??STD_ConfigureEndpoints_1:
   \   00000014   A900               LSLS     R1,R5,#+2
   \   00000016   6268               LDR      R2,[R4, #+4]
   \   00000018   D268               LDR      R2,[R2, #+12]
   \   0000001A   5158               LDR      R1,[R2, R1]
   \   0000001C   0268               LDR      R2,[R0, #+0]
   \   0000001E   5269               LDR      R2,[R2, #+20]
   \   00000020   9269               LDR      R2,[R2, #+24]
   \   00000022   ........           BL       __iar_via_R2
     70              }
   \   00000026   6D1C               ADDS     R5,R5,#+1
   \   00000028   2D06               LSLS     R5,R5,#+24
   \   0000002A   2D0E               LSRS     R5,R5,#+24
   \                     ??STD_ConfigureEndpoints_0:
   \   0000002C   2068               LDR      R0,[R4, #+0]
   \   0000002E   8168               LDR      R1,[R0, #+8]
   \   00000030   491E               SUBS     R1,R1,#+1
   \   00000032   8D42               CMP      R5,R1
   \   00000034   EED3               BCC      ??STD_ConfigureEndpoints_1
     71          }
   \   00000036   38BC               POP      {R3-R5}
   \   00000038   01BC               POP      {R0}
   \   0000003A   0047               BX       R0               ;; return
     72          
     73          //------------------------------------------------------------------------------
     74          // \brief  Sends a zero-length packet and starts the configuration procedure.
     75          // \param  pClass          Pointer to a class driver instance
     76          // \param  bConfiguration  Newly selected configuration
     77          //------------------------------------------------------------------------------
     78          static void STD_SetConfiguration(S_std_class   *pClass,
     79                                           unsigned char bConfiguration)
     80          {
     81              USB_SendZLP0(pClass->pUsb,
     82                           (Callback_f) STD_ConfigureEndpoints,
     83                           pClass);
     84          }
     85          
     86          //------------------------------------------------------------------------------
     87          // \brief  Sends the currently selected configuration to the host.
     88          // \param  pClass Pointer to a class driver instance
     89          //------------------------------------------------------------------------------
     90          static void STD_GetConfiguration(S_std_class *pClass)
     91          {
     92              if (ISSET(USB_GetState(pClass->pUsb), USB_STATE_CONFIGURED)) {
     93          
     94                  pClass->wData = 1;
     95              }
     96              else {
     97          
     98                  pClass->wData = 0;
     99              }
    100          
    101              USB_Write(pClass->pUsb, 0, &(pClass->wData), 1, 0, 0);
    102          }
    103          
    104          //------------------------------------------------------------------------------
    105          // \brief  Sends the current device status to the host.
    106          // \param  pClass Pointer to a class driver interface
    107          //------------------------------------------------------------------------------
    108          static void STD_GetDeviceStatus(S_std_class *pClass)
    109          {
    110              // Bus or self-powered ?
    111              if (ISSET(pClass->pDescriptors->pConfiguration->bmAttibutes,
    112                        USB_CONFIG_SELF_NOWAKEUP)) {
    113          
    114                  // Self powered device
    115                  pClass->wDeviceStatus |= SELF_POWERED;
    116              }
    117              else {
    118          
    119                  // Bus powered device
    120                  pClass->wDeviceStatus &= ~SELF_POWERED;
    121              }
    122          
    123              // Return the device status
    124              USB_Write(pClass->pUsb, 0, &(pClass->wDeviceStatus), 2, 0, 0);
    125          }
    126          
    127          //------------------------------------------------------------------------------
    128          // \brief  Sends the current status of specified endpoint to the host.
    129          // \param  pClass    Pointer to a class driver instance
    130          // \param  bEndpoint Endpoint number
    131          //------------------------------------------------------------------------------
    132          static void STD_GetEndpointStatus(S_std_class   *pClass,
    133                                            unsigned char bEndpoint)
    134          {
    135              //! Retrieve the endpoint current status
    136              pClass->wData = (unsigned short) USB_Halt(pClass->pUsb,
    137                                                        bEndpoint,
    138                                                        USB_GET_STATUS);
    139          
    140              //! Return the endpoint status
    141              USB_Write(pClass->pUsb, 0, &(pClass->wData), 2, 0, 0);
    142          }
    143          
    144          //------------------------------------------------------------------------------
    145          // \brief  Sends the device descriptor to the host.
    146          //
    147          //         The number of bytes actually sent depends on both the length
    148          //         requested by the host and the actual length of the descriptor.
    149          // \param  pClass  Pointer to a class driver instance
    150          // \param  wLength Number of bytes requested by the host
    151          //------------------------------------------------------------------------------
    152          static void STD_GetDeviceDescriptor(const S_std_class *pClass,
    153                                              unsigned short    wLength)
    154          {
    155              USB_Write(pClass->pUsb,
    156                        0,
    157                        (void *) pClass->pDescriptors->pDevice,
    158                        min(sizeof(S_usb_device_descriptor), wLength),
    159                        0,
    160                        0);
    161          }
    162          
    163          //------------------------------------------------------------------------------
    164          // \brief  Sends the configuration descriptor to the host.
    165          //
    166          //         The number of bytes actually sent depends on both the length
    167          //         requested by the host and the actual length of the descriptor.
    168          // \param  pClass  Pointer to a class driver instance
    169          // \param  wLength Number of bytes requested by the host
    170          //------------------------------------------------------------------------------
    171          static void STD_GetConfigurationDescriptor(const S_std_class *pClass,
    172                                                     unsigned short    wLength)
    173          {
    174              USB_Write(pClass->pUsb,
    175                        0,
    176                        (void *) pClass->pDescriptors->pConfiguration,
    177                        min(pClass->pDescriptors->pConfiguration->wTotalLength,
    178                            wLength),
    179                        0,
    180                        0);
    181          }
    182          
    183          #if defined(HIGHSPEED)
    184          //------------------------------------------------------------------------------
    185          // \brief  Sends the qualifier descriptor to the host.
    186          //
    187          //         The number of bytes actually sent depends on both the length
    188          //         requested by the host and the actual length of the descriptor.
    189          // \param  pClass  Pointer to a class driver instance
    190          // \param  wLength Number of bytes requested by the host
    191          //------------------------------------------------------------------------------
    192          static void STD_GetQualifierDescriptor(const S_std_class *pClass,
    193                                                 unsigned short    wLength)
    194          {
    195              USB_Write(pClass->pUsb,
    196                        0,
    197                        (void *) pClass->pDescriptors->pQualifier,
    198                        min(pClass->pDescriptors->pQualifier->bLength, wLength),
    199                        0,
    200                        0);
    201          }
    202          
    203          //------------------------------------------------------------------------------
    204          // \brief  Sends the other speed configuration descriptor to the host.
    205          //
    206          //         The number of bytes actually sent depends on both the length
    207          //         requested by the host and the actual length of the descriptor.
    208          // \param  pClass  Pointer to a class driver instance
    209          // \param  wLength Number of bytes requested by the host
    210          //------------------------------------------------------------------------------
    211          static void STD_GetOSCDescriptor(const S_std_class *pClass,
    212                                           unsigned short    wLength)
    213          {
    214              USB_Write(pClass->pUsb,
    215                        0,
    216                        (void *) pClass->pDescriptors->pOtherSpeedConfiguration,
    217                        min(pClass->pDescriptors->pOtherSpeedConfiguration->wTotalLength,
    218                            wLength),
    219                        0,
    220                        0);
    221          }
    222          #endif
    223          
    224          //------------------------------------------------------------------------------
    225          // \brief  Sends the specified string descriptor to the host
    226          //
    227          //         The number of bytes actually sent depends on both the length
    228          //         requested by the host and the actual length of the descriptor.
    229          // \param  pClass  Pointer to a class driver instance
    230          // \param  wLength Number of bytes requested by the host
    231          // \param  wIndex  Index of requested string descriptor
    232          //------------------------------------------------------------------------------
    233          static void STD_GetStringDescriptor(const S_std_class *pClass,
    234                                              unsigned short    wLength,
    235                                              unsigned char     bIndex)
    236          {
    237              USB_Write(pClass->pUsb,
    238                        0,
    239                        (void *) pClass->pDescriptors->pStrings[bIndex],
    240                        min( *(pClass->pDescriptors->pStrings[bIndex]), wLength),
    241                        0,
    242                        0);
    243          }
    244          
    245          //------------------------------------------------------------------------------
    246          //      Exported functions
    247          //------------------------------------------------------------------------------
    248          //------------------------------------------------------------------------------
    249          //! \ingroup usb_std_req_hlr
    250          //! \brief   Handles standard SETUP requests
    251          //! \param   pClass Pointer to a class driver instance
    252          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    253          void STD_RequestHandler(S_std_class *pClass)
    254          {
   \                     STD_RequestHandler:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    255              S_usb_request *pSetup = USB_GetSetup(pClass->pUsb);
   \   00000004   2068               LDR      R0,[R4, #+0]
   \   00000006   0169               LDR      R1,[R0, #+16]
    256          
    257              //TRACE_DEBUG_M("Std ");
    258          
    259              // Handle incoming request
    260              switch (pSetup->bRequest) {
   \   00000008   4A78               LDRB     R2,[R1, #+1]
   \   0000000A   092A               CMP      R2,#+9
   \   0000000C   00D9               BLS      .+4
   \   0000000E   F6E0               B        ??STD_RequestHandler_1
   \   00000010   01A3               ADR      R3,??STD_RequestHandler_0
   \   00000012   9B5C               LDRB     R3,[R3, R2]
   \   00000014   5B00               LSLS     R3,R3,#+1
   \   00000016   9F44               ADD      PC,PC,R3
   \                     ??STD_RequestHandler_0:
   \   00000018   9A70F2CD           DC8      +154,+112,+242,+205
   \   0000001C   F24904F2           DC8      +242,+73,+4,+242
   \   00000020   5D53               DC8      +93,+83
    261              //----------------------
    262              case USB_GET_DESCRIPTOR:
    263              //----------------------
    264                  //TRACE_DEBUG_M("gDesc ");
    265          
    266                  // The HBYTE macro returns the upper byte of a word
    267                  switch (HBYTE(pSetup->wValue)) {
   \                     ??STD_RequestHandler_2:
   \   00000022   4A88               LDRH     R2,[R1, #+2]
   \   00000024   130A               LSRS     R3,R2,#+8
   \   00000026   012B               CMP      R3,#+1
   \   00000028   04D0               BEQ      ??STD_RequestHandler_3
   \   0000002A   022B               CMP      R3,#+2
   \   0000002C   14D0               BEQ      ??STD_RequestHandler_4
   \   0000002E   032B               CMP      R3,#+3
   \   00000030   24D0               BEQ      ??STD_RequestHandler_5
   \   00000032   E4E0               B        ??STD_RequestHandler_1
    268                  //-------------------------
    269                  case USB_DEVICE_DESCRIPTOR:
    270                  //-------------------------
    271                      //TRACE_DEBUG_M("Dev ");
    272                      STD_GetDeviceDescriptor(pClass, pSetup->wLength);
   \                     ??STD_RequestHandler_3:
   \   00000034   CB88               LDRH     R3,[R1, #+6]
   \   00000036   132B               CMP      R3,#+19
   \   00000038   00D3               BCC      ??STD_RequestHandler_6
   \   0000003A   1223               MOVS     R3,#+18
   \                     ??STD_RequestHandler_6:
   \   0000003C   0500               MOVS     R5,R0
   \   0000003E   0021               MOVS     R1,#+0
   \   00000040   0020               MOVS     R0,#+0
   \   00000042   03B4               PUSH     {R0,R1}
   \   00000044   6068               LDR      R0,[R4, #+4]
   \   00000046   0268               LDR      R2,[R0, #+0]
   \                     ??STD_RequestHandler_7:
   \   00000048   2800               MOVS     R0,R5
   \   0000004A   2C68               LDR      R4,[R5, #+0]
   \                     ??STD_RequestHandler_8:
   \   0000004C   6469               LDR      R4,[R4, #+20]
   \   0000004E   6468               LDR      R4,[R4, #+4]
   \   00000050   ........           BL       __iar_via_R4
   \   00000054   02B0               ADD      SP,SP,#+8
   \   00000056   D8E0               B        ??STD_RequestHandler_9
    273                      break;
    274          
    275                  //--------------------------------
    276                  case USB_CONFIGURATION_DESCRIPTOR:
    277                  //--------------------------------
    278                      TRACE_DEBUG_M("Cfg ");
    279                      STD_GetConfigurationDescriptor(pClass, pSetup->wLength);
   \                     ??STD_RequestHandler_4:
   \   00000058   C888               LDRH     R0,[R1, #+6]
   \   0000005A   6168               LDR      R1,[R4, #+4]
   \   0000005C   4968               LDR      R1,[R1, #+4]
   \   0000005E   8B78               LDRB     R3,[R1, #+2]
   \   00000060   CA78               LDRB     R2,[R1, #+3]
   \   00000062   1206               LSLS     R2,R2,#+24
   \   00000064   120C               LSRS     R2,R2,#+16
   \   00000066   1343               ORRS     R3,R3,R2
   \   00000068   8342               CMP      R3,R0
   \   0000006A   00D9               BLS      ??STD_RequestHandler_10
   \   0000006C   0300               MOVS     R3,R0
   \                     ??STD_RequestHandler_10:
   \   0000006E   2568               LDR      R5,[R4, #+0]
   \   00000070   0021               MOVS     R1,#+0
   \   00000072   0020               MOVS     R0,#+0
   \   00000074   03B4               PUSH     {R0,R1}
   \   00000076   6068               LDR      R0,[R4, #+4]
   \   00000078   4268               LDR      R2,[R0, #+4]
   \   0000007A   E5E7               B.N      ??STD_RequestHandler_7
    280                      break;
    281          
    282          #if defined(HIGHSPEED)
    283                  //-----------------------------------
    284                  case USB_DEVICE_QUALIFIER_DESCRIPTOR:
    285                  //-----------------------------------
    286                      //TRACE_DEBUG_M("Qua ");
    287                      STD_GetQualifierDescriptor(pClass, pSetup->wLength);
    288                      break;
    289          
    290                  //--------------------------------------------
    291                  case USB_OTHER_SPEED_CONFIGURATION_DESCRIPTOR:
    292                  //--------------------------------------------
    293                      //TRACE_DEBUG_M("OSC ");
    294                      STD_GetOSCDescriptor(pClass, pSetup->wLength);
    295                      break;
    296          #endif
    297                  //-------------------------
    298                  case USB_STRING_DESCRIPTOR:
    299                  //-------------------------
    300                      //TRACE_DEBUG_M("Str%d ", LBYTE(pSetup->wValue));
    301                      STD_GetStringDescriptor(pClass,
    302                                              pSetup->wLength,
    303                                              LBYTE(pSetup->wValue));
   \                     ??STD_RequestHandler_5:
   \   0000007C   C988               LDRH     R1,[R1, #+6]
   \   0000007E   1206               LSLS     R2,R2,#+24
   \   00000080   920D               LSRS     R2,R2,#+22
   \   00000082   6568               LDR      R5,[R4, #+4]
   \   00000084   AB68               LDR      R3,[R5, #+8]
   \   00000086   9B58               LDR      R3,[R3, R2]
   \   00000088   1B78               LDRB     R3,[R3, #+0]
   \   0000008A   8B42               CMP      R3,R1
   \   0000008C   00D9               BLS      ??STD_RequestHandler_11
   \   0000008E   0B00               MOVS     R3,R1
   \                     ??STD_RequestHandler_11:
   \   00000090   0400               MOVS     R4,R0
   \   00000092   0021               MOVS     R1,#+0
   \   00000094   0020               MOVS     R0,#+0
   \   00000096   03B4               PUSH     {R0,R1}
   \   00000098   A868               LDR      R0,[R5, #+8]
   \   0000009A   8258               LDR      R2,[R0, R2]
   \   0000009C   2000               MOVS     R0,R4
   \   0000009E   2468               LDR      R4,[R4, #+0]
   \                     ??STD_RequestHandler_12:
   \   000000A0   6469               LDR      R4,[R4, #+20]
   \   000000A2   6468               LDR      R4,[R4, #+4]
   \   000000A4   ........           BL       __iar_via_R4
   \   000000A8   02B0               ADD      SP,SP,#+8
   \   000000AA   AEE0               B        ??STD_RequestHandler_9
    304                      break;
    305          
    306                  //------
    307                  default:
    308                  //------
    309                      TRACE_WARNING(
    310                          "W: STD_RequestHandler: Unknown GetDescriptor = 0x%02X\n\r",
    311                          pSetup->bRequest
    312                      );
    313                      USB_Stall(pClass->pUsb, 0);
    314          
    315                  }
    316                  break;
    317          
    318              //-------------------
    319              case USB_SET_ADDRESS:
    320              //-------------------
    321                  TRACE_DEBUG_M("sAddr ");
    322                  USB_SendZLP0(pClass->pUsb,
    323                               (Callback_f) USB_SetAddress,
    324                               (void *) pClass->pUsb);
   \                     ??STD_RequestHandler_13:
   \   000000AC   0400               MOVS     R4,R0
   \   000000AE   0100               MOVS     R1,R0
   \   000000B0   5748               LDR      R0,??STD_RequestHandler_14  ;; USB_SetAddress
   \   000000B2   03B4               PUSH     {R0,R1}
   \   000000B4   0023               MOVS     R3,#+0
   \   000000B6   0022               MOVS     R2,#+0
   \   000000B8   1100               MOVS     R1,R2
   \   000000BA   2000               MOVS     R0,R4
   \   000000BC   2468               LDR      R4,[R4, #+0]
   \   000000BE   C5E7               B.N      ??STD_RequestHandler_8
    325                  break;
    326          
    327              //-------------------------
    328              case USB_SET_CONFIGURATION:
    329              //-------------------------
    330                  TRACE_DEBUG_M("sCfg ");
    331                  STD_SetConfiguration(pClass, (char) pSetup->wValue);
   \                     ??STD_RequestHandler_15:
   \   000000C0   0500               MOVS     R5,R0
   \   000000C2   2100               MOVS     R1,R4
   \   000000C4   5348               LDR      R0,??STD_RequestHandler_14+0x4  ;; STD_ConfigureEndpoints
   \   000000C6   03B4               PUSH     {R0,R1}
   \   000000C8   0023               MOVS     R3,#+0
   \   000000CA   0022               MOVS     R2,#+0
   \   000000CC   1100               MOVS     R1,R2
   \   000000CE   2800               MOVS     R0,R5
   \   000000D0   2C68               LDR      R4,[R5, #+0]
   \   000000D2   E5E7               B.N      ??STD_RequestHandler_12
    332                  break;
    333          
    334              //-------------------------
    335              case USB_GET_CONFIGURATION:
    336              //------------------------- 
    337                  TRACE_DEBUG_M("gCfg ");
    338                  STD_GetConfiguration(pClass);
   \                     ??STD_RequestHandler_16:
   \   000000D4   4169               LDR      R1,[R0, #+20]
   \   000000D6   0968               LDR      R1,[R1, #+0]
   \   000000D8   1022               MOVS     R2,#+16
   \   000000DA   0A40               ANDS     R2,R2,R1
   \   000000DC   511E               SUBS     R1,R2,#+1
   \   000000DE   8941               SBCS     R1,R1,R1
   \   000000E0   C943               MVNS     R1,R1
   \   000000E2   C90F               LSRS     R1,R1,#+31
   \   000000E4   6181               STRH     R1,[R4, #+10]
   \   000000E6   0500               MOVS     R5,R0
   \   000000E8   0021               MOVS     R1,#+0
   \   000000EA   0020               MOVS     R0,#+0
   \   000000EC   03B4               PUSH     {R0,R1}
   \   000000EE   0123               MOVS     R3,#+1
   \   000000F0   0A34               ADDS     R4,R4,#+10
   \   000000F2   2200               MOVS     R2,R4
   \   000000F4   2800               MOVS     R0,R5
   \   000000F6   2C68               LDR      R4,[R5, #+0]
   \   000000F8   A8E7               B.N      ??STD_RequestHandler_8
    339                  break;
    340          
    341              //---------------------
    342              case USB_CLEAR_FEATURE:
    343              //---------------------
    344                  TRACE_DEBUG_M("cFeat ");
    345          
    346                  switch (pSetup->wValue) {
   \                     ??STD_RequestHandler_17:
   \   000000FA   4A88               LDRH     R2,[R1, #+2]
   \   000000FC   002A               CMP      R2,#+0
   \   000000FE   02D0               BEQ      ??STD_RequestHandler_18
   \   00000100   012A               CMP      R2,#+1
   \   00000102   17D0               BEQ      ??STD_RequestHandler_19
   \   00000104   7BE0               B        ??STD_RequestHandler_1
    347                      //---------------------
    348                      case USB_ENDPOINT_HALT:
    349                      //---------------------
    350                          TRACE_DEBUG_M("Hlt ");
    351                          USB_Halt(pClass->pUsb, LBYTE(pSetup->wIndex), USB_CLEAR_FEATURE);
   \                     ??STD_RequestHandler_18:
   \   00000106   0122               MOVS     R2,#+1
   \   00000108   8988               LDRH     R1,[R1, #+4]
   \   0000010A   4906               LSLS     R1,R1,#+25
   \   0000010C   490E               LSRS     R1,R1,#+25
   \   0000010E   0368               LDR      R3,[R0, #+0]
   \   00000110   5B69               LDR      R3,[R3, #+20]
   \   00000112   1B69               LDR      R3,[R3, #+16]
   \   00000114   ........           BL       __iar_via_R3
    352                          USB_SendZLP0(pClass->pUsb, 0, 0);
   \   00000118   2468               LDR      R4,[R4, #+0]
   \   0000011A   0021               MOVS     R1,#+0
   \   0000011C   0020               MOVS     R0,#+0
   \   0000011E   03B4               PUSH     {R0,R1}
   \   00000120   0300               MOVS     R3,R0
   \   00000122   0200               MOVS     R2,R0
   \   00000124   2000               MOVS     R0,R4
   \   00000126   2468               LDR      R4,[R4, #+0]
   \   00000128   6469               LDR      R4,[R4, #+20]
   \   0000012A   6468               LDR      R4,[R4, #+4]
   \   0000012C   ........           BL       __iar_via_R4
   \   00000130   02B0               ADD      SP,SP,#+8
   \   00000132   6AE0               B        ??STD_RequestHandler_9
    353                          break;
    354          
    355                      //----------------------------
    356                      case USB_DEVICE_REMOTE_WAKEUP:
    357                      //----------------------------
    358                          TRACE_DEBUG_M("RmWak ");
    359                          pClass->wDeviceStatus &= ~REMOTE_WAKEUP; // Remote wakeup disabled
   \                     ??STD_RequestHandler_19:
   \   00000134   2189               LDRH     R1,[R4, #+8]
   \   00000136   384A               LDR      R2,??STD_RequestHandler_14+0x8  ;; 0xfffd
   \   00000138   0A40               ANDS     R2,R2,R1
   \   0000013A   2281               STRH     R2,[R4, #+8]
    360                          USB_SendZLP0(pClass->pUsb, 0, 0);
   \   0000013C   0400               MOVS     R4,R0
   \   0000013E   0021               MOVS     R1,#+0
   \   00000140   0020               MOVS     R0,#+0
   \   00000142   03B4               PUSH     {R0,R1}
   \   00000144   0300               MOVS     R3,R0
   \   00000146   0200               MOVS     R2,R0
   \   00000148   2000               MOVS     R0,R4
   \   0000014A   2468               LDR      R4,[R4, #+0]
   \   0000014C   7EE7               B.N      ??STD_RequestHandler_8
    361                          break;
    362          
    363                      //------
    364                      default:
    365                      //------
    366                          TRACE_DEBUG_H("Sta ");
    367                          USB_Stall(pClass->pUsb, 0);
    368          
    369                  }
    370                  break;
    371          
    372              //------------------
    373              case USB_GET_STATUS:
    374              //------------------
    375                  TRACE_DEBUG_H("gSta ");
    376          
    377                  switch (USB_REQUEST_RECIPIENT(pSetup)) {
   \                     ??STD_RequestHandler_20:
   \   0000014E   0A78               LDRB     R2,[R1, #+0]
   \   00000150   D206               LSLS     R2,R2,#+27
   \   00000152   D20E               LSRS     R2,R2,#+27
   \   00000154   02D0               BEQ      ??STD_RequestHandler_21
   \   00000156   022A               CMP      R2,#+2
   \   00000158   18D0               BEQ      ??STD_RequestHandler_22
   \   0000015A   50E0               B        ??STD_RequestHandler_1
    378                  //-------------------------
    379                  case USB_RECIPIENT_DEVICE:
    380                  //-------------------------
    381                      TRACE_DEBUG_M("Dev ");
    382                      STD_GetDeviceStatus(pClass);
   \                     ??STD_RequestHandler_21:
   \   0000015C   6168               LDR      R1,[R4, #+4]
   \   0000015E   4968               LDR      R1,[R1, #+4]
   \   00000160   C979               LDRB     R1,[R1, #+7]
   \   00000162   C022               MOVS     R2,#+192
   \   00000164   0A40               ANDS     R2,R2,R1
   \   00000166   C02A               CMP      R2,#+192
   \   00000168   2189               LDRH     R1,[R4, #+8]
   \   0000016A   02D1               BNE      ??STD_RequestHandler_23
   \   0000016C   0122               MOVS     R2,#+1
   \   0000016E   0A43               ORRS     R2,R2,R1
   \   00000170   01E0               B.N      ??STD_RequestHandler_24
   \                     ??STD_RequestHandler_23:
   \   00000172   2A4A               LDR      R2,??STD_RequestHandler_14+0xC  ;; 0xfffe
   \   00000174   0A40               ANDS     R2,R2,R1
   \                     ??STD_RequestHandler_24:
   \   00000176   2281               STRH     R2,[R4, #+8]
   \   00000178   0500               MOVS     R5,R0
   \   0000017A   0021               MOVS     R1,#+0
   \   0000017C   0020               MOVS     R0,#+0
   \   0000017E   03B4               PUSH     {R0,R1}
   \   00000180   0223               MOVS     R3,#+2
   \   00000182   0834               ADDS     R4,R4,#+8
   \   00000184   2200               MOVS     R2,R4
   \   00000186   2800               MOVS     R0,R5
   \   00000188   2C68               LDR      R4,[R5, #+0]
   \   0000018A   5FE7               B.N      ??STD_RequestHandler_8
    383                      break;
    384          
    385                  //---------------------------
    386                  case USB_RECIPIENT_ENDPOINT:
    387                  //---------------------------
    388                      TRACE_DEBUG_M("Ept ");
    389                      STD_GetEndpointStatus(pClass,
    390                                            LBYTE(pSetup->wIndex));
   \                     ??STD_RequestHandler_22:
   \   0000018C   0022               MOVS     R2,#+0
   \   0000018E   8988               LDRH     R1,[R1, #+4]
   \   00000190   4906               LSLS     R1,R1,#+25
   \   00000192   490E               LSRS     R1,R1,#+25
   \   00000194   0368               LDR      R3,[R0, #+0]
   \   00000196   5B69               LDR      R3,[R3, #+20]
   \   00000198   1B69               LDR      R3,[R3, #+16]
   \   0000019A   ........           BL       __iar_via_R3
   \   0000019E   6081               STRH     R0,[R4, #+10]
   \   000001A0   2568               LDR      R5,[R4, #+0]
   \   000001A2   0021               MOVS     R1,#+0
   \   000001A4   0020               MOVS     R0,#+0
   \   000001A6   03B4               PUSH     {R0,R1}
   \   000001A8   0223               MOVS     R3,#+2
   \   000001AA   0A34               ADDS     R4,R4,#+10
   \   000001AC   2200               MOVS     R2,R4
   \   000001AE   2800               MOVS     R0,R5
   \   000001B0   2C68               LDR      R4,[R5, #+0]
   \   000001B2   75E7               B.N      ??STD_RequestHandler_12
    391                      break;
    392          
    393                  //------
    394                  default:
    395                  //------
    396                      TRACE_WARNING(
    397                          "W: STD_RequestHandler: Unsupported GetStatus = 0x%02X\n\r",
    398                          pSetup->bmRequestType
    399                      );
    400                      USB_Stall(pClass->pUsb, 0);
    401          
    402                  }
    403                  break;
    404          
    405              //-------------------
    406              case USB_SET_FEATURE:
    407              //-------------------
    408                  TRACE_DEBUG_H("sFeat ");
    409          
    410                  switch (pSetup->wValue) {
   \                     ??STD_RequestHandler_25:
   \   000001B4   4A88               LDRH     R2,[R1, #+2]
   \   000001B6   002A               CMP      R2,#+0
   \   000001B8   02D0               BEQ      ??STD_RequestHandler_26
   \   000001BA   012A               CMP      R2,#+1
   \   000001BC   12D0               BEQ      ??STD_RequestHandler_27
   \   000001BE   1EE0               B        ??STD_RequestHandler_28
    411                  //---------------------
    412                  case USB_ENDPOINT_HALT:
    413                  //---------------------
    414                      USB_Halt(pClass->pUsb, LBYTE(pSetup->wIndex), USB_SET_FEATURE);
   \                     ??STD_RequestHandler_26:
   \   000001C0   0322               MOVS     R2,#+3
   \   000001C2   8988               LDRH     R1,[R1, #+4]
   \   000001C4   4906               LSLS     R1,R1,#+25
   \   000001C6   490E               LSRS     R1,R1,#+25
   \   000001C8   0368               LDR      R3,[R0, #+0]
   \   000001CA   5B69               LDR      R3,[R3, #+20]
   \   000001CC   1B69               LDR      R3,[R3, #+16]
   \   000001CE   ........           BL       __iar_via_R3
    415                      USB_SendZLP0(pClass->pUsb, 0, 0);
   \   000001D2   2468               LDR      R4,[R4, #+0]
   \   000001D4   0021               MOVS     R1,#+0
   \   000001D6   0020               MOVS     R0,#+0
   \   000001D8   03B4               PUSH     {R0,R1}
   \   000001DA   0300               MOVS     R3,R0
   \   000001DC   0200               MOVS     R2,R0
   \   000001DE   2000               MOVS     R0,R4
   \   000001E0   2468               LDR      R4,[R4, #+0]
   \   000001E2   33E7               B.N      ??STD_RequestHandler_8
    416                      break;
    417          
    418                  //----------------------------
    419                  case USB_DEVICE_REMOTE_WAKEUP:
    420                  //----------------------------
    421                      pClass->wDeviceStatus |= REMOTE_WAKEUP; // Remote wakeup enabled
   \                     ??STD_RequestHandler_27:
   \   000001E4   2189               LDRH     R1,[R4, #+8]
   \   000001E6   0222               MOVS     R2,#+2
   \   000001E8   0A43               ORRS     R2,R2,R1
   \   000001EA   2281               STRH     R2,[R4, #+8]
    422                      USB_SendZLP0(pClass->pUsb, 0, 0);
   \   000001EC   0400               MOVS     R4,R0
   \   000001EE   0021               MOVS     R1,#+0
   \   000001F0   0020               MOVS     R0,#+0
   \   000001F2   03B4               PUSH     {R0,R1}
   \   000001F4   0300               MOVS     R3,R0
   \   000001F6   0200               MOVS     R2,R0
   \   000001F8   2000               MOVS     R0,R4
   \   000001FA   2468               LDR      R4,[R4, #+0]
   \   000001FC   50E7               B.N      ??STD_RequestHandler_12
    423                      break;
    424          
    425                  //------
    426                  default:
    427                  //------
    428                      TRACE_WARNING(
    429                          "W: STD_RequestHandler: Unsupported SetFeature=0x%04X\n\r",
    430                          pSetup->wValue
    431                      );
    432                      USB_Stall(pClass->pUsb, 0);
    433          
    434                  }
    435                  break;
    436          
    437              //------
    438              default:
    439              //------
    440                  TRACE_WARNING(
    441                      "W: STD_RequestHandler: Unsupported request: 0x%02X\n\r",
    442                      pSetup->bRequest
    443                  );
    444                  USB_Stall(pClass->pUsb, 0);
   \                     ??STD_RequestHandler_28:
   \                     ??STD_RequestHandler_1:
   \   000001FE   0021               MOVS     R1,#+0
   \   00000200   0268               LDR      R2,[R0, #+0]
   \   00000202   5269               LDR      R2,[R2, #+20]
   \   00000204   D268               LDR      R2,[R2, #+12]
   \   00000206   ........           BL       __iar_via_R2
    445              }
    446          }
   \                     ??STD_RequestHandler_9:
   \   0000020A   38BC               POP      {R3-R5}
   \   0000020C   01BC               POP      {R0}
   \   0000020E   0047               BX       R0               ;; return
   \                     ??STD_RequestHandler_14:
   \   00000210   ........           DC32     USB_SetAddress
   \   00000214   ........           DC32     STD_ConfigureEndpoints
   \   00000218   FDFF0000           DC32     0xfffd
   \   0000021C   FEFF0000           DC32     0xfffe
    447          
    448          

   Maximum stack usage in bytes:

     Function               .cstack
     --------               -------
     STD_ConfigureEndpoints     16
     STD_RequestHandler         24
     USB_SetAddress              8


   Section sizes:

     Function/Label         Bytes
     --------------         -----
     USB_SetAddress           18
     STD_ConfigureEndpoints   60
     STD_RequestHandler      544
      Others                   8

 
 630 bytes in section Debug.txt
 
 604 bytes of CODE memory (+ 26 bytes shared)

Errors: none
Warnings: none
