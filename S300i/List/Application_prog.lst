###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           04/Jun/2013  20:18:18 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\Framework\Application_prog.c                  #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\Framework\Application_prog.c" -D              #
#                    AT91SAM7S256 -D AT91SAM7SEK -D iH -D __ALARM -D          #
#                    __WIFI_MODULE -D S300i -lC "D:\Zeuron\Projekty\S300\S300 #
#                    -program v1.3 - 04.06.2013\S300i\List\" --diag_suppress  #
#                    Pa082 -o "D:\Zeuron\Projekty\S300\S300-program v1.3 -    #
#                    04.06.2013\S300i\Obj\" --debug --endian little --cpu     #
#                    ARM7TDMI -e --fpu None --dlib_config "C:\Program Files   #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    5.0\ARM\INC\DLib_Config_Normal.h" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v1.3 - 04.06.2013\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v1.3 - 04.06.2013\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v1.3 - 04.06.2013\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\Framework\Configuration\" -I "C:\Program      #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\INC\" --section .text=Debug.txt --interwork      #
#                    --cpu_mode thumb -Oh                                     #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300i\List\Application_prog.lst               #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300i\Obj\Application_prog.o                  #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\Application_prog.c
      1          //****************************************************************************//
      2          //*--------------------------------------------------------------------------*//
      3          //*                                 CEURON                                   *//                       
      4          //*--------------------------------------------------------------------------*//
      5          //*--------------------------------------------------------------------------*//
      6          //*  Nazwa pliku                  : Application_prog.c                       *//
      7          //*  Opis                         : Plik obs³ugi programu u¿ytkowego         *//
      8          //*  Autor                        : Pawe³ Narwojsz                           *//
      9          //*  Data utrzorzenia             : 10.09.2007                               *//
     10          //*  Data ostatniej modyfikacji   : --.--.----                               *//
     11          //*--------------------------------------------------------------------------*//
     12          //*                                                                          *//
     13          //*--------------------------------------------------------------------------*//
     14          //* Rejestr zmian  (data - opis):                                            *//
     15          //*                                                                          *//
     16          //*                               Brak zmian                                 *//
     17          //*                                                                          *//
     18          //*__________________________________________________________________________*// 
     19          //****************************************************************************//
     20          //****************************************************************************//
     21          
     22          
     23          
     24          
     25          #include "Application_prog.h" 
     26          
     27          #include "Framework.h"
     28          #include "core/device.h"                                                        //aduje bibliotreki dla odpowiedniego procesora
     29          #include "modbus.h"

                                          
                                          ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\Configuration\InterruptPriority.h",59  Warning[Pe001]: 
          last line of file ends without a newline
     30          #include "usart.h"
     31          #include "RF_Exe.h"
     32          #include "ScreenMENU2.h"
     33          
     34          
     35          //Zmienne globalne -------------------------------------------------------------
     36            char NumberScene=NumberSceneMax;  //iloœæ u¿ywanych scen. Wartoœæ pierwotnie NumberSceneMax nastêpnie wyliczana
     37            short ScreenUse;

   \                                 In section .bss, align 1
     38            char SceneBefOff=0; //Je¿eli >0 to oznacza ¿e sceny zosta³y wy³¹czone przyskiem/zdarzeniem off.  SceneBefOff= nr sceny przed wy³¹czeniem
   \                     SceneBefOff:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     39            _TransQuality TransQuality; //tablica informacyjna jakoœci po³¹czenia pola odpowiadaj¹ polom _ProgramTab.NeuronsIdTab
   \                     TransQuality:
   \   00000000                      DS8 216
     40          
     41            //___________________________Koniec zmiennych globalnych________________________
     42          
     43          
     44          
     45          
     46          #ifdef _LIVE_RJESTR   
     47            extern unsigned short LIVE_TAB[LIVE_TAB_SIZE];
     48            extern char LIVE_TAB_IDX;
     49          #endif
     50            
     51          
     52          extern RAM ram;
     53          extern int g_US0_BAUDRATE;
     54          //extern FlashPagesOffset;

   \                                 In section .bss, align 4
     55          Convers_DW_F ProgConvers_DW_F;
   \                     ProgConvers_DW_F:
   \   00000000                      DS8 4
     56          
     57          extern  _ScreenPaternDesign ScreenSetTab_0[];
     58          extern  _ScreenPaternDesign ScreenSetTab_1[];
     59          extern int int1;
     60          extern int FlashProgramOfset;
     61          extern int g_counter;
     62          extern char AdressModbus;
     63          extern char q_US0_Comm_Mode;
     64          extern char US0_MasterMODBUS_ENABLE;
     65          extern void Delay (unsigned long a);
     66          extern char g_Stop_Program;                                                     //1- zatrzymuje program
     67          extern char g_Restart_Program;                                                  //1- restartuje program
     68          extern unsigned int CyklPerSek;
     69          extern _DateTime DateTime;
     70          extern _RF_TaskTab  RF_TaskTab;

   \                                 In section .bss, align 4
     71          _ButtonGraph  ButtonExe[ScreenNr][ScrenButtonNr];                                         //do tej zmiennej przepisywane sa stany 1 z Button
   \                     ButtonExe:
   \   00000000                      DS8 576
     72          
     73          

   \                                 In section .bss, align 8
     74          volatile _ProgramTab gProg;
   \                     gProg:
   \   00000000                      DS8 50800
     75          char        *pProg=(char*)&gProg;

   \                                 In section .bss, align 4
     76          _NeuronsListUnit NeuronsList[NumberNeurons];
   \                     NeuronsList:
   \   00000000                      DS8 420
     77          
     78          
     79          
     80          
     81          char Variables[13];    //zmienne
     82          char VariablesImpulse[13];    //zmienne - flaga impulsu
     83          //char VariablesNetTmp[13];    //zmienne tyczmasowe dla komunikacji WiFi stosowana jako separacja  Variables[] ¿eby nie nadpisywaæ zmiennych

   \                                 In section .bss, align 4
     84          short int VariablesAnal[AnalogVarAmount];    //zmienne
   \                     VariablesAnal:
   \   00000000                      DS8 40
     85          
     86          extern unsigned char ChangeStageFlag;
     87          
     88          

   \                                 In section .bss, align 4
     89          _MainStage  MainStage; 
   \                     MainStage:
   \   00000000                      DS8 1808
     90          _Trap      Trap;
     91          
     92          extern _ZD_MODBUS ZD_MODBUS_0[ZD_MODBUS_Tab_Max];

   \                                 In section Debug.txt, align 4, keep-with-next
     93          void SetModbusTask(void)
     94          {
     95          
     96                ptr_ZD_MODBUS ZD_MODBUS;
     97          
     98          
     99                ZD_MODBUS         =   ZD_MODBUS_0;
    100            
    101          
    102             
    103                
    104                char i=0; 
    105            
    106           
    107                   
    108                ZD_MODBUS[i].Adress=1;
   \                     SetModbusTask:
   \   00000000   ....               LDR      R0,??DataTable0  ;; ZD_MODBUS_0
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0170               STRB     R1,[R0, #+0]
    109                ZD_MODBUS[i].Function=0xF;
   \   00000006   0F21               MOVS     R1,#+15
   \   00000008   4170               STRB     R1,[R0, #+1]
    110                ZD_MODBUS[i].Target=0x0;
   \   0000000A   0022               MOVS     R2,#+0
   \   0000000C   8270               STRB     R2,[R0, #+2]
   \   0000000E   C270               STRB     R2,[R0, #+3]
    111                ZD_MODBUS[i].StartAdr=0;
   \   00000010   0271               STRB     R2,[R0, #+4]
   \   00000012   4271               STRB     R2,[R0, #+5]
    112                ZD_MODBUS[i].Coil=8;
   \   00000014   0822               MOVS     R2,#+8
   \   00000016   8271               STRB     R2,[R0, #+6]
   \   00000018   0022               MOVS     R2,#+0
   \   0000001A   C271               STRB     R2,[R0, #+7]
    113                ZD_MODBUS[i].Error=0x0;
   \   0000001C   C272               STRB     R2,[R0, #+11]
   \   0000001E   0273               STRB     R2,[R0, #+12]
    114                
    115                i=1; 
    116                ZD_MODBUS[i].Adress=2;
   \   00000020   0222               MOVS     R2,#+2
   \   00000022   4273               STRB     R2,[R0, #+13]
    117                ZD_MODBUS[i].Function=0xF;
   \   00000024   8173               STRB     R1,[R0, #+14]
    118                ZD_MODBUS[i].Target=0x0;
   \   00000026   0022               MOVS     R2,#+0
   \   00000028   C273               STRB     R2,[R0, #+15]
   \   0000002A   0274               STRB     R2,[R0, #+16]
    119                ZD_MODBUS[i].StartAdr=1;
   \   0000002C   0122               MOVS     R2,#+1
   \   0000002E   4274               STRB     R2,[R0, #+17]
   \   00000030   0022               MOVS     R2,#+0
   \   00000032   8274               STRB     R2,[R0, #+18]
    120                ZD_MODBUS[i].Coil=8;
   \   00000034   0822               MOVS     R2,#+8
   \   00000036   C274               STRB     R2,[R0, #+19]
   \   00000038   0022               MOVS     R2,#+0
   \   0000003A   0275               STRB     R2,[R0, #+20]
    121                ZD_MODBUS[i].Error=0x0;
   \   0000003C   0276               STRB     R2,[R0, #+24]
   \   0000003E   4276               STRB     R2,[R0, #+25]
    122           
    123                i=2; 
    124                ZD_MODBUS[i].Adress=3;
   \   00000040   0322               MOVS     R2,#+3
   \   00000042   8276               STRB     R2,[R0, #+26]
    125                ZD_MODBUS[i].Function=0xF;
   \   00000044   C176               STRB     R1,[R0, #+27]
    126                ZD_MODBUS[i].Target=0x0;
   \   00000046   0021               MOVS     R1,#+0
   \   00000048   0177               STRB     R1,[R0, #+28]
   \   0000004A   4177               STRB     R1,[R0, #+29]
    127                ZD_MODBUS[i].StartAdr=2;
   \   0000004C   0221               MOVS     R1,#+2
   \   0000004E   8177               STRB     R1,[R0, #+30]
   \   00000050   090A               LSRS     R1,R1,#+8
   \   00000052   C177               STRB     R1,[R0, #+31]
    128                ZD_MODBUS[i].Coil=8;
   \   00000054   0100               MOVS     R1,R0
   \   00000056   2031               ADDS     R1,R1,#+32
   \   00000058   0822               MOVS     R2,#+8
   \   0000005A   0A70               STRB     R2,[R1, #+0]
   \   0000005C   120A               LSRS     R2,R2,#+8
   \   0000005E   4A70               STRB     R2,[R1, #+1]
    129                ZD_MODBUS[i].Error=0x0;      
   \   00000060   2530               ADDS     R0,R0,#+37
   \   00000062   0270               STRB     R2,[R0, #+0]
   \   00000064   4270               STRB     R2,[R0, #+1]
    130          
    131               
    132                
    133          }
   \   00000066   7047               BX       LR               ;; return
    134          
    135          
    136          //*-----------------------------------------------------------------------------
    137          //* Nazwa funkcji :    PortStageRead
    138          //* Funkcja wydobywa wartoœæ bitu o numerze PortNr ze zmiennej pod adresem *Stage 
    139          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    140          char PortStageRead(short int Stage, char PortNr)
    141          {
   \                     PortStageRead:
   \   00000000   0200               MOVS     R2,R0
    142              char odp=0;
    143              odp=(Stage>>PortNr)&0x1;
    144              return odp;
   \   00000002   0A41               ASRS     R2,R2,R1
   \   00000004   0120               MOVS     R0,#+1
   \   00000006   1040               ANDS     R0,R0,R2
   \   00000008   7047               BX       LR               ;; return
    145          }
    146          
    147          //*-----------------------------------------------------------------------------
    148          //* Nazwa funkcji :    PortStageSet
    149          //* Funkcja ustawia stan portu (bit PortNr dla zmiennej pod adresem *Stage) na Value 
    150          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    151          void PortStageSet(short int *Stage, char PortNr, char Value)
    152          {
   \                     PortStageSet:
   \   00000000   11B4               PUSH     {R0,R4}
    153              Value&=0x1;
    154              *Stage=(*Stage&(~(0x1<<PortNr))) | (Value<<PortNr);
   \   00000002   0388               LDRH     R3,[R0, #+0]
   \   00000004   0124               MOVS     R4,#+1
   \   00000006   8C40               LSLS     R4,R4,R1
   \   00000008   A343               BICS     R3,R3,R4
   \   0000000A   0124               MOVS     R4,#+1
   \   0000000C   1440               ANDS     R4,R4,R2
   \   0000000E   8C40               LSLS     R4,R4,R1
   \   00000010   1C43               ORRS     R4,R4,R3
   \   00000012   0480               STRH     R4,[R0, #+0]
    155          }
   \   00000014   18BC               POP      {R3,R4}
   \   00000016   7047               BX       LR               ;; return
    156          
    157          
    158          
    159          //*-----------------------------------------------------------------------------
    160          //* Nazwa funkcji :    ProcStI_Action
    161          //* Funkcja procedury "Stan wejœcia"
    162          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    163          void ProcStI_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    164          {  
   \                     ProcStI_Action:
   \   00000000   10B5               PUSH     {R4,LR}
    165            //je¿eli port w wêŸle == 1 i wiarygodny pomiar
    166            if (Proc->Nr>=0)
   \   00000002   0123               MOVS     R3,#+1
   \   00000004   CB56               LDRSB    R3,[R1, R3]
   \   00000006   002B               CMP      R3,#+0
   \   00000008   14D4               BMI      ??ProcStI_Action_0
    167            {
    168              if ((MainStg->StageI[Proc->Nr].Port !=0x8AAA))
   \   0000000A   1624               MOVS     R4,#+22
   \   0000000C   6343               MULS     R3,R4,R3
   \   0000000E   D218               ADDS     R2,R2,R3
   \   00000010   A032               ADDS     R2,R2,#+160
   \   00000012   1388               LDRH     R3,[R2, #+0]
   \   00000014   ....               LDR      R4,??DataTable3  ;; 0x8aaa
   \   00000016   A342               CMP      R3,R4
   \   00000018   18D0               BEQ      ??ProcStI_Action_1
    169              {
    170                 if (*PrvOut)
   \   0000001A   0023               MOVS     R3,#+0
   \   0000001C   C05E               LDRSH    R0,[R0, R3]
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   13D0               BEQ      ??ProcStI_Action_2
    171                 {
    172                    Proc->Out=PortStageRead(MainStg->StageI[Proc->Nr].Port, Proc->Tag.Port);  
   \   00000022   1088               LDRH     R0,[R2, #+0]
   \   00000024   0004               LSLS     R0,R0,#+16
   \   00000026   0014               ASRS     R0,R0,#+16
   \   00000028   0A7A               LDRB     R2,[R1, #+8]
   \   0000002A   1041               ASRS     R0,R0,R2
   \   0000002C   0122               MOVS     R2,#+1
   \   0000002E   0240               ANDS     R2,R2,R0
   \   00000030   4A82               STRH     R2,[R1, #+18]
   \   00000032   0BE0               B        ??ProcStI_Action_1
    173                 }else{
    174                   Proc->Out=0;
    175                 }
    176              }
    177              
    178            //je¿eli zmienna dwustanowa  
    179            }else{
    180                Proc->Out= (Variables[Proc->Tag.Port/8]>> (Proc->Tag.Port%8))&0x1;
   \                     ??ProcStI_Action_0:
   \   00000034   087A               LDRB     R0,[R1, #+8]
   \   00000036   C210               ASRS     R2,R0,#+3
   \   00000038   ....               LDR      R3,??DataTable24  ;; Trap
   \   0000003A   9A18               ADDS     R2,R3,R2
   \   0000003C   127C               LDRB     R2,[R2, #+16]
   \   0000003E   C308               LSRS     R3,R0,#+3
   \   00000040   DB00               LSLS     R3,R3,#+3
   \   00000042   C01A               SUBS     R0,R0,R3
   \   00000044   0241               ASRS     R2,R2,R0
   \   00000046   0120               MOVS     R0,#+1
   \   00000048   1040               ANDS     R0,R0,R2
   \                     ??ProcStI_Action_2:
   \   0000004A   4882               STRH     R0,[R1, #+18]
    181            }
    182          
    183          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStI_Action_1:
   \   0000004C   10BC               POP      {R4}
   \   0000004E   01BC               POP      {R0}
   \   00000050   0047               BX       R0               ;; return
    184          
    185          
    186          
    187          //*-----------------------------------------------------------------------------
    188          //* Nazwa funkcji :    ProcStI_Action
    189          //* Funkcja procedury "Stan wejœcia"
    190          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    191          void ProcStNI_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    192          {  
   \                     ProcStNI_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    193                   //je¿eli port w wêŸle == 1 i wiarygodny pomiar
    194            if ((MainStg->StageI[Proc->Nr].Port !=0x8AAA))
   \   00000002   0123               MOVS     R3,#+1
   \   00000004   CB56               LDRSB    R3,[R1, R3]
   \   00000006   1624               MOVS     R4,#+22
   \   00000008   5C43               MULS     R4,R3,R4
   \   0000000A   1219               ADDS     R2,R2,R4
   \   0000000C   A032               ADDS     R2,R2,#+160
   \   0000000E   1488               LDRH     R4,[R2, #+0]
   \   00000010   ....               LDR      R5,??DataTable3  ;; 0x8aaa
   \   00000012   AC42               CMP      R4,R5
   \   00000014   21D0               BEQ      ??ProcStNI_Action_0
    195            {
    196            
    197             if (*PrvOut)
   \   00000016   0024               MOVS     R4,#+0
   \   00000018   005F               LDRSH    R0,[R0, R4]
   \   0000001A   0028               CMP      R0,#+0
   \   0000001C   1CD0               BEQ      ??ProcStNI_Action_1
    198             {
    199          
    200                   if (Proc->Nr>=0)
   \   0000001E   002B               CMP      R3,#+0
   \   00000020   0AD4               BMI      ??ProcStNI_Action_2
    201                   {
    202                     if (PortStageRead(MainStg->StageI[Proc->Nr].Port, Proc->Tag.Port)==1)
   \   00000022   1088               LDRH     R0,[R2, #+0]
   \   00000024   0004               LSLS     R0,R0,#+16
   \   00000026   0014               ASRS     R0,R0,#+16
   \   00000028   0A7A               LDRB     R2,[R1, #+8]
   \   0000002A   1041               ASRS     R0,R0,R2
   \   0000002C   0122               MOVS     R2,#+1
   \   0000002E   0240               ANDS     R2,R2,R0
   \   00000030   501E               SUBS     R0,R2,#+1
   \   00000032   8041               SBCS     R0,R0,R0
   \   00000034   C00F               LSRS     R0,R0,#+31
   \   00000036   0FE0               B.N      ??ProcStNI_Action_1
    203                     {
    204                      Proc->Out=0; 
    205                     }else{
    206                      Proc->Out=1;
    207                     }
    208                   }else{
    209                     if (((Variables[Proc->Tag.Port/8]>> (Proc->Tag.Port%8))&0x1)==1)
   \                     ??ProcStNI_Action_2:
   \   00000038   087A               LDRB     R0,[R1, #+8]
   \   0000003A   C210               ASRS     R2,R0,#+3
   \   0000003C   ....               LDR      R3,??DataTable24  ;; Trap
   \   0000003E   9A18               ADDS     R2,R3,R2
   \   00000040   127C               LDRB     R2,[R2, #+16]
   \   00000042   C308               LSRS     R3,R0,#+3
   \   00000044   DB00               LSLS     R3,R3,#+3
   \   00000046   C01A               SUBS     R0,R0,R3
   \   00000048   0241               ASRS     R2,R2,R0
   \   0000004A   0120               MOVS     R0,#+1
   \   0000004C   1040               ANDS     R0,R0,R2
   \   0000004E   421E               SUBS     R2,R0,#+1
   \   00000050   9241               SBCS     R2,R2,R2
   \   00000052   D20F               LSRS     R2,R2,#+31
   \   00000054   4A82               STRH     R2,[R1, #+18]
   \   00000056   00E0               B        ??ProcStNI_Action_0
    210                     {
    211                      Proc->Out=0; 
    212                     }else{
    213                      Proc->Out=1;
    214                     }
    215                   }
    216                 }else{
    217                   Proc->Out=0;
   \                     ??ProcStNI_Action_1:
   \   00000058   4882               STRH     R0,[R1, #+18]
    218                 }
    219             }
    220          
    221          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStNI_Action_0:
   \   0000005A   ....               B.N      ??Subroutine0_0

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
   \                     ??Subroutine0_0:
   \   00000004   38BC               POP      {R3-R5}
   \   00000006   01BC               POP      {R0}
   \   00000008   0047               BX       R0               ;; return
    222          
    223          
    224          
    225          
    226          //*-----------------------------------------------------------------------------
    227          //* Nazwa funkcji :    ProcGetAnal_Action
    228          //* Funkcja procedury "Stan wejœcia analogowego"
    229          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    230          void ProcGetReg_Action(_Procedure *Proc, _MainStage *MainStg) 
    231          {  
   \                     ProcGetReg_Action:
   \   00000000   10B5               PUSH     {R4,LR}
    232            if (Proc->Nr>=0)
   \   00000002   027A               LDRB     R2,[R0, #+8]
   \   00000004   5200               LSLS     R2,R2,#+1
   \   00000006   0123               MOVS     R3,#+1
   \   00000008   C356               LDRSB    R3,[R0, R3]
   \   0000000A   1624               MOVS     R4,#+22
   \   0000000C   5C43               MULS     R4,R3,R4
   \   0000000E   0919               ADDS     R1,R1,R4
   \   00000010   8C18               ADDS     R4,R1,R2
   \   00000012   A034               ADDS     R4,R4,#+160
   \   00000014   0949               LDR      R1,??ProcGetReg_Action_0  ;; 0xffff8aaa
   \   00000016   002B               CMP      R3,#+0
   \   00000018   05D4               BMI      ??ProcGetReg_Action_1
    233            {
    234                if ((MainStg->StageI[Proc->Nr].Value[Proc->Tag.RegNr])!=(signed short int )0x8AAA)
   \   0000001A   0022               MOVS     R2,#+0
   \   0000001C   A25E               LDRSH    R2,[R4, R2]
   \   0000001E   8A42               CMP      R2,R1
   \   00000020   08D0               BEQ      ??ProcGetReg_Action_2
    235                {
    236                  Proc->Out=MainStg->StageI[Proc->Nr].Value[Proc->Tag.RegNr];  
   \   00000022   2188               LDRH     R1,[R4, #+0]
   \   00000024   05E0               B.N      ??ProcGetReg_Action_3
    237                }
    238            }else{
    239                if ((MainStg->StageI[Proc->Nr].Value[Proc->Tag.RegNr])!=(signed short int )0x8AAA)
   \                     ??ProcGetReg_Action_1:
   \   00000026   0023               MOVS     R3,#+0
   \   00000028   E35E               LDRSH    R3,[R4, R3]
   \   0000002A   8B42               CMP      R3,R1
   \   0000002C   02D0               BEQ      ??ProcGetReg_Action_2
    240                {
    241                  Proc->Out=VariablesAnal[Proc->Tag.RegNr];
   \   0000002E   ....               LDR      R1,??DataTable7  ;; VariablesAnal
   \   00000030   895A               LDRH     R1,[R1, R2]
   \                     ??ProcGetReg_Action_3:
   \   00000032   4182               STRH     R1,[R0, #+18]
    242                }
    243            }
    244               
    245          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcGetReg_Action_2:
   \   00000034   10BC               POP      {R4}
   \   00000036   01BC               POP      {R0}
   \   00000038   0047               BX       R0               ;; return
   \   0000003A   C046               Nop      
   \                     ??ProcGetReg_Action_0:
   \   0000003C   AA8AFFFF           DC32     0xffff8aaa
    246          
    247          
    248          
    249          //*-----------------------------------------------------------------------------
    250          //* Nazwa funkcji :    ProcSetAnal_Action
    251          //* Funkcja procedury "Ustawienie wyjœcia analogowego"
    252          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    253          void ProcSetAnal_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    254          {  
   \                     ProcSetAnal_Action:
   \   00000000   70B5               PUSH     {R4-R6,LR}
    255            if (Proc->Nr>=0)
   \   00000002   0123               MOVS     R3,#+1
   \   00000004   CC56               LDRSB    R4,[R1, R3]
   \   00000006   002C               CMP      R4,#+0
   \   00000008   09D4               BMI      ??ProcSetAnal_Action_0
    256            {
    257                MainStg->StageQ[Proc->Nr].Value[Proc->Tag.RegNr]=*PrvOut;
   \   0000000A   ....               LDR      R3,??DataTable20  ;; 0x3a2
   \   0000000C   0D7A               LDRB     R5,[R1, #+8]
   \   0000000E   6D00               LSLS     R5,R5,#+1
   \   00000010   1626               MOVS     R6,#+22
   \   00000012   7443               MULS     R4,R6,R4
   \   00000014   1219               ADDS     R2,R2,R4
   \   00000016   5219               ADDS     R2,R2,R5
   \   00000018   0488               LDRH     R4,[R0, #+0]
   \   0000001A   D452               STRH     R4,[R2, R3]
   \   0000001C   04E0               B        ??ProcSetAnal_Action_1
    258            }else{
    259                VariablesAnal[Proc->Tag.RegNr]=*PrvOut;
   \                     ??ProcSetAnal_Action_0:
   \   0000001E   0A7A               LDRB     R2,[R1, #+8]
   \   00000020   5200               LSLS     R2,R2,#+1
   \   00000022   ....               LDR      R3,??DataTable7  ;; VariablesAnal
   \   00000024   0488               LDRH     R4,[R0, #+0]
   \   00000026   9C52               STRH     R4,[R3, R2]
    260            }  
    261            Proc->Out=*PrvOut;
   \                     ??ProcSetAnal_Action_1:
   \   00000028   ....               B.N      ?Subroutine1
    262           
    263          }//_______________________ Koniec funkcji  ____________________________

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ?Subroutine1:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
   \                     ??Subroutine1_0:
   \   00000004   70BC               POP      {R4-R6}
   \   00000006   01BC               POP      {R0}
   \   00000008   0047               BX       R0               ;; return
    264          
    265          
    266          
    267          
    268          //*-----------------------------------------------------------------------------
    269          //* Nazwa funkcji :    ProcConstAnal_Action
    270          //* Funkcja procedury "staa analogowa"
    271          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    272          void ProcConstAnal_Action(_Procedure *Proc) 
    273          {  
    274            Proc->Out=Proc->Tag.ConstAnValue;  
   \                     ProcConstAnal_Action:
   \   00000000   0189               LDRH     R1,[R0, #+8]
   \   00000002   4182               STRH     R1,[R0, #+18]
    275          }//_______________________ Koniec funkcji  ____________________________
   \   00000004   7047               BX       LR               ;; return
    276          
    277          
    278          
    279          
    280          
    281          //*-----------------------------------------------------------------------------
    282          
    283          
    284          
    285          
    286          
    287          //*-----------------------------------------------------------------------------
    288          //* Nazwa funkcji :    ProcStB_Action
    289          //* Funkcja procedury "Akcja przycisków przycisków"
    290          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    291          void ProcStB_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    292          {  
   \                     ProcStB_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    293             if (*PrvOut)
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C05E               LDRSH    R0,[R0, R3]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   04D0               BEQ      ??ProcStB_Action_0
    294             {
    295                Proc->Out=MainStg->StageButtonExe[Proc->Nr];  
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   0856               LDRSB    R0,[R1, R0]
   \   0000000E   1018               ADDS     R0,R2,R0
   \   00000010   5030               ADDS     R0,R0,#+80
   \   00000012   0078               LDRB     R0,[R0, #+0]
    296          
    297             }else{
    298               Proc->Out=0;
   \                     ??ProcStB_Action_0:
   \   00000014   4882               STRH     R0,[R1, #+18]
    299             }
    300          
    301          }//_______________________ Koniec funkcji  ____________________________
   \   00000016   ....               B.N      ??Subroutine2_1

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ?Subroutine2:
   \   00000000   4A82               STRH     R2,[R1, #+18]
   \                     ??Subroutine2_0:
   \   00000002   0088               LDRH     R0,[R0, #+0]
   \   00000004   0874               STRB     R0,[R1, #+16]
   \                     ??Subroutine2_1:
   \   00000006   08BC               POP      {R3}
   \   00000008   01BC               POP      {R0}
   \   0000000A   0047               BX       R0               ;; return
   \                     ??Subroutine2_2:
   \   0000000C   ........           DC32     g_seconds_counter
   \   00000010   ........           DC32     g_seconds_counter
    302          
    303          
    304          
    305          //*-----------------------------------------------------------------------------
    306          //* Nazwa funkcji :    ProcStQ_Action
    307          //* Funkcja procedury "Stan wyjœcia"
    308          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    309          void ProcStQ_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    310          {  
   \                     ProcStQ_Action:
   \   00000000   10B5               PUSH     {R4,LR}
    311             if (*PrvOut)
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C05E               LDRSH    R0,[R0, R3]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   0CD0               BEQ      ??ProcStQ_Action_0
    312             {
    313                Proc->Out=PortStageRead(MainStg->StageQ[Proc->Nr].Port,Proc->Tag.Port);  
   \   0000000A   ....               LDR      R0,??DataTable20  ;; 0x3a2
   \   0000000C   0123               MOVS     R3,#+1
   \   0000000E   CB56               LDRSB    R3,[R1, R3]
   \   00000010   1624               MOVS     R4,#+22
   \   00000012   6343               MULS     R3,R4,R3
   \   00000014   D218               ADDS     R2,R2,R3
   \   00000016   125A               LDRH     R2,[R2, R0]
   \   00000018   1204               LSLS     R2,R2,#+16
   \   0000001A   1214               ASRS     R2,R2,#+16
   \   0000001C   087A               LDRB     R0,[R1, #+8]
   \   0000001E   0241               ASRS     R2,R2,R0
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   1040               ANDS     R0,R0,R2
    314             }else{
    315                Proc->Out=0;
   \                     ??ProcStQ_Action_0:
   \   00000024   4882               STRH     R0,[R1, #+18]
    316             }
    317          
    318          }//_______________________ Koniec funkcji  ____________________________
   \   00000026   10BC               POP      {R4}
   \   00000028   01BC               POP      {R0}
   \   0000002A   0047               BX       R0               ;; return
    319          
    320          
    321          
    322          
    323          
    324          //*-----------------------------------------------------------------------------
    325          //* Nazwa funkcji :    ProcStS_Action
    326          //* Funkcja procedury "Stan sceny"
    327          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    328          void ProcStS_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    329          {  
   \                     ProcStS_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    330            Proc->Out=0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   4B82               STRH     R3,[R1, #+18]
    331             if (*PrvOut)
   \   00000006   C05E               LDRSH    R0,[R0, R3]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   07D0               BEQ      ??ProcStS_Action_0
    332             {
    333                if (Proc->Nr==MainStg->SceneNr) Proc->Out=1;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   0856               LDRSB    R0,[R1, R0]
   \   00000010   ....               LDR      R3,??DataTable9  ;; 0x6ea
   \   00000012   D25C               LDRB     R2,[R2, R3]
   \   00000014   9042               CMP      R0,R2
   \   00000016   01D1               BNE      ??ProcStS_Action_0
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   4882               STRH     R0,[R1, #+18]
    334             }
    335          
    336          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStS_Action_0:
   \   0000001C   ....               B.N      ??Subroutine2_1
    337          
    338          
    339          
    340          /*
    341          
    342          //-----------------------------------------------------------------------------
    343          // Nazwa funkcji :    ProcStT_Action
    344          // Funkcja procedury "Stan timera"
    345          //-----------------------------------------------------------------------------
    346          void ProcStT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    347          {  
    348             if (*PrvOut)
    349             {
    350                Proc->Out=PortStageRead(MainStg->StageTimer[Proc->Nr].Port,Proc->Tag.Port);  
    351             }else{
    352                Proc->Out=0;
    353             }
    354          
    355          }//_______________________ Koniec funkcji  ____________________________
    356          
    357          
    358          
    359          
    360          //-----------------------------------------------------------------------------
    361          // Nazwa funkcji :    ProcStT_Action
    362          // Funkcja procedury "Stan timera"
    363          //-----------------------------------------------------------------------------
    364          void ProcStNT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    365          {  
    366             if (*PrvOut) 
    367             {
    368                if (PortStageRead(MainStg->StageTimer[Proc->Nr].Port,Proc->Tag.Port))
    369                {
    370                  Proc->Out=0;
    371                }else{
    372                  Proc->Out=1;  
    373                }
    374             }else{
    375                Proc->Out=0;
    376             }
    377          
    378          }//_______________________ Koniec funkcji  ____________________________
    379          */
    380          
    381          
    382          
    383           extern unsigned long long g_NextTimeProgram;
    384          
    385          
    386          //*-----------------------------------------------------------------------------
    387          //* Nazwa funkcji :    ProcWOUT_Action
    388          //* Funkcja procedury "Ustaw stan wyjœcia"
    389          //*-----------------------------------------------------------------------------
    390          

   \                                 In section Debug.txt, align 4, keep-with-next
    391          void ProcWOUT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    392          {  
   \                     ProcWOUT_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0B00               MOVS     R3,R1
    393          
    394               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   205E               LDRSH    R0,[R4, R0]
   \   0000000A   0128               CMP      R0,#+1
   \   0000000C   2FD1               BNE      ??ProcWOUT_Action_0
   \   0000000E   1220               MOVS     R0,#+18
   \   00000010   185E               LDRSH    R0,[R3, R0]
   \   00000012   0028               CMP      R0,#+0
   \   00000014   5DD1               BNE      ??ProcWOUT_Action_1
    395               {
    396                if ((Proc->Nr>=0) && (Proc->Nr!=0xFF))   //je¿eli wêze³
                                                     ^
Warning[Pa084]: pointless integer comparison with an out of range value
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   1956               LDRSB    R1,[R3, R0]
   \   0000001A   0029               CMP      R1,#+0
   \   0000001C   1BD4               BMI      ??ProcWOUT_Action_2
   \   0000001E   FF29               CMP      R1,#+255
   \   00000020   19D0               BEQ      ??ProcWOUT_Action_2
    397                {
    398                   PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,1); 
                                       ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000022   187A               LDRB     R0,[R3, #+8]
   \   00000024   ....               LDR      R5,??DataTable20  ;; 0x3a2
   \   00000026   1626               MOVS     R6,#+22
   \   00000028   7143               MULS     R1,R6,R1
   \   0000002A   5118               ADDS     R1,R2,R1
   \   0000002C   4919               ADDS     R1,R1,R5
   \   0000002E   0125               MOVS     R5,#+1
   \   00000030   8540               LSLS     R5,R5,R0
   \   00000032   0888               LDRH     R0,[R1, #+0]
   \   00000034   A843               BICS     R0,R0,R5
   \   00000036   0543               ORRS     R5,R5,R0
   \   00000038   0D80               STRH     R5,[R1, #+0]
    399                   if (TransQuality.Mensur[Proc->Nr-1]>0)  MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   0000003A   0120               MOVS     R0,#+1
   \   0000003C   1856               LDRSB    R0,[R3, R0]
   \   0000003E   8100               LSLS     R1,R0,#+2
   \   00000040   ....               LDR      R5,??DataTable21  ;; TransQuality
   \   00000042   6918               ADDS     R1,R5,R1
   \   00000044   896C               LDR      R1,[R1, #+72]
   \   00000046   0029               CMP      R1,#+0
   \   00000048   11D0               BEQ      ??ProcWOUT_Action_0
   \   0000004A   ....               LDR      R1,??DataTable22  ;; 0x6eb
   \   0000004C   1018               ADDS     R0,R2,R0
   \   0000004E   ....               LDR      R5,??DataTable23  ;; ChangeStageFlag
   \   00000050   2D78               LDRB     R5,[R5, #+0]
   \   00000052   4554               STRB     R5,[R0, R1]
   \   00000054   0BE0               B        ??ProcWOUT_Action_0
    400                 
    401                   #ifdef _LIVE_RJESTR 
    402                       LIVE_TAB[LIVE_TAB_IDX]=0xF000 | ((Proc->Nr&0xF)<<8) | ((MainStg->StageQ[Proc->Nr].Port)&0xFF);
    403                       if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    404                   #endif
    405          
    406                }else{  //je¿eli zmienna dwustanowa  
    407                    Variables[Proc->Tag.Port/8] |= 1<<(Proc->Tag.Port%8);
   \                     ??ProcWOUT_Action_2:
   \   00000056   187A               LDRB     R0,[R3, #+8]
   \   00000058   ....               LDR      R1,??DataTable24  ;; Trap
   \   0000005A   C510               ASRS     R5,R0,#+3
   \   0000005C   4D19               ADDS     R5,R1,R5
   \   0000005E   2E7C               LDRB     R6,[R5, #+16]
   \   00000060   0121               MOVS     R1,#+1
   \   00000062   C708               LSRS     R7,R0,#+3
   \   00000064   FF00               LSLS     R7,R7,#+3
   \   00000066   C01B               SUBS     R0,R0,R7
   \   00000068   8140               LSLS     R1,R1,R0
   \   0000006A   3143               ORRS     R1,R1,R6
   \   0000006C   2974               STRB     R1,[R5, #+16]
    408                    
    409                    #ifdef _LIVE_RJESTR   
    410                        LIVE_TAB[LIVE_TAB_IDX]=0xF000 | ((Proc->Nr&0xF)<<8) | ((MainStg->StageQ[Proc->Nr].Port)&0xFF);
    411                        if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    412                    #endif
    413                }
    414               }
    415          
    416               if ((*PrvOut==0) && (Proc->Out==1))
   \                     ??ProcWOUT_Action_0:
   \   0000006E   0020               MOVS     R0,#+0
   \   00000070   205E               LDRSH    R0,[R4, R0]
   \   00000072   0028               CMP      R0,#+0
   \   00000074   2DD1               BNE      ??ProcWOUT_Action_1
   \   00000076   1220               MOVS     R0,#+18
   \   00000078   185E               LDRSH    R0,[R3, R0]
   \   0000007A   0128               CMP      R0,#+1
   \   0000007C   29D1               BNE      ??ProcWOUT_Action_1
    417               {
    418                  if (Proc->Nr>=0)    //je¿eli wêze³
   \   0000007E   1956               LDRSB    R1,[R3, R0]
   \   00000080   0029               CMP      R1,#+0
   \   00000082   187A               LDRB     R0,[R3, #+8]
   \   00000084   1AD4               BMI      ??ProcWOUT_Action_3
    419                  {
    420                     PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,0); 
                                         ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000086   ....               LDR      R5,??DataTable20  ;; 0x3a2
   \   00000088   1626               MOVS     R6,#+22
   \   0000008A   7143               MULS     R1,R6,R1
   \   0000008C   5118               ADDS     R1,R2,R1
   \   0000008E   4919               ADDS     R1,R1,R5
   \   00000090   0D88               LDRH     R5,[R1, #+0]
   \   00000092   0126               MOVS     R6,#+1
   \   00000094   8640               LSLS     R6,R6,R0
   \   00000096   B543               BICS     R5,R5,R6
   \   00000098   0026               MOVS     R6,#+0
   \   0000009A   8640               LSLS     R6,R6,R0
   \   0000009C   2E43               ORRS     R6,R6,R5
   \   0000009E   0E80               STRH     R6,[R1, #+0]
    421                   
    422                     if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \   000000A0   0120               MOVS     R0,#+1
   \   000000A2   1856               LDRSB    R0,[R3, R0]
   \   000000A4   8100               LSLS     R1,R0,#+2
   \   000000A6   ....               LDR      R5,??DataTable21  ;; TransQuality
   \   000000A8   6918               ADDS     R1,R5,R1
   \   000000AA   896C               LDR      R1,[R1, #+72]
   \   000000AC   0029               CMP      R1,#+0
   \   000000AE   10D0               BEQ      ??ProcWOUT_Action_1
    423                     MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   000000B0   ....               LDR      R1,??DataTable22  ;; 0x6eb
   \   000000B2   1018               ADDS     R0,R2,R0
   \   000000B4   ....               LDR      R2,??DataTable23  ;; ChangeStageFlag
   \   000000B6   1278               LDRB     R2,[R2, #+0]
   \   000000B8   4254               STRB     R2,[R0, R1]
   \   000000BA   0AE0               B        ??ProcWOUT_Action_1
    424                    
    425                  }else //je¿eli zmienna dwustanowa
    426                  { 
    427                      Variables[Proc->Tag.Port/8]&= ~(1<<(Proc->Tag.Port%8));
   \                     ??ProcWOUT_Action_3:
   \   000000BC   ....               LDR      R1,??DataTable24  ;; Trap
   \   000000BE   C210               ASRS     R2,R0,#+3
   \   000000C0   8918               ADDS     R1,R1,R2
   \   000000C2   0D7C               LDRB     R5,[R1, #+16]
   \   000000C4   0122               MOVS     R2,#+1
   \   000000C6   C608               LSRS     R6,R0,#+3
   \   000000C8   F600               LSLS     R6,R6,#+3
   \   000000CA   801B               SUBS     R0,R0,R6
   \   000000CC   8240               LSLS     R2,R2,R0
   \   000000CE   9543               BICS     R5,R5,R2
   \   000000D0   0D74               STRB     R5,[R1, #+16]
    428                      #ifdef _LIVE_RJESTR 
    429                        LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    430                        if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    431                      #endif
    432                  }  
    433               }
    434               Proc->Out=*PrvOut;
   \                     ??ProcWOUT_Action_1:
   \   000000D2   2088               LDRH     R0,[R4, #+0]
   \   000000D4   5882               STRH     R0,[R3, #+18]
    435            
    436          }//_______________________ Koniec funkcji  ____________________________
   \   000000D6   F8BC               POP      {R3-R7}
   \   000000D8   01BC               POP      {R0}
   \   000000DA   0047               BX       R0               ;; return
    437          
    438          
    439                
    440          
    441          //*-----------------------------------------------------------------------------
    442          //* Nazwa funkcji :    ProcWOUTS_Action
    443          //* Funkcja procedury "Ustaw stan wyjœcia na 1"
    444          //*-----------------------------------------------------------------------------
    445          

   \                                 In section Debug.txt, align 4, keep-with-next
    446          void ProcWOUTS_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    447          {  
   \                     ProcWOUTS_Action:
   \   00000000   70B5               PUSH     {R4-R6,LR}
    448          
    449               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   012B               CMP      R3,#+1
   \   00000008   2DD1               BNE      ??ProcWOUTS_Action_0
   \   0000000A   1223               MOVS     R3,#+18
   \   0000000C   CB5E               LDRSH    R3,[R1, R3]
   \   0000000E   002B               CMP      R3,#+0
   \   00000010   29D1               BNE      ??ProcWOUTS_Action_0
    450               {
    451                if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000012   0123               MOVS     R3,#+1
   \   00000014   CC56               LDRSB    R4,[R1, R3]
   \   00000016   002C               CMP      R4,#+0
   \   00000018   19D4               BMI      ??ProcWOUTS_Action_1
    452                {
    453                 PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,1); 
                                     ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   0000001A   0B7A               LDRB     R3,[R1, #+8]
   \   0000001C   ....               LDR      R5,??DataTable20  ;; 0x3a2
   \   0000001E   1626               MOVS     R6,#+22
   \   00000020   7443               MULS     R4,R6,R4
   \   00000022   1419               ADDS     R4,R2,R4
   \   00000024   6419               ADDS     R4,R4,R5
   \   00000026   0125               MOVS     R5,#+1
   \   00000028   9D40               LSLS     R5,R5,R3
   \   0000002A   2388               LDRH     R3,[R4, #+0]
   \   0000002C   AB43               BICS     R3,R3,R5
   \   0000002E   1D43               ORRS     R5,R5,R3
   \   00000030   2580               STRH     R5,[R4, #+0]
    454                 
    455                 if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \   00000032   0123               MOVS     R3,#+1
   \   00000034   CB56               LDRSB    R3,[R1, R3]
   \   00000036   9C00               LSLS     R4,R3,#+2
   \   00000038   ....               LDR      R5,??DataTable21  ;; TransQuality
   \   0000003A   2C19               ADDS     R4,R5,R4
   \   0000003C   A46C               LDR      R4,[R4, #+72]
   \   0000003E   002C               CMP      R4,#+0
   \   00000040   11D0               BEQ      ??ProcWOUTS_Action_0
    456                   MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   00000042   ....               LDR      R4,??DataTable22  ;; 0x6eb
   \   00000044   D218               ADDS     R2,R2,R3
   \   00000046   ....               LDR      R3,??DataTable23  ;; ChangeStageFlag
   \   00000048   1B78               LDRB     R3,[R3, #+0]
   \   0000004A   1355               STRB     R3,[R2, R4]
   \   0000004C   0BE0               B        ??ProcWOUTS_Action_0
    457                
    458                 #ifdef _LIVE_RJESTR 
    459                 LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    460                 if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    461                 #endif
    462                 
    463                 //je¿eli zmienna dwustanowa  
    464                }else{
    465                    Variables[Proc->Tag.Port/8]|= 1<<(Proc->Tag.Port%8);
   \                     ??ProcWOUTS_Action_1:
   \   0000004E   0A7A               LDRB     R2,[R1, #+8]
   \   00000050   D310               ASRS     R3,R2,#+3
   \   00000052   ....               LDR      R4,??DataTable24  ;; Trap
   \   00000054   E318               ADDS     R3,R4,R3
   \   00000056   1D7C               LDRB     R5,[R3, #+16]
   \   00000058   0124               MOVS     R4,#+1
   \   0000005A   D608               LSRS     R6,R2,#+3
   \   0000005C   F600               LSLS     R6,R6,#+3
   \   0000005E   921B               SUBS     R2,R2,R6
   \   00000060   9440               LSLS     R4,R4,R2
   \   00000062   2C43               ORRS     R4,R4,R5
   \   00000064   1C74               STRB     R4,[R3, #+16]
   \                     ??ProcWOUTS_Action_0:
   \   00000066   C046               Nop      
    466                }
    467               }
    468               Proc->Out=*PrvOut;
   \   00000068                      REQUIRE ?Subroutine1
   \   00000068                      ;; // Fall through to label ?Subroutine1
    469            
    470          }//_______________________ Koniec funkcji  ____________________________
    471          
    472          
    473          //*-----------------------------------------------------------------------------
    474          //* Nazwa funkcji :    ProcWOUTR_Action
    475          //* Funkcja procedury "Ustaw stan wyjœcia  na 0"
    476          //*-----------------------------------------------------------------------------
    477          

   \                                 In section Debug.txt, align 4, keep-with-next
    478          void ProcWOUTR_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    479          {  
   \                     ProcWOUTR_Action:
   \   00000000   70B5               PUSH     {R4-R6,LR}
    480          
    481               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   012B               CMP      R3,#+1
   \   00000008   2FD1               BNE      ??ProcWOUTR_Action_0
   \   0000000A   1223               MOVS     R3,#+18
   \   0000000C   CB5E               LDRSH    R3,[R1, R3]
   \   0000000E   002B               CMP      R3,#+0
   \   00000010   2BD1               BNE      ??ProcWOUTR_Action_0
    482               {
    483                if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000012   0123               MOVS     R3,#+1
   \   00000014   CC56               LDRSB    R4,[R1, R3]
   \   00000016   002C               CMP      R4,#+0
   \   00000018   1BD4               BMI      ??ProcWOUTR_Action_1
    484                { 
    485                 PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,0); 
                                     ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   0000001A   0B7A               LDRB     R3,[R1, #+8]
   \   0000001C   134D               LDR      R5,??ProcWOUTR_Action_2  ;; 0x3a2
   \   0000001E   1626               MOVS     R6,#+22
   \   00000020   7443               MULS     R4,R6,R4
   \   00000022   1419               ADDS     R4,R2,R4
   \   00000024   6419               ADDS     R4,R4,R5
   \   00000026   2588               LDRH     R5,[R4, #+0]
   \   00000028   0126               MOVS     R6,#+1
   \   0000002A   9E40               LSLS     R6,R6,R3
   \   0000002C   B543               BICS     R5,R5,R6
   \   0000002E   0026               MOVS     R6,#+0
   \   00000030   9E40               LSLS     R6,R6,R3
   \   00000032   2E43               ORRS     R6,R6,R5
   \   00000034   2680               STRH     R6,[R4, #+0]
    486                 
    487                 if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \   00000036   0123               MOVS     R3,#+1
   \   00000038   CB56               LDRSB    R3,[R1, R3]
   \   0000003A   9C00               LSLS     R4,R3,#+2
   \   0000003C   0C4D               LDR      R5,??ProcWOUTR_Action_2+0x4  ;; TransQuality
   \   0000003E   2C19               ADDS     R4,R5,R4
   \   00000040   A46C               LDR      R4,[R4, #+72]
   \   00000042   002C               CMP      R4,#+0
   \   00000044   11D0               BEQ      ??ProcWOUTR_Action_0
    488                   MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   00000046   0B4C               LDR      R4,??ProcWOUTR_Action_2+0x8  ;; 0x6eb
   \   00000048   D218               ADDS     R2,R2,R3
   \   0000004A   0B4B               LDR      R3,??ProcWOUTR_Action_2+0xC  ;; ChangeStageFlag
   \   0000004C   1B78               LDRB     R3,[R3, #+0]
   \   0000004E   1355               STRB     R3,[R2, R4]
   \   00000050   0BE0               B        ??ProcWOUTR_Action_0
    489                 
    490                 #ifdef _LIVE_RJESTR 
    491                  LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    492                  if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    493                 #endif
    494                  
    495                  //je¿eli zmienna dwustanowa  
    496                }else{
    497                    Variables[Proc->Tag.Port/8]&= ~(1<<(Proc->Tag.Port%8));
   \                     ??ProcWOUTR_Action_1:
   \   00000052   0A7A               LDRB     R2,[R1, #+8]
   \   00000054   D310               ASRS     R3,R2,#+3
   \   00000056   094C               LDR      R4,??ProcWOUTR_Action_2+0x10  ;; Trap
   \   00000058   E318               ADDS     R3,R4,R3
   \   0000005A   1D7C               LDRB     R5,[R3, #+16]
   \   0000005C   0124               MOVS     R4,#+1
   \   0000005E   D608               LSRS     R6,R2,#+3
   \   00000060   F600               LSLS     R6,R6,#+3
   \   00000062   921B               SUBS     R2,R2,R6
   \   00000064   9440               LSLS     R4,R4,R2
   \   00000066   A543               BICS     R5,R5,R4
   \   00000068   1D74               STRB     R5,[R3, #+16]
    498                }
    499               }
    500               Proc->Out=*PrvOut;
   \                     ??ProcWOUTR_Action_0:
   \   0000006A   ....               B.N      ?Subroutine1
   \                     ??ProcWOUTR_Action_2:
   \   0000006C   A2030000           DC32     0x3a2
   \   00000070   ........           DC32     TransQuality
   \   00000074   EB060000           DC32     0x6eb
   \   00000078   ........           DC32     ChangeStageFlag
   \   0000007C   ........           DC32     Trap
    501            
    502          }//_______________________ Koniec funkcji  ____________________________
    503          
    504          
    505          
    506          
    507          //*-----------------------------------------------------------------------------
    508          //* Nazwa funkcji :    ProcWOUTC_Action
    509          //* Funkcja procedury "zmaina stanu wyjœcia/zmiennej na przeciwny "
    510          //*-----------------------------------------------------------------------------
    511          

   \                                 In section Debug.txt, align 4, keep-with-next
    512          void ProcWOUTC_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    513          {  
   \                     ProcWOUTC_Action:
   \   00000000   70B5               PUSH     {R4-R6,LR}
    514          
    515               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   012B               CMP      R3,#+1
   \   00000008   42D1               BNE      ??ProcWOUTC_Action_0
   \   0000000A   1223               MOVS     R3,#+18
   \   0000000C   CB5E               LDRSH    R3,[R1, R3]
   \   0000000E   002B               CMP      R3,#+0
   \   00000010   3ED1               BNE      ??ProcWOUTC_Action_0
    516               {
    517                if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000012   0B7A               LDRB     R3,[R1, #+8]
   \   00000014   0124               MOVS     R4,#+1
   \   00000016   0C57               LDRSB    R4,[R1, R4]
   \   00000018   002C               CMP      R4,#+0
   \   0000001A   27D4               BMI      ??ProcWOUTC_Action_1
    518                {
    519                     if (PortStageRead(MainStg->StageQ[Proc->Nr].Port,Proc->Tag.Port)==1) //je¿eli wyjœcie w stanie wysokim to zeruj je¿eli nie to ustaw 1
   \   0000001C   1D4D               LDR      R5,??ProcWOUTC_Action_2  ;; 0x3a2
   \   0000001E   1626               MOVS     R6,#+22
   \   00000020   7443               MULS     R4,R6,R4
   \   00000022   1419               ADDS     R4,R2,R4
   \   00000024   6419               ADDS     R4,R4,R5
   \   00000026   2588               LDRH     R5,[R4, #+0]
   \   00000028   2D04               LSLS     R5,R5,#+16
   \   0000002A   2D14               ASRS     R5,R5,#+16
   \   0000002C   1D41               ASRS     R5,R5,R3
   \   0000002E   ED07               LSLS     R5,R5,#+31
   \   00000030   08D5               BPL      ??ProcWOUTC_Action_3
    520                     { 
    521                        PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,0); 
                                            ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000032   2588               LDRH     R5,[R4, #+0]
   \   00000034   0126               MOVS     R6,#+1
   \   00000036   9E40               LSLS     R6,R6,R3
   \   00000038   B543               BICS     R5,R5,R6
   \   0000003A   0026               MOVS     R6,#+0
   \   0000003C   9E40               LSLS     R6,R6,R3
   \   0000003E   2E43               ORRS     R6,R6,R5
   \   00000040   2680               STRH     R6,[R4, #+0]
   \   00000042   05E0               B        ??ProcWOUTC_Action_4
    522                     }else{
    523                        PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,1);
                                            ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \                     ??ProcWOUTC_Action_3:
   \   00000044   0125               MOVS     R5,#+1
   \   00000046   9D40               LSLS     R5,R5,R3
   \   00000048   2388               LDRH     R3,[R4, #+0]
   \   0000004A   AB43               BICS     R3,R3,R5
   \   0000004C   1D43               ORRS     R5,R5,R3
   \   0000004E   2580               STRH     R5,[R4, #+0]
    524                     }
    525                   
    526                     if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \                     ??ProcWOUTC_Action_4:
   \   00000050   0123               MOVS     R3,#+1
   \   00000052   CB56               LDRSB    R3,[R1, R3]
   \   00000054   9C00               LSLS     R4,R3,#+2
   \   00000056   104D               LDR      R5,??ProcWOUTC_Action_2+0x4  ;; TransQuality
   \   00000058   2C19               ADDS     R4,R5,R4
   \   0000005A   A46C               LDR      R4,[R4, #+72]
   \   0000005C   002C               CMP      R4,#+0
   \   0000005E   17D0               BEQ      ??ProcWOUTC_Action_0
    527                     MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   00000060   0E4C               LDR      R4,??ProcWOUTC_Action_2+0x8  ;; 0x6eb
   \   00000062   D218               ADDS     R2,R2,R3
   \   00000064   0E4B               LDR      R3,??ProcWOUTC_Action_2+0xC  ;; ChangeStageFlag
   \   00000066   1B78               LDRB     R3,[R3, #+0]
   \   00000068   1355               STRB     R3,[R2, R4]
   \   0000006A   11E0               B        ??ProcWOUTC_Action_0
    528                  
    529                     #ifdef _LIVE_RJESTR 
    530                      LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    531                      if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    532                     #endif
    533                   
    534                 
    535                 //je¿eli zmienna dwustanowa  
    536                }else{
    537                      if (Variables[Proc->Tag.Port/8] && (1<<(Proc->Tag.Port%8)))
   \                     ??ProcWOUTC_Action_1:
   \   0000006C   0122               MOVS     R2,#+1
   \   0000006E   DC08               LSRS     R4,R3,#+3
   \   00000070   E400               LSLS     R4,R4,#+3
   \   00000072   1C1B               SUBS     R4,R3,R4
   \   00000074   A240               LSLS     R2,R2,R4
   \   00000076   DB10               ASRS     R3,R3,#+3
   \   00000078   0A4C               LDR      R4,??ProcWOUTC_Action_2+0x10  ;; Trap
   \   0000007A   E318               ADDS     R3,R4,R3
   \   0000007C   1C7C               LDRB     R4,[R3, #+16]
   \   0000007E   002C               CMP      R4,#+0
   \   00000080   04D0               BEQ      ??ProcWOUTC_Action_5
   \   00000082   002A               CMP      R2,#+0
   \   00000084   02D0               BEQ      ??ProcWOUTC_Action_5
    538                      {
    539                         Variables[Proc->Tag.Port/8] &= ~(1<<(Proc->Tag.Port%8));
   \   00000086   9443               BICS     R4,R4,R2
   \   00000088   1C74               STRB     R4,[R3, #+16]
   \   0000008A   01E0               B        ??ProcWOUTC_Action_0
    540                      }else{
    541                         Variables[Proc->Tag.Port/8] |= (1<<(Proc->Tag.Port%8));
   \                     ??ProcWOUTC_Action_5:
   \   0000008C   2243               ORRS     R2,R2,R4
   \   0000008E   1A74               STRB     R2,[R3, #+16]
    542                      }
    543                }
    544               }
    545               Proc->Out=*PrvOut;
   \                     ??ProcWOUTC_Action_0:
   \   00000090   ....               B.N      ?Subroutine1
   \   00000092   C046               Nop      
   \                     ??ProcWOUTC_Action_2:
   \   00000094   A2030000           DC32     0x3a2
   \   00000098   ........           DC32     TransQuality
   \   0000009C   EB060000           DC32     0x6eb
   \   000000A0   ........           DC32     ChangeStageFlag
   \   000000A4   ........           DC32     Trap
    546            
    547          }//_______________________ Koniec funkcji  ____________________________
    548          
    549          
    550          
    551          
    552          
    553          /*
    554          //-----------------------------------------------------------------------------
    555          // Nazwa funkcji :    ProcSetT_Action
    556          // Funkcja procedury "Forsuj stan timera"
    557          //-----------------------------------------------------------------------------
    558          
    559          void ProcRstT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    560          {  
    561               if ((*PrvOut==1) && (Proc->Out==0))
    562               {
    563                  MainStg->StageTimer[Proc->Nr].Curent=0;
    564                  MainObiect.Timer[Proc->Nr]=0;
    565               }
    566               Proc->Out=*PrvOut;
    567            
    568          }//_______________________ Koniec funkcji  ____________________________
    569          */
    570          
    571          
    572          
    573          //*-----------------------------------------------------------------------------
    574          //* Nazwa funkcji :    ProcNOT_Action
    575          //* Funkcja procedury "Negacja
    576          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    577          void ProcNOT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    578          {  
    579             if (*PrvOut)
   \                     ProcNOT_Action:
   \   00000000   0022               MOVS     R2,#+0
   \   00000002   825E               LDRSH    R2,[R0, R2]
   \   00000004   501E               SUBS     R0,R2,#+1
   \   00000006   8041               SBCS     R0,R0,R0
   \   00000008   C00F               LSRS     R0,R0,#+31
   \   0000000A   4882               STRH     R0,[R1, #+18]
    580             {
    581                Proc->Out=0;  
    582             }else{
    583                Proc->Out=1;
    584             }
    585          }//_______________________ Koniec funkcji__ ____________________________
   \   0000000C   7047               BX       LR               ;; return
    586          
    587          
    588          
    589          
    590          //*-----------------------------------------------------------------------------
    591          //* Nazwa funkcji :    ProcToggleT_Action
    592          //* Funkcja procedury "Przerzutnik typu T"
    593          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    594          void ProcToggleRS_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    595          {  
   \                     ProcToggleRS_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    596             if ((*PrvOut))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C05E               LDRSH    R0,[R0, R3]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   02D0               BEQ      ??ProcToggleRS_Action_0
    597             {
    598               Proc->Out=1;
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   5082               STRH     R0,[R2, #+18]
   \   0000000E   03E0               B        ??ProcToggleRS_Action_1
    599             }
    600             else if (*UpOut)
   \                     ??ProcToggleRS_Action_0:
   \   00000010   085E               LDRSH    R0,[R1, R0]
   \   00000012   0028               CMP      R0,#+0
   \   00000014   00D0               BEQ      ??ProcToggleRS_Action_1
    601             {
    602               Proc->Out=0;
   \   00000016   5382               STRH     R3,[R2, #+18]
    603             }
    604             
    605          
    606               
    607          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcToggleRS_Action_1:
   \   00000018   ....               B.N      ??Subroutine2_1
    608          
    609          
    610          
    611          
    612          //*-----------------------------------------------------------------------------
    613          //* Nazwa funkcji :    ProcToggleT_Action
    614          //* Funkcja procedury "Przerzutnik typu T"
    615          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    616          void ProcToggleT_Action(short int *PrvOut, _Procedure *Proc) 
    617          {  
   \                     ProcToggleT_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    618             if ((*PrvOut) && (Proc->LastIn==0) && (Proc->Out==0))
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   825E               LDRSH    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   0CD0               BEQ      ??ProcToggleT_Action_0
   \   0000000A   0A7C               LDRB     R2,[R1, #+16]
   \   0000000C   002A               CMP      R2,#+0
   \   0000000E   09D1               BNE      ??ProcToggleT_Action_0
   \   00000010   1222               MOVS     R2,#+18
   \   00000012   8A5E               LDRSH    R2,[R1, R2]
   \   00000014   002A               CMP      R2,#+0
   \   00000016   01D1               BNE      ??ProcToggleT_Action_1
    619             {
    620               Proc->Out=1;
   \   00000018   0122               MOVS     R2,#+1
   \   0000001A   02E0               B.N      ??ProcToggleT_Action_2
    621             }
   \                     ??ProcToggleT_Action_1:
   \   0000001C   012A               CMP      R2,#+1
   \   0000001E   01D1               BNE      ??ProcToggleT_Action_0
    622             else if ((*PrvOut) && (Proc->LastIn==0) && (Proc->Out==1))
    623             {
    624               Proc->Out=0;
   \   00000020   0022               MOVS     R2,#+0
   \                     ??ProcToggleT_Action_2:
   \   00000022   4A82               STRH     R2,[R1, #+18]
    625             }
    626             
    627             Proc->LastIn=*PrvOut;
   \                     ??ProcToggleT_Action_0:
   \   00000024   ....               B.N      ??Subroutine2_0
    628                 
    629          
    630          
    631          }//_______________________ Koniec funkcji__ ____________________________
    632          
    633          
    634          //*-----------------------------------------------------------------------------
    635          //* Nazwa funkcji :    ProcTLI1_Action
    636          //* Funkcja procedury "Procedura impulsu jednocyklowego
    637          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    638          void ProcTLI1_Action(short int *PrvOut, _Procedure *Proc) 
    639          {  
   \                     ProcTLI1_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    640             if ((*PrvOut) && (Proc->LastIn==0))
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   825E               LDRSH    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   03D0               BEQ      ??ProcTLI1_Action_0
   \   0000000A   0B7C               LDRB     R3,[R1, #+16]
   \   0000000C   5A1E               SUBS     R2,R3,#+1
   \   0000000E   9241               SBCS     R2,R2,R2
   \   00000010   D20F               LSRS     R2,R2,#+31
    641             {
    642               Proc->Out=1;
    643             }
    644             else
    645             {
    646               Proc->Out=0;
   \                     ??ProcTLI1_Action_0:
   \   00000012   ....               B.N      ?Subroutine2
    647             }
    648             
    649             Proc->LastIn=*PrvOut;
    650                 
    651          
    652          
    653          }//_______________________ Koniec funkcji__ ____________________________
    654          
    655          
    656          
    657          
    658          //*-----------------------------------------------------------------------------
    659          //* Nazwa funkcji :    ProcLim_Action
    660          //* Funkcja procedury "Porównanie wartoœci. Je¿eli 1>2 q=1"
    661          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    662          void ProcLim_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    663          {  
   \                     ProcLim_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    664             if ((*PrvOut)>(*UpOut))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C95E               LDRSH    R1,[R1, R3]
   \   00000006   C05E               LDRSH    R0,[R0, R3]
   \   00000008   8142               CMP      R1,R0
   \   0000000A   01DA               BGE      ??ProcLim_Action_0
    665             {
    666               Proc->Out=1;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   00E0               B        ??ProcLim_Action_1
    667             }
    668             else
    669             {
    670               Proc->Out=0;
   \                     ??ProcLim_Action_0:
   \   00000010   0020               MOVS     R0,#+0
   \                     ??ProcLim_Action_1:
   \   00000012   5082               STRH     R0,[R2, #+18]
    671             }
    672               
    673          }//_______________________ Koniec funkcji__ ____________________________
   \   00000014   ....               B.N      ??Subroutine2_1
    674          
    675          
    676          
    677          
    678          //*-----------------------------------------------------------------------------
    679          //* Nazwa funkcji :    ProcEven_Action
    680          //* Funkcja procedury "Porównanie wartoœci. Je¿eli 1=2 q=1"
    681          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    682          void ProcEven_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    683          {  
   \                     ProcEven_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    684             if ((*PrvOut)==(*UpOut))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C05E               LDRSH    R0,[R0, R3]
   \   00000006   C95E               LDRSH    R1,[R1, R3]
   \   00000008   8842               CMP      R0,R1
   \   0000000A   01D1               BNE      ??ProcEven_Action_0
    685             {
    686               Proc->Out=1;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   00E0               B        ??ProcEven_Action_1
    687             }
    688             else
    689             {
    690               Proc->Out=0;
   \                     ??ProcEven_Action_0:
   \   00000010   0020               MOVS     R0,#+0
   \                     ??ProcEven_Action_1:
   \   00000012   5082               STRH     R0,[R2, #+18]
    691             }
    692             
    693          
    694               
    695          }//_______________________ Koniec funkcji__ ____________________________
   \   00000014   ....               B.N      ??Subroutine2_1
    696          
    697          
    698          
    699          
    700          //*-----------------------------------------------------------------------------
    701          //* Nazwa funkcji :    ProcPlus_Action
    702          //* Funkcja procedury "Plus"
    703          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    704          void ProcPlus_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    705          {  
    706               Proc->Out=(*PrvOut)+(*UpOut);  
   \                     ProcPlus_Action:
   \   00000000   0023               MOVS     R3,#+0
   \   00000002   C05E               LDRSH    R0,[R0, R3]
   \   00000004   C95E               LDRSH    R1,[R1, R3]
   \   00000006   4018               ADDS     R0,R0,R1
   \   00000008   5082               STRH     R0,[R2, #+18]
    707          }//_______________________ Koniec funkcji__ ____________________________
   \   0000000A   7047               BX       LR               ;; return
    708          
    709          
    710          
    711          //*-----------------------------------------------------------------------------
    712          //* Nazwa funkcji :    ProcPlus_Action
    713          //* Funkcja procedury "Plus"
    714          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    715          void ProcMinus_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    716          {  
    717               Proc->Out=(*PrvOut)-(*UpOut);  
   \                     ProcMinus_Action:
   \   00000000   0023               MOVS     R3,#+0
   \   00000002   C05E               LDRSH    R0,[R0, R3]
   \   00000004   C95E               LDRSH    R1,[R1, R3]
   \   00000006   401A               SUBS     R0,R0,R1
   \   00000008   5082               STRH     R0,[R2, #+18]
    718          }//_______________________ Koniec funkcji__ ____________________________
   \   0000000A   7047               BX       LR               ;; return
    719          
    720          
    721          //*-----------------------------------------------------------------------------
    722          //* Nazwa funkcji :    ProcPlus_Action
    723          //* Funkcja procedury "Plus"
    724          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    725          void ProcMul_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    726          {    
   \                     ProcMul_Action:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   1400               MOVS     R4,R2
    727               int odp;
    728               odp=(*PrvOut)*(*UpOut)/10; 
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   805E               LDRSH    R0,[R0, R2]
   \   00000008   895E               LDRSH    R1,[R1, R2]
   \   0000000A   4843               MULS     R0,R1,R0
   \   0000000C   0A21               MOVS     R1,#+10
   \   0000000E   ........           BL       __aeabi_idivmod
    729               if (odp>30000)
   \   00000012   0449               LDR      R1,??ProcMul_Action_0  ;; 0x7531
   \   00000014   8842               CMP      R0,R1
   \   00000016   00DB               BLT      ??ProcMul_Action_1
    730               {
    731                  if (odp>0) Proc->Out=30000; else Proc->Out=-30000;
   \   00000018   481E               SUBS     R0,R1,#+1
    732               }else{
    733                  Proc->Out=odp; 
   \                     ??ProcMul_Action_1:
   \   0000001A   6082               STRH     R0,[R4, #+18]
    734               }
    735          }//_______________________ Koniec funkcji__ ____________________________
   \   0000001C   10BC               POP      {R4}
   \   0000001E   01BC               POP      {R0}
   \   00000020   0047               BX       R0               ;; return
   \   00000022   C046               Nop      
   \                     ??ProcMul_Action_0:
   \   00000024   31750000           DC32     0x7531
    736          
    737          
    738          //*-----------------------------------------------------------------------------
    739          //* Nazwa funkcji :    ProcPlus_Action
    740          //* Funkcja procedury "Plus"
    741          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    742          void ProcDiv_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    743          {  
   \                     ProcDiv_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0E00               MOVS     R6,R1
   \   00000006   1500               MOVS     R5,R2
    744               if ((*UpOut)==0)
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   205E               LDRSH    R0,[R4, R0]
   \   0000000C   0021               MOVS     R1,#+0
   \   0000000E   715E               LDRSH    R1,[R6, R1]
   \   00000010   0029               CMP      R1,#+0
   \   00000012   05D1               BNE      ??ProcDiv_Action_0
    745               {
    746                 if ((*PrvOut)>0) Proc->Out=30000; else Proc->Out=-30000;
   \   00000014   0128               CMP      R0,#+1
   \   00000016   01DB               BLT      ??ProcDiv_Action_1
   \   00000018   1248               LDR      R0,??ProcDiv_Action_2  ;; 0x7530
   \   0000001A   1EE0               B.N      ??ProcDiv_Action_3
   \                     ??ProcDiv_Action_1:
   \   0000001C   1248               LDR      R0,??ProcDiv_Action_2+0x4  ;; 0xffff8ad0
   \   0000001E   1CE0               B.N      ??ProcDiv_Action_3
    747               }else{
    748                
    749                Proc->Out=((*PrvOut)*10)/(*UpOut); 
   \                     ??ProcDiv_Action_0:
   \   00000020   0A22               MOVS     R2,#+10
   \   00000022   5043               MULS     R0,R2,R0
   \   00000024   ........           BL       __aeabi_idivmod
   \   00000028   6882               STRH     R0,[R5, #+18]
    750                if ( (((*PrvOut)*100)/(*UpOut))>((((*PrvOut)*10)/(*UpOut))*10)+5) Proc->Out++;
   \   0000002A   0020               MOVS     R0,#+0
   \   0000002C   365E               LDRSH    R6,[R6, R0]
   \   0000002E   275E               LDRSH    R7,[R4, R0]
   \   00000030   6420               MOVS     R0,#+100
   \   00000032   7843               MULS     R0,R7,R0
   \   00000034   3100               MOVS     R1,R6
   \   00000036   ........           BL       __aeabi_idivmod
   \   0000003A   0400               MOVS     R4,R0
   \   0000003C   0A20               MOVS     R0,#+10
   \   0000003E   4743               MULS     R7,R0,R7
   \   00000040   3800               MOVS     R0,R7
   \   00000042   3100               MOVS     R1,R6
   \   00000044   ........           BL       __aeabi_idivmod
   \   00000048   0100               MOVS     R1,R0
   \   0000004A   0A20               MOVS     R0,#+10
   \   0000004C   4143               MULS     R1,R0,R1
   \   0000004E   491D               ADDS     R1,R1,#+5
   \   00000050   A142               CMP      R1,R4
   \   00000052   03DA               BGE      ??ProcDiv_Action_4
   \   00000054   1220               MOVS     R0,#+18
   \   00000056   285E               LDRSH    R0,[R5, R0]
   \   00000058   401C               ADDS     R0,R0,#+1
   \                     ??ProcDiv_Action_3:
   \   0000005A   6882               STRH     R0,[R5, #+18]
    751               }
    752          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcDiv_Action_4:
   \   0000005C   F8BC               POP      {R3-R7}
   \   0000005E   01BC               POP      {R0}
   \   00000060   0047               BX       R0               ;; return
   \   00000062   C046               Nop      
   \                     ??ProcDiv_Action_2:
   \   00000064   30750000           DC32     0x7530
   \   00000068   D08AFFFF           DC32     0xffff8ad0
    753          
    754          
    755          
    756          
    757          
    758          //*-----------------------------------------------------------------------------
    759          //* Nazwa funkcji :    ProcConect_Action
    760          //* Funkcja procedury "Przeniesienie stanu w prawo"
    761          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    762          void ProcConect_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    763          {  
    764                Proc->Out=*PrvOut;  
   \                     ProcConect_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    765            
    766          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    767          
    768          
    769          
    770          //*-----------------------------------------------------------------------------
    771          //* Nazwa funkcji :    ProcDown_Action
    772          //* Funkcja procedury "Przeniesienie stanu w dó³"
    773          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    774          void ProcDown_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    775          {  
    776                Proc->Out=*PrvOut;  
   \                     ProcDown_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    777          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    778          
    779          
    780          
    781          //*-----------------------------------------------------------------------------
    782          //* Nazwa funkcji :    ProcDownRight_Action
    783          //* Funkcja procedury "Przeniesienie stanu w dó³ i prawo"
    784          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    785          void ProcDownRight_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    786          {  
    787                Proc->Out=*PrvOut;
   \                     ProcDownRight_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    788          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    789          
    790          
    791          
    792          
    793          
    794          //*-----------------------------------------------------------------------------
    795          //* Nazwa funkcji :    ProcUpToRight_Action
    796          //* Funkcja procedury "Przeniesienie stanu z góry w prawo"
    797          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    798          void ProcUpToRight_Action(short int *PrvUpOut, _Procedure *Proc) 
    799          {  
    800                Proc->Out=*PrvUpOut;
   \                     ProcUpToRight_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    801          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    802          
    803          
    804          
    805          //*-----------------------------------------------------------------------------
    806          //* Nazwa funkcji :    ProcUpToRightDown_Action
    807          //* Funkcja procedury "Przeniesienie stanu z góry w prawo i dó³"
    808          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    809          void ProcUpToRightDown_Action(short int *PrvUpOut, _Procedure *Proc) 
    810          {  
    811                Proc->Out=*PrvUpOut;
   \                     ProcUpToRightDown_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    812          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    813          
    814          
    815          //*-----------------------------------------------------------------------------
    816          //* Nazwa funkcji :    ProcSetScn
    817          //* Funkcja procedury "Ustaw scenê"
    818          //*-----------------------------------------------------------------------------
    819          char LastScene=0;

   \                                 In section Debug.txt, align 4, keep-with-next
    820          void ProcSetScn_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    821          {  
   \                     ProcSetScn_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    822               
    823            
    824               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   012B               CMP      R3,#+1
   \   00000008   19D1               BNE      ??ProcSetScn_Action_0
   \   0000000A   1223               MOVS     R3,#+18
   \   0000000C   CB5E               LDRSH    R3,[R1, R3]
   \   0000000E   002B               CMP      R3,#+0
   \   00000010   15D1               BNE      ??ProcSetScn_Action_0
    825               {  
    826                  //if (Proc->Tag.NrScene>NumberScene) Proc->Tag.NrScene=NumberScene;
    827                 if (Proc->Nr==0)  //je¿eli on/off scen
   \   00000012   0123               MOVS     R3,#+1
   \   00000014   CB56               LDRSB    R3,[R1, R3]
   \   00000016   002B               CMP      R3,#+0
   \   00000018   0FD1               BNE      ??ProcSetScn_Action_1
    828                 {
    829                   if (LastScene)
   \   0000001A   094B               LDR      R3,??ProcSetScn_Action_2  ;; Trap
   \   0000001C   5C7A               LDRB     R4,[R3, #+9]
   \   0000001E   002C               CMP      R4,#+0
   \   00000020   04D0               BEQ      ??ProcSetScn_Action_3
    830                   {
    831                      MainStg->SceneNr=LastScene;
   \   00000022   084D               LDR      R5,??ProcSetScn_Action_2+0x4  ;; 0x6ea
   \   00000024   5455               STRB     R4,[R2, R5]
    832                      LastScene=0;
   \   00000026   0022               MOVS     R2,#+0
   \   00000028   5A72               STRB     R2,[R3, #+9]
   \   0000002A   08E0               B        ??ProcSetScn_Action_0
    833                   }else{ 
    834                      LastScene=MainStg->SceneNr;
   \                     ??ProcSetScn_Action_3:
   \   0000002C   054C               LDR      R4,??ProcSetScn_Action_2+0x4  ;; 0x6ea
   \   0000002E   1219               ADDS     R2,R2,R4
   \   00000030   1478               LDRB     R4,[R2, #+0]
   \   00000032   5C72               STRB     R4,[R3, #+9]
    835                      MainStg->SceneNr=0;
   \   00000034   0023               MOVS     R3,#+0
   \   00000036   1370               STRB     R3,[R2, #+0]
   \   00000038   01E0               B        ??ProcSetScn_Action_0
    836                   }
    837                   
    838                 }else{
    839                  MainStg->SceneNr=Proc->Nr;
   \                     ??ProcSetScn_Action_1:
   \   0000003A   024C               LDR      R4,??ProcSetScn_Action_2+0x4  ;; 0x6ea
   \   0000003C   1355               STRB     R3,[R2, R4]
    840                 }
    841               }
    842          
    843               
    844               Proc->Out=*PrvOut;
   \                     ??ProcSetScn_Action_0:
   \   0000003E   ....               B.N      ?Subroutine0
   \                     ??ProcSetScn_Action_2:
   \   00000040   ........           DC32     Trap
   \   00000044   EA060000           DC32     0x6ea
    845          
    846          }//_______________________ Koniec funkcji__ ____________________________
    847          
    848          
    849          
    850          
    851          //*-----------------------------------------------------------------------------
    852          //* Nazwa funkcji :    ProcInc_Action
    853          //* Funkcja procedury "Inkrementuj scenê"
    854          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    855          void ProcInc_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    856          {  
   \                     ProcInc_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    857               if ((*PrvOut) && (Proc->LastIn==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   002B               CMP      R3,#+0
   \   00000008   0DD0               BEQ      ??ProcInc_Action_0
   \   0000000A   0B7C               LDRB     R3,[R1, #+16]
   \   0000000C   002B               CMP      R3,#+0
   \   0000000E   0AD1               BNE      ??ProcInc_Action_0
    858               {  
    859                  
    860                    if (MainStg->SceneNr<NumberScene) MainStg->SceneNr++;
   \   00000010   ....               LDR      R3,??DataTable25  ;; 0x6ea
   \   00000012   D218               ADDS     R2,R2,R3
   \   00000014   1378               LDRB     R3,[R2, #+0]
   \   00000016   ....               LDR      R4,??DataTable26  ;; Trap
   \   00000018   257A               LDRB     R5,[R4, #+8]
   \   0000001A   AB42               CMP      R3,R5
   \   0000001C   01D2               BCS      ??ProcInc_Action_1
   \   0000001E   5B1C               ADDS     R3,R3,#+1
   \   00000020   1370               STRB     R3,[R2, #+0]
    861                    LastScene=0;
   \                     ??ProcInc_Action_1:
   \   00000022   0022               MOVS     R2,#+0
   \   00000024   6272               STRB     R2,[R4, #+9]
    862               }
    863               
    864          
    865               Proc->LastIn=*PrvOut;
   \                     ??ProcInc_Action_0:
   \   00000026   0288               LDRH     R2,[R0, #+0]
   \   00000028   0A74               STRB     R2,[R1, #+16]
   \   0000002A   C046               Nop      
    866               Proc->Out=*PrvOut;
   \   0000002C                      REQUIRE ?Subroutine0
   \   0000002C                      ;; // Fall through to label ?Subroutine0
    867           
    868          }//_______________________ Koniec funkcji__ ____________________________
    869          
    870          
    871          //*-----------------------------------------------------------------------------
    872          //* Nazwa funkcji :    ProcIncDec_Action
    873          //* Funkcja procedury "Dekrementuj scenê"
    874          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    875          void ProcDec_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    876          {  
   \                     ProcDec_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    877               if ((*PrvOut) && (Proc->LastIn==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   002B               CMP      R3,#+0
   \   00000008   0CD0               BEQ      ??ProcDec_Action_0
   \   0000000A   0B7C               LDRB     R3,[R1, #+16]
   \   0000000C   002B               CMP      R3,#+0
   \   0000000E   09D1               BNE      ??ProcDec_Action_0
    878               {  
    879                  
    880                  if (MainStg->SceneNr>0) MainStg->SceneNr--;
   \   00000010   074B               LDR      R3,??ProcDec_Action_1  ;; 0x6ea
   \   00000012   D218               ADDS     R2,R2,R3
   \   00000014   1378               LDRB     R3,[R2, #+0]
   \   00000016   002B               CMP      R3,#+0
   \   00000018   01D0               BEQ      ??ProcDec_Action_2
   \   0000001A   5B1E               SUBS     R3,R3,#+1
   \   0000001C   1370               STRB     R3,[R2, #+0]
    881                  LastScene=0;
   \                     ??ProcDec_Action_2:
   \   0000001E   054A               LDR      R2,??ProcDec_Action_1+0x4  ;; Trap + 9
   \   00000020   0023               MOVS     R3,#+0
   \   00000022   1370               STRB     R3,[R2, #+0]
    882               }
    883               
    884          
    885               Proc->LastIn=*PrvOut;
   \                     ??ProcDec_Action_0:
   \   00000024   0288               LDRH     R2,[R0, #+0]
   \   00000026   0A74               STRB     R2,[R1, #+16]
    886               Proc->Out=*PrvOut;
   \   00000028   0088               LDRH     R0,[R0, #+0]
   \   0000002A   4882               STRH     R0,[R1, #+18]
    887          
    888          }//_______________________ Koniec funkcji__ ____________________________
   \   0000002C   ....               B.N      ??Subroutine2_1
   \   0000002E   C046               Nop      
   \                     ??ProcDec_Action_1:
   \   00000030   EA060000           DC32     0x6ea
   \   00000034   ........           DC32     Trap + 9
    889          
    890          
    891          
    892          //*-----------------------------------------------------------------------------
    893          //* Nazwa funkcji :    ProcSPK_Action
    894          //* Funkcja procedury "Dekrementuj scenê"
    895          //*-----------------------------------------------------------------------------
    896          extern     char Speaker[SPK_Amount];                                                   //sygna³ dŸwiêkowy

   \                                 In section Debug.txt, align 4, keep-with-next
    897          void ProcSPK_Action(short int *PrvOut, _Procedure *Proc) 
    898          {  
   \                     ProcSPK_Action:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    899               if ((*PrvOut) && (Proc->Out==0))
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   205E               LDRSH    R0,[R4, R0]
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   1AD0               BEQ      ??ProcSPK_Action_0
   \   0000000E   1220               MOVS     R0,#+18
   \   00000010   285E               LDRSH    R0,[R5, R0]
   \   00000012   0028               CMP      R0,#+0
   \   00000014   26D1               BNE      ??ProcSPK_Action_1
    900               {  
    901                  for (char i=0; i<SPK_Amount; i++) Speaker[i]=0;
   \   00000016   154E               LDR      R6,??ProcSPK_Action_2  ;; Speaker
   \   00000018   0421               MOVS     R1,#+4
   \   0000001A   3000               MOVS     R0,R6
   \   0000001C   ........           BL       __aeabi_memclr
    902                  Speaker[Proc->Tag.SpeakerType]=1;
   \   00000020   287A               LDRB     R0,[R5, #+8]
   \   00000022   0121               MOVS     R1,#+1
   \   00000024   3154               STRB     R1,[R6, R0]
    903                  if (Proc->Tag.SpeakerType==0) 
   \   00000026   287A               LDRB     R0,[R5, #+8]
   \   00000028   0028               CMP      R0,#+0
   \   0000002A   0FD1               BNE      ??ProcSPK_Action_3
    904                  {
    905                         ButtonBipCounter=g_counter+300000;
   \   0000002C   104A               LDR      R2,??ProcSPK_Action_2+0x4  ;; ButtonBipCounter
   \   0000002E   1148               LDR      R0,??ProcSPK_Action_2+0x8  ;; g_counter
   \   00000030   0068               LDR      R0,[R0, #+0]
   \   00000032   1149               LDR      R1,??ProcSPK_Action_2+0xC  ;; 0x493e0
   \   00000034   4018               ADDS     R0,R0,R1
   \   00000036   C117               ASRS     R1,R0,#+31
   \   00000038   03C2               STM      R2!,{R0,R1}
    906                         AT91C_BASE_PIOA->PIO_SODR =SpeakerPin;  
                                                           ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   0000003A   1048               LDR      R0,??ProcSPK_Action_2+0x10  ;; 0xfffff430
   \   0000003C   8021               MOVS     R1,#+128
   \   0000003E   0906               LSLS     R1,R1,#+24       ;; #-2147483648
   \   00000040   0160               STR      R1,[R0, #+0]
   \   00000042   03E0               B        ??ProcSPK_Action_3
    907                  }
    908               }else if (*PrvOut==0) {
    909                 for (char i=0; i<SPK_Amount; i++) Speaker[i]=0;
   \                     ??ProcSPK_Action_0:
   \   00000044   0421               MOVS     R1,#+4
   \   00000046   0948               LDR      R0,??ProcSPK_Action_2  ;; Speaker
   \   00000048   ........           BL       __aeabi_memclr
    910               }
    911               if ((*PrvOut==0) && (Proc->Out==1))
   \                     ??ProcSPK_Action_3:
   \   0000004C   0020               MOVS     R0,#+0
   \   0000004E   205E               LDRSH    R0,[R4, R0]
   \   00000050   0028               CMP      R0,#+0
   \   00000052   07D1               BNE      ??ProcSPK_Action_1
   \   00000054   1220               MOVS     R0,#+18
   \   00000056   285E               LDRSH    R0,[R5, R0]
   \   00000058   0128               CMP      R0,#+1
   \   0000005A   03D1               BNE      ??ProcSPK_Action_1
    912               {  
    913                  AT91C_BASE_PIOA->PIO_CODR =SpeakerPin;  
                                                    ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   0000005C   0848               LDR      R0,??ProcSPK_Action_2+0x14  ;; 0xfffff434
   \   0000005E   8021               MOVS     R1,#+128
   \   00000060   0906               LSLS     R1,R1,#+24       ;; #-2147483648
   \   00000062   0160               STR      R1,[R0, #+0]
    914               }
    915               Proc->Out=*PrvOut;
   \                     ??ProcSPK_Action_1:
   \   00000064   2088               LDRH     R0,[R4, #+0]
   \   00000066   6882               STRH     R0,[R5, #+18]
    916          }//_______________________ Koniec funkcji__ ____________________________
   \   00000068   ....               B.N      ??Subroutine1_0
   \   0000006A   C046               Nop      
   \                     ??ProcSPK_Action_2:
   \   0000006C   ........           DC32     Speaker
   \   00000070   ........           DC32     ButtonBipCounter
   \   00000074   ........           DC32     g_counter
   \   00000078   E0930400           DC32     0x493e0
   \   0000007C   30F4FFFF           DC32     0xfffff430
   \   00000080   34F4FFFF           DC32     0xfffff434
    917          
    918          
    919          
    920          
    921          
    922          //*-----------------------------------------------------------------------------
    923          //* Nazwa funkcji :    ProcSumL_Action
    924          //* Funkcja procedury "Sumy logicznej"
    925          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    926          void ProcSumL_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    927          {  
    928            Proc->Out=*PrvOut | *UpOut;   
   \                     ProcSumL_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   0988               LDRH     R1,[R1, #+0]
   \   00000004   0143               ORRS     R1,R1,R0
   \   00000006   5182               STRH     R1,[R2, #+18]
    929          }//_______________________ Koniec funkcji__ ____________________________
   \   00000008   7047               BX       LR               ;; return
    930          
    931          
    932          
    933          //*-----------------------------------------------------------------------------
    934          //* Nazwa funkcji :    ProcIncDec_Action
    935          //* Funkcja procedury "Inkrementuj scenê"
    936          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    937          void ProcTimerSet_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    938          {  
   \                     ProcTimerSet_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    939             if ((*PrvOut)==0)
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   825E               LDRSH    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   0DD0               BEQ      ??ProcTimerSet_Action_0
    940             {
    941               Proc->Out=0;
    942             }else{
    943               if ((*PrvOut) && (Proc->LastIn==0))
   \   0000000A   0A7C               LDRB     R2,[R1, #+16]
   \   0000000C   002A               CMP      R2,#+0
   \   0000000E   02D1               BNE      ??ProcTimerSet_Action_1
    944               {  
    945                 Proc->Tag.CounterStartTime=g_seconds_counter; 
   \   00000010   ....               LDR      R2,??Subroutine2_2  ;; g_seconds_counter
   \   00000012   1268               LDR      R2,[R2, #+0]
   \   00000014   CA60               STR      R2,[R1, #+12]
    946                 Proc->Out=0;
    947               }
    948               
    949               if ((Proc->Tag.CounterStartTime+Proc->Tag.SetCounter)<g_seconds_counter)
   \                     ??ProcTimerSet_Action_1:
   \   00000016   CA68               LDR      R2,[R1, #+12]
   \   00000018   8B68               LDR      R3,[R1, #+8]
   \   0000001A   D218               ADDS     R2,R2,R3
   \   0000001C   ....               LDR      R3,??Subroutine2_2+0x4  ;; g_seconds_counter
   \   0000001E   1B68               LDR      R3,[R3, #+0]
   \   00000020   9A42               CMP      R2,R3
   \   00000022   9241               SBCS     R2,R2,R2
   \   00000024   D20F               LSRS     R2,R2,#+31
   \                     ??ProcTimerSet_Action_0:
   \   00000026   C046               Nop      
   \   00000028                      REQUIRE ?Subroutine2
   \   00000028                      ;; // Fall through to label ?Subroutine2
    950               {
    951                 Proc->Out=1;
    952               }else{
    953                 Proc->Out=0;
    954               }
    955             }   
    956             
    957             Proc->LastIn=*PrvOut;
    958          }//_______________________ Koniec funkcji__ ____________________________
    959          
    960          
    961          
    962          
    963          
    964          
    965          //*-----------------------------------------------------------------------------
    966          //* Nazwa funkcji :    ProcClock_Action
    967          //* Funkcja procedury "Zegar"
    968          //*-----------------------------------------------------------------------------
    969          

   \                                 In section Debug.txt, align 4, keep-with-next
    970          void ProcClock_Action(short int *PrvOut, _Procedure *Proc) 
    971          {  
   \                     ProcClock_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    972             Proc->Out=0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   4A82               STRH     R2,[R1, #+18]
    973             if (*PrvOut)
   \   00000006   805E               LDRSH    R0,[R0, R2]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   31D0               BEQ      ??ProcClock_Action_0
    974             {
    975                if ((Proc->Tag.ClkPrcType==PrcMounth) && (Proc->Tag.ClkPrcVal==DateTime.Mounth))  Proc->Out=1; 
   \   0000000C   087A               LDRB     R0,[R1, #+8]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   06D1               BNE      ??ProcClock_Action_1
   \   00000012   487A               LDRB     R0,[R1, #+9]
   \   00000014   174A               LDR      R2,??ProcClock_Action_2  ;; DateTime + 1
   \   00000016   1278               LDRB     R2,[R2, #+0]
   \   00000018   9042               CMP      R0,R2
   \   0000001A   29D1               BNE      ??ProcClock_Action_0
   \   0000001C   0120               MOVS     R0,#+1
   \   0000001E   4882               STRH     R0,[R1, #+18]
    976                if ((Proc->Tag.ClkPrcType==PrcDay)    && (Proc->Tag.ClkPrcVal==DateTime.Day))     Proc->Out=1; 
   \                     ??ProcClock_Action_1:
   \   00000020   087A               LDRB     R0,[R1, #+8]
   \   00000022   0128               CMP      R0,#+1
   \   00000024   06D1               BNE      ??ProcClock_Action_3
   \   00000026   487A               LDRB     R0,[R1, #+9]
   \   00000028   134A               LDR      R2,??ProcClock_Action_2+0x4  ;; DateTime + 2
   \   0000002A   1278               LDRB     R2,[R2, #+0]
   \   0000002C   9042               CMP      R0,R2
   \   0000002E   1FD1               BNE      ??ProcClock_Action_0
   \   00000030   0120               MOVS     R0,#+1
   \   00000032   4882               STRH     R0,[R1, #+18]
    977                if ((Proc->Tag.ClkPrcType==PrcHour)   && (Proc->Tag.ClkPrcVal==DateTime.Hour))    Proc->Out=1; 
   \                     ??ProcClock_Action_3:
   \   00000034   087A               LDRB     R0,[R1, #+8]
   \   00000036   0228               CMP      R0,#+2
   \   00000038   06D1               BNE      ??ProcClock_Action_4
   \   0000003A   487A               LDRB     R0,[R1, #+9]
   \   0000003C   0F4A               LDR      R2,??ProcClock_Action_2+0x8  ;; DateTime + 3
   \   0000003E   1278               LDRB     R2,[R2, #+0]
   \   00000040   9042               CMP      R0,R2
   \   00000042   15D1               BNE      ??ProcClock_Action_0
   \   00000044   0120               MOVS     R0,#+1
   \   00000046   4882               STRH     R0,[R1, #+18]
    978                if ((Proc->Tag.ClkPrcType==PrcMinute) && (Proc->Tag.ClkPrcVal==DateTime.Minute))  Proc->Out=1;  
   \                     ??ProcClock_Action_4:
   \   00000048   087A               LDRB     R0,[R1, #+8]
   \   0000004A   0328               CMP      R0,#+3
   \   0000004C   06D1               BNE      ??ProcClock_Action_5
   \   0000004E   487A               LDRB     R0,[R1, #+9]
   \   00000050   0B4A               LDR      R2,??ProcClock_Action_2+0xC  ;; DateTime + 4
   \   00000052   1278               LDRB     R2,[R2, #+0]
   \   00000054   9042               CMP      R0,R2
   \   00000056   0BD1               BNE      ??ProcClock_Action_0
   \   00000058   0120               MOVS     R0,#+1
   \   0000005A   4882               STRH     R0,[R1, #+18]
    979                if ((Proc->Tag.ClkPrcType==PrcSecond) && (Proc->Tag.ClkPrcVal==DateTime.Second))  Proc->Out=1; 
   \                     ??ProcClock_Action_5:
   \   0000005C   087A               LDRB     R0,[R1, #+8]
   \   0000005E   0428               CMP      R0,#+4
   \   00000060   06D1               BNE      ??ProcClock_Action_0
   \   00000062   487A               LDRB     R0,[R1, #+9]
   \   00000064   074A               LDR      R2,??ProcClock_Action_2+0x10  ;; DateTime + 5
   \   00000066   1278               LDRB     R2,[R2, #+0]
   \   00000068   9042               CMP      R0,R2
   \   0000006A   01D1               BNE      ??ProcClock_Action_0
   \   0000006C   0120               MOVS     R0,#+1
   \   0000006E   4882               STRH     R0,[R1, #+18]
    980                        
    981          
    982             }
    983          
    984          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcClock_Action_0:
   \   00000070   ....               B.N      ??Subroutine2_1
   \   00000072   C046               Nop      
   \                     ??ProcClock_Action_2:
   \   00000074   ........           DC32     DateTime + 1
   \   00000078   ........           DC32     DateTime + 2
   \   0000007C   ........           DC32     DateTime + 3
   \   00000080   ........           DC32     DateTime + 4
   \   00000084   ........           DC32     DateTime + 5
    985          
    986          
    987          
    988          //*-----------------------------------------------------------------------------
    989          //* Nazwa funkcji :    ProcDay_Action
    990          //* Funkcja procedury "Dnia tygodnia"
    991          //*-----------------------------------------------------------------------------
    992          

   \                                 In section Debug.txt, align 4, keep-with-next
    993          void ProcDay_Action(short int *PrvOut, _Procedure *Proc) 
    994          {  
   \                     ProcDay_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    995             Proc->Out=0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   4A82               STRH     R2,[R1, #+18]
    996             if (*PrvOut)
   \   00000006   805E               LDRSH    R0,[R0, R2]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   06D0               BEQ      ??ProcDay_Action_0
    997             {
    998                if (Proc->Tag.DayOfWeek==DateTime.DayOfWeek)  Proc->Out=1; 
   \   0000000C   087A               LDRB     R0,[R1, #+8]
   \   0000000E   034A               LDR      R2,??ProcDay_Action_1  ;; DateTime + 6
   \   00000010   1278               LDRB     R2,[R2, #+0]
   \   00000012   9042               CMP      R0,R2
   \   00000014   01D1               BNE      ??ProcDay_Action_0
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   4882               STRH     R0,[R1, #+18]
    999          
   1000             }
   1001          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcDay_Action_0:
   \   0000001A   ....               B.N      ??Subroutine2_1
   \                     ??ProcDay_Action_1:
   \   0000001C   ........           DC32     DateTime + 6
   1002          
   1003          
   1004          
   1005          
   1006          
   1007          
   1008          
   1009          //*-----------------------------------------------------------------------------
   1010          //* Nazwa funkcji :    Program
   1011          //* Funkcja opóŸnienia
   1012          //*-----------------------------------------------------------------------------
   1013          volatile char Busy_program=0;
   1014          
   1015          char SceneNrLast=0;
   1016          char RealPrcLines=MaxPrcLines;
   1017          
   1018          int PtogTime=0;
   1019          unsigned long last_time;
   1020          

   \                                 In section Debug.txt, align 4, keep-with-next
   1021          void Program (_ProgramTab *ProgTab) 
   1022          { 
   \                     Program:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   85B0               SUB      SP,SP,#+20
   \   00000004   0027               MOVS     R7,#+0
   1023              static int MemCol=0;
   1024              static int MemRow=0;
   1025              int StartLineNr=0;
   1026              int StartPrcInLine=0;
   \   00000006   0297               STR      R7,[SP, #+8]
   \   00000008   CB4D               LDR      R5,??Program_1   ;; Trap
   \   0000000A   A97A               LDRB     R1,[R5, #+10]
   \   0000000C   0029               CMP      R1,#+0
   \   0000000E   00D0               BEQ      .+4
   \   00000010   F5E1               B        ??Program_2
   \   00000012   0121               MOVS     R1,#+1
   \   00000014   A972               STRB     R1,[R5, #+10]
   1027              
   1028              if (Busy_program==0)
   1029              {
   1030                Busy_program=1;
   1031              
   1032          
   1033             last_time=g_counter;
   \   00000016   C949               LDR      R1,??Program_1+0x4  ;; g_counter
   \   00000018   0968               LDR      R1,[R1, #+0]
   \   0000001A   A963               STR      R1,[R5, #+56]
   1034            
   1035          
   1036            
   1037            short int StPrvPrc; //stan poprzedniej procedury
   1038            short int StUpPrc; //stan procedury z linii wy¿ej, z tej samej kolumny dla sumy logicznej
   1039            
   1040            if ((Trap.Enable) && (Trap.Change))
   \   0000001C   2978               LDRB     R1,[R5, #+0]
   \   0000001E   0029               CMP      R1,#+0
   \   00000020   07D0               BEQ      ??Program_3
   \   00000022   2979               LDRB     R1,[R5, #+4]
   \   00000024   0029               CMP      R1,#+0
   \   00000026   04D0               BEQ      ??Program_3
   1041                  {
   1042                    StartPrcInLine=MemCol;
   \   00000028   E96B               LDR      R1,[R5, #+60]
   \   0000002A   0291               STR      R1,[SP, #+8]
   1043                    StartLineNr=MemRow;
   \   0000002C   2F6C               LDR      R7,[R5, #+64]
   1044                    Trap.Change=0;
   \   0000002E   0021               MOVS     R1,#+0
   \   00000030   2971               STRB     R1,[R5, #+4]
   1045                  }
   1046            
   1047             
   1048                
   1049                          
   1050                 
   1051                   
   1052            
   1053                 for (char NB=0; NB<NumberButton; NB++)
   \                     ??Program_3:
   \   00000032   C34E               LDR      R6,??Program_1+0x8  ;; MainStage
   \   00000034   3100               MOVS     R1,R6
   \   00000036   5031               ADDS     R1,R1,#+80
   \   00000038   3200               MOVS     R2,R6
   \   0000003A   1023               MOVS     R3,#+16
   1054                 {
   1055                      MainStage.StageButtonExe[NB]=MainStage.StageButton[NB];  
   \                     ??Program_4:
   \   0000003C   1478               LDRB     R4,[R2, #+0]
   \   0000003E   0C70               STRB     R4,[R1, #+0]
   \   00000040   5478               LDRB     R4,[R2, #+1]
   \   00000042   4C70               STRB     R4,[R1, #+1]
   \   00000044   9478               LDRB     R4,[R2, #+2]
   \   00000046   8C70               STRB     R4,[R1, #+2]
   \   00000048   D478               LDRB     R4,[R2, #+3]
   \   0000004A   CC70               STRB     R4,[R1, #+3]
   \   0000004C   1479               LDRB     R4,[R2, #+4]
   \   0000004E   0C71               STRB     R4,[R1, #+4]
   1056                 }
   \   00000050   521D               ADDS     R2,R2,#+5
   \   00000052   491D               ADDS     R1,R1,#+5
   \   00000054   5B1E               SUBS     R3,R3,#+1
   \   00000056   F1D1               BNE      ??Program_4
   1057            
   1058            
   1059            
   1060                for (int LineNr=StartLineNr; LineNr<RealPrcLines; LineNr++)
   \   00000058   F021               MOVS     R1,#+240
   \   0000005A   7943               MULS     R1,R7,R1
   \   0000005C   4018               ADDS     R0,R0,R1
   \   0000005E   1830               ADDS     R0,R0,#+24
   \   00000060   24E0               B.N      ??Program_5
   1061                {
   1062                  for (int PrcInLine=StartPrcInLine; PrcInLine<MaxPrcInLine; PrcInLine++)
   1063                  {
   1064                   
   1065                    
   1066          
   1067                    
   1068                    
   1069                    
   1070                   if ((Trap.Enable) &&  (Trap.Row==LineNr) && (Trap.Col==PrcInLine)) 
   1071                   {
   1072                     Trap.Activ=1; 
   1073                     MemCol=PrcInLine;
   1074                     MemRow=LineNr;
   1075                      
   1076                   }
   1077                   if ((Trap.Enable==0) || (Trap.Activ==0) )
   1078                   {
   1079          
   1080                     
   1081                   if (Trap.Enable==0)
   1082                   {
   1083                    MemCol=PrcInLine;
   1084                    MemRow=LineNr;
   1085                   }  
   1086                     
   1087                     
   1088                     if (ProgTab->Line[LineNr].Proc[PrcInLine].Type!=None)
   1089                     {
   1090                        if (PrcInLine==0)
   1091                        {
   1092                          StPrvPrc= 1;
   1093                        }else{
   1094                          StPrvPrc= (ProgTab->Line[LineNr].Proc[PrcInLine-1].Out);
   1095                        }
   1096                        
   1097                        
   1098          
   1099                        switch (ProgTab->Line[LineNr].Proc[PrcInLine].Type)
   1100                        {    
   1101                            case ProcConect     : ProcConect_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1102                            case ProcDown       : ProcDown_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1103                            case ProcDownRight  : ProcDownRight_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1104                            case ProcSumLogRight     : 
   1105                                                StUpPrc= 0;
   1106                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1107                                                ProcSumL_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1108                                                break;
   1109                            case ProcSumLogDown     : 
   1110                                                StUpPrc= 0;
   1111                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1112                                                ProcSumL_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1113                                                break;
   1114                            case ProcUpToRight     : 
   1115                                                StUpPrc= 0;
   1116                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1117                                                ProcUpToRight_Action(&StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1118                                                break;
   1119                                                
   1120                            case ProcUpToRightDown    : 
   1121                                                StUpPrc= 0;
   1122                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1123                                                ProcUpToRightDown_Action(&StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1124                                                break;                    
   1125                                             
   1126                           
   1127                            
   1128                            case ProcNOT        : ProcNOT_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;         
   1129                            case ProcToggleRS   : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1130                                                  ProcToggleRS_Action(&StPrvPrc, &StUpPrc,  &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;    
   1131                            case ProcToggleT    : ProcToggleT_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;         
   1132                            case ProcTLI1       : ProcTLI1_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;         
   1133                            case ProcStI        : ProcStI_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1134                            case ProcStNI       : ProcStNI_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1135                            case ProcStQ        : ProcStQ_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1136                            case ProcStB        : ProcStB_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1137                            case ProcStS        : ProcStS_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1138                            case ProcWOUT       : ProcWOUT_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1139                            case ProcWOUTS      : ProcWOUTS_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]),&MainStage); break;
   1140                            case ProcWOUTR      : ProcWOUTR_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]),&MainStage); break;
   1141                            case ProcWOUTC      : ProcWOUTC_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]),&MainStage); break;
   1142                            case ProcSetScn     : ProcSetScn_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1143                            case ProcInc        : ProcInc_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;             
   1144                            case ProcDec        : ProcDec_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;             
   1145                            case ProcSPK        : ProcSPK_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break; 
   1146                            case ProcTimerSet   : ProcTimerSet_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1147                            case ProcClock      : ProcClock_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1148                            case ProcDay        : ProcDay_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1149                            case ProcGetReg     : ProcGetReg_Action(&(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1150                            case ProcSetReg     : ProcSetAnal_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1151                            case ProcConstAnal  : ProcConstAnal_Action(&(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1152                            case ProcLim        : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1153                                                  ProcLim_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1154                            case ProcEven       : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1155                                                  ProcEven_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1156                            case ProcPlus       : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1157                                                  ProcPlus_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1158                            case ProcMinus      : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1159                                                  ProcMinus_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1160                            case ProcMul        : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1161                                                  ProcMul_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1162                            case ProcDiv        : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   \                     ??Program_6:
   \   00000062   002F               CMP      R7,#+0
   \   00000064   04D0               BEQ      ??Program_7
   \   00000066   6846               MOV      R0,SP
   \   00000068   2100               MOVS     R1,R4
   \   0000006A   DE39               SUBS     R1,R1,#+222
   \   0000006C   0988               LDRH     R1,[R1, #+0]
   \   0000006E   4180               STRH     R1,[R0, #+2]
   1163                                                  ProcDiv_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   \                     ??Program_7:
   \   00000070   2200               MOVS     R2,R4
   \   00000072   00A9               ADD      R1,SP,#+0
   \   00000074   891C               ADDS     R1,R1,#+2
   \   00000076   6846               MOV      R0,SP
   \   00000078   ........           BL       ProcDiv_Action
   1164          
   1165                            
   1166                        }
   1167                        
   1168                     }  
   1169                    
   1170                   
   1171                   
   1172                   
   1173                   
   1174                   
   1175                   if ((LineNr==RealPrcLines-1) && (PrcInLine==MaxPrcInLine-1))
   \                     ??Program_8:
   \   0000007C   287B               LDRB     R0,[R5, #+12]
   \   0000007E   401E               SUBS     R0,R0,#+1
   \   00000080   8742               CMP      R7,R0
   \   00000082   0AD1               BNE      ??Program_9
   \   00000084   0198               LDR      R0,[SP, #+4]
   \   00000086   0928               CMP      R0,#+9
   \   00000088   07D1               BNE      ??Program_9
   1176                    { 
   1177                    
   1178                        //ThermostatsExecute();
   1179          
   1180                          /* 
   1181                          for (char iNrQ=0; iNrQ<NumberNeurons; iNrQ++)
   1182                          {  
   1183                            for (char iNrReg=0; iNrReg<NumberReg; iNrReg++)
   1184                          {
   1185                            MainStage.StageQ[iNrQ].Value[iNrReg]=MainStage.StageQ_TMP[iNrQ].Value[iNrReg]; 
   1186                          }
   1187                          
   1188                          }
   1189                          */
   1190          
   1191                      /*
   1192                      for (char iNrReg=0; iNrReg<NumberReg; iNrReg++)
   1193                      {
   1194                        MainStage.StageI[0].Value[iNrReg]=MainStage.StageQ[0].Value[iNrReg]; 
   1195                      }
   1196                     */
   1197           
   1198            
   1199                      if (MainStage.SceneNr!=SceneNrLast)
   \   0000008A   AE48               LDR      R0,??Program_1+0xC  ;; 0x6ea
   \   0000008C   305C               LDRB     R0,[R6, R0]
   \   0000008E   E97A               LDRB     R1,[R5, #+11]
   \   00000090   8842               CMP      R0,R1
   \   00000092   02D0               BEQ      ??Program_9
   1200                      {
   1201                        SceneNrLast=MainStage.SceneNr;
   \   00000094   E872               STRB     R0,[R5, #+11]
   1202                        MenuPaint();
   \   00000096   ........           BL       MenuPaint
   1203                      }
   1204           
   1205                   
   1206          
   1207                   }
   \                     ??Program_9:
   \   0000009A   0198               LDR      R0,[SP, #+4]
   \   0000009C   401C               ADDS     R0,R0,#+1
   \   0000009E   0190               STR      R0,[SP, #+4]
   \   000000A0   1834               ADDS     R4,R4,#+24
   \   000000A2   0A28               CMP      R0,#+10
   \   000000A4   0FDB               BLT      ??Program_10
   \                     ??Program_11:
   \   000000A6   7F1C               ADDS     R7,R7,#+1
   \   000000A8   0398               LDR      R0,[SP, #+12]
   \   000000AA   F030               ADDS     R0,R0,#+240
   \                     ??Program_5:
   \   000000AC   0390               STR      R0,[SP, #+12]
   \   000000AE   287B               LDRB     R0,[R5, #+12]
   \   000000B0   8742               CMP      R7,R0
   \   000000B2   00DB               BLT      .+4
   \   000000B4   75E1               B        ??Program_12
   \   000000B6   0298               LDR      R0,[SP, #+8]
   \   000000B8   0190               STR      R0,[SP, #+4]
   \   000000BA   0A28               CMP      R0,#+10
   \   000000BC   F3DA               BGE      ??Program_11
   \   000000BE   1821               MOVS     R1,#+24
   \   000000C0   4843               MULS     R0,R1,R0
   \   000000C2   0399               LDR      R1,[SP, #+12]
   \   000000C4   0C18               ADDS     R4,R1,R0
   \                     ??Program_10:
   \   000000C6   2878               LDRB     R0,[R5, #+0]
   \   000000C8   0028               CMP      R0,#+0
   \   000000CA   0CD0               BEQ      ??Program_13
   \   000000CC   6878               LDRB     R0,[R5, #+1]
   \   000000CE   B842               CMP      R0,R7
   \   000000D0   0DD1               BNE      ??Program_14
   \   000000D2   A878               LDRB     R0,[R5, #+2]
   \   000000D4   0199               LDR      R1,[SP, #+4]
   \   000000D6   8842               CMP      R0,R1
   \   000000D8   09D1               BNE      ??Program_14
   \   000000DA   0120               MOVS     R0,#+1
   \   000000DC   E870               STRB     R0,[R5, #+3]
   \   000000DE   0198               LDR      R0,[SP, #+4]
   \   000000E0   E863               STR      R0,[R5, #+60]
   \   000000E2   2F64               STR      R7,[R5, #+64]
   \   000000E4   D9E7               B        ??Program_9
   \                     ??Program_13:
   \   000000E6   0198               LDR      R0,[SP, #+4]
   \   000000E8   E863               STR      R0,[R5, #+60]
   \   000000EA   2F64               STR      R7,[R5, #+64]
   \   000000EC   02E0               B        ??Program_15
   \                     ??Program_14:
   \   000000EE   E878               LDRB     R0,[R5, #+3]
   \   000000F0   0028               CMP      R0,#+0
   \   000000F2   D2D1               BNE      ??Program_9
   \                     ??Program_15:
   \   000000F4   2078               LDRB     R0,[R4, #+0]
   \   000000F6   0028               CMP      R0,#+0
   \   000000F8   C0D0               BEQ      ??Program_8
   \   000000FA   0198               LDR      R0,[SP, #+4]
   \   000000FC   0028               CMP      R0,#+0
   \   000000FE   6846               MOV      R0,SP
   \   00000100   01D1               BNE      ??Program_16
   \   00000102   0121               MOVS     R1,#+1
   \   00000104   01E0               B.N      ??Program_17
   \                     ??Program_16:
   \   00000106   A11F               SUBS     R1,R4,#+6
   \   00000108   0988               LDRH     R1,[R1, #+0]
   \                     ??Program_17:
   \   0000010A   0180               STRH     R1,[R0, #+0]
   \   0000010C   2078               LDRB     R0,[R4, #+0]
   \   0000010E   801E               SUBS     R0,R0,#+2
   \   00000110   3D28               CMP      R0,#+61
   \   00000112   B3D8               BHI      ??Program_8
   \   00000114   01A1               ADR      R1,??Program_0
   \   00000116   4000               LSLS     R0,R0,#+1
   \   00000118   095E               LDRSH    R1,[R1, R0]
   \   0000011A   8F44               ADD      PC,PC,R1
   \                     ??Program_0:
   \   0000011C   7A007A007A00       DC16     +122,+122,+122,+130
   \              8200        
   \   00000124   8200A000A000       DC16     +130,+160,+160,+182
   \              B600        
   \   0000012C   C400E000EA00       DC16     +196,+224,+234,+65374
   \              5EFF        
   \   00000134   5EFF5EFF5EFF       DC16     +65374,+65374,+65374,+65374
   \              5EFF        
   \   0000013C   5EFF5EFFF400       DC16     +65374,+65374,+244,+256
   \              0001        
   \   00000144   0C0118012401       DC16     +268,+280,+292,+65374
   \              5EFF        
   \   0000014C   5EFF5EFF5EFF       DC16     +65374,+65374,+65374,+65374
   \              5EFF        
   \   00000154   5EFF5EFF3001       DC16     +65374,+65374,+304,+316
   \              3C01        
   \   0000015C   480154016001       DC16     +328,+340,+352,+364
   \              6C01        
   \   00000164   780184015EFF       DC16     +376,+388,+65374,+65374
   \              5EFF        
   \   0000016C   5EFF5EFF5EFF       DC16     +65374,+65374,+65374,+398
   \              8E01        
   \   00000174   9A01A4015EFF       DC16     +410,+420,+65374,+65374
   \              5EFF        
   \   0000017C   5EFF5EFF5EFF       DC16     +65374,+65374,+65374,+65374
   \              5EFF        
   \   00000184   5EFFC401AE01       DC16     +65374,+452,+430,+440
   \              B801        
   \   0000018C   CE01F6012A02       DC16     +462,+502,+554,+584
   \              4802        
   \   00000194   680244FF           DC16     +616,+65348
   \                     ??Program_18:
   \   00000198   6846               MOV      R0,SP
   \   0000019A   0088               LDRH     R0,[R0, #+0]
   \                     ??Program_19:
   \   0000019C   6082               STRH     R0,[R4, #+18]
   \   0000019E   6DE7               B        ??Program_8
   \                     ??Program_20:
   \   000001A0   6846               MOV      R0,SP
   \   000001A2   0021               MOVS     R1,#+0
   \   000001A4   4180               STRH     R1,[R0, #+2]
   \   000001A6   002F               CMP      R7,#+0
   \   000001A8   03D0               BEQ      ??Program_21
   \   000001AA   2100               MOVS     R1,R4
   \   000001AC   DE39               SUBS     R1,R1,#+222
   \   000001AE   0988               LDRH     R1,[R1, #+0]
   \   000001B0   4180               STRH     R1,[R0, #+2]
   \                     ??Program_21:
   \   000001B2   0088               LDRH     R0,[R0, #+0]
   \   000001B4   6946               MOV      R1,SP
   \   000001B6   4988               LDRH     R1,[R1, #+2]
   \   000001B8   0143               ORRS     R1,R1,R0
   \                     ??Program_22:
   \   000001BA   6182               STRH     R1,[R4, #+18]
   \   000001BC   5EE7               B        ??Program_8
   \                     ??Program_23:
   \   000001BE   6846               MOV      R0,SP
   \   000001C0   0021               MOVS     R1,#+0
   \   000001C2   4180               STRH     R1,[R0, #+2]
   \   000001C4   002F               CMP      R7,#+0
   \   000001C6   03D0               BEQ      ??Program_24
   \   000001C8   2100               MOVS     R1,R4
   \   000001CA   DE39               SUBS     R1,R1,#+222
   \   000001CC   0988               LDRH     R1,[R1, #+0]
   \   000001CE   4180               STRH     R1,[R0, #+2]
   \                     ??Program_24:
   \   000001D0   4088               LDRH     R0,[R0, #+2]
   \   000001D2   E3E7               B.N      ??Program_19
   \                     ??Program_25:
   \   000001D4   6946               MOV      R1,SP
   \   000001D6   0020               MOVS     R0,#+0
   \   000001D8   085E               LDRSH    R0,[R1, R0]
   \   000001DA   411E               SUBS     R1,R0,#+1
   \   000001DC   8941               SBCS     R1,R1,R1
   \   000001DE   C90F               LSRS     R1,R1,#+31
   \   000001E0   EBE7               B.N      ??Program_22
   \                     ??Program_26:
   \   000001E2   002F               CMP      R7,#+0
   \   000001E4   04D0               BEQ      ??Program_27
   \   000001E6   6846               MOV      R0,SP
   \   000001E8   2100               MOVS     R1,R4
   \   000001EA   DE39               SUBS     R1,R1,#+222
   \   000001EC   0988               LDRH     R1,[R1, #+0]
   \   000001EE   4180               STRH     R1,[R0, #+2]
   \                     ??Program_27:
   \   000001F0   2200               MOVS     R2,R4
   \   000001F2   00A9               ADD      R1,SP,#+0
   \   000001F4   891C               ADDS     R1,R1,#+2
   \   000001F6   6846               MOV      R0,SP
   \   000001F8   ........           BL       ProcToggleRS_Action
   \   000001FC   3EE7               B        ??Program_8
   \                     ??Program_28:
   \   000001FE   2100               MOVS     R1,R4
   \   00000200   6846               MOV      R0,SP
   \   00000202   ........           BL       ProcToggleT_Action
   \   00000206   39E7               B        ??Program_8
   \                     ??Program_29:
   \   00000208   2100               MOVS     R1,R4
   \   0000020A   6846               MOV      R0,SP
   \   0000020C   ........           BL       ProcTLI1_Action
   \   00000210   34E7               B        ??Program_8
   \                     ??Program_30:
   \   00000212   3200               MOVS     R2,R6
   \   00000214   2100               MOVS     R1,R4
   \   00000216   6846               MOV      R0,SP
   \   00000218   ........           BL       ProcStI_Action
   \   0000021C   2EE7               B        ??Program_8
   \                     ??Program_31:
   \   0000021E   3200               MOVS     R2,R6
   \   00000220   2100               MOVS     R1,R4
   \   00000222   6846               MOV      R0,SP
   \   00000224   ........           BL       ProcStNI_Action
   \   00000228   28E7               B        ??Program_8
   \                     ??Program_32:
   \   0000022A   3200               MOVS     R2,R6
   \   0000022C   2100               MOVS     R1,R4
   \   0000022E   6846               MOV      R0,SP
   \   00000230   ........           BL       ProcStQ_Action
   \   00000234   22E7               B        ??Program_8
   \                     ??Program_33:
   \   00000236   3200               MOVS     R2,R6
   \   00000238   2100               MOVS     R1,R4
   \   0000023A   6846               MOV      R0,SP
   \   0000023C   ........           BL       ProcStB_Action
   \   00000240   1CE7               B        ??Program_8
   \                     ??Program_34:
   \   00000242   3200               MOVS     R2,R6
   \   00000244   2100               MOVS     R1,R4
   \   00000246   6846               MOV      R0,SP
   \   00000248   ........           BL       ProcStS_Action
   \   0000024C   16E7               B        ??Program_8
   \                     ??Program_35:
   \   0000024E   3200               MOVS     R2,R6
   \   00000250   2100               MOVS     R1,R4
   \   00000252   6846               MOV      R0,SP
   \   00000254   ........           BL       ProcWOUT_Action
   \   00000258   10E7               B        ??Program_8
   \                     ??Program_36:
   \   0000025A   3200               MOVS     R2,R6
   \   0000025C   2100               MOVS     R1,R4
   \   0000025E   6846               MOV      R0,SP
   \   00000260   ........           BL       ProcWOUTS_Action
   \   00000264   0AE7               B        ??Program_8
   \                     ??Program_37:
   \   00000266   3200               MOVS     R2,R6
   \   00000268   2100               MOVS     R1,R4
   \   0000026A   6846               MOV      R0,SP
   \   0000026C   ........           BL       ProcWOUTR_Action
   \   00000270   04E7               B        ??Program_8
   \                     ??Program_38:
   \   00000272   3200               MOVS     R2,R6
   \   00000274   2100               MOVS     R1,R4
   \   00000276   6846               MOV      R0,SP
   \   00000278   ........           BL       ProcWOUTC_Action
   \   0000027C   FEE6               B        ??Program_8
   \                     ??Program_39:
   \   0000027E   3200               MOVS     R2,R6
   \   00000280   2100               MOVS     R1,R4
   \   00000282   6846               MOV      R0,SP
   \   00000284   ........           BL       ProcSetScn_Action
   \   00000288   F8E6               B        ??Program_8
   \                     ??Program_40:
   \   0000028A   3200               MOVS     R2,R6
   \   0000028C   2100               MOVS     R1,R4
   \   0000028E   6846               MOV      R0,SP
   \   00000290   ........           BL       ProcInc_Action
   \   00000294   F2E6               B        ??Program_8
   \                     ??Program_41:
   \   00000296   3200               MOVS     R2,R6
   \   00000298   2100               MOVS     R1,R4
   \   0000029A   6846               MOV      R0,SP
   \   0000029C   ........           BL       ProcDec_Action
   \   000002A0   ECE6               B        ??Program_8
   \                     ??Program_42:
   \   000002A2   2100               MOVS     R1,R4
   \   000002A4   6846               MOV      R0,SP
   \   000002A6   ........           BL       ProcSPK_Action
   \   000002AA   E7E6               B        ??Program_8
   \                     ??Program_43:
   \   000002AC   3200               MOVS     R2,R6
   \   000002AE   2100               MOVS     R1,R4
   \   000002B0   6846               MOV      R0,SP
   \   000002B2   ........           BL       ProcTimerSet_Action
   \   000002B6   E1E6               B        ??Program_8
   \                     ??Program_44:
   \   000002B8   2100               MOVS     R1,R4
   \   000002BA   6846               MOV      R0,SP
   \   000002BC   ........           BL       ProcClock_Action
   \   000002C0   DCE6               B        ??Program_8
   \                     ??Program_45:
   \   000002C2   2100               MOVS     R1,R4
   \   000002C4   6846               MOV      R0,SP
   \   000002C6   ........           BL       ProcDay_Action
   \   000002CA   D7E6               B        ??Program_8
   \                     ??Program_46:
   \   000002CC   3100               MOVS     R1,R6
   \   000002CE   2000               MOVS     R0,R4
   \   000002D0   ........           BL       ProcGetReg_Action
   \   000002D4   D2E6               B        ??Program_8
   \                     ??Program_47:
   \   000002D6   3200               MOVS     R2,R6
   \   000002D8   2100               MOVS     R1,R4
   \   000002DA   6846               MOV      R0,SP
   \   000002DC   ........           BL       ProcSetAnal_Action
   \   000002E0   CCE6               B        ??Program_8
   \                     ??Program_48:
   \   000002E2   2000               MOVS     R0,R4
   \   000002E4   0830               ADDS     R0,R0,#+8
   \   000002E6   0188               LDRH     R1,[R0, #+0]
   \   000002E8   4181               STRH     R1,[R0, #+10]
   \   000002EA   C7E6               B        ??Program_8
   \                     ??Program_49:
   \   000002EC   002F               CMP      R7,#+0
   \   000002EE   04D0               BEQ      ??Program_50
   \   000002F0   6846               MOV      R0,SP
   \   000002F2   2100               MOVS     R1,R4
   \   000002F4   DE39               SUBS     R1,R1,#+222
   \   000002F6   0988               LDRH     R1,[R1, #+0]
   \   000002F8   4180               STRH     R1,[R0, #+2]
   \                     ??Program_50:
   \   000002FA   6A46               MOV      R2,SP
   \   000002FC   0221               MOVS     R1,#+2
   \   000002FE   515E               LDRSH    R1,[R2, R1]
   \   00000300   6B46               MOV      R3,SP
   \   00000302   0022               MOVS     R2,#+0
   \   00000304   9A5E               LDRSH    R2,[R3, R2]
   \   00000306   9142               CMP      R1,R2
   \   00000308   01DA               BGE      ??Program_51
   \   0000030A   0121               MOVS     R1,#+1
   \   0000030C   55E7               B.N      ??Program_22
   \                     ??Program_51:
   \   0000030E   0021               MOVS     R1,#+0
   \   00000310   6182               STRH     R1,[R4, #+18]
   \   00000312   B3E6               B        ??Program_8
   \                     ??Program_52:
   \   00000314   002F               CMP      R7,#+0
   \   00000316   04D0               BEQ      ??Program_53
   \   00000318   6846               MOV      R0,SP
   \   0000031A   2100               MOVS     R1,R4
   \   0000031C   DE39               SUBS     R1,R1,#+222
   \   0000031E   0988               LDRH     R1,[R1, #+0]
   \   00000320   4180               STRH     R1,[R0, #+2]
   \                     ??Program_53:
   \   00000322   6A46               MOV      R2,SP
   \   00000324   0021               MOVS     R1,#+0
   \   00000326   515E               LDRSH    R1,[R2, R1]
   \   00000328   6B46               MOV      R3,SP
   \   0000032A   0222               MOVS     R2,#+2
   \   0000032C   9A5E               LDRSH    R2,[R3, R2]
   \   0000032E   9142               CMP      R1,R2
   \   00000330   EDD1               BNE      ??Program_51
   \   00000332   0121               MOVS     R1,#+1
   \   00000334   41E7               B.N      ??Program_22
   \   00000336   C046               Nop      
   \                     ??Program_1:
   \   00000338   ........           DC32     Trap
   \   0000033C   ........           DC32     g_counter
   \   00000340   ........           DC32     MainStage
   \   00000344   EA060000           DC32     0x6ea
   \                     ??Program_54:
   \   00000348   002F               CMP      R7,#+0
   \   0000034A   04D0               BEQ      ??Program_55
   \   0000034C   6846               MOV      R0,SP
   \   0000034E   2100               MOVS     R1,R4
   \   00000350   DE39               SUBS     R1,R1,#+222
   \   00000352   0988               LDRH     R1,[R1, #+0]
   \   00000354   4180               STRH     R1,[R0, #+2]
   \                     ??Program_55:
   \   00000356   6946               MOV      R1,SP
   \   00000358   0020               MOVS     R0,#+0
   \   0000035A   085E               LDRSH    R0,[R1, R0]
   \   0000035C   6A46               MOV      R2,SP
   \   0000035E   0221               MOVS     R1,#+2
   \   00000360   515E               LDRSH    R1,[R2, R1]
   \   00000362   4018               ADDS     R0,R0,R1
   \   00000364   1AE7               B.N      ??Program_19
   \                     ??Program_56:
   \   00000366   002F               CMP      R7,#+0
   \   00000368   04D0               BEQ      ??Program_57
   \   0000036A   6846               MOV      R0,SP
   \   0000036C   2100               MOVS     R1,R4
   \   0000036E   DE39               SUBS     R1,R1,#+222
   \   00000370   0988               LDRH     R1,[R1, #+0]
   \   00000372   4180               STRH     R1,[R0, #+2]
   \                     ??Program_57:
   \   00000374   6946               MOV      R1,SP
   \   00000376   0020               MOVS     R0,#+0
   \   00000378   085E               LDRSH    R0,[R1, R0]
   \   0000037A   6A46               MOV      R2,SP
   \   0000037C   0221               MOVS     R1,#+2
   \   0000037E   515E               LDRSH    R1,[R2, R1]
   \   00000380   401A               SUBS     R0,R0,R1
   \   00000382   6082               STRH     R0,[R4, #+18]
   \   00000384   7AE6               B        ??Program_8
   \                     ??Program_58:
   \   00000386   002F               CMP      R7,#+0
   \   00000388   04D0               BEQ      ??Program_59
   \   0000038A   6846               MOV      R0,SP
   \   0000038C   2100               MOVS     R1,R4
   \   0000038E   DE39               SUBS     R1,R1,#+222
   \   00000390   0988               LDRH     R1,[R1, #+0]
   \   00000392   4180               STRH     R1,[R0, #+2]
   \                     ??Program_59:
   \   00000394   2200               MOVS     R2,R4
   \   00000396   00A9               ADD      R1,SP,#+0
   \   00000398   891C               ADDS     R1,R1,#+2
   \   0000039A   6846               MOV      R0,SP
   \   0000039C   ........           BL       ProcMul_Action
   \   000003A0   6CE6               B        ??Program_8
   1208                   
   1209                   
   1210                  }
   1211                  
   1212                  
   1213                }
   1214              }
   1215            
   1216            
   1217            
   1218            //zerowanie wyjœæ  z flagami impulsu      
   1219                 for (char iNrQ=0; iNrQ<NumberNeurons; iNrQ++)
   \                     ??Program_12:
   \   000003A2   1B48               LDR      R0,??Program_60  ;; 0x6eb
   \   000003A4   3018               ADDS     R0,R6,R0
   \   000003A6   1B49               LDR      R1,??Program_60+0x4  ;; 0x6a4
   \   000003A8   7118               ADDS     R1,R6,R1
   \   000003AA   1B4A               LDR      R2,??Program_60+0x8  ;; 0x3a2
   \   000003AC   B218               ADDS     R2,R6,R2
   \   000003AE   2323               MOVS     R3,#+35
   1220                 {
   1221                    if ((MainStage.StageQImpulse[iNrQ]) && (MainStage.SendStageChange[iNrQ]==0))
   \                     ??Program_61:
   \   000003B0   0C88               LDRH     R4,[R1, #+0]
   \   000003B2   002C               CMP      R4,#+0
   \   000003B4   0BD0               BEQ      ??Program_62
   \   000003B6   0478               LDRB     R4,[R0, #+0]
   \   000003B8   002C               CMP      R4,#+0
   \   000003BA   08D1               BNE      ??Program_62
   1222                    {
   1223                      MainStage.StageQ[iNrQ].Port &=~(MainStage.StageQImpulse[iNrQ]); 
   \   000003BC   1488               LDRH     R4,[R2, #+0]
   \   000003BE   0E88               LDRH     R6,[R1, #+0]
   \   000003C0   B443               BICS     R4,R4,R6
   \   000003C2   1480               STRH     R4,[R2, #+0]
   1224                      MainStage.StageQImpulse[iNrQ]=0;
   \   000003C4   0024               MOVS     R4,#+0
   \   000003C6   0C80               STRH     R4,[R1, #+0]
   1225                      MainStage.SendStageChange[iNrQ]=ChangeStageFlag;
   \   000003C8   144C               LDR      R4,??Program_60+0xC  ;; ChangeStageFlag
   \   000003CA   2478               LDRB     R4,[R4, #+0]
   \   000003CC   0470               STRB     R4,[R0, #+0]
   1226                    } 
   1227                 }
   \                     ??Program_62:
   \   000003CE   1632               ADDS     R2,R2,#+22
   \   000003D0   891C               ADDS     R1,R1,#+2
   \   000003D2   401C               ADDS     R0,R0,#+1
   \   000003D4   5B1E               SUBS     R3,R3,#+1
   \   000003D6   EBD1               BNE      ??Program_61
   1228            
   1229            //zerowanie zmiennych  z flagami impulsu  
   1230            for (char i=0; i<sizeof(VariablesImpulse); i++)
   \   000003D8   2800               MOVS     R0,R5
   \   000003DA   2030               ADDS     R0,R0,#+32
   \   000003DC   2900               MOVS     R1,R5
   \   000003DE   1031               ADDS     R1,R1,#+16
   \   000003E0   0D22               MOVS     R2,#+13
   1231            {
   1232              if (VariablesImpulse[i]>0)
   \                     ??Program_63:
   \   000003E2   0378               LDRB     R3,[R0, #+0]
   \   000003E4   002B               CMP      R3,#+0
   \   000003E6   04D0               BEQ      ??Program_64
   1233              {
   1234                Variables[i]&=~(VariablesImpulse[i]);
   \   000003E8   0C78               LDRB     R4,[R1, #+0]
   \   000003EA   9C43               BICS     R4,R4,R3
   \   000003EC   0C70               STRB     R4,[R1, #+0]
   1235                VariablesImpulse[i]=0;
   \   000003EE   0023               MOVS     R3,#+0
   \   000003F0   0370               STRB     R3,[R0, #+0]
   1236              }
   1237            }
   \                     ??Program_64:
   \   000003F2   491C               ADDS     R1,R1,#+1
   \   000003F4   401C               ADDS     R0,R0,#+1
   \   000003F6   521E               SUBS     R2,R2,#+1
   \   000003F8   F3D1               BNE      ??Program_63
   1238            
   1239            
   1240            
   1241            Busy_program=0;
   \   000003FA   0020               MOVS     R0,#+0
   \   000003FC   A872               STRB     R0,[R5, #+10]
   1242            
   1243              }
   1244             
   1245              
   1246              PtogTime=g_counter-last_time;
   \                     ??Program_2:
   \   000003FE   0848               LDR      R0,??Program_60+0x10  ;; g_counter
   \   00000400   0068               LDR      R0,[R0, #+0]
   \   00000402   A96B               LDR      R1,[R5, #+56]
   \   00000404   401A               SUBS     R0,R0,R1
   \   00000406   6863               STR      R0,[R5, #+52]
   1247          
   1248          }//_______________________ Koniec funkcji program__ ____________________________
   \   00000408   05B0               ADD      SP,SP,#+20
   \   0000040A   F0BC               POP      {R4-R7}
   \   0000040C   01BC               POP      {R0}
   \   0000040E   0047               BX       R0               ;; return
   \                     ??Program_60:
   \   00000410   EB060000           DC32     0x6eb
   \   00000414   A4060000           DC32     0x6a4
   \   00000418   A2030000           DC32     0x3a2
   \   0000041C   ........           DC32     ChangeStageFlag
   \   00000420   ........           DC32     g_counter

   \                                 In section .data, align 4
   \                     Trap:
   \   00000000   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \                     NumberScene:
   \   00000008   0A                 DC8 10
   \                     LastScene:
   \   00000009   00                 DC8 0
   \                     Busy_program:
   \   0000000A   00                 DC8 0
   \                     SceneNrLast:
   \   0000000B   00                 DC8 0
   \                     RealPrcLines:
   \   0000000C   C8                 DC8 200
   \   0000000D   000000             DC8 0, 0, 0
   \                     Variables:
   \   00000010   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     VariablesImpulse:
   \   00000020   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     ScreenUse:
   \   00000030   0000               DC8 0, 0
   \   00000032   0000               DC8 0, 0
   \                     PtogTime:
   \   00000034   00000000           DC32 0
   \                     last_time:
   \   00000038   00000000           DC8 0, 0, 0, 0
   \   0000003C   00000000           DC32 0
   \   00000040   00000000           DC32 0

   \                                 In section .data, align 4
   \                     pProg:
   \   00000000   ........           DC32 gProg
   1249          
   1250          
   1251          
   1252          //-----------------------------------------------------------------------------
   1253          // Nazwa funkcji :    SceneNrCount
   1254          // Funkcja zlicza u¿ywane w programie u¿ytkowym sceny. Odpowiedzi¹ jest iloœæ scen
   1255          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1256          char SceneNrCount(_ProgramTab *ProgTab)
   1257          {
   \                     SceneNrCount:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0100               MOVS     R1,R0
   1258                char MaxScnNr=0;
   \   00000004   0020               MOVS     R0,#+0
   1259                for (int LineNr=0; LineNr<MaxPrcLines; LineNr++)
   \   00000006   1931               ADDS     R1,R1,#+25
   \   00000008   FA22               MOVS     R2,#+250
   \   0000000A   D200               LSLS     R2,R2,#+3        ;; #+2000
   1260                {
   1261                  for (int PrcInLine=0; PrcInLine<MaxPrcInLine; PrcInLine++)
   1262                  {
   1263                     if ((ProgTab->Line[LineNr].Proc[PrcInLine].Type==ProcStS) && (ProgTab->Line[LineNr].Proc[PrcInLine].Nr>MaxScnNr))
   \                     ??SceneNrCount_0:
   \   0000000C   4B1E               SUBS     R3,R1,#+1
   \   0000000E   1B78               LDRB     R3,[R3, #+0]
   \   00000010   182B               CMP      R3,#+24
   \   00000012   05D1               BNE      ??SceneNrCount_1
   \   00000014   0024               MOVS     R4,#+0
   \   00000016   0C57               LDRSB    R4,[R1, R4]
   \   00000018   A042               CMP      R0,R4
   \   0000001A   01DA               BGE      ??SceneNrCount_1
   1264                     {
   1265                       MaxScnNr=ProgTab->Line[LineNr].Proc[PrcInLine].Nr;
   \   0000001C   2006               LSLS     R0,R4,#+24
   \   0000001E   000E               LSRS     R0,R0,#+24
   1266                     }
   1267                  }
   \                     ??SceneNrCount_1:
   \   00000020   1831               ADDS     R1,R1,#+24
   1268                  
   1269                }
   \   00000022   521E               SUBS     R2,R2,#+1
   \   00000024   F2D1               BNE      ??SceneNrCount_0
   1270            
   1271                return MaxScnNr;
   \   00000026   10BC               POP      {R4}
   \   00000028   02BC               POP      {R1}
   \   0000002A   0847               BX       R1               ;; return
   1272          }//_______________________ Koniec funkcji_______________________________________
   1273          
   1274          
   1275          
   1276          
   1277             
   1278          //-----------------------------------------------------------------------------
   1279          // Nazwa funkcji :    ScreenNrCount
   1280          // Funkcja zlicza u¿ywane ekrany. Odpowiedzi¹ jest suma logiczna u¿ywanych ekranów
   1281          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1282          short CheckScreenUse(_ProgramTab *ProgTab)
   1283          {
   \                     CheckScreenUse:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   0022               MOVS     R2,#+0
   1284            
   1285                short ScreenUse=1; 
   1286               
   1287                char f=1;  
   1288            
   1289                char sc=0;
   1290                _ScreenPaternDesign *ScreenPaternDesign; 
   1291                while ((f)&&(sc<ScreenNr))
   1292                {
   1293                  f=0;
   \                     ??CheckScreenUse_0:
   \   00000008   0023               MOVS     R3,#+0
   1294                  
   1295                       if (sc==0) 
   \   0000000A   1000               MOVS     R0,R2
   \   0000000C   01D1               BNE      ??CheckScreenUse_1
   1296                      {
   1297                        ScreenPaternDesign=ScreenSetTab_0;
   \   0000000E   1948               LDR      R0,??CheckScreenUse_2  ;; ScreenSetTab_0
   \   00000010   00E0               B.N      ??CheckScreenUse_3
   1298                      }else{
   1299                        ScreenPaternDesign=ScreenSetTab_1; 
   \                     ??CheckScreenUse_1:
   \   00000012   1948               LDR      R0,??CheckScreenUse_2+0x4  ;; ScreenSetTab_1
   \                     ??CheckScreenUse_3:
   \   00000014   0090               STR      R0,[SP, #+0]
   1300                      }  
   1301          
   1302                  for (int bt=0; bt<ScrenButtonNr; bt++)
   \   00000016   0024               MOVS     R4,#+0
   \   00000018   A020               MOVS     R0,#+160
   \   0000001A   5043               MULS     R0,R2,R0
   \   0000001C   029D               LDR      R5,[SP, #+8]
   \   0000001E   2D18               ADDS     R5,R5,R0
   \   00000020   1648               LDR      R0,??CheckScreenUse_2+0x8  ;; 0xbbaa
   \   00000022   2E18               ADDS     R6,R5,R0
   1303                  {
   1304                    if ((ScreenPaternDesign[ProgTab->Screen[sc].PaternDesign].Button[bt].Width>0) && (ProgTab->Screen[sc].Button[bt].OpenPage>0) )
   \                     ??CheckScreenUse_4:
   \   00000024   A700               LSLS     R7,R4,#+2
   \   00000026   BC46               MOV      R12,R7
   \   00000028   1548               LDR      R0,??CheckScreenUse_2+0xC  ;; 0xbb98
   \   0000002A   285C               LDRB     R0,[R5, R0]
   \   0000002C   5827               MOVS     R7,#+88
   \   0000002E   7843               MULS     R0,R7,R0
   \   00000030   009F               LDR      R7,[SP, #+0]
   \   00000032   3818               ADDS     R0,R7,R0
   \   00000034   6746               MOV      R7,R12
   \   00000036   C019               ADDS     R0,R0,R7
   \   00000038   8078               LDRB     R0,[R0, #+2]
   \   0000003A   0028               CMP      R0,#+0
   \   0000003C   0BD0               BEQ      ??CheckScreenUse_5
   \   0000003E   3078               LDRB     R0,[R6, #+0]
   \   00000040   0707               LSLS     R7,R0,#+28
   \   00000042   08D0               BEQ      ??CheckScreenUse_5
   1305                    {
   1306                      ScreenUse |=1<<(ProgTab->Screen[sc].Button[bt].OpenPage-1);
   \   00000044   0123               MOVS     R3,#+1
   \   00000046   0007               LSLS     R0,R0,#+28
   \   00000048   000F               LSRS     R0,R0,#+28
   \   0000004A   401E               SUBS     R0,R0,#+1
   \   0000004C   8340               LSLS     R3,R3,R0
   \   0000004E   0B43               ORRS     R3,R3,R1
   \   00000050   1904               LSLS     R1,R3,#+16
   \   00000052   0914               ASRS     R1,R1,#+16
   1307                      f=1;
   \   00000054   0123               MOVS     R3,#+1
   1308                    }
   1309                  }
   \                     ??CheckScreenUse_5:
   \   00000056   641C               ADDS     R4,R4,#+1
   \   00000058   0836               ADDS     R6,R6,#+8
   \   0000005A   092C               CMP      R4,#+9
   \   0000005C   E2DB               BLT      ??CheckScreenUse_4
   1310                  sc++;
   \   0000005E   521C               ADDS     R2,R2,#+1
   \   00000060   1206               LSLS     R2,R2,#+24
   \   00000062   120E               LSRS     R2,R2,#+24
   1311                  
   1312                }
   \   00000064   002B               CMP      R3,#+0
   \   00000066   01D0               BEQ      ??CheckScreenUse_6
   \   00000068   082A               CMP      R2,#+8
   \   0000006A   CDD3               BCC      ??CheckScreenUse_0
   1313                
   1314           
   1315            
   1316                return ScreenUse;
   \                     ??CheckScreenUse_6:
   \   0000006C   0800               MOVS     R0,R1
   \   0000006E   FEBC               POP      {R1-R7}
   \   00000070   02BC               POP      {R1}
   \   00000072   0847               BX       R1               ;; return
   \                     ??CheckScreenUse_2:
   \   00000074   ........           DC32     ScreenSetTab_0
   \   00000078   ........           DC32     ScreenSetTab_1
   \   0000007C   AABB0000           DC32     0xbbaa
   \   00000080   98BB0000           DC32     0xbb98
   1317            
   1318          }//_______________________ Koniec funkcji_______________________________________
   1319          
   1320          
   1321               
   1322               
   1323               

   \                                 In section Debug.txt, align 4, keep-with-next
   1324          void CountLines(_ProgramTab *ProgTab)
   1325          {
   \                     CountLines:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   1326               char UseLine=0;
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0022               MOVS     R2,#+0
   1327                  for (char j=0; j<MaxPrcLines; j++)
   \   00000006   1830               ADDS     R0,R0,#+24
   1328                    for (char i=0; i<MaxPrcInLine; i++) 
   \                     ??CountLines_0:
   \   00000008   0A24               MOVS     R4,#+10
   1329                      if (ProgTab->Line[j].Proc[i].Type>0) UseLine=j;
   \                     ??CountLines_1:
   \   0000000A   0578               LDRB     R5,[R0, #+0]
   \   0000000C   002D               CMP      R5,#+0
   \   0000000E   00D0               BEQ      ??CountLines_2
   \   00000010   0A00               MOVS     R2,R1
   \                     ??CountLines_2:
   \   00000012   1830               ADDS     R0,R0,#+24
   \   00000014   641E               SUBS     R4,R4,#+1
   \   00000016   F8D1               BNE      ??CountLines_1
   \   00000018   491C               ADDS     R1,R1,#+1
   \   0000001A   0C06               LSLS     R4,R1,#+24
   \   0000001C   240E               LSRS     R4,R4,#+24
   \   0000001E   C82C               CMP      R4,#+200
   \   00000020   F2D3               BCC      ??CountLines_0
   1330              RealPrcLines=UseLine+1; 
   \   00000022   0248               LDR      R0,??CountLines_3  ;; Trap + 12
   \   00000024   521C               ADDS     R2,R2,#+1
   \   00000026   0270               STRB     R2,[R0, #+0]
   1331          }
   \   00000028   ....               B.N      ??Subroutine0_0
   \   0000002A   C046               Nop      
   \                     ??CountLines_3:
   \   0000002C   ........           DC32     Trap + 12
   1332          
   1333          
   1334          

   \                                 In section Debug.txt, align 4, keep-with-next
   1335          void RefreshNeuronsList(_ProgramTab *ProgTab)
   1336          {
   \                     RefreshNeuronsList:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   1337            for (char i=0; i<NumberNeurons; i++)
   \   00000002   0E49               LDR      R1,??RefreshNeuronsList_0  ;; 0xc098
   \   00000004   4418               ADDS     R4,R0,R1
   \   00000006   0E4D               LDR      R5,??RefreshNeuronsList_0+0x4  ;; NeuronsList
   \   00000008   2326               MOVS     R6,#+35
   \   0000000A   0027               MOVS     R7,#+0
   1338            {
   1339             if (ProgTab->NeuronsIdTab[i]>0)
   \                     ??RefreshNeuronsList_1:
   \   0000000C   2068               LDR      R0,[R4, #+0]
   \   0000000E   0128               CMP      R0,#+1
   \   00000010   0ADB               BLT      ??RefreshNeuronsList_2
   1340             {
   1341                 NeuronsList[i].NeuronType=(_NeuronType)((ProgTab->NeuronsIdTab[i])/1000000);
   \   00000012   0C49               LDR      R1,??RefreshNeuronsList_0+0x8  ;; 0xf4240
   \   00000014   ........           BL       __aeabi_idivmod
   \   00000018   2870               STRB     R0,[R5, #+0]
   1342                 NeuronsList[i].NeuronID=(ProgTab->NeuronsIdTab[i])-(NeuronsList[i].NeuronType*1000000);
   \   0000001A   2068               LDR      R0,[R4, #+0]
   \   0000001C   2978               LDRB     R1,[R5, #+0]
   \   0000001E   094A               LDR      R2,??RefreshNeuronsList_0+0x8  ;; 0xf4240
   \   00000020   5143               MULS     R1,R2,R1
   \   00000022   401A               SUBS     R0,R0,R1
   \   00000024   6860               STR      R0,[R5, #+4]
   \   00000026   01E0               B        ??RefreshNeuronsList_3
   1343             }else{
   1344                 NeuronsList[i].NeuronType=(_NeuronType)0;
   \                     ??RefreshNeuronsList_2:
   \   00000028   2F70               STRB     R7,[R5, #+0]
   1345                 NeuronsList[i].NeuronID=0;
   \   0000002A   6F60               STR      R7,[R5, #+4]
   1346             }
   1347            }
   \                     ??RefreshNeuronsList_3:
   \   0000002C   0C35               ADDS     R5,R5,#+12
   \   0000002E   241D               ADDS     R4,R4,#+4
   \   00000030   761E               SUBS     R6,R6,#+1
   \   00000032   EBD1               BNE      ??RefreshNeuronsList_1
   1348          }
   \   00000034   F8BC               POP      {R3-R7}
   \   00000036   01BC               POP      {R0}
   \   00000038   0047               BX       R0               ;; return
   \   0000003A   C046               Nop      
   \                     ??RefreshNeuronsList_0:
   \   0000003C   98C00000           DC32     0xc098
   \   00000040   ........           DC32     NeuronsList
   \   00000044   40420F00           DC32     0xf4240
   1349          
   1350          
   1351          
   1352          //-----------------------------------------------------------------------------
   1353          // Nazwa funkcji :    AddRsTask
   1354          // Funkcja ustawia dodanie zadania dla transmisji Rs
   1355          // Ord - typ rozkazu : odczyt wejœæ, zapis
   1356          // Node - nr wêz³a/urz¹dzenia
   1357          // Reg  - nr rejestru w wêŸle 
   1358          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1359          void AddRsTask(_OrderType Ord, char Node, char Reg)
   1360          { 
   \                     AddRsTask:
   \   00000000   F7B5               PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0021               MOVS     R1,#+0
   1361               ptr_ZD_MODBUS ZD_MODBUS;
   1362               ZD_MODBUS         =   ZD_MODBUS_0;
   1363               
   1364              char OrdExist=0;
   1365              char RfOrd=0;
   \   00000004   0022               MOVS     R2,#+0
   1366              char FreePlace=0;
   1367              
   1368              
   1369              //przepisanie rozkazu na zrozumia³y dla tablicy zadañ Rs
   1370              if (Ord==SI) RfOrd=0x4; 
   \   00000006   0128               CMP      R0,#+1
   \   00000008   01D1               BNE      ??AddRsTask_0
   \   0000000A   0422               MOVS     R2,#+4
   \   0000000C   02E0               B        ??AddRsTask_1
   1371              if (Ord==SQ) RfOrd=0xF; 
   \                     ??AddRsTask_0:
   \   0000000E   0228               CMP      R0,#+2
   \   00000010   00D1               BNE      ??AddRsTask_1
   \   00000012   0F22               MOVS     R2,#+15
   1372          
   1373                
   1374          
   1375                    
   1376              //Sprawdzenie czy taki rozkaz nie istnieje w tablicy
   1377              char i=0;
   \                     ??AddRsTask_1:
   \   00000014   0020               MOVS     R0,#+0
   \   00000016   2C4B               LDR      R3,??AddRsTask_2  ;; ZD_MODBUS_0
   1378              while ((i<ZD_MODBUS_Tab_Max) && (OrdExist==0))
   1379              {
   1380                 if ((ZD_MODBUS[i].Adress==Node) && 
   1381                     (ZD_MODBUS[i].Function==RfOrd) &&
   1382                     (ZD_MODBUS[i].Target==Reg) &&
   1383                     (ZD_MODBUS[i].StartAdr==Node-0))
   \                     ??AddRsTask_3:
   \   00000018   0D24               MOVS     R4,#+13
   \   0000001A   4443               MULS     R4,R0,R4
   \   0000001C   1D19               ADDS     R5,R3,R4
   \   0000001E   2E78               LDRB     R6,[R5, #+0]
   \   00000020   6F46               MOV      R7,SP
   \   00000022   3F79               LDRB     R7,[R7, #+4]
   \   00000024   BE42               CMP      R6,R7
   \   00000026   1BD1               BNE      ??AddRsTask_4
   \   00000028   6D78               LDRB     R5,[R5, #+1]
   \   0000002A   9542               CMP      R5,R2
   \   0000002C   18D1               BNE      ??AddRsTask_4
   \   0000002E   1D00               MOVS     R5,R3
   \   00000030   AD1C               ADDS     R5,R5,#+2
   \   00000032   2E19               ADDS     R6,R5,R4
   \   00000034   3578               LDRB     R5,[R6, #+0]
   \   00000036   7778               LDRB     R7,[R6, #+1]
   \   00000038   3F06               LSLS     R7,R7,#+24
   \   0000003A   3F0C               LSRS     R7,R7,#+16
   \   0000003C   3D43               ORRS     R5,R5,R7
   \   0000003E   6E46               MOV      R6,SP
   \   00000040   367A               LDRB     R6,[R6, #+8]
   \   00000042   B542               CMP      R5,R6
   \   00000044   0CD1               BNE      ??AddRsTask_4
   \   00000046   1D00               MOVS     R5,R3
   \   00000048   2D1D               ADDS     R5,R5,#+4
   \   0000004A   2D19               ADDS     R5,R5,R4
   \   0000004C   2C78               LDRB     R4,[R5, #+0]
   \   0000004E   6E78               LDRB     R6,[R5, #+1]
   \   00000050   3606               LSLS     R6,R6,#+24
   \   00000052   360C               LSRS     R6,R6,#+16
   \   00000054   3443               ORRS     R4,R4,R6
   \   00000056   6D46               MOV      R5,SP
   \   00000058   2D79               LDRB     R5,[R5, #+4]
   \   0000005A   AC42               CMP      R4,R5
   \   0000005C   00D1               BNE      ??AddRsTask_4
   1384                    {
   1385                      OrdExist=1;
   \   0000005E   0121               MOVS     R1,#+1
   1386                    }
   1387                 i++;
   \                     ??AddRsTask_4:
   \   00000060   401C               ADDS     R0,R0,#+1
   1388              }
   \   00000062   0406               LSLS     R4,R0,#+24
   \   00000064   240E               LSRS     R4,R4,#+24
   \   00000066   142C               CMP      R4,#+20
   \   00000068   01D2               BCS      ??AddRsTask_5
   \   0000006A   0C00               MOVS     R4,R1
   \   0000006C   D4D0               BEQ      ??AddRsTask_3
   1389              
   1390              //je¿eli rozkaz nie istnieje to dodaj
   1391              if (OrdExist==0)
   \                     ??AddRsTask_5:
   \   0000006E   0029               CMP      R1,#+0
   \   00000070   27D1               BNE      ??AddRsTask_6
   1392              {
   1393                //znajdŸ wolne miejsce w tablicy zadañ 
   1394                FreePlace=0;
   \   00000072   0020               MOVS     R0,#+0
   \                     ??AddRsTask_7:
   \   00000074   0D21               MOVS     R1,#+13
   \   00000076   4143               MULS     R1,R0,R1
   \   00000078   595C               LDRB     R1,[R3, R1]
   \   0000007A   0029               CMP      R1,#+0
   \   0000007C   04D0               BEQ      ??AddRsTask_8
   1395                while ((FreePlace<ZD_MODBUS_Tab_Max) && (ZD_MODBUS[FreePlace].Adress!=0)) FreePlace++;
   \   0000007E   401C               ADDS     R0,R0,#+1
   \   00000080   0106               LSLS     R1,R0,#+24
   \   00000082   090E               LSRS     R1,R1,#+24
   \   00000084   1429               CMP      R1,#+20
   \   00000086   F5D3               BCC      ??AddRsTask_7
   1396                
   1397                
   1398                if (FreePlace<ZD_MODBUS_Tab_Max)     //jezeli jest miejsce w tablicy to dodaj
   \                     ??AddRsTask_8:
   \   00000088   0106               LSLS     R1,R0,#+24
   \   0000008A   090E               LSRS     R1,R1,#+24
   \   0000008C   1429               CMP      R1,#+20
   \   0000008E   18D2               BCS      ??AddRsTask_6
   1399                { 
   1400                  ZD_MODBUS[FreePlace].Adress=Node;
   \   00000090   0006               LSLS     R0,R0,#+24
   \   00000092   000E               LSRS     R0,R0,#+24
   \   00000094   0D21               MOVS     R1,#+13
   \   00000096   4843               MULS     R0,R1,R0
   \   00000098   1818               ADDS     R0,R3,R0
   \   0000009A   6946               MOV      R1,SP
   \   0000009C   0979               LDRB     R1,[R1, #+4]
   \   0000009E   0170               STRB     R1,[R0, #+0]
   1401                  ZD_MODBUS[FreePlace].Function=RfOrd;
   \   000000A0   4270               STRB     R2,[R0, #+1]
   1402                  ZD_MODBUS[FreePlace].Target=Reg;
   \   000000A2   6946               MOV      R1,SP
   \   000000A4   097A               LDRB     R1,[R1, #+8]
   \   000000A6   8170               STRB     R1,[R0, #+2]
   \   000000A8   0021               MOVS     R1,#+0
   \   000000AA   C170               STRB     R1,[R0, #+3]
   1403                  ZD_MODBUS[FreePlace].StartAdr=Node-0;   //miejsce w pamiêci do pobrania danych (odpowiada nodowi)
   \   000000AC   6946               MOV      R1,SP
   \   000000AE   0979               LDRB     R1,[R1, #+4]
   \   000000B0   0171               STRB     R1,[R0, #+4]
   \   000000B2   0021               MOVS     R1,#+0
   \   000000B4   4171               STRB     R1,[R0, #+5]
   1404                  ZD_MODBUS[FreePlace].Coil=16;
   \   000000B6   1021               MOVS     R1,#+16
   \   000000B8   8171               STRB     R1,[R0, #+6]
   \   000000BA   0021               MOVS     R1,#+0
   \   000000BC   C171               STRB     R1,[R0, #+7]
   1405                  ZD_MODBUS[FreePlace].Error=0x0; 
   \   000000BE   C172               STRB     R1,[R0, #+11]
   \   000000C0   0173               STRB     R1,[R0, #+12]
   1406                }
   1407                
   1408                
   1409              }
   1410              
   1411                
   1412          
   1413                
   1414                          
   1415          }//_______________________ Koniec funkcji  AddRsTask _________________
   \                     ??AddRsTask_6:
   \   000000C2   FEBC               POP      {R1-R7}
   \   000000C4   01BC               POP      {R0}
   \   000000C6   0047               BX       R0               ;; return
   \                     ??AddRsTask_2:
   \   000000C8   ........           DC32     ZD_MODBUS_0
   1416          
   1417          
   1418          
   1419          
   1420          
   1421          //-----------------------------------------------------------------------------
   1422          // Nazwa funkcji :    AddRfTask_SearchNode
   1423          // Funkcja ustawia dodanie zadania dla transmisji Rs "Ramka rozg³oœna z wyszukaniem wêz³a"
   1424          // Funkcja zastêpuje wszystkie zadanie z rozkazem R_RegOrd (odczytu statusu) rz¹danego wêz³a oraz blokuje odpytywanie wêz³a
   1425          // Node - nr wêz³a/urz¹dzeia
   1426          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1427          void AddRfTask_SearchNodeTask(char Node)
   1428          { 
   \                     AddRfTask_SearchNodeTask:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   1429              if (NeuronsList[Node-1].ReadSuspend) return;
   \   00000002   6846               MOV      R0,SP
   \   00000004   0078               LDRB     R0,[R0, #+0]
   \   00000006   0C21               MOVS     R1,#+12
   \   00000008   4843               MULS     R0,R1,R0
   \   0000000A   1849               LDR      R1,??AddRfTask_SearchNodeTask_0  ;; NeuronsList
   \   0000000C   0818               ADDS     R0,R1,R0
   \   0000000E   0838               SUBS     R0,R0,#+8
   \   00000010   0179               LDRB     R1,[R0, #+4]
   \   00000012   4907               LSLS     R1,R1,#+29
   \   00000014   23D4               BMI      ??AddRfTask_SearchNodeTask_1
   1430          
   1431              for (char i=0; i<RF_Tasks-1; i++)  
   \   00000016   1649               LDR      R1,??AddRfTask_SearchNodeTask_0+0x4  ;; RF_TaskTab + 4
   \   00000018   4522               MOVS     R2,#+69
   \   0000001A   164C               LDR      R4,??AddRfTask_SearchNodeTask_0+0x8  ;; 0xff0fffff
   \   0000001C   2300               MOVS     R3,R4
   \   0000001E   164C               LDR      R4,??AddRfTask_SearchNodeTask_0+0xC  ;; 0xfffff
   1432              {
   1433                 //znalezienie rozkazu odpytania statusu
   1434                 if ((RF_TaskTab[i].Node==Node) && 
   1435                     (RF_TaskTab[i].Command.ID==NeuronsList[Node-1].NeuronID) &&
   1436                     ((RF_TaskTab[i].Command.Order==R_RegOrd) || (RF_TaskTab[i].Command.Order==W_RegOrd)) )
   \                     ??AddRfTask_SearchNodeTask_2:
   \   00000020   0D1F               SUBS     R5,R1,#+4
   \   00000022   2D78               LDRB     R5,[R5, #+0]
   \   00000024   6E46               MOV      R6,SP
   \   00000026   3678               LDRB     R6,[R6, #+0]
   \   00000028   B542               CMP      R5,R6
   \   0000002A   15D1               BNE      ??AddRfTask_SearchNodeTask_3
   \   0000002C   0D68               LDR      R5,[R1, #+0]
   \   0000002E   2600               MOVS     R6,R4
   \   00000030   2E40               ANDS     R6,R6,R5
   \   00000032   0768               LDR      R7,[R0, #+0]
   \   00000034   BE42               CMP      R6,R7
   \   00000036   0FD1               BNE      ??AddRfTask_SearchNodeTask_3
   \   00000038   DE43               MVNS     R6,R3
   \   0000003A   2E40               ANDS     R6,R6,R5
   \   0000003C   360D               LSRS     R6,R6,#+20
   \   0000003E   012E               CMP      R6,#+1
   \   00000040   10D0               BEQ      ??AddRfTask_SearchNodeTask_4
   \   00000042   022E               CMP      R6,#+2
   \   00000044   08D1               BNE      ??AddRfTask_SearchNodeTask_3
   1437                 {
   1438                     if (RF_TaskTab[i].Command.Order==R_RegOrd)
   1439                     {
   1440                        RF_TaskTab[i].Command.Order=R_BC_Order;
   1441                     }else{
   1442                        RF_TaskTab[i].Command.Order=W_BC_Order;
   \   00000046   1D40               ANDS     R5,R5,R3
   \   00000048   8026               MOVS     R6,#+128
   \   0000004A   3604               LSLS     R6,R6,#+16       ;; #+8388608
   \                     ??AddRfTask_SearchNodeTask_5:
   \   0000004C   2E43               ORRS     R6,R6,R5
   \   0000004E   0E60               STR      R6,[R1, #+0]
   1443                     }
   1444                     NeuronsList[Node-1].ReadSuspend=1;
   \   00000050   0579               LDRB     R5,[R0, #+4]
   \   00000052   0426               MOVS     R6,#+4
   \   00000054   2E43               ORRS     R6,R6,R5
   \   00000056   0671               STRB     R6,[R0, #+4]
   \                     ??AddRfTask_SearchNodeTask_3:
   \   00000058   0831               ADDS     R1,R1,#+8
   \   0000005A   521E               SUBS     R2,R2,#+1
   \   0000005C   E0D1               BNE      ??AddRfTask_SearchNodeTask_2
   \                     ??AddRfTask_SearchNodeTask_1:
   \   0000005E   F8BC               POP      {R3-R7}
   \   00000060   01BC               POP      {R0}
   \   00000062   0047               BX       R0               ;; return
   \                     ??AddRfTask_SearchNodeTask_4:
   \   00000064   1D40               ANDS     R5,R5,R3
   \   00000066   E026               MOVS     R6,#+224
   \   00000068   F603               LSLS     R6,R6,#+15       ;; #+7340032
   \   0000006A   EFE7               B.N      ??AddRfTask_SearchNodeTask_5
   \                     ??AddRfTask_SearchNodeTask_0:
   \   0000006C   ........           DC32     NeuronsList
   \   00000070   ........           DC32     RF_TaskTab + 4
   \   00000074   FFFF0FFF           DC32     0xff0fffff
   \   00000078   FFFF0F00           DC32     0xfffff
   1445                 }
   1446              } 
   1447          }
   1448          
   1449          
   1450          //-----------------------------------------------------------------------------
   1451          // Nazwa funkcji :    AddRfTask_SearchNode
   1452          // Funkcja ustawia dodanie zadania dla transmisji Rs "Wy³¹czenie ramki rozg³oœnej z wyszukaniem wêz³a"
   1453          // Funkcja w³¹cza ponowne odpytanie wêz³a zablokowanego funkcj¹ AddRfTask_SearchNode
   1454          // Node - nr wêz³a/urz¹dzeia
   1455          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1456          void AddRfTask_RemoveSearchNodeTask(char Node)
   1457          { 
   \                     AddRfTask_RemoveSearchNodeTask:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   1458              for (char i=0; i<RF_Tasks-1; i++)  
   \   00000002   1848               LDR      R0,??AddRfTask_RemoveSearchNodeTask_0  ;; RF_TaskTab + 4
   \   00000004   4521               MOVS     R1,#+69
   \   00000006   6A46               MOV      R2,SP
   \   00000008   1278               LDRB     R2,[R2, #+0]
   \   0000000A   0C23               MOVS     R3,#+12
   \   0000000C   5A43               MULS     R2,R3,R2
   \   0000000E   164B               LDR      R3,??AddRfTask_RemoveSearchNodeTask_0+0x4  ;; NeuronsList
   \   00000010   9A18               ADDS     R2,R3,R2
   \   00000012   083A               SUBS     R2,R2,#+8
   \   00000014   154C               LDR      R4,??AddRfTask_RemoveSearchNodeTask_0+0x8  ;; 0xff0fffff
   \   00000016   2300               MOVS     R3,R4
   \   00000018   154C               LDR      R4,??AddRfTask_RemoveSearchNodeTask_0+0xC  ;; 0xfffff
   1459              {
   1460                 //znalezienie rozkazu odpytania statusu
   1461                 if ((RF_TaskTab[i].Node==Node) && 
   1462                     (RF_TaskTab[i].Command.ID==NeuronsList[Node-1].NeuronID) &&
   1463                     ((RF_TaskTab[i].Command.Order==R_BC_Order) || (RF_TaskTab[i].Command.Order==W_BC_Order)))
   \                     ??AddRfTask_RemoveSearchNodeTask_1:
   \   0000001A   051F               SUBS     R5,R0,#+4
   \   0000001C   2D78               LDRB     R5,[R5, #+0]
   \   0000001E   6E46               MOV      R6,SP
   \   00000020   3678               LDRB     R6,[R6, #+0]
   \   00000022   B542               CMP      R5,R6
   \   00000024   15D1               BNE      ??AddRfTask_RemoveSearchNodeTask_2
   \   00000026   0568               LDR      R5,[R0, #+0]
   \   00000028   2600               MOVS     R6,R4
   \   0000002A   2E40               ANDS     R6,R6,R5
   \   0000002C   1768               LDR      R7,[R2, #+0]
   \   0000002E   BE42               CMP      R6,R7
   \   00000030   0FD1               BNE      ??AddRfTask_RemoveSearchNodeTask_2
   \   00000032   DE43               MVNS     R6,R3
   \   00000034   2E40               ANDS     R6,R6,R5
   \   00000036   360D               LSRS     R6,R6,#+20
   \   00000038   072E               CMP      R6,#+7
   \   0000003A   10D0               BEQ      ??AddRfTask_RemoveSearchNodeTask_3
   \   0000003C   082E               CMP      R6,#+8
   \   0000003E   08D1               BNE      ??AddRfTask_RemoveSearchNodeTask_2
   1464                 {
   1465                     if (RF_TaskTab[i].Command.Order==R_BC_Order)
   1466                     {
   1467                        RF_TaskTab[i].Command.Order=R_RegOrd;
   1468                     }else{
   1469                        RF_TaskTab[i].Command.Order=W_RegOrd;
   \   00000040   1D40               ANDS     R5,R5,R3
   \   00000042   8026               MOVS     R6,#+128
   \   00000044   B603               LSLS     R6,R6,#+14       ;; #+2097152
   \                     ??AddRfTask_RemoveSearchNodeTask_4:
   \   00000046   2E43               ORRS     R6,R6,R5
   \   00000048   0660               STR      R6,[R0, #+0]
   1470                     }
   1471                     NeuronsList[Node-1].ReadSuspend=0;
   \   0000004A   1579               LDRB     R5,[R2, #+4]
   \   0000004C   FB26               MOVS     R6,#+251
   \   0000004E   2E40               ANDS     R6,R6,R5
   \   00000050   1671               STRB     R6,[R2, #+4]
   \                     ??AddRfTask_RemoveSearchNodeTask_2:
   \   00000052   0830               ADDS     R0,R0,#+8
   \   00000054   491E               SUBS     R1,R1,#+1
   \   00000056   E0D1               BNE      ??AddRfTask_RemoveSearchNodeTask_1
   1472                 }
   1473              } 
   1474          }
   \   00000058   F8BC               POP      {R3-R7}
   \   0000005A   01BC               POP      {R0}
   \   0000005C   0047               BX       R0               ;; return
   \                     ??AddRfTask_RemoveSearchNodeTask_3:
   \   0000005E   1D40               ANDS     R5,R5,R3
   \   00000060   661C               ADDS     R6,R4,#+1
   \   00000062   F0E7               B.N      ??AddRfTask_RemoveSearchNodeTask_4
   \                     ??AddRfTask_RemoveSearchNodeTask_0:
   \   00000064   ........           DC32     RF_TaskTab + 4
   \   00000068   ........           DC32     NeuronsList
   \   0000006C   FFFF0FFF           DC32     0xff0fffff
   \   00000070   FFFF0F00           DC32     0xfffff
   1475          
   1476          
   1477          //usuñ wszystkie zadania dla tego wêz³a

   \                                 In section Debug.txt, align 4, keep-with-next
   1478          char RemoveRfNodeAllTaska( char Node)
   1479          {
   \                     RemoveRfNodeAllTaska:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   1480            for (char TSK=0; TSK<RF_Tasks-1; TSK++)
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   254B               LDR      R3,??RemoveRfNodeAllTaska_0  ;; RF_TaskTab
   \   00000008   F024               MOVS     R4,#+240
   \   0000000A   2404               LSLS     R4,R4,#+16       ;; #+15728640
   1481            {
   1482               if (RF_TaskTab[TSK].Node==Node) //wyczyœæ wêze³
   \                     ??RemoveRfNodeAllTaska_1:
   \   0000000C   1878               LDRB     R0,[R3, #+0]
   \   0000000E   6D46               MOV      R5,SP
   \   00000010   2D78               LDRB     R5,[R5, #+0]
   \   00000012   A842               CMP      R0,R5
   \   00000014   01D1               BNE      ??RemoveRfNodeAllTaska_2
   1483               {
   1484                  RF_TaskTab[TSK].Node=0;
   \   00000016   1970               STRB     R1,[R3, #+0]
   1485                  RF_TaskTab[TSK].Command.ID=0;
   1486                  RF_TaskTab[TSK].Command.Order=0;
   1487                  RF_TaskTab[TSK].Command.Auxi=0;
   \   00000018   5960               STR      R1,[R3, #+4]
   1488               }
   1489               
   1490               //przesuñ pozosta³e zadania do góry
   1491               char Tp=TSK;
   \                     ??RemoveRfNodeAllTaska_2:
   \   0000001A   1500               MOVS     R5,R2
   \   0000001C   1BE0               B        ??RemoveRfNodeAllTaska_3
   1492               while ((Tp+1<RF_Tasks-1) && (RF_TaskTab[Tp+1].Node))
   1493               {
   1494                 RF_TaskTab[Tp].Node=RF_TaskTab[Tp+1].Node;
   \                     ??RemoveRfNodeAllTaska_4:
   \   0000001E   3070               STRB     R0,[R6, #+0]
   1495                 RF_TaskTab[Tp].Command.ID=RF_TaskTab[Tp+1].Command.ID;
   \   00000020   7068               LDR      R0,[R6, #+4]
   \   00000022   070D               LSRS     R7,R0,#+20
   \   00000024   3F05               LSLS     R7,R7,#+20
   \   00000026   F068               LDR      R0,[R6, #+12]
   \   00000028   0003               LSLS     R0,R0,#+12
   \   0000002A   000B               LSRS     R0,R0,#+12
   \   0000002C   3843               ORRS     R0,R0,R7
   \   0000002E   7060               STR      R0,[R6, #+4]
   1496                 RF_TaskTab[Tp].Command.Order=RF_TaskTab[Tp+1].Command.Order;
   \   00000030   1B4F               LDR      R7,??RemoveRfNodeAllTaska_0+0x4  ;; 0xff0fffff
   \   00000032   0740               ANDS     R7,R7,R0
   \   00000034   F068               LDR      R0,[R6, #+12]
   \   00000036   000D               LSRS     R0,R0,#+20
   \   00000038   0005               LSLS     R0,R0,#+20
   \   0000003A   2040               ANDS     R0,R0,R4
   \   0000003C   3843               ORRS     R0,R0,R7
   \   0000003E   7060               STR      R0,[R6, #+4]
   1497                 RF_TaskTab[Tp].Command.Auxi=RF_TaskTab[Tp+1].Command.Order;
   \   00000040   0002               LSLS     R0,R0,#+8
   \   00000042   000A               LSRS     R0,R0,#+8
   \   00000044   F768               LDR      R7,[R6, #+12]
   \   00000046   2740               ANDS     R7,R7,R4
   \   00000048   3F0D               LSRS     R7,R7,#+20
   \   0000004A   3F06               LSLS     R7,R7,#+24
   \   0000004C   0743               ORRS     R7,R7,R0
   \   0000004E   7760               STR      R7,[R6, #+4]
   1498                 Tp++;
   \   00000050   6D1C               ADDS     R5,R5,#+1
   \   00000052   2D06               LSLS     R5,R5,#+24
   \   00000054   2D0E               LSRS     R5,R5,#+24
   1499               }
   \                     ??RemoveRfNodeAllTaska_3:
   \   00000056   2806               LSLS     R0,R5,#+24
   \   00000058   000E               LSRS     R0,R0,#+24
   \   0000005A   401C               ADDS     R0,R0,#+1
   \   0000005C   0004               LSLS     R0,R0,#+16
   \   0000005E   000C               LSRS     R0,R0,#+16
   \   00000060   4528               CMP      R0,#+69
   \   00000062   05D2               BCS      ??RemoveRfNodeAllTaska_5
   \   00000064   E800               LSLS     R0,R5,#+3
   \   00000066   0D4E               LDR      R6,??RemoveRfNodeAllTaska_0  ;; RF_TaskTab
   \   00000068   3618               ADDS     R6,R6,R0
   \   0000006A   307A               LDRB     R0,[R6, #+8]
   \   0000006C   0028               CMP      R0,#+0
   \   0000006E   D6D1               BNE      ??RemoveRfNodeAllTaska_4
   1500               
   1501               //usuñ pozosta³oœæ po czyszczeniu
   1502               if ((Tp<RF_Tasks-1) && (RF_TaskTab[Tp].Node))
   \                     ??RemoveRfNodeAllTaska_5:
   \   00000070   2806               LSLS     R0,R5,#+24
   \   00000072   000E               LSRS     R0,R0,#+24
   \   00000074   4528               CMP      R0,#+69
   \   00000076   08D2               BCS      ??RemoveRfNodeAllTaska_6
   \   00000078   2D06               LSLS     R5,R5,#+24
   \   0000007A   680D               LSRS     R0,R5,#+21
   \   0000007C   074D               LDR      R5,??RemoveRfNodeAllTaska_0  ;; RF_TaskTab
   \   0000007E   2818               ADDS     R0,R5,R0
   \   00000080   0578               LDRB     R5,[R0, #+0]
   \   00000082   002D               CMP      R5,#+0
   \   00000084   01D0               BEQ      ??RemoveRfNodeAllTaska_6
   1503               {
   1504                  RF_TaskTab[Tp].Node=0;
   \   00000086   0170               STRB     R1,[R0, #+0]
   1505                  RF_TaskTab[Tp].Command.ID=0;
   1506                  RF_TaskTab[Tp].Command.Order=0;
   1507                  RF_TaskTab[Tp].Command.Auxi=0; 
   \   00000088   4160               STR      R1,[R0, #+4]
   1508               } 
   1509            }  
   \                     ??RemoveRfNodeAllTaska_6:
   \   0000008A   521C               ADDS     R2,R2,#+1
   \   0000008C   0833               ADDS     R3,R3,#+8
   \   0000008E   1006               LSLS     R0,R2,#+24
   \   00000090   000E               LSRS     R0,R0,#+24
   \   00000092   4528               CMP      R0,#+69
   \   00000094   BAD3               BCC      ??RemoveRfNodeAllTaska_1
   1510          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "RemoveRfNodeAllTaska"
   \   00000096   F8BC               POP      {R3-R7}
   \   00000098   01BC               POP      {R0}
   \   0000009A   0047               BX       R0               ;; return
   \                     ??RemoveRfNodeAllTaska_0:
   \   0000009C   ........           DC32     RF_TaskTab
   \   000000A0   FFFF0FFF           DC32     0xff0fffff
   1511          
   1512          
   1513          
   1514          
   1515          //usuñ wszystkie zadania dla tego wêz³a

   \                                 In section Debug.txt, align 4, keep-with-next
   1516          char RemoveRfTask(char TSK)
   1517          {
   \                     RemoveRfTask:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0200               MOVS     R2,R0
   1518          
   1519                RF_TaskTab[TSK].Node=0;
   \   00000004   1E48               LDR      R0,??RemoveRfTask_0  ;; RF_TaskTab
   \   00000006   D100               LSLS     R1,R2,#+3
   \   00000008   4318               ADDS     R3,R0,R1
   \   0000000A   0021               MOVS     R1,#+0
   \   0000000C   1970               STRB     R1,[R3, #+0]
   1520                RF_TaskTab[TSK].Command.ID=0;
   1521                RF_TaskTab[TSK].Command.Order=0;
   1522                RF_TaskTab[TSK].Command.Auxi=0;
   \   0000000E   5960               STR      R1,[R3, #+4]
   1523          
   1524               //przesuñ pozosta³e zadania do góry
   1525               char Tp=TSK;
   \   00000010   1C4B               LDR      R3,??RemoveRfTask_0+0x4  ;; 0xfffff
   \   00000012   1D4C               LDR      R4,??RemoveRfTask_0+0x8  ;; 0xfff00000
   \   00000014   1CE0               B        ??RemoveRfTask_1
   1526               while ((Tp+1<RF_Tasks-1) && (RF_TaskTab[Tp+1].Node))
   1527               {
   1528                 RF_TaskTab[Tp].Node=RF_TaskTab[Tp+1].Node;
   \                     ??RemoveRfTask_2:
   \   00000016   2E70               STRB     R6,[R5, #+0]
   1529                 RF_TaskTab[Tp].Command.ID=RF_TaskTab[Tp+1].Command.ID;
   \   00000018   6F68               LDR      R7,[R5, #+4]
   \   0000001A   2740               ANDS     R7,R7,R4
   \   0000001C   EE68               LDR      R6,[R5, #+12]
   \   0000001E   1E40               ANDS     R6,R6,R3
   \   00000020   3E43               ORRS     R6,R6,R7
   \   00000022   6E60               STR      R6,[R5, #+4]
   1530                 RF_TaskTab[Tp].Command.Order=RF_TaskTab[Tp+1].Command.Order;
   \   00000024   194F               LDR      R7,??RemoveRfTask_0+0xC  ;; 0xff0fffff
   \   00000026   3740               ANDS     R7,R7,R6
   \   00000028   BC46               MOV      R12,R7
   \   0000002A   EE68               LDR      R6,[R5, #+12]
   \   0000002C   360D               LSRS     R6,R6,#+20
   \   0000002E   3705               LSLS     R7,R6,#+20
   \   00000030   F026               MOVS     R6,#+240
   \   00000032   3604               LSLS     R6,R6,#+16       ;; #+15728640
   \   00000034   3E40               ANDS     R6,R6,R7
   \   00000036   6746               MOV      R7,R12
   \   00000038   3E43               ORRS     R6,R6,R7
   \   0000003A   6E60               STR      R6,[R5, #+4]
   1531                 RF_TaskTab[Tp].Command.Auxi=RF_TaskTab[Tp+1].Command.Auxi;
   \   0000003C   3602               LSLS     R6,R6,#+8
   \   0000003E   360A               LSRS     R6,R6,#+8
   \   00000040   EF68               LDR      R7,[R5, #+12]
   \   00000042   3F0E               LSRS     R7,R7,#+24
   \   00000044   3F06               LSLS     R7,R7,#+24
   \   00000046   3743               ORRS     R7,R7,R6
   \   00000048   6F60               STR      R7,[R5, #+4]
   1532                 Tp++;
   \   0000004A   521C               ADDS     R2,R2,#+1
   \   0000004C   1206               LSLS     R2,R2,#+24
   \   0000004E   120E               LSRS     R2,R2,#+24
   1533               }
   \                     ??RemoveRfTask_1:
   \   00000050   1500               MOVS     R5,R2
   \   00000052   6D1C               ADDS     R5,R5,#+1
   \   00000054   2D04               LSLS     R5,R5,#+16
   \   00000056   2D0C               LSRS     R5,R5,#+16
   \   00000058   452D               CMP      R5,#+69
   \   0000005A   04D2               BCS      ??RemoveRfTask_3
   \   0000005C   D500               LSLS     R5,R2,#+3
   \   0000005E   4519               ADDS     R5,R0,R5
   \   00000060   2E7A               LDRB     R6,[R5, #+8]
   \   00000062   002E               CMP      R6,#+0
   \   00000064   D7D1               BNE      ??RemoveRfTask_2
   1534               
   1535               //usuñ pozosta³oœæ po czyszczeniu
   1536               if ((Tp<RF_Tasks-1) && (RF_TaskTab[Tp].Node))
   \                     ??RemoveRfTask_3:
   \   00000066   452A               CMP      R2,#+69
   \   00000068   06D2               BCS      ??RemoveRfTask_4
   \   0000006A   D200               LSLS     R2,R2,#+3
   \   0000006C   8018               ADDS     R0,R0,R2
   \   0000006E   0278               LDRB     R2,[R0, #+0]
   \   00000070   002A               CMP      R2,#+0
   \   00000072   01D0               BEQ      ??RemoveRfTask_4
   1537               {
   1538                  RF_TaskTab[Tp].Node=0;
   \   00000074   0170               STRB     R1,[R0, #+0]
   1539                  RF_TaskTab[Tp].Command.ID=0;
   1540                  RF_TaskTab[Tp].Command.Order=0;
   1541                  RF_TaskTab[Tp].Command.Auxi=0; 
   \   00000076   4160               STR      R1,[R0, #+4]
   1542               } 
   1543           
   1544          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "RemoveRfTask"
   \                     ??RemoveRfTask_4:
   \   00000078   F8BC               POP      {R3-R7}
   \   0000007A   01BC               POP      {R0}
   \   0000007C   0047               BX       R0               ;; return
   \   0000007E   C046               Nop      
   \                     ??RemoveRfTask_0:
   \   00000080   ........           DC32     RF_TaskTab
   \   00000084   FFFF0F00           DC32     0xfffff
   \   00000088   0000F0FF           DC32     0xfff00000
   \   0000008C   FFFF0FFF           DC32     0xff0fffff
   1545          
   1546          
   1547          
   1548          //-----------------------------------------------------------------------------
   1549          // Nazwa funkcji :    AddRfTask
   1550          // Funkcja ustawia dodanie zadania dla transmisji Rs
   1551          // Ord - typ rozkazu : odczyt wejœæ, zapis
   1552          // Node - nr wêz³a/urz¹dzeia
   1553          // Reg  - nr rejestru w wêŸle 
   1554          //-----------------------------------------------------------------------------
   1555          // Funkcja zwrca 1- je¿eli powodzenie dodawania zadania
   1556          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1557          char AddRfTask(_OrderType Ord, char Node, char Reg)
   1558          { 
   \                     AddRfTask:
   \   00000000   F6B5               PUSH     {R1,R2,R4-R7,LR}
   \   00000002   85B0               SUB      SP,SP,#+20
   1559          
   1560              if (NeuronsList[Node-1].NeuronID==0) return 0;
   \   00000004   6946               MOV      R1,SP
   \   00000006   097D               LDRB     R1,[R1, #+20]
   \   00000008   0C22               MOVS     R2,#+12
   \   0000000A   5143               MULS     R1,R2,R1
   \   0000000C   6D4A               LDR      R2,??AddRfTask_0  ;; NeuronsList
   \   0000000E   5118               ADDS     R1,R2,R1
   \   00000010   0839               SUBS     R1,R1,#+8
   \   00000012   0968               LDR      R1,[R1, #+0]
   \   00000014   0291               STR      R1,[SP, #+8]
   \   00000016   0029               CMP      R1,#+0
   \   00000018   01D1               BNE      ??AddRfTask_1
   \                     ??AddRfTask_2:
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   CDE0               B        ??AddRfTask_3
   \                     ??AddRfTask_1:
   \   0000001E   0021               MOVS     R1,#+0
   \   00000020   0191               STR      R1,[SP, #+4]
   1561             
   1562              //1-dodano zadanie, 0-niedodano
   1563              char OrdExist=0;
   1564              char RfOrd;
   1565              char FreePlace=0;
   1566              char FirstOccureNode=0xFF;        //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   \   00000022   FF22               MOVS     R2,#+255
   1567              char LastOccureNode=0xFF;        //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   \   00000024   0092               STR      R2,[SP, #+0]
   1568             
   1569              //zabezpieczenie przed przekroczeniami
   1570              if (Node>NumberNeurons) return 0;
   \   00000026   6946               MOV      R1,SP
   \   00000028   097D               LDRB     R1,[R1, #+20]
   \   0000002A   2429               CMP      R1,#+36
   \   0000002C   F5D2               BCS      ??AddRfTask_2
   1571              if (Reg>99) return 0;
   \   0000002E   6946               MOV      R1,SP
   \   00000030   097E               LDRB     R1,[R1, #+24]
   \   00000032   6429               CMP      R1,#+100
   \   00000034   F1D2               BCS      ??AddRfTask_2
   1572              
   1573              
   1574              //przepisanie rozkazu na zrozumia³y dla tablicy zadañ RF
   1575              switch (Ord)
   \   00000036   0128               CMP      R0,#+1
   \   00000038   06D0               BEQ      ??AddRfTask_4
   \   0000003A   0228               CMP      R0,#+2
   \   0000003C   06D0               BEQ      ??AddRfTask_5
   \   0000003E   0428               CMP      R0,#+4
   \   00000040   06D0               BEQ      ??AddRfTask_6
   \   00000042   0528               CMP      R0,#+5
   \   00000044   06D0               BEQ      ??AddRfTask_7
   \   00000046   06E0               B        ??AddRfTask_8
   1576              {
   1577                  case SI:      RfOrd=R_RegOrd; break; 
   \                     ??AddRfTask_4:
   \   00000048   0123               MOVS     R3,#+1
   \   0000004A   04E0               B        ??AddRfTask_8
   1578                  case SQ:      RfOrd=W_RegOrd; break; 
   \                     ??AddRfTask_5:
   \   0000004C   0223               MOVS     R3,#+2
   \   0000004E   02E0               B        ??AddRfTask_8
   1579                  case SNewId:  RfOrd=W_NewIdOrd; break; 
   \                     ??AddRfTask_6:
   \   00000050   0523               MOVS     R3,#+5
   \   00000052   00E0               B        ??AddRfTask_8
   1580                  case SBC:     RfOrd=R_BC_Order; break; 
   \                     ??AddRfTask_7:
   \   00000054   0723               MOVS     R3,#+7
   1581              }  
   1582           
   1583          
   1584                
   1585              //Sprawdzenie czy taki rozkaz nie istnieje w tablicy
   1586              char i=0;
   \                     ??AddRfTask_8:
   \   00000056   0024               MOVS     R4,#+0
   \   00000058   0391               STR      R1,[SP, #+12]
   \   0000005A   F021               MOVS     R1,#+240
   \   0000005C   0904               LSLS     R1,R1,#+16       ;; #+15728640
   \   0000005E   5A48               LDR      R0,??AddRfTask_0+0x4  ;; 0xfffff
   1587              while ((i<RF_Tasks-1) && (OrdExist==0))
   1588              {
   1589                 if ((RF_TaskTab[i].Node==Node) && 
   1590                     (RF_TaskTab[i].Command.ID==NeuronsList[Node-1].NeuronID) &&
   1591                     (RF_TaskTab[i].Command.Order==RfOrd) &&
   1592                     (RF_TaskTab[i].Command.Auxi==Reg))
   \                     ??AddRfTask_9:
   \   00000060   E500               LSLS     R5,R4,#+3
   \   00000062   5A4E               LDR      R6,??AddRfTask_0+0x8  ;; RF_TaskTab
   \   00000064   7519               ADDS     R5,R6,R5
   \   00000066   2E78               LDRB     R6,[R5, #+0]
   \   00000068   6F46               MOV      R7,SP
   \   0000006A   3F7D               LDRB     R7,[R7, #+20]
   \   0000006C   BE42               CMP      R6,R7
   \   0000006E   12D1               BNE      ??AddRfTask_10
   \   00000070   6D68               LDR      R5,[R5, #+4]
   \   00000072   0600               MOVS     R6,R0
   \   00000074   2E40               ANDS     R6,R6,R5
   \   00000076   029F               LDR      R7,[SP, #+8]
   \   00000078   BE42               CMP      R6,R7
   \   0000007A   0CD1               BNE      ??AddRfTask_10
   \   0000007C   0E00               MOVS     R6,R1
   \   0000007E   2E40               ANDS     R6,R6,R5
   \   00000080   360D               LSRS     R6,R6,#+20
   \   00000082   1B06               LSLS     R3,R3,#+24
   \   00000084   1B0E               LSRS     R3,R3,#+24
   \   00000086   9E42               CMP      R6,R3
   \   00000088   05D1               BNE      ??AddRfTask_10
   \   0000008A   2D0E               LSRS     R5,R5,#+24
   \   0000008C   039E               LDR      R6,[SP, #+12]
   \   0000008E   B542               CMP      R5,R6
   \   00000090   01D1               BNE      ??AddRfTask_10
   1593                    {
   1594                      OrdExist=1;
   \   00000092   0125               MOVS     R5,#+1
   \   00000094   0195               STR      R5,[SP, #+4]
   1595                    }
   1596                
   1597                 i++;
   \                     ??AddRfTask_10:
   \   00000096   641C               ADDS     R4,R4,#+1
   1598              }
   \   00000098   2506               LSLS     R5,R4,#+24
   \   0000009A   2D0E               LSRS     R5,R5,#+24
   \   0000009C   452D               CMP      R5,#+69
   \   0000009E   02D2               BCS      ??AddRfTask_11
   \   000000A0   019D               LDR      R5,[SP, #+4]
   \   000000A2   2D06               LSLS     R5,R5,#+24
   \   000000A4   DCD0               BEQ      ??AddRfTask_9
   1599              
   1600              i=0;
   1601              char Rf_Zad=0; //iloœæ zadañ.  
   \                     ??AddRfTask_11:
   \   000000A6   0020               MOVS     R0,#+0
   \   000000A8   484C               LDR      R4,??AddRfTask_0+0x8  ;; RF_TaskTab
   \   000000AA   4525               MOVS     R5,#+69
   1602              //Odszukanie ostatniego i ewentualnie pierwszego zadania z tym wêz³em - ma to na cenu u³o¿enie zadañ wêz³ów po kolei co jest konieczne do prawid³owego odpytywania sterowników w trybie slave. Sterowniki takie czekaj¹ na wszystkie swoje odpytania a je¿eli wyst¹pi odpytanie innego wêz³a lub ponowne odpytanie rejestru 0 odpytywanego sterownika to prze³¹czaj¹ sie na tryb master, wykonuj¹ w³asne odpytania a nastêpnie prze³¹czaj¹ siê ponownie w trym slave. Pierwszym zadaniem w kolejce zawsze musi byæ odpytanie rejestru 0
   1603              //Obliczenie iloœci zadañ
   1604              while (i<RF_Tasks-1)
   1605              {
   1606                   if (RF_TaskTab[i].Node==Node)
   \                     ??AddRfTask_12:
   \   000000AC   2678               LDRB     R6,[R4, #+0]
   \   000000AE   6F46               MOV      R7,SP
   \   000000B0   3F7D               LDRB     R7,[R7, #+20]
   \   000000B2   BE42               CMP      R6,R7
   \   000000B4   0ED1               BNE      ??AddRfTask_13
   1607                   {
   1608                     if ((RF_TaskTab[i].Command.Order==R_RegOrd) && (Reg==0) &&  (FirstOccureNode==0xFF))  FirstOccureNode=Rf_Zad; //pierwsze wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   \   000000B6   6668               LDR      R6,[R4, #+4]
   \   000000B8   0E40               ANDS     R6,R6,R1
   \   000000BA   360D               LSRS     R6,R6,#+20
   \   000000BC   012E               CMP      R6,#+1
   \   000000BE   08D1               BNE      ??AddRfTask_14
   \   000000C0   6E46               MOV      R6,SP
   \   000000C2   367E               LDRB     R6,[R6, #+24]
   \   000000C4   002E               CMP      R6,#+0
   \   000000C6   04D1               BNE      ??AddRfTask_14
   \   000000C8   1606               LSLS     R6,R2,#+24
   \   000000CA   360E               LSRS     R6,R6,#+24
   \   000000CC   FF2E               CMP      R6,#+255
   \   000000CE   00D1               BNE      ??AddRfTask_14
   \   000000D0   0200               MOVS     R2,R0
   1609                     //if (FirstOccureNode==0xFF)  FirstOccureNode=Rf_Zad; //pierwsze wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   1610                     LastOccureNode=Rf_Zad;                                               //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   \                     ??AddRfTask_14:
   \   000000D2   0090               STR      R0,[SP, #+0]
   1611                   }
   1612                   
   1613                   if (RF_TaskTab[i].Node!=0) Rf_Zad++;
   \                     ??AddRfTask_13:
   \   000000D4   2678               LDRB     R6,[R4, #+0]
   \   000000D6   002E               CMP      R6,#+0
   \   000000D8   02D0               BEQ      ??AddRfTask_15
   \   000000DA   401C               ADDS     R0,R0,#+1
   \   000000DC   0006               LSLS     R0,R0,#+24
   \   000000DE   000E               LSRS     R0,R0,#+24
   1614                   i++;    
   \                     ??AddRfTask_15:
   \   000000E0   0834               ADDS     R4,R4,#+8
   \   000000E2   6D1E               SUBS     R5,R5,#+1
   1615              }
   \   000000E4   E2D1               BNE      ??AddRfTask_12
   1616              if(Rf_Zad>=RF_Tasks-1) return 0;    //je¿eli nie ma ju¿ miejsca na nowe zadania to wyjdŸ z funkcji
   \   000000E6   4528               CMP      R0,#+69
   \   000000E8   97D2               BCS      ??AddRfTask_2
   1617              
   1618              
   1619              
   1620              //je¿eli rozkaz nie istnieje to dodaj. Je¿eli na liœcie s¹ ju¿ 
   1621              if (OrdExist==0)
   \   000000EA   0199               LDR      R1,[SP, #+4]
   \   000000EC   0906               LSLS     R1,R1,#+24
   \   000000EE   63D1               BNE      ??AddRfTask_16
   1622              {
   1623                if (FirstOccureNode!=0xFF)                                                //znajdŸ miejsce w tablicy zadañ dla nowego zadania
   \   000000F0   1106               LSLS     R1,R2,#+24
   \   000000F2   090E               LSRS     R1,R1,#+24
   \   000000F4   FF29               CMP      R1,#+255
   \   000000F6   01D0               BEQ      ??AddRfTask_17
   1624                {
   1625                   FreePlace=FirstOccureNode;                                              //miejsce w tablicy na nowe zadanie przed dotychczasowymi zadaniami
   \   000000F8   1400               MOVS     R4,R2
   \   000000FA   08E0               B        ??AddRfTask_18
   1626                }
   1627                else if (LastOccureNode!=0xFF)  
   \                     ??AddRfTask_17:
   \   000000FC   0099               LDR      R1,[SP, #+0]
   \   000000FE   0906               LSLS     R1,R1,#+24
   \   00000100   090E               LSRS     R1,R1,#+24
   \   00000102   FF29               CMP      R1,#+255
   \   00000104   02D0               BEQ      ??AddRfTask_19
   1628                {
   1629                   FreePlace=LastOccureNode+1;                                             //miejsce w tablicy na nowe zadanie za dotychczasowymi zadaniami
   \   00000106   009C               LDR      R4,[SP, #+0]
   \   00000108   641C               ADDS     R4,R4,#+1
   \   0000010A   00E0               B        ??AddRfTask_18
   1630                }else{
   1631                   FreePlace=Rf_Zad;                                                          //miejsce w tablicy na nowe zadanie
   \                     ??AddRfTask_19:
   \   0000010C   0400               MOVS     R4,R0
   1632                }
   1633                
   1634                //je¿eli zadanie ma byæ wprowadzone pomiêdzy inne zadania
   1635                if (((FirstOccureNode!=0xFF) && (FirstOccureNode+1>Rf_Zad)) || 
   1636                    ((LastOccureNode!=0xFF)  && (LastOccureNode<Rf_Zad)))
   \                     ??AddRfTask_18:
   \   0000010E   1106               LSLS     R1,R2,#+24
   \   00000110   090E               LSRS     R1,R1,#+24
   \   00000112   FF29               CMP      R1,#+255
   \   00000114   02D0               BEQ      ??AddRfTask_20
   \   00000116   521C               ADDS     R2,R2,#+1
   \   00000118   9042               CMP      R0,R2
   \   0000011A   09DB               BLT      ??AddRfTask_21
   \                     ??AddRfTask_20:
   \   0000011C   0099               LDR      R1,[SP, #+0]
   \   0000011E   0906               LSLS     R1,R1,#+24
   \   00000120   090E               LSRS     R1,R1,#+24
   \   00000122   FF29               CMP      R1,#+255
   \   00000124   30D0               BEQ      ??AddRfTask_22
   \   00000126   0099               LDR      R1,[SP, #+0]
   \   00000128   0906               LSLS     R1,R1,#+24
   \   0000012A   090E               LSRS     R1,R1,#+24
   \   0000012C   8142               CMP      R1,R0
   \   0000012E   2BD2               BCS      ??AddRfTask_22
   1637                {
   1638                  //rozsuniêcie zadañ
   1639                  signed char  Pz=Rf_Zad-1;
   \                     ??AddRfTask_21:
   \   00000130   401E               SUBS     R0,R0,#+1
   \   00000132   0006               LSLS     R0,R0,#+24
   \   00000134   0016               ASRS     R0,R0,#+24
   \   00000136   0200               MOVS     R2,R0
   \   00000138   2106               LSLS     R1,R4,#+24
   \   0000013A   090E               LSRS     R1,R1,#+24
   \   0000013C   8842               CMP      R0,R1
   \   0000013E   1FDA               BGE      ??AddRfTask_23
   \   00000140   22E0               B        ??AddRfTask_22
   1640                  while (Pz>=FreePlace)
   1641                  {
   1642                     RF_TaskTab[Pz+1].Node=RF_TaskTab[Pz].Node;
   \                     ??AddRfTask_24:
   \   00000142   D000               LSLS     R0,R2,#+3
   \   00000144   2149               LDR      R1,??AddRfTask_0+0x8  ;; RF_TaskTab
   \   00000146   0D18               ADDS     R5,R1,R0
   \   00000148   2878               LDRB     R0,[R5, #+0]
   \   0000014A   2872               STRB     R0,[R5, #+8]
   1643                     RF_TaskTab[Pz+1].Command.ID=RF_TaskTab[Pz].Command.ID;
   \   0000014C   1E48               LDR      R0,??AddRfTask_0+0x4  ;; 0xfffff
   \   0000014E   E968               LDR      R1,[R5, #+12]
   \   00000150   090D               LSRS     R1,R1,#+20
   \   00000152   0905               LSLS     R1,R1,#+20
   \   00000154   6E68               LDR      R6,[R5, #+4]
   \   00000156   3040               ANDS     R0,R0,R6
   \   00000158   0843               ORRS     R0,R0,R1
   \   0000015A   E860               STR      R0,[R5, #+12]
   \   0000015C   F021               MOVS     R1,#+240
   \   0000015E   0904               LSLS     R1,R1,#+16       ;; #+15728640
   \   00000160   1B4E               LDR      R6,??AddRfTask_0+0xC  ;; 0xff0fffff
   \   00000162   0640               ANDS     R6,R6,R0
   \   00000164   6868               LDR      R0,[R5, #+4]
   \   00000166   000D               LSRS     R0,R0,#+20
   \   00000168   0005               LSLS     R0,R0,#+20
   \   0000016A   0140               ANDS     R1,R1,R0
   \   0000016C   3143               ORRS     R1,R1,R6
   \   0000016E   E960               STR      R1,[R5, #+12]
   1644                     RF_TaskTab[Pz+1].Command.Order=RF_TaskTab[Pz].Command.Order;
   1645                     RF_TaskTab[Pz+1].Command.Auxi=RF_TaskTab[Pz].Command.Auxi;
   \   00000170   0802               LSLS     R0,R1,#+8
   \   00000172   000A               LSRS     R0,R0,#+8
   \   00000174   6968               LDR      R1,[R5, #+4]
   \   00000176   090E               LSRS     R1,R1,#+24
   \   00000178   0906               LSLS     R1,R1,#+24
   \   0000017A   0143               ORRS     R1,R1,R0
   \   0000017C   E960               STR      R1,[R5, #+12]
   1646                     Pz--;
   \   0000017E   521E               SUBS     R2,R2,#+1
   1647                  }
   \                     ??AddRfTask_23:
   \   00000180   2006               LSLS     R0,R4,#+24
   \   00000182   000E               LSRS     R0,R0,#+24
   \   00000184   8242               CMP      R2,R0
   \   00000186   DCDA               BGE      ??AddRfTask_24
   1648                }
   1649                
   1650                 //while ((FreePlace<RF_Tasks) && (RF_TaskTab[FreePlace].Node!=0)) FreePlace++;   //tak by³o do wersji 1.2 w³acznie
   1651                if (FreePlace<RF_Tasks-1)     //jezeli jest miejsce w tablicy to dodaj
   \                     ??AddRfTask_22:
   \   00000188   2006               LSLS     R0,R4,#+24
   \   0000018A   000E               LSRS     R0,R0,#+24
   \   0000018C   4528               CMP      R0,#+69
   \   0000018E   13D2               BCS      ??AddRfTask_16
   \   00000190   2406               LSLS     R4,R4,#+24
   \   00000192   600D               LSRS     R0,R4,#+21
   \   00000194   0D49               LDR      R1,??AddRfTask_0+0x8  ;; RF_TaskTab
   \   00000196   0818               ADDS     R0,R1,R0
   \   00000198   6946               MOV      R1,SP
   \   0000019A   097D               LDRB     R1,[R1, #+20]
   \   0000019C   0170               STRB     R1,[R0, #+0]
   1652                {
   1653                  RF_TaskTab[FreePlace].Node=Node;
   1654                  RF_TaskTab[FreePlace].Command.ID=NeuronsList[Node-1].NeuronID;
   1655                  RF_TaskTab[FreePlace].Command.Order=RfOrd;
   1656                  RF_TaskTab[FreePlace].Command.Auxi=Reg;
   \   0000019E   0299               LDR      R1,[SP, #+8]
   \   000001A0   0B4A               LDR      R2,??AddRfTask_0+0xC  ;; 0xff0fffff
   \   000001A2   0A40               ANDS     R2,R2,R1
   \   000001A4   1B06               LSLS     R3,R3,#+24
   \   000001A6   1909               LSRS     R1,R3,#+4
   \   000001A8   1143               ORRS     R1,R1,R2
   \   000001AA   0902               LSLS     R1,R1,#+8
   \   000001AC   090A               LSRS     R1,R1,#+8
   \   000001AE   6A46               MOV      R2,SP
   \   000001B0   127E               LDRB     R2,[R2, #+24]
   \   000001B2   1206               LSLS     R2,R2,#+24
   \   000001B4   0A43               ORRS     R2,R2,R1
   \   000001B6   4260               STR      R2,[R0, #+4]
   1657                  
   1658                }
   1659                
   1660                
   1661              }
   1662          
   1663              return 1; 
   \                     ??AddRfTask_16:
   \   000001B8   0120               MOVS     R0,#+1
   \                     ??AddRfTask_3:
   \   000001BA   07B0               ADD      SP,SP,#+28
   \   000001BC   F0BC               POP      {R4-R7}
   \   000001BE   02BC               POP      {R1}
   \   000001C0   0847               BX       R1               ;; return
   \   000001C2   C046               Nop      
   \                     ??AddRfTask_0:
   \   000001C4   ........           DC32     NeuronsList
   \   000001C8   FFFF0F00           DC32     0xfffff
   \   000001CC   ........           DC32     RF_TaskTab
   \   000001D0   FFFF0FFF           DC32     0xff0fffff
   1664          
   1665          
   1666          }//_______________________ Koniec funkcji  AddRfTask _________________
   1667          
   1668          
   1669          
   1670          
   1671          
   1672          
   1673          

   \                                 In section Debug.txt, align 4, keep-with-next
   1674          char AddRfTaskTMP(_OrderType Ord, char Node, char Reg)
   1675          { 
   \                     AddRfTaskTMP:
   \   00000000   01B5               PUSH     {R0,LR}
   1676          
   1677              if (NeuronsList[Node-1].NeuronID==0) return 0;
   \   00000002   0C20               MOVS     R0,#+12
   \   00000004   4843               MULS     R0,R1,R0
   \   00000006   094B               LDR      R3,??AddRfTaskTMP_0  ;; NeuronsList
   \   00000008   1818               ADDS     R0,R3,R0
   \   0000000A   0838               SUBS     R0,R0,#+8
   \   0000000C   0068               LDR      R0,[R0, #+0]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   09D0               BEQ      ??AddRfTaskTMP_1
   1678             
   1679              //1-dodano zadanie, 0-niedodano
   1680              char OrdExist=0;
                          ^
Warning[Pe177]: variable "OrdExist" was declared but never referenced
   1681              char RfOrd;
                          ^
Warning[Pe550]: variable "RfOrd" was set but never used
   1682              char FreePlace=0;
                          ^
Warning[Pe177]: variable "FreePlace" was declared but never referenced
   1683              char FirstOccureNode=0xFF;        //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
                          ^
Warning[Pe177]: variable "FirstOccureNode" was declared but never referenced
   1684              char LastOccureNode=0xFF;        //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
                          ^
Warning[Pe177]: variable "LastOccureNode" was declared but never referenced
   1685             
   1686              //zabezpieczenie przed przekroczeniami
   1687              if (Node>NumberNeurons) return 0;
   \   00000012   2429               CMP      R1,#+36
   \   00000014   01D3               BCC      ??AddRfTaskTMP_2
   \                     ??AddRfTaskTMP_3:
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   05E0               B        ??AddRfTaskTMP_1
   1688              if (Reg>99) return 0;
   \                     ??AddRfTaskTMP_2:
   \   0000001A   642A               CMP      R2,#+100
   \   0000001C   FBD2               BCS      ??AddRfTaskTMP_3
   1689              
   1690              
   1691              //przepisanie rozkazu na zrozumia³y dla tablicy zadañ RF
   1692              switch (Ord)
   1693              {
   1694                  case SI:      RfOrd=R_RegOrd; break; 
   1695                  case SQ:      RfOrd=W_RegOrd; break; 
   1696                  case SNewId:  RfOrd=W_NewIdOrd; break; 
   1697                  case SBC:     RfOrd=R_BC_Order; break; 
   1698              }  
   1699           
   1700          
   1701               
   1702             /*
   1703              //Sprawdzenie czy taki rozkaz nie istnieje w tablicy
   1704              char i=0;
   1705              while ((i<35) && (OrdExist==0))
   1706              {
   1707                 if ((RF_TaskTab[i].Node==Node) && 
   1708                     (RF_TaskTab[i].Command.ID==NeuronsList[Node-1].NeuronID) &&
   1709                     (RF_TaskTab[i].Command.Order==R_RegOrd) &&
   1710                     (RF_TaskTab[i].Command.Auxi==Reg))
   1711                    {
   1712                      OrdExist=1;
   1713                    }
   1714                
   1715                 i++;
   1716              }
   1717              */
   1718              Delay(0xFF);
   \                     ??AddRfTaskTMP_4:
   \   0000001E   FF20               MOVS     R0,#+255
   \   00000020   ........           BL       Delay
   1719            
   1720           /*
   1721              while ((i<35) && (OrdExist==0))
   1722              {
   1723                 if ((RF_TaskTab[i].Node==Node) && 
   1724                     (RF_TaskTab[i].Command.ID==NeuronsList[Node-1].NeuronID) &&
   1725                     (RF_TaskTab[i].Command.Order==R_RegOrd) &&
   1726                     (RF_TaskTab[i].Command.Auxi==Reg))
   1727                    {
   1728                      OrdExist=1;
   1729                    }
   1730                
   1731                 i++;
   1732              }
   1733           */ 
   1734          
   1735              
   1736          /*
   1737              i=0;
   1738              char Rf_Zad=0; //iloœæ zadañ.  
   1739              //Odszukanie ostatniego i ewentualnie pierwszego zadania z tym wêz³em - ma to na cenu u³o¿enie zadañ wêz³ów po kolei co jest konieczne do prawid³owego odpytywania sterowników w trybie slave. Sterowniki takie czekaj¹ na wszystkie swoje odpytania a je¿eli wyst¹pi odpytanie innego wêz³a lub ponowne odpytanie rejestru 0 odpytywanego sterownika to prze³¹czaj¹ sie na tryb master, wykonuj¹ w³asne odpytania a nastêpnie prze³¹czaj¹ siê ponownie w trym slave. Pierwszym zadaniem w kolejce zawsze musi byæ odpytanie rejestru 0
   1740              //Obliczenie iloœci zadañ
   1741              while (i<RF_Tasks-1)
   1742              {
   1743                   if (RF_TaskTab[i].Node==Node)
   1744                   {
   1745                     if ((RfOrd==R_RegOrd) && (Reg==0) &&  (FirstOccureNode==0xFF))  FirstOccureNode=Rf_Zad; //pierwsze wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   1746                     LastOccureNode=Rf_Zad;                                               //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   1747                   }
   1748                   
   1749                   if (RF_TaskTab[i].Node!=0) Rf_Zad++;
   1750                   i++;    
   1751              }
   1752              if(Rf_Zad>=RF_Tasks-1) return 0;    //je¿eli nie ma ju¿ miejsca na nowe zadania to wyjdŸ z funkcji
   1753            */  
   1754             /* 
   1755             
   1756              //je¿eli rozkaz nie istnieje to dodaj. Je¿eli na liœcie s¹ ju¿ 
   1757              if (OrdExist==0)
   1758              {
   1759                if (FirstOccureNode!=0xFF)                                                //znajdŸ miejsce w tablicy zadañ dla nowego zadania
   1760                {
   1761                   FreePlace=FirstOccureNode;                                              //miejsce w tablicy na nowe zadanie przed dotychczasowymi zadaniami
   1762                }
   1763                else if (LastOccureNode!=0xFF)  
   1764                {
   1765                   FreePlace=LastOccureNode+1;                                             //miejsce w tablicy na nowe zadanie za dotychczasowymi zadaniami
   1766                }else{
   1767                   FreePlace=Rf_Zad;                                                          //miejsce w tablicy na nowe zadanie
   1768                }
   1769                
   1770                //je¿eli zadanie ma byæ wprowadzone pomiêdzy inne zadania
   1771                if (((FirstOccureNode!=0xFF) && (FirstOccureNode+1>Rf_Zad)) || 
   1772                    ((LastOccureNode!=0xFF)  && (LastOccureNode<Rf_Zad)))
   1773                {
   1774                  //rozsuniêcie zadañ
   1775                  unsigned char  Pz=Rf_Zad-1;
   1776                  while (Pz>=FreePlace)
   1777                  {
   1778                     RF_TaskTab[Pz+1].Node=RF_TaskTab[Pz].Node;
   1779                     RF_TaskTab[Pz+1].Command.ID=RF_TaskTab[Pz].Command.ID;
   1780                     RF_TaskTab[Pz+1].Command.Order=RF_TaskTab[Pz].Command.Order;
   1781                     RF_TaskTab[Pz+1].Command.Auxi=RF_TaskTab[Pz].Command.Auxi;
   1782                     Pz--;
   1783                  }
   1784                }
   1785                
   1786                 //while ((FreePlace<RF_Tasks) && (RF_TaskTab[FreePlace].Node!=0)) FreePlace++;   //tak by³o do wersji 1.2 w³acznie
   1787                if (FreePlace<RF_Tasks-1)     //jezeli jest miejsce w tablicy to dodaj
   1788                {
   1789                  RF_TaskTab[FreePlace].Node=Node;
   1790                  RF_TaskTab[FreePlace].Command.ID=NeuronsList[Node-1].NeuronID;
   1791                  RF_TaskTab[FreePlace].Command.Order=RfOrd;
   1792                  RF_TaskTab[FreePlace].Command.Auxi=Reg;
   1793                  
   1794                }
   1795                
   1796                
   1797              }
   1798              */
   1799             
   1800            
   1801          
   1802            /*
   1803            RF_TaskTab[5].Node=Node;
   1804            RF_TaskTab[5].Command.ID=100008;
   1805            RF_TaskTab[5].Command.Order=R_RegOrd;
   1806            RF_TaskTab[5].Command.Auxi=Reg;
   1807            */
   1808              return 1; 
   \   00000024   0120               MOVS     R0,#+1
   \                     ??AddRfTaskTMP_1:
   \   00000026   08BC               POP      {R3}
   \   00000028   02BC               POP      {R1}
   \   0000002A   0847               BX       R1               ;; return
   \                     ??AddRfTaskTMP_0:
   \   0000002C   ........           DC32     NeuronsList
   1809          
   1810          
   1811          }//_______________________ Koniec funkcji  AddRfTask _________________
   1812          
   1813          
   1814          
   1815          
   1816          
   1817          //-----------------------------------------------------------------------------
   1818          // Nazwa funkcji :    SetTask
   1819          // Funkcja ustawia zadania transmisji RS oraz RF
   1820          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1821          void SetTask(_ProgramTab *ProgTab)
   1822          { 
   \                     SetTask:
   \   00000000   F0B5               PUSH     {R4-R7,LR}
   \   00000002   8BB0               SUB      SP,SP,#+44
   \   00000004   0500               MOVS     R5,R0
   1823                _Procedure Proc; 
   1824                _OrderType SetOrd=NonOrd;
   1825                char       RegOrd=0;
   1826            
   1827                
   1828                //wyczyszczenie tablicy zadañ
   1829                for (char i=0; i<RF_Tasks; i++) 
   \   00000006   8148               LDR      R0,??SetTask_0   ;; RF_TaskTab
   \   00000008   0E21               MOVS     R1,#+14
   \   0000000A   0024               MOVS     R4,#+0
   \   0000000C   0023               MOVS     R3,#+0
   1830                {
   1831                  RF_TaskTab[i].Node=0;
   \                     ??SetTask_1:
   \   0000000E   0470               STRB     R4,[R0, #+0]
   1832                  RF_TaskTab[i].Command.ID=0;
   1833                  RF_TaskTab[i].Command.Order=0;
   1834                  RF_TaskTab[i].Command.Auxi=0;
   \   00000010   4460               STR      R4,[R0, #+4]
   \   00000012   0472               STRB     R4,[R0, #+8]
   \   00000014   C460               STR      R4,[R0, #+12]
   \   00000016   0474               STRB     R4,[R0, #+16]
   \   00000018   4461               STR      R4,[R0, #+20]
   \   0000001A   0476               STRB     R4,[R0, #+24]
   \   0000001C   C461               STR      R4,[R0, #+28]
   \   0000001E   0200               MOVS     R2,R0
   \   00000020   2032               ADDS     R2,R2,#+32
   \   00000022   1370               STRB     R3,[R2, #+0]
   \   00000024   5460               STR      R4,[R2, #+4]
   1835                }
   \   00000026   2830               ADDS     R0,R0,#+40
   \   00000028   491E               SUBS     R1,R1,#+1
   \   0000002A   F0D1               BNE      ??SetTask_1
   1836                
   1837                for (char node=0; node<NumberNeurons; node++)
   \   0000002C   0026               MOVS     R6,#+0
   \   0000002E   784F               LDR      R7,??SetTask_0+0x4  ;; NeuronsList
   1838                {
   1839                   if((NeuronsList[node].NeuronType!=NoneNodeType) && (NeuronsList[node].NeuronType>=BeginRF) && (NeuronsList[node].NeuronType<=EndRF))  AddRfTask(SI, node+1, 0);
   \                     ??SetTask_2:
   \   00000030   3878               LDRB     R0,[R7, #+0]
   \   00000032   0028               CMP      R0,#+0
   \   00000034   0BD0               BEQ      ??SetTask_3
   \   00000036   0228               CMP      R0,#+2
   \   00000038   09D3               BCC      ??SetTask_3
   \   0000003A   0628               CMP      R0,#+6
   \   0000003C   07D2               BCS      ??SetTask_3
   \   0000003E   0022               MOVS     R2,#+0
   \   00000040   3100               MOVS     R1,R6
   \   00000042   491C               ADDS     R1,R1,#+1
   \   00000044   0906               LSLS     R1,R1,#+24
   \   00000046   090E               LSRS     R1,R1,#+24
   \   00000048   0120               MOVS     R0,#+1
   \   0000004A   ........           BL       AddRfTask
   1840                }
   \                     ??SetTask_3:
   \   0000004E   761C               ADDS     R6,R6,#+1
   \   00000050   0C37               ADDS     R7,R7,#+12
   \   00000052   3006               LSLS     R0,R6,#+24
   \   00000054   000E               LSRS     R0,R0,#+24
   \   00000056   2328               CMP      R0,#+35
   \   00000058   EAD3               BCC      ??SetTask_2
   1841                
   1842                
   1843                for (int LineNr=0; LineNr<RealPrcLines; LineNr++)
   \   0000005A   0094               STR      R4,[SP, #+0]
   \   0000005C   1835               ADDS     R5,R5,#+24
   \   0000005E   0295               STR      R5,[SP, #+8]
   \   00000060   33E0               B        ??SetTask_4
   1844                {
   1845                  for (int PrcInLine=0; PrcInLine<MaxPrcInLine; PrcInLine++)
   1846                  {
   1847          
   1848                        Proc=ProgTab->Line[LineNr].Proc[PrcInLine];
   1849                        
   1850                        RegOrd=Proc.Tag.RegNr;
   1851                        SetOrd=NonOrd;
   1852                        //wybór typu rozkazu
   1853                        switch (Proc.Type)
   1854                        {
   1855                           case ProcWOUT:       SetOrd=SQ;  RegOrd=0; break;
   1856                           case ProcWOUTS:      SetOrd=SQ;  RegOrd=0; break;
   1857                           case ProcWOUTR:      SetOrd=SQ;  RegOrd=0; break;
   1858                           case ProcWOUTC:      SetOrd=SQ;  RegOrd=0; break;
   1859                           case ProcStI:        SetOrd=SI;  RegOrd=0; break;
   1860                           case ProcStNI:       SetOrd=SI;  RegOrd=0; break;
   1861                           case ProcSetReg:     SetOrd=SQ;  RegOrd=Proc.Tag.RegNr; break;
   1862                           case ProcGetReg:     SetOrd=SI;  RegOrd=Proc.Tag.RegNr; break;
   \                     ??SetTask_5:
   \   00000062   0127               MOVS     R7,#+1
   1863                        }     
   1864                         
   1865                        
   1866                        //je¿eli rozkaz
   1867                        if (SetOrd!=NonOrd)
   1868                        {
   1869                              
   1870                                //Je¿eli nody z transmisj¹ RS
   1871                                if (((NeuronsList[Proc.Nr-1].NeuronType>=BeginRS) && (NeuronsList[Proc.Nr-1].NeuronType<=EndRS)) || (NeuronsList[Proc.Nr-1].NeuronType==0))
   \                     ??SetTask_6:
   \   00000064   6846               MOV      R0,SP
   \   00000066   04A9               ADD      R1,SP,#+16
   \   00000068   4978               LDRB     R1,[R1, #+1]
   \   0000006A   0173               STRB     R1,[R0, #+12]
   \   0000006C   6946               MOV      R1,SP
   \   0000006E   0C20               MOVS     R0,#+12
   \   00000070   0856               LDRSB    R0,[R1, R0]
   \   00000072   0C21               MOVS     R1,#+12
   \   00000074   4843               MULS     R0,R1,R0
   \   00000076   6749               LDR      R1,??SetTask_0+0x8  ;; NeuronsList - 12
   \   00000078   0818               ADDS     R0,R1,R0
   \   0000007A   0190               STR      R0,[SP, #+4]
   \   0000007C   0078               LDRB     R0,[R0, #+0]
   \   0000007E   0028               CMP      R0,#+0
   \   00000080   01D0               BEQ      ??SetTask_7
   \   00000082   0328               CMP      R0,#+3
   \   00000084   01D3               BCC      ??SetTask_8
   \                     ??SetTask_7:
   \   00000086   0028               CMP      R0,#+0
   \   00000088   08D1               BNE      ??SetTask_9
   1872                                {
   1873                                  AddRsTask(SetOrd, Proc.Nr, RegOrd);                //Dodaj rozkaz do tablicy zadañ Modbus
   \                     ??SetTask_8:
   \   0000008A   2A00               MOVS     R2,R5
   \   0000008C   6946               MOV      R1,SP
   \   0000008E   0C20               MOVS     R0,#+12
   \   00000090   0956               LDRSB    R1,[R1, R0]
   \   00000092   0906               LSLS     R1,R1,#+24
   \   00000094   090E               LSRS     R1,R1,#+24
   \   00000096   3800               MOVS     R0,R7
   \   00000098   ........           BL       AddRsTask
   1874                                }
   1875                                //Je¿eli nody z transmisj¹ RF
   1876                                if ((NeuronsList[Proc.Nr-1].NeuronType>=BeginRF) && (NeuronsList[Proc.Nr-1].NeuronType<=EndRF))
   \                     ??SetTask_9:
   \   0000009C   0198               LDR      R0,[SP, #+4]
   \   0000009E   0078               LDRB     R0,[R0, #+0]
   \   000000A0   0228               CMP      R0,#+2
   \   000000A2   0AD3               BCC      ??SetTask_10
   \   000000A4   0628               CMP      R0,#+6
   \   000000A6   08D2               BCS      ??SetTask_10
   1877                                {
   1878                                   AddRfTask(SetOrd, Proc.Nr, RegOrd);                //Dodaj rozkaz do tablicy zadañ RF
   \   000000A8   2A00               MOVS     R2,R5
   \   000000AA   6946               MOV      R1,SP
   \   000000AC   0C20               MOVS     R0,#+12
   \   000000AE   0956               LDRSB    R1,[R1, R0]
   \   000000B0   0906               LSLS     R1,R1,#+24
   \   000000B2   090E               LSRS     R1,R1,#+24
   \   000000B4   3800               MOVS     R0,R7
   \   000000B6   ........           BL       AddRfTask
   1879                                }
   1880                        }  
   \                     ??SetTask_10:
   \   000000BA   0298               LDR      R0,[SP, #+8]
   \   000000BC   1830               ADDS     R0,R0,#+24
   \   000000BE   0290               STR      R0,[SP, #+8]
   \   000000C0   761E               SUBS     R6,R6,#+1
   \   000000C2   08D1               BNE      ??SetTask_11
   \   000000C4   0098               LDR      R0,[SP, #+0]
   \   000000C6   401C               ADDS     R0,R0,#+1
   \   000000C8   0090               STR      R0,[SP, #+0]
   \                     ??SetTask_4:
   \   000000CA   0098               LDR      R0,[SP, #+0]
   \   000000CC   5249               LDR      R1,??SetTask_0+0xC  ;; Trap + 12
   \   000000CE   0978               LDRB     R1,[R1, #+0]
   \   000000D0   8842               CMP      R0,R1
   \   000000D2   1BDA               BGE      ??SetTask_12
   \   000000D4   0A26               MOVS     R6,#+10
   \                     ??SetTask_11:
   \   000000D6   04A8               ADD      R0,SP,#+16
   \   000000D8   0299               LDR      R1,[SP, #+8]
   \   000000DA   1822               MOVS     R2,#+24
   \   000000DC   ........           BL       __aeabi_memcpy4
   \   000000E0   04A8               ADD      R0,SP,#+16
   \   000000E2   057A               LDRB     R5,[R0, #+8]
   \   000000E4   6846               MOV      R0,SP
   \   000000E6   007C               LDRB     R0,[R0, #+16]
   \   000000E8   1438               SUBS     R0,R0,#+20
   \   000000EA   0128               CMP      R0,#+1
   \   000000EC   0AD9               BLS      ??SetTask_13
   \   000000EE   0C38               SUBS     R0,R0,#+12
   \   000000F0   0328               CMP      R0,#+3
   \   000000F2   04D9               BLS      ??SetTask_14
   \   000000F4   1838               SUBS     R0,R0,#+24
   \   000000F6   B4D0               BEQ      ??SetTask_5
   \   000000F8   401E               SUBS     R0,R0,#+1
   \   000000FA   05D0               BEQ      ??SetTask_15
   \   000000FC   DDE7               B        ??SetTask_10
   \                     ??SetTask_14:
   \   000000FE   0227               MOVS     R7,#+2
   \                     ??SetTask_16:
   \   00000100   0025               MOVS     R5,#+0
   \   00000102   AFE7               B        ??SetTask_6
   \                     ??SetTask_13:
   \   00000104   0127               MOVS     R7,#+1
   \   00000106   FBE7               B.N      ??SetTask_16
   \                     ??SetTask_15:
   \   00000108   0227               MOVS     R7,#+2
   \   0000010A   ABE7               B        ??SetTask_6
   1881                        
   1882                  }
   1883                  
   1884                }
   1885                
   1886                
   1887                
   1888                
   1889                
   1890                //Bezpoœrednie zmienne ekranowe
   1891                volatile _Screen* ScreenLokal;
   1892                 _ScreenPaternDesign *ScreenPaternDesign;
   1893          
   1894                
   1895                 for (char Sheet=0; Sheet<ScreenNr; Sheet++)
   \                     ??SetTask_12:
   \   0000010C   4348               LDR      R0,??SetTask_0+0x10  ;; gProg + 48024
   \   0000010E   0190               STR      R0,[SP, #+4]
   1896                 {
   1897                     if (ScreenUse&1<<Sheet)
   \                     ??SetTask_17:
   \   00000110   3020               MOVS     R0,#+48
   \   00000112   4349               LDR      R1,??SetTask_0+0x14  ;; Trap
   \   00000114   085E               LDRSH    R0,[R1, R0]
   \   00000116   0121               MOVS     R1,#+1
   \   00000118   A140               LSLS     R1,R1,R4
   \   0000011A   0140               ANDS     R1,R1,R0
   \   0000011C   6AD0               BEQ      ??SetTask_18
   1898                     {
   1899                        if (Sheet==0) 
   \   0000011E   2006               LSLS     R0,R4,#+24
   \   00000120   01D1               BNE      ??SetTask_19
   1900                        {
   1901                          ScreenPaternDesign=ScreenSetTab_0;
   \   00000122   4048               LDR      R0,??SetTask_0+0x18  ;; ScreenSetTab_0
   \   00000124   00E0               B.N      ??SetTask_20
   1902                        }else{
   1903                          ScreenPaternDesign=ScreenSetTab_1; 
   \                     ??SetTask_19:
   \   00000126   4048               LDR      R0,??SetTask_0+0x1C  ;; ScreenSetTab_1
   \                     ??SetTask_20:
   \   00000128   0290               STR      R0,[SP, #+8]
   1904                        } 
   1905                       
   1906                       ScreenLokal=&gProg.Screen[Sheet];
   \   0000012A   0198               LDR      R0,[SP, #+4]
   \   0000012C   0090               STR      R0,[SP, #+0]
   1907                       for (char i=0; i<ScrenAnalogNr; i++)
   \   0000012E   029D               LDR      R5,[SP, #+8]
   \   00000130   3635               ADDS     R5,R5,#+54
   \   00000132   0600               MOVS     R6,R0
   \   00000134   7336               ADDS     R6,R6,#+115
   \   00000136   0427               MOVS     R7,#+4
   1908                          {
   1909          
   1910                                if ( (ScreenPaternDesign[ScreenLokal->PaternDesign].Value[i].Width>0) && ((ScreenLokal->Analog[i].Nr>0) || ((ScreenLokal->Analog[i].Nr==0)&&(ScreenLokal->Analog[i].Reg>0))))
   \                     ??SetTask_21:
   \   00000138   0098               LDR      R0,[SP, #+0]
   \   0000013A   0078               LDRB     R0,[R0, #+0]
   \   0000013C   5821               MOVS     R1,#+88
   \   0000013E   4843               MULS     R0,R1,R0
   \   00000140   285C               LDRB     R0,[R5, R0]
   \   00000142   0028               CMP      R0,#+0
   \   00000144   0DD0               BEQ      ??SetTask_22
   \   00000146   3078               LDRB     R0,[R6, #+0]
   \   00000148   0028               CMP      R0,#+0
   \   0000014A   05D1               BNE      ??SetTask_23
   \   0000014C   3078               LDRB     R0,[R6, #+0]
   \   0000014E   0028               CMP      R0,#+0
   \   00000150   07D1               BNE      ??SetTask_22
   \   00000152   7078               LDRB     R0,[R6, #+1]
   \   00000154   0028               CMP      R0,#+0
   \   00000156   04D0               BEQ      ??SetTask_22
   1911                                 {
   1912                                    AddRfTask(SI, ScreenLokal->Analog[i].Nr, ScreenLokal->Analog[i].Reg);
   \                     ??SetTask_23:
   \   00000158   7278               LDRB     R2,[R6, #+1]
   \   0000015A   3178               LDRB     R1,[R6, #+0]
   \   0000015C   0120               MOVS     R0,#+1
   \   0000015E   ........           BL       AddRfTask
   1913                                 }
   1914                          }
   \                     ??SetTask_22:
   \   00000162   F61D               ADDS     R6,R6,#+7
   \   00000164   2D1D               ADDS     R5,R5,#+4
   \   00000166   7F1E               SUBS     R7,R7,#+1
   \   00000168   E6D1               BNE      ??SetTask_21
   1915                       for (char i=0; i<ScrenGraphNr; i++)
   \   0000016A   029D               LDR      R5,[SP, #+8]
   \   0000016C   2635               ADDS     R5,R5,#+38
   \   0000016E   009E               LDR      R6,[SP, #+0]
   \   00000170   5736               ADDS     R6,R6,#+87
   \   00000172   0427               MOVS     R7,#+4
   1916                          {
   1917                                if ((ScreenPaternDesign[ScreenLokal->PaternDesign].Graph[i].Width>0) && ((ScreenLokal->Graph[i].Type==GraphOnOff) || (ScreenLokal->Graph[i].PlusOnOff==1) || (ScreenLokal->Graph[i].Type==GraphWartosc)))
   \                     ??SetTask_24:
   \   00000174   0098               LDR      R0,[SP, #+0]
   \   00000176   0078               LDRB     R0,[R0, #+0]
   \   00000178   5821               MOVS     R1,#+88
   \   0000017A   4843               MULS     R0,R1,R0
   \   0000017C   285C               LDRB     R0,[R5, R0]
   \   0000017E   0028               CMP      R0,#+0
   \   00000180   0ED0               BEQ      ??SetTask_25
   \   00000182   301F               SUBS     R0,R6,#+4
   \   00000184   0178               LDRB     R1,[R0, #+0]
   \   00000186   0B29               CMP      R1,#+11
   \   00000188   05D0               BEQ      ??SetTask_26
   \   0000018A   B178               LDRB     R1,[R6, #+2]
   \   0000018C   C907               LSLS     R1,R1,#+31
   \   0000018E   02D4               BMI      ??SetTask_26
   \   00000190   0078               LDRB     R0,[R0, #+0]
   \   00000192   0A28               CMP      R0,#+10
   \   00000194   04D1               BNE      ??SetTask_25
   1918                                 {
   1919                                    AddRfTask(SI, ScreenLokal->Graph[i].Nr, ScreenLokal->Graph[i].Reg);
   \                     ??SetTask_26:
   \   00000196   7278               LDRB     R2,[R6, #+1]
   \   00000198   3178               LDRB     R1,[R6, #+0]
   \   0000019A   0120               MOVS     R0,#+1
   \   0000019C   ........           BL       AddRfTask
   1920                                 }
   1921                          }
   \                     ??SetTask_25:
   \   000001A0   F61D               ADDS     R6,R6,#+7
   \   000001A2   2D1D               ADDS     R5,R5,#+4
   \   000001A4   7F1E               SUBS     R7,R7,#+1
   \   000001A6   E5D1               BNE      ??SetTask_24
   1922                       
   1923                       //je¿eli na stronie jest termostat
   1924                       if (((Sheet==0) && (gProg.Screen[Sheet].PaternDesign==MainScreenTermo)) || 
   1925                              ((Sheet) && (gProg.Screen[Sheet].PaternDesign==SubScreenTermo)))
   \   000001A8   2006               LSLS     R0,R4,#+24
   \   000001AA   03D1               BNE      ??SetTask_27
   \   000001AC   0198               LDR      R0,[SP, #+4]
   \   000001AE   0078               LDRB     R0,[R0, #+0]
   \   000001B0   0828               CMP      R0,#+8
   \   000001B2   05D0               BEQ      ??SetTask_28
   \                     ??SetTask_27:
   \   000001B4   2006               LSLS     R0,R4,#+24
   \   000001B6   1DD0               BEQ      ??SetTask_18
   \   000001B8   0198               LDR      R0,[SP, #+4]
   \   000001BA   0078               LDRB     R0,[R0, #+0]
   \   000001BC   0528               CMP      R0,#+5
   \   000001BE   19D1               BNE      ??SetTask_18
   1926                        {
   1927                        
   1928                       if (ScreenLokal->Thermo.ActorNode>0)
   \                     ??SetTask_28:
   \   000001C0   009D               LDR      R5,[SP, #+0]
   \   000001C2   8C35               ADDS     R5,R5,#+140
   \   000001C4   0020               MOVS     R0,#+0
   \   000001C6   2856               LDRSB    R0,[R5, R0]
   \   000001C8   0128               CMP      R0,#+1
   \   000001CA   07DB               BLT      ??SetTask_29
   1929                                 {
   1930                                    AddRfTask(SQ, ScreenLokal->Thermo.ActorNode, ScreenLokal->Thermo.ActorPort);
   \   000001CC   6A78               LDRB     R2,[R5, #+1]
   \   000001CE   0020               MOVS     R0,#+0
   \   000001D0   2956               LDRSB    R1,[R5, R0]
   \   000001D2   0906               LSLS     R1,R1,#+24
   \   000001D4   090E               LSRS     R1,R1,#+24
   \   000001D6   0220               MOVS     R0,#+2
   \   000001D8   ........           BL       AddRfTask
   1931                                 }   
   1932                       if (ScreenLokal->Thermo.SensorNode>0)
   \                     ??SetTask_29:
   \   000001DC   0320               MOVS     R0,#+3
   \   000001DE   2856               LDRSB    R0,[R5, R0]
   \   000001E0   0128               CMP      R0,#+1
   \   000001E2   07DB               BLT      ??SetTask_18
   1933                                 {
   1934                                    AddRfTask(SI, ScreenLokal->Thermo.SensorNode, ScreenLokal->Thermo.SensorReg);
   \   000001E4   2A79               LDRB     R2,[R5, #+4]
   \   000001E6   0320               MOVS     R0,#+3
   \   000001E8   2956               LDRSB    R1,[R5, R0]
   \   000001EA   0906               LSLS     R1,R1,#+24
   \   000001EC   090E               LSRS     R1,R1,#+24
   \   000001EE   0120               MOVS     R0,#+1
   \   000001F0   ........           BL       AddRfTask
   1935                                 }  
   1936                       
   1937                        }
   1938                     
   1939                     }
   1940          
   1941                 }
   \                     ??SetTask_18:
   \   000001F4   641C               ADDS     R4,R4,#+1
   \   000001F6   0198               LDR      R0,[SP, #+4]
   \   000001F8   A030               ADDS     R0,R0,#+160
   \   000001FA   0190               STR      R0,[SP, #+4]
   \   000001FC   2006               LSLS     R0,R4,#+24
   \   000001FE   000E               LSRS     R0,R0,#+24
   \   00000200   0828               CMP      R0,#+8
   \   00000202   85D3               BCC      ??SetTask_17
   1942                //-------------------------------
   1943                
   1944                
   1945                //Dodanie standardowego odpytywania wez³ów nie u¿ywanych w programie
   1946                 /*
   1947                 char ExstF=0;
   1948                
   1949                for (char i=0; i<NumberNeurons; i++)
   1950                {
   1951                  ExstF=0;
   1952                  if (NeuronsList[i].NeuronID!=0)
   1953                  {
   1954                     for (char j=0; j<RF_Tasks; j++)
   1955                     {
   1956                       if (RF_TaskTab[j].Command.ID==0)  //je¿eli brak zadañ to wyjdŸ
   1957                       { 
   1958                         j=RF_Tasks;
   1959                       }else if (RF_TaskTab[j].Command.ID==NeuronsList[i].NeuronID)    //je¿eli zadanie dla tego noda istnieje
   1960                       {
   1961                         ExstF=1;   //ustaw flagê
   1962                       }
   1963                     }
   1964                     
   1965                     //je¿eli nie znaleziono zadania dla wez³a przypisz pytanie standardowe
   1966                     if (ExstF==0)
   1967                     {
   1968                         AddRfTask(SI, i+1, 0);                //Dodaj pytanie standardowe do tablicy zadañ RF
   1969                     }
   1970                  }
   1971                  
   1972                }
   1973                 */
   1974               
   1975                
   1976                
   1977                          
   1978          }//_______________________ Koniec funkcji  SetTask_________________
   \   00000204   0BB0               ADD      SP,SP,#+44
   \   00000206   F0BC               POP      {R4-R7}
   \   00000208   01BC               POP      {R0}
   \   0000020A   0047               BX       R0               ;; return
   \                     ??SetTask_0:
   \   0000020C   ........           DC32     RF_TaskTab
   \   00000210   ........           DC32     NeuronsList
   \   00000214   ........           DC32     NeuronsList - 12
   \   00000218   ........           DC32     Trap + 12
   \   0000021C   ........           DC32     gProg + 48024
   \   00000220   ........           DC32     Trap
   \   00000224   ........           DC32     ScreenSetTab_0
   \   00000228   ........           DC32     ScreenSetTab_1
   1979          
   1980          
   1981          
   1982          
   1983          
   1984          
   1985          
   1986          
   1987          //-----------------------------------------------------------------------------
   1988          // Nazwa funkcji :    ProgramChangeSave
   1989          // Funkcja zapisu zmian w programie u¿ytkowym
   1990          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1991          void ProgramChangeExecute(_ProgramTab *ProgTab)
   1992          {
   \                     ProgramChangeExecute:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1993             //obliczenie iloœci u¿ywanych scen
   1994             NumberScene=SceneNrCount(ProgTab);
   \   00000004   094D               LDR      R5,??ProgramChangeExecute_0  ;; Trap
   \   00000006   ........           BL       SceneNrCount
   \   0000000A   2872               STRB     R0,[R5, #+8]
   1995             
   1996             //obliczenie iloœci u¿ywanych linii
   1997             CountLines(ProgTab);
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       CountLines
   1998             
   1999             //obliczenie iloœci u¿ywanych stron ekranowych
   2000             ScreenUse=CheckScreenUse(ProgTab);
   \   00000012   2000               MOVS     R0,R4
   \   00000014   ........           BL       CheckScreenUse
   \   00000018   2886               STRH     R0,[R5, #+48]
   2001             
   2002          
   2003             
   2004             //odœwierzenie/przepisanie listy neuronów
   2005             RefreshNeuronsList(ProgTab);
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       RefreshNeuronsList
   2006             
   2007             
   2008             //ustawienie zadañ Rs i RF
   2009             SetTask(ProgTab);
   \   00000020   2000               MOVS     R0,R4
   \   00000022   ........           BL       SetTask
   2010            
   2011          }//_______________________ Koniec funkcji zapisu zmian programu_________________
   \   00000026   ........           BL       ??Subroutine0_0
   \   0000002A   C046               Nop      
   \                     ??ProgramChangeExecute_0:
   \   0000002C   ........           DC32     Trap
   2012          
   2013          
   2014          
   2015          
   2016          
   2017          
   2018          //*-----------------------------------------------------------------------------
   2019          //* Nazwa funkcji :    GetBinVarPack
   2020          //* Funkcja zwraca paczkê w tablicy wartoœci zmienncyh dwustanowych z zakresu B000 - B700
   2021          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   2022          void GetBinVarPack(WORD adr, WORD Length,unsigned char *Tab )
   2023          {
   2024            /*
   2025                  WORD  RamByte=(adr/8);
   2026                  WORD  RamBit= (adr) % 8;
   2027                  char  CurentByte;
   2028                  char  CurentBit;  
   2029            
   2030              
   2031                for (WORD i=0; i<Length; i++)
   2032                      {
   2033                         Tab[CurentByte] &= ~(1<<CurentBit);
   2034                         Tab[CurentByte] |=  (((ram.BinVarRAM[RamByte]>>RamBit) & 0x1)<< CurentBit);
   2035                                   
   2036                         if (CurentBit<7) {CurentBit++;} else {CurentBit=0; CurentByte++;}
   2037                         if (RamBit<7) {RamBit++;} else {RamBit=0; RamByte++;}
   2038                      }  
   2039            
   2040           */
   2041          }//_______________________ Koniec funkcji GetBinVar ____________________________
   \                     GetBinVarPack:
   \   00000000   7047               BX       LR               ;; return
   2042          
   2043          
   2044          
   2045          
   2046          
   2047          
   2048          
   2049          
   2050          
   2051          //*-----------------------------------------------------------------------------
   2052          //* Nazwa funkcji :    GetBinVar
   2053          //* Funkcja przepisuje paczkê wartoœci zmiennych dwustanowej komunikacyjnej DA00 - DDFF do Tab
   2054          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   2055          void GetBinVarPackComm(WORD adr, WORD Length, unsigned char* Tab )
   2056          {
   \                     GetBinVarPackComm:
   \   00000000   F7B5               PUSH     {R0-R2,R4-R7,LR}
   2057                  WORD  RamByte=adr;
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0025               MOVS     R5,#+0
   2058                  WORD  RamBit= 0;
   2059                  char  CurentByte = 0;
   \   00000006   0026               MOVS     R6,#+0
   2060                  char  CurentBit = 0;  
   \   00000008   2F00               MOVS     R7,R5
   2061          
   2062                  for (char i=0; i<16; i++)  {Tab[i]=0;}
   \   0000000A   1021               MOVS     R1,#+16
   \   0000000C   1000               MOVS     R0,R2
   \   0000000E   ........           BL       __aeabi_memclr
   2063               
   2064              
   2065                for (WORD i=0; i<Length; i++)
   \   00000012   2800               MOVS     R0,R5
   \   00000014   6946               MOV      R1,SP
   \   00000016   8988               LDRH     R1,[R1, #+4]
   \   00000018   0029               CMP      R1,#+0
   \   0000001A   33D0               BEQ      ??GetBinVarPackComm_0
   2066                      {
   2067                         if ((ram.VarCom_Word[RamByte]>>RamBit) & 0x1) { Tab[CurentByte] |= 0x1<<CurentBit;} else {Tab[CurentByte] &= ~(0x1<<CurentBit);}
   \                     ??GetBinVarPackComm_1:
   \   0000001C   6100               LSLS     R1,R4,#+1
   \   0000001E   1B4A               LDR      R2,??GetBinVarPackComm_2  ;; ram
   \   00000020   515A               LDRH     R1,[R2, R1]
   \   00000022   2941               ASRS     R1,R1,R5
   \   00000024   C907               LSLS     R1,R1,#+31
   \   00000026   08D5               BPL      ??GetBinVarPackComm_3
   \   00000028   3100               MOVS     R1,R6
   \   0000002A   029A               LDR      R2,[SP, #+8]
   \   0000002C   5118               ADDS     R1,R2,R1
   \   0000002E   0A78               LDRB     R2,[R1, #+0]
   \   00000030   0123               MOVS     R3,#+1
   \   00000032   BB40               LSLS     R3,R3,R7
   \   00000034   1343               ORRS     R3,R3,R2
   \   00000036   0B70               STRB     R3,[R1, #+0]
   \   00000038   07E0               B        ??GetBinVarPackComm_4
   \                     ??GetBinVarPackComm_3:
   \   0000003A   3100               MOVS     R1,R6
   \   0000003C   029A               LDR      R2,[SP, #+8]
   \   0000003E   5118               ADDS     R1,R2,R1
   \   00000040   0A78               LDRB     R2,[R1, #+0]
   \   00000042   0123               MOVS     R3,#+1
   \   00000044   BB40               LSLS     R3,R3,R7
   \   00000046   9A43               BICS     R2,R2,R3
   \   00000048   0A70               STRB     R2,[R1, #+0]
   2068                        
   2069                         
   2070                         if (CurentBit<7) {CurentBit++;} else {CurentBit=0; CurentByte++; Tab[CurentByte]=0;}
   \                     ??GetBinVarPackComm_4:
   \   0000004A   072F               CMP      R7,#+7
   \   0000004C   03D2               BCS      ??GetBinVarPackComm_5
   \   0000004E   7F1C               ADDS     R7,R7,#+1
   \   00000050   3F06               LSLS     R7,R7,#+24
   \   00000052   3F0E               LSRS     R7,R7,#+24
   \   00000054   05E0               B        ??GetBinVarPackComm_6
   \                     ??GetBinVarPackComm_5:
   \   00000056   0027               MOVS     R7,#+0
   \   00000058   761C               ADDS     R6,R6,#+1
   \   0000005A   3606               LSLS     R6,R6,#+24
   \   0000005C   360E               LSRS     R6,R6,#+24
   \   0000005E   0299               LDR      R1,[SP, #+8]
   \   00000060   8F55               STRB     R7,[R1, R6]
   2071                         if (RamBit<7) {RamBit++;} else {RamBit=0; RamByte++;}
   \                     ??GetBinVarPackComm_6:
   \   00000062   072D               CMP      R5,#+7
   \   00000064   03D2               BCS      ??GetBinVarPackComm_7
   \   00000066   6D1C               ADDS     R5,R5,#+1
   \   00000068   2D04               LSLS     R5,R5,#+16
   \   0000006A   2D0C               LSRS     R5,R5,#+16
   \   0000006C   03E0               B        ??GetBinVarPackComm_8
   \                     ??GetBinVarPackComm_7:
   \   0000006E   0025               MOVS     R5,#+0
   \   00000070   641C               ADDS     R4,R4,#+1
   \   00000072   2404               LSLS     R4,R4,#+16
   \   00000074   240C               LSRS     R4,R4,#+16
   2072                      }  
   \                     ??GetBinVarPackComm_8:
   \   00000076   401C               ADDS     R0,R0,#+1
   \   00000078   6A46               MOV      R2,SP
   \   0000007A   9288               LDRH     R2,[R2, #+4]
   \   0000007C   0104               LSLS     R1,R0,#+16
   \   0000007E   090C               LSRS     R1,R1,#+16
   \   00000080   9142               CMP      R1,R2
   \   00000082   CBD3               BCC      ??GetBinVarPackComm_1
   2073          }//_______________________ Koniec funkcji GetBinVarComm ________________________
   \                     ??GetBinVarPackComm_0:
   \   00000084   FEBC               POP      {R1-R7}
   \   00000086   01BC               POP      {R0}
   \   00000088   0047               BX       R0               ;; return
   \   0000008A   C046               Nop      
   \                     ??GetBinVarPackComm_2:
   \   0000008C   ........           DC32     ram
   2074          
   2075          
   2076          //*-----------------------------------------------------------------------------
   2077          //* Nazwa funkcji :    GetRegPackComm
   2078          //* Funkcja przepisuje StageQ
   2079          //*   Adr - nr StageQ
   2080          //*   Reg - nr rejestru
   2081          //*   LengthBit - ile bitów do kopiowania je¿eli wiêcej ni¿ 16 to kopiuje z nastêpnego rejestru
   2082          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   2083          void GetRegPackComm(short int  Adr, char Reg, char LengthBit, unsigned char* Tab )
   2084          {
   \                     GetRegPackComm:
   \   00000000   FDB5               PUSH     {R0,R2-R7,LR}
   2085                  WORD  RamWord=Reg;
   \   00000002   0C00               MOVS     R4,R1
   \   00000004   0025               MOVS     R5,#+0
   2086                  WORD  RamBitInWord= 0;
   2087                  char  CurentByte = 0;
   \   00000006   0026               MOVS     R6,#+0
   2088                  char  CurentBit = 0;  
   \   00000008   2F00               MOVS     R7,R5
   2089           
   2090                  Adr+=1;
   \   0000000A   6946               MOV      R1,SP
   \   0000000C   401C               ADDS     R0,R0,#+1
   \   0000000E   0880               STRH     R0,[R1, #+0]
   2091                  
   2092                  for (char i=0; i<16; i++)  {Tab[i]=0;}
   \   00000010   1021               MOVS     R1,#+16
   \   00000012   1800               MOVS     R0,R3
   \   00000014   ........           BL       __aeabi_memclr
   2093               
   2094              
   2095                for (WORD i=0; i<LengthBit; i++)
   \   00000018   2900               MOVS     R1,R5
   \   0000001A   6846               MOV      R0,SP
   \   0000001C   0079               LDRB     R0,[R0, #+4]
   \   0000001E   0028               CMP      R0,#+0
   \   00000020   3DD0               BEQ      ??GetRegPackComm_0
   2096                      {
   2097                         if ((MainStage.StageQ[Adr].Value[RamWord]>>RamBitInWord) & 0x1) { Tab[CurentByte] |= 0x1<<CurentBit;} else {Tab[CurentByte] &= ~(0x1<<CurentBit);}
   \                     ??GetRegPackComm_1:
   \   00000022   2048               LDR      R0,??GetRegPackComm_2  ;; 0x3a2
   \   00000024   8446               MOV      R12,R0
   \   00000026   6200               LSLS     R2,R4,#+1
   \   00000028   6B46               MOV      R3,SP
   \   0000002A   0020               MOVS     R0,#+0
   \   0000002C   185E               LDRSH    R0,[R3, R0]
   \   0000002E   1623               MOVS     R3,#+22
   \   00000030   5843               MULS     R0,R3,R0
   \   00000032   1D4B               LDR      R3,??GetRegPackComm_2+0x4  ;; MainStage
   \   00000034   1818               ADDS     R0,R3,R0
   \   00000036   8218               ADDS     R2,R0,R2
   \   00000038   6046               MOV      R0,R12
   \   0000003A   105E               LDRSH    R0,[R2, R0]
   \   0000003C   2841               ASRS     R0,R0,R5
   \   0000003E   C007               LSLS     R0,R0,#+31
   \   00000040   08D5               BPL      ??GetRegPackComm_3
   \   00000042   3000               MOVS     R0,R6
   \   00000044   029A               LDR      R2,[SP, #+8]
   \   00000046   1018               ADDS     R0,R2,R0
   \   00000048   0278               LDRB     R2,[R0, #+0]
   \   0000004A   0123               MOVS     R3,#+1
   \   0000004C   BB40               LSLS     R3,R3,R7
   \   0000004E   1343               ORRS     R3,R3,R2
   \   00000050   0370               STRB     R3,[R0, #+0]
   \   00000052   07E0               B        ??GetRegPackComm_4
   \                     ??GetRegPackComm_3:
   \   00000054   3000               MOVS     R0,R6
   \   00000056   029A               LDR      R2,[SP, #+8]
   \   00000058   1018               ADDS     R0,R2,R0
   \   0000005A   0278               LDRB     R2,[R0, #+0]
   \   0000005C   0123               MOVS     R3,#+1
   \   0000005E   BB40               LSLS     R3,R3,R7
   \   00000060   9A43               BICS     R2,R2,R3
   \   00000062   0270               STRB     R2,[R0, #+0]
   2098                        
   2099                         
   2100                         if (CurentBit<7) {CurentBit++;} else {CurentBit=0; CurentByte++; Tab[CurentByte]=0;}
   \                     ??GetRegPackComm_4:
   \   00000064   072F               CMP      R7,#+7
   \   00000066   03D2               BCS      ??GetRegPackComm_5
   \   00000068   7F1C               ADDS     R7,R7,#+1
   \   0000006A   3F06               LSLS     R7,R7,#+24
   \   0000006C   3F0E               LSRS     R7,R7,#+24
   \   0000006E   05E0               B        ??GetRegPackComm_6
   \                     ??GetRegPackComm_5:
   \   00000070   0027               MOVS     R7,#+0
   \   00000072   761C               ADDS     R6,R6,#+1
   \   00000074   3606               LSLS     R6,R6,#+24
   \   00000076   360E               LSRS     R6,R6,#+24
   \   00000078   0298               LDR      R0,[SP, #+8]
   \   0000007A   8755               STRB     R7,[R0, R6]
   2101                         if (RamBitInWord<15) {RamBitInWord++;} else {RamBitInWord=0; RamWord++;}
   \                     ??GetRegPackComm_6:
   \   0000007C   0F2D               CMP      R5,#+15
   \   0000007E   03D2               BCS      ??GetRegPackComm_7
   \   00000080   6D1C               ADDS     R5,R5,#+1
   \   00000082   2D04               LSLS     R5,R5,#+16
   \   00000084   2D0C               LSRS     R5,R5,#+16
   \   00000086   03E0               B        ??GetRegPackComm_8
   \                     ??GetRegPackComm_7:
   \   00000088   0025               MOVS     R5,#+0
   \   0000008A   641C               ADDS     R4,R4,#+1
   \   0000008C   2404               LSLS     R4,R4,#+16
   \   0000008E   240C               LSRS     R4,R4,#+16
   2102                      }  
   \                     ??GetRegPackComm_8:
   \   00000090   491C               ADDS     R1,R1,#+1
   \   00000092   6A46               MOV      R2,SP
   \   00000094   1279               LDRB     R2,[R2, #+4]
   \   00000096   0804               LSLS     R0,R1,#+16
   \   00000098   000C               LSRS     R0,R0,#+16
   \   0000009A   9042               CMP      R0,R2
   \   0000009C   C1D3               BCC      ??GetRegPackComm_1
   2103          }//_______________________ Koniec funkcji GetRegPackComm ________________________
   \                     ??GetRegPackComm_0:
   \   0000009E   FEBC               POP      {R1-R7}
   \   000000A0   01BC               POP      {R0}
   \   000000A2   0047               BX       R0               ;; return
   \                     ??GetRegPackComm_2:
   \   000000A4   A2030000           DC32     0x3a2
   \   000000A8   ........           DC32     MainStage

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   ........           DC32     ZD_MODBUS_0

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   AA8A0000           DC32     0x8aaa

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     VariablesAnal

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   EA060000           DC32     0x6ea

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable20:
   \   00000000   A2030000           DC32     0x3a2

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable21:
   \   00000000   ........           DC32     TransQuality

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable22:
   \   00000000   EB060000           DC32     0x6eb

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable23:
   \   00000000   ........           DC32     ChangeStageFlag

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable24:
   \   00000000   ........           DC32     Trap

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable25:
   \   00000000   EA060000           DC32     0x6ea

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable26:
   \   00000000   ........           DC32     Trap
   2104          
   2105          
   2106          
   2107          
   2108          
   2109          
   2110          //****************************************************************************//
   2111          //****************************************************************************//
   2112          //*************************** P R O C E D U R Y ******************************//
   2113          //****************************************************************************//
   2114          //****************************************************************************//
   2115          
   2116          
   2117          
   2118          
   2119          
   2120          
   2121          
   2122          
   2123          
   2124          
   2125          

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     AddRfTask                          48
     AddRfTaskTMP                        8
     AddRfTask_RemoveSearchNodeTask     24
     AddRfTask_SearchNodeTask           24
     AddRsTask                          32
     CheckScreenUse                     32
     CountLines                         16
     GetBinVarPack                       0
     GetBinVarPackComm                  32
     GetRegPackComm                     32
     PortStageRead                       0
     PortStageSet                        8
     ProcClock_Action                    8
     ProcConect_Action                   0
     ProcConstAnal_Action                0
     ProcDay_Action                      8
     ProcDec_Action                      8
     ProcDiv_Action                     24
     ProcDownRight_Action                0
     ProcDown_Action                     0
     ProcEven_Action                     8
     ProcGetReg_Action                   8
     ProcInc_Action                     16
     ProcLim_Action                      8
     ProcMinus_Action                    0
     ProcMul_Action                      8
     ProcNOT_Action                      0
     ProcPlus_Action                     0
     ProcSPK_Action                     16
     ProcSetAnal_Action                 16
     ProcSetScn_Action                  16
     ProcStB_Action                      8
     ProcStI_Action                      8
     ProcStNI_Action                    16
     ProcStQ_Action                      8
     ProcStS_Action                      8
     ProcSumL_Action                     0
     ProcTLI1_Action                     8
     ProcTimerSet_Action                 8
     ProcToggleRS_Action                 8
     ProcToggleT_Action                  8
     ProcUpToRightDown_Action            0
     ProcUpToRight_Action                0
     ProcWOUTC_Action                   16
     ProcWOUTR_Action                   16
     ProcWOUTS_Action                   16
     ProcWOUT_Action                    24
     Program                            40
     ProgramChangeExecute               16
     RefreshNeuronsList                 24
     RemoveRfNodeAllTaska               24
     RemoveRfTask                       24
     SceneNrCount                        8
     SetModbusTask                       0
     SetTask                            64


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     SceneBefOff                        1
     TransQuality                     216
     ProgConvers_DW_F                   4
     ButtonExe                        576
     gProg                          50800
     NeuronsList                      420
     VariablesAnal                     40
     MainStage                       1808
     SetModbusTask                    104
     PortStageRead                     10
     PortStageSet                      24
     ProcStI_Action                    82
     ProcStNI_Action                   92
     ?Subroutine0                      10
     ProcGetReg_Action                 64
     ProcSetAnal_Action                42
     ?Subroutine1                      10
     ProcConstAnal_Action               6
     ProcStB_Action                    24
     ?Subroutine2                      20
     ProcStQ_Action                    44
     ProcStS_Action                    30
     ProcWOUT_Action                  220
     ProcWOUTS_Action                 104
     ProcWOUTR_Action                 128
     ProcWOUTC_Action                 168
     ProcNOT_Action                    14
     ProcToggleRS_Action               26
     ProcToggleT_Action                38
     ProcTLI1_Action                   20
     ProcLim_Action                    22
     ProcEven_Action                   22
     ProcPlus_Action                   12
     ProcMinus_Action                  12
     ProcMul_Action                    40
     ProcDiv_Action                   108
     ProcConect_Action                  6
     ProcDown_Action                    6
     ProcDownRight_Action               6
     ProcUpToRight_Action               6
     ProcUpToRightDown_Action           6
     ProcSetScn_Action                 72
     ProcInc_Action                    44
     ProcDec_Action                    56
     ProcSPK_Action                   132
     ProcSumL_Action                   10
     ProcTimerSet_Action               40
     ProcClock_Action                 136
     ProcDay_Action                    32
     Program                         1060
     Trap                              68
     pProg                              4
     SceneNrCount                      44
     CheckScreenUse                   132
     CountLines                        48
     RefreshNeuronsList                72
     AddRsTask                        204
     AddRfTask_SearchNodeTask         124
     AddRfTask_RemoveSearchNodeTask   116
     RemoveRfNodeAllTaska             164
     RemoveRfTask                     144
     AddRfTask                        468
     AddRfTaskTMP                      48
     SetTask                          556
     ProgramChangeExecute              48
     GetBinVarPack                      2
     GetBinVarPackComm                144
     GetRegPackComm                   172
     ??DataTable0                       4
     ??DataTable3                       4
     ??DataTable7                       4
     ??DataTable9                       4
     ??DataTable20                      4
     ??DataTable21                      4
     ??DataTable22                      4
     ??DataTable23                      4
     ??DataTable24                      4
     ??DataTable25                      4
     ??DataTable26                      4

 
 53 865 bytes in section .bss
     72 bytes in section .data
  5 638 bytes in section Debug.txt
 
  5 638 bytes of CODE memory
 53 937 bytes of DATA memory

Errors: none
Warnings: 17
