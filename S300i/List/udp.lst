###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           04/Jun/2013  20:18:36 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\core\udp.c                                    #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\core\udp.c" -D AT91SAM7S256 -D AT91SAM7SEK    #
#                    -D iH -D __ALARM -D __WIFI_MODULE -D S300i -lC           #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\S300i\List\" --diag_suppress Pa082 -o         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\S300i\Obj\" --debug --endian little --cpu     #
#                    ARM7TDMI -e --fpu None --dlib_config "C:\Program Files   #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    5.0\ARM\INC\DLib_Config_Normal.h" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v1.3 - 04.06.2013\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v1.3 - 04.06.2013\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v1.3 - 04.06.2013\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\Framework\Configuration\" -I "C:\Program      #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\INC\" --section .text=Debug.txt --interwork      #
#                    --cpu_mode thumb -Oh                                     #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300i\List\udp.lst                            #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300i\Obj\udp.o                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\core\udp.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support  -  ROUSSET  -
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2006, Atmel Corporation
      5          
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaiimer below.
     13           *
     14           * - Redistributions in binary form must reproduce the above copyright notice,
     15           * this list of conditions and the disclaimer below in the documentation and/or
     16           * other materials provided with the distribution.
     17           *
     18           * Atmel's name may not be used to endorse or promote products derived from
     19           * this software without specific prior written permission.
     20           *
     21           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     22           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     23           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     24           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     25           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     26           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     27           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     28           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     29           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     30           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31           * ----------------------------------------------------------------------------
     32           */
     33          
     34          
     35          extern char znak;
     36          
     37          /*
     38          $Id: udp.c,v 1.1.2.1 2006/12/05 08:33:25 danielru Exp $
     39          */
     40          
     41          //------------------------------------------------------------------------------
     42          //      Includes
     43          //------------------------------------------------------------------------------
     44          
     45          #include "common.h"
     46          #include "device.h"
     47          #include "board.h"
     48          #include "trace.h"
     49          #include "usb.h"
     50          
     51          #ifdef UDP
     52          
     53          #define UDP_STATE_SHOULD_RECONNECT      0x10000000
     54          #define UDP_EPTYPE_INDEX                8
     55          #define UDP_EPDIR_INDEX                 10
     56          
     57          #define ISR_MASK                      0x00003FFF
     58          
     59          //------------------------------------------------------------------------------
     60          //      Structures
     61          //------------------------------------------------------------------------------
     62          
     63          // \brief  Endpoint states
     64          typedef enum {
     65          
     66              endpointStateDisabled,
     67              endpointStateIdle,
     68              endpointStateWrite,
     69              endpointStateRead,
     70              endpointStateHalted
     71          
     72          } EndpointState_t;
     73          
     74          //------------------------------------------------------------------------------
     75          //      Macros
     76          //------------------------------------------------------------------------------
     77          
     78          // \brief  Clear flags in the UDP_CSR register and waits for synchronization
     79          // \param  pUsb      Pointer to a S_usb instance
     80          // \param  bEndpoint Index of endpoint
     81          // \param  dFlags    Flags to clear
     82          #define UDP_CLEAREPFLAGS(pUsb, bEndpoint, dFlags) { \
     83              while (!ISCLEARED(UDP_GetDriverInterface(pUsb)->UDP_CSR[bEndpoint], dFlags)) \
     84                  CLEAR(UDP_GetDriverInterface(pUsb)->UDP_CSR[bEndpoint], dFlags); \
     85          }
     86          
     87          // \brief  Set flags in the UDP_CSR register and waits for synchronization
     88          // \param  pUsb      Pointer to a S_usb instance
     89          // \param  bEndpoint Index of endpoint
     90          // \param  dFlags    Flags to clear
     91          #define UDP_SETEPFLAGS(pUsb, bEndpoint, dFlags) { \
     92              while (ISCLEARED(UDP_GetDriverInterface(pUsb)->UDP_CSR[bEndpoint], dFlags)) \
     93                  SET(UDP_GetDriverInterface(pUsb)->UDP_CSR[bEndpoint], dFlags); \
     94          }
     95          
     96          //------------------------------------------------------------------------------
     97          //      Internal Functions
     98          //------------------------------------------------------------------------------
     99          //------------------------------------------------------------------------------
    100          // \brief  Returns a pointer to the UDP controller interface used by an USB
    101          //         driver
    102          //
    103          //         The pointer is cast to the correct type (AT91PS_UDP).
    104          // \param  pUsb Pointer to a S_usb instance
    105          // \return Pointer to the USB controller interface
    106          // \see    S_usb
    107          //------------------------------------------------------------------------------
    108          extern __inline AT91PS_UDP UDP_GetDriverInterface(const S_usb *pUsb)
    109          {
    110              return (AT91PS_UDP) pUsb->pDriver->pInterface;
    111          }
    112          
    113          //------------------------------------------------------------------------------
    114          // \brief  Enables the peripheral clock of the USB controller associated with
    115          //         the specified USB driver
    116          // \param  pUsb Pointer to a S_usb instance
    117          // \see    S_usb
    118          //------------------------------------------------------------------------------
    119          extern __inline void UDP_EnableMCK(const S_usb *pUsb)
    120          {
    121              AT91C_BASE_PMC->PMC_PCER = 1 << USB_GetDriverID(pUsb);
    122          }
    123          
    124          //------------------------------------------------------------------------------
    125          // \brief  Disables the peripheral clock of the USB controller associated with
    126          //         the specified USB driver
    127          // \param  pUsb Pointer to a S_usb instance
    128          // \see    S_usb
    129          //------------------------------------------------------------------------------
    130          extern __inline void UDP_DisableMCK(const S_usb *pUsb)
    131          {
    132              AT91C_BASE_PMC->PMC_PCDR = 1 << USB_GetDriverID(pUsb);
    133          }
    134          
    135          //------------------------------------------------------------------------------
    136          // \brief  Enables the 48MHz clock of the USB controller associated with
    137          //         the specified USB driver
    138          // \param  pUsb Pointer to a S_usb instance
    139          // \see    S_usb
    140          //------------------------------------------------------------------------------
    141          extern __inline void UDP_EnableUDPCK(const S_usb *pUsb)
    142          {
    143              SET(AT91C_BASE_PMC->PMC_SCER, USB_GetDriverPMC(pUsb));
    144          }
    145          
    146          //------------------------------------------------------------------------------
    147          // \brief  Disables the 48MHz clock of the USB controller associated with
    148          //         the specified USB driver
    149          // \param  pUsb Pointer to a S_usb instance
    150          // \see    S_usb
    151          //------------------------------------------------------------------------------
    152          extern __inline void UDP_DisableUDPCK(const S_usb *pUsb)
    153          {
    154              SET(AT91C_BASE_PMC->PMC_SCDR, USB_GetDriverPMC(pUsb));
    155          }
    156          
    157          //------------------------------------------------------------------------------
    158          // \brief  Enables the transceiver of the USB controller associated with
    159          //         the specified USB driver
    160          // \param  pUsb Pointer to a S_usb instance
    161          // \see    S_usb
    162          //------------------------------------------------------------------------------
    163          extern __inline void UDP_EnableTransceiver(const S_usb *pUsb)
    164          {
    165              CLEAR(UDP_GetDriverInterface(pUsb)->UDP_TXVC, AT91C_UDP_TXVDIS);
    166          }
    167          
    168          //------------------------------------------------------------------------------
    169          // \brief  Disables the transceiver of the USB controller associated with
    170          //         the specified USB driver
    171          // \param  pUsb Pointer to a S_usb instance
    172          // \see    S_usb
    173          //------------------------------------------------------------------------------
    174          extern __inline void UDP_DisableTransceiver(const S_usb *pUsb)
    175          {
    176              SET(UDP_GetDriverInterface(pUsb)->UDP_TXVC, AT91C_UDP_TXVDIS);
    177          }
    178          
    179          //------------------------------------------------------------------------------
    180          // \brief  Invokes the callback associated with a finished transfer on an
    181          //         endpoint
    182          // \param  pEndpoint Pointer to a S_usb_endpoint instance
    183          // \param  bStatus   Status code returned by the transfer operation
    184          // \see    Status codes
    185          // \see    S_usb_endpoint
    186          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    187          extern __inline void UDP_EndOfTransfer(S_usb_endpoint *pEndpoint,
    188                                                 char bStatus)
    189          {
   \                     UDP_EndOfTransfer:
   \   00000000   10B5               PUSH     {R4,LR}
    190              if ((pEndpoint->dState == endpointStateWrite)
    191                  || (pEndpoint->dState == endpointStateRead)) 
   \   00000002   426A               LDR      R2,[R0, #+36]
   \   00000004   022A               CMP      R2,#+2
   \   00000006   02D0               BEQ      ??UDP_EndOfTransfer_0
   \   00000008   426A               LDR      R2,[R0, #+36]
   \   0000000A   032A               CMP      R2,#+3
   \   0000000C   0BD1               BNE      ??UDP_EndOfTransfer_1
    192              {
    193          
    194                                                                                         // TRACE_DEBUG_L("EoT ");
    195          
    196                  // Endpoint returns in Idle state
    197                  pEndpoint->dState = endpointStateIdle;
   \                     ??UDP_EndOfTransfer_0:
   \   0000000E   0122               MOVS     R2,#+1
   \   00000010   4262               STR      R2,[R0, #+36]
    198                                                                                          
    199                  // Invoke callback is present
    200                  if (pEndpoint->fCallback != 0) 
   \   00000012   0469               LDR      R4,[R0, #+16]
   \   00000014   2200               MOVS     R2,R4
   \   00000016   06D0               BEQ      ??UDP_EndOfTransfer_1
    201                  {                                                                      
    202          
    203                      pEndpoint->fCallback((unsigned int) pEndpoint->pArgument,
    204                                           (unsigned int) bStatus,
    205                                           pEndpoint->dBytesTransferred,
    206                                           pEndpoint->dBytesRemaining
    207                                           + pEndpoint->dBytesBuffered);
   \   00000018   4268               LDR      R2,[R0, #+4]
   \   0000001A   8368               LDR      R3,[R0, #+8]
   \   0000001C   D318               ADDS     R3,R2,R3
   \   0000001E   C268               LDR      R2,[R0, #+12]
   \   00000020   4069               LDR      R0,[R0, #+20]
   \   00000022   ........           BL       __iar_via_R4
    208                                                                                          
    209                  }
    210                  
    211              }
    212                                                                                          //TRACE_DEBUG_L("KON_EoT ");
    213          }
   \                     ??UDP_EndOfTransfer_1:
   \   00000026   10BC               POP      {R4}
   \   00000028   01BC               POP      {R0}
   \   0000002A   0047               BX       R0               ;; return
    214          
    215          //------------------------------------------------------------------------------
    216          // \brief  Clears the correct RX flag in an endpoint status register
    217          // \param  pUsb      Pointer to a S_usb instance
    218          // \param  bEndpoint Index of endpoint
    219          // \see    S_usb_endpoint
    220          // \see    S_usb
    221          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    222          static void UDP_ClearRXFlag(const S_usb * pUsb,
    223                                      unsigned char bEndpoint)
    224          {
   \                     UDP_ClearRXFlag:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    225              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   00000002   8268               LDR      R2,[R0, #+8]
   \   00000004   9142               CMP      R1,R2
   \   00000006   01D3               BCC      ??UDP_ClearRXFlag_0
   \   00000008   0022               MOVS     R2,#+0
   \   0000000A   03E0               B        ??UDP_ClearRXFlag_1
   \                     ??UDP_ClearRXFlag_0:
   \   0000000C   2822               MOVS     R2,#+40
   \   0000000E   4A43               MULS     R2,R1,R2
   \   00000010   4368               LDR      R3,[R0, #+4]
   \   00000012   9A18               ADDS     R2,R3,R2
   \                     ??UDP_ClearRXFlag_1:
   \   00000014   8900               LSLS     R1,R1,#+2
   \   00000016   1C32               ADDS     R2,R2,#+28
   \   00000018   04E0               B        ??UDP_ClearRXFlag_2
    226          
    227              // Clear flag
    228              UDP_CLEAREPFLAGS(pUsb, bEndpoint, pEndpoint->dFlag);
   \                     ??UDP_ClearRXFlag_3:
   \   0000001A   2468               LDR      R4,[R4, #+0]
   \   0000001C   6418               ADDS     R4,R4,R1
   \   0000001E   256B               LDR      R5,[R4, #+48]
   \   00000020   9D43               BICS     R5,R5,R3
   \   00000022   2563               STR      R5,[R4, #+48]
   \                     ??UDP_ClearRXFlag_2:
   \   00000024   1368               LDR      R3,[R2, #+0]
   \   00000026   0468               LDR      R4,[R0, #+0]
   \   00000028   2568               LDR      R5,[R4, #+0]
   \   0000002A   6D18               ADDS     R5,R5,R1
   \   0000002C   2D6B               LDR      R5,[R5, #+48]
   \   0000002E   1D40               ANDS     R5,R5,R3
   \   00000030   F3D1               BNE      ??UDP_ClearRXFlag_3
    229          
    230              // Swap banks
    231              if (pEndpoint->dFlag == AT91C_UDP_RX_DATA_BK0) {
   \   00000032   022B               CMP      R3,#+2
   \   00000034   04D1               BNE      ??UDP_ClearRXFlag_4
    232          
    233                  if (pEndpoint->dNumFIFO > 1) {
   \   00000036   1079               LDRB     R0,[R2, #+4]
   \   00000038   0228               CMP      R0,#+2
   \   0000003A   03D3               BCC      ??UDP_ClearRXFlag_5
    234          
    235                      // Swap bank if in dual-fifo mode
    236                      pEndpoint->dFlag = AT91C_UDP_RX_DATA_BK1;
   \   0000003C   4020               MOVS     R0,#+64
   \   0000003E   00E0               B.N      ??UDP_ClearRXFlag_6
    237                  }
    238              }
    239              else {
    240          
    241                  pEndpoint->dFlag = AT91C_UDP_RX_DATA_BK0;
   \                     ??UDP_ClearRXFlag_4:
   \   00000040   0220               MOVS     R0,#+2
   \                     ??UDP_ClearRXFlag_6:
   \   00000042   1060               STR      R0,[R2, #+0]
    242              }
    243          }
   \                     ??UDP_ClearRXFlag_5:
   \   00000044   38BC               POP      {R3-R5}
   \   00000046   01BC               POP      {R0}
   \   00000048   0047               BX       R0               ;; return
    244          
    245          //------------------------------------------------------------------------------
    246          // \brief  Transfers a data payload from the current tranfer buffer to the
    247          //         endpoint FIFO.
    248          // \param  pUsb      Pointer to a S_usb instance
    249          // \param  bEndpoint Index of endpoint
    250          // \return Number of bytes transferred
    251          // \see    S_usb
    252          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    253          static unsigned int UDP_WritePayload(const S_usb * pUsb,
    254                                               unsigned char bEndpoint)
    255          {
   \                     UDP_WritePayload:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    256              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000002   0268               LDR      R2,[R0, #+0]
   \   00000004   1268               LDR      R2,[R2, #+0]
    257              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   00000006   8368               LDR      R3,[R0, #+8]
   \   00000008   9942               CMP      R1,R3
   \   0000000A   01D3               BCC      ??UDP_WritePayload_0
   \   0000000C   0023               MOVS     R3,#+0
   \   0000000E   03E0               B        ??UDP_WritePayload_1
   \                     ??UDP_WritePayload_0:
   \   00000010   2823               MOVS     R3,#+40
   \   00000012   4B43               MULS     R3,R1,R3
   \   00000014   4068               LDR      R0,[R0, #+4]
   \   00000016   C318               ADDS     R3,R0,R3
    258              unsigned int   dBytes;
    259              unsigned int   dCtr;
    260          
    261              // Get the number of bytes to send
    262              dBytes = min(pEndpoint->wMaxPacketSize, pEndpoint->dBytesRemaining);
   \                     ??UDP_WritePayload_1:
   \   00000018   5C68               LDR      R4,[R3, #+4]
   \   0000001A   9869               LDR      R0,[R3, #+24]
   \   0000001C   A042               CMP      R0,R4
   \   0000001E   00D9               BLS      ??UDP_WritePayload_2
   \   00000020   2000               MOVS     R0,R4
    263          
    264              // Transfer one packet in the FIFO buffer
    265              for (dCtr = 0; dCtr < dBytes; dCtr++) {
   \                     ??UDP_WritePayload_2:
   \   00000022   0028               CMP      R0,#+0
   \   00000024   09D0               BEQ      ??UDP_WritePayload_3
   \   00000026   0400               MOVS     R4,R0
   \   00000028   8900               LSLS     R1,R1,#+2
   \   0000002A   5118               ADDS     R1,R2,R1
    266          
    267                  pInterface->UDP_FDR[bEndpoint] = *(pEndpoint->pData);
   \                     ??UDP_WritePayload_4:
   \   0000002C   1A68               LDR      R2,[R3, #+0]
   \   0000002E   1578               LDRB     R5,[R2, #+0]
   \   00000030   0D65               STR      R5,[R1, #+80]
    268                  pEndpoint->pData++;
   \   00000032   521C               ADDS     R2,R2,#+1
   \   00000034   1A60               STR      R2,[R3, #+0]
    269              }
   \   00000036   641E               SUBS     R4,R4,#+1
   \   00000038   F8D1               BNE      ??UDP_WritePayload_4
    270          
    271              pEndpoint->dBytesBuffered += dBytes;
   \                     ??UDP_WritePayload_3:
   \   0000003A   9968               LDR      R1,[R3, #+8]
   \   0000003C   0918               ADDS     R1,R1,R0
   \   0000003E   9960               STR      R1,[R3, #+8]
    272              pEndpoint->dBytesRemaining -= dBytes;
   \   00000040   5968               LDR      R1,[R3, #+4]
   \   00000042   091A               SUBS     R1,R1,R0
   \   00000044   5960               STR      R1,[R3, #+4]
    273          
    274              return dBytes;
   \   00000046   38BC               POP      {R3-R5}
   \   00000048   02BC               POP      {R1}
   \   0000004A   0847               BX       R1               ;; return
    275          }
    276          
    277          //------------------------------------------------------------------------------
    278          // \brief  Transfers a data payload from an endpoint FIFO to the current
    279          //         transfer buffer.
    280          // \param  pUsb        Pointer to a S_usb instance
    281          // \param  bEndpoint   Index of endpoint
    282          // \param  wPacketSize Size of received data packet
    283          // \return Number of bytes transferred
    284          // \see    S_usb
    285          //------------------------------------------------------------------------------
    286          static unsigned int UDP_GetPayload(const S_usb * pUsb,
    287                                             unsigned char bEndpoint,
    288                                             unsigned short wPacketSize)
    289          {
    290              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
    291              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
    292              unsigned int   dBytes;
    293              unsigned int   dCtr;
    294          
    295                                                                                          //TRACE_DEBUG_L("IN_GetPayLoad ");
    296              // Get number of bytes to retrieve
    297              dBytes = min(pEndpoint->dBytesRemaining, wPacketSize);
    298          
    299              // Retrieve packet
    300              for (dCtr = 0; dCtr < dBytes; dCtr++) {
    301          
    302                  *pEndpoint->pData = (char) pInterface->UDP_FDR[bEndpoint];
    303                  pEndpoint->pData++;
    304                  
    305              }
    306          
    307              pEndpoint->dBytesRemaining -= dBytes;
    308              pEndpoint->dBytesTransferred += dBytes;
    309              pEndpoint->dBytesBuffered += wPacketSize - dBytes;
    310                                                                                          //TRACE_DEBUG_L("KON_GetPayLoad ");
    311              return dBytes;
    312                                                                                
    313          }
    314          
    315          //------------------------------------------------------------------------------
    316          // \brief  Transfers a received SETUP packet from endpoint 0 FIFO to the
    317          //         S_usb_request structure of an USB driver
    318          // \param  pUsb Pointer to a S_usb instance
    319          // \see    S_usb
    320          //------------------------------------------------------------------------------
    321          static void UDP_GetSetup(S_usb const *pUsb)
    322          {
    323              char *pData = (char *) USB_GetSetup(pUsb);
    324              AT91PS_UDP pInterface = UDP_GetDriverInterface(pUsb);
    325              unsigned int dCtr;
    326          
    327              // Copy packet
    328              for (dCtr = 0; dCtr < 8; dCtr++) {
    329          
    330                  *pData = (char) pInterface->UDP_FDR[0];
    331                  pData++;
    332              }
    333          }
    334          
    335          //------------------------------------------------------------------------------
    336          // \brief  This function reset all endpoint transfer descriptors
    337          // \param  pUsb Pointer to a S_usb instance
    338          // \see    S_usb
    339          //------------------------------------------------------------------------------
    340          static void UDP_ResetEndpoints(const S_usb *pUsb)
    341          {
    342              S_usb_endpoint *pEndpoint;
    343              unsigned char bEndpoint;
    344          
    345              // Reset the transfer descriptor of every endpoint
    346              for (bEndpoint = 0; bEndpoint < pUsb->dNumEndpoints; bEndpoint++) {
    347          
    348                  pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
    349          
    350                  // Reset endpoint transfer descriptor
    351                  pEndpoint->pData = 0;
    352                  pEndpoint->dBytesRemaining = 0;
    353                  pEndpoint->dBytesTransferred = 0;
    354                  pEndpoint->dBytesBuffered = 0;
    355                  pEndpoint->fCallback = 0;
    356                  pEndpoint->pArgument = 0;
    357          
    358                  // Configure endpoint characteristics
    359                  pEndpoint->dFlag = AT91C_UDP_RX_DATA_BK0;
    360                  pEndpoint->dState = endpointStateDisabled;
    361              }
    362          }
    363          
    364          //------------------------------------------------------------------------------
    365          // \brief  Disable all endpoints (except control endpoint 0), aborting current
    366          //         transfers if necessary.
    367          // \param  pUsb Pointer to a S_usb instance
    368          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    369          static void UDP_DisableEndpoints(const S_usb *pUsb)
    370          {
   \                     UDP_DisableEndpoints:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
    371              S_usb_endpoint *pEndpoint;
    372              unsigned char bEndpoint;
    373          
    374              // For each endpoint, if it is enabled, disable it and invoke the callback
    375              // Control endpoint 0 is not disabled
    376              for (bEndpoint = 1; bEndpoint < pUsb->dNumEndpoints; bEndpoint++) {
   \   00000004   0125               MOVS     R5,#+1
   \   00000006   0026               MOVS     R6,#+0
   \   00000008   0BE0               B        ??UDP_DisableEndpoints_0
   \                     ??UDP_DisableEndpoints_1:
   \   0000000A   2821               MOVS     R1,#+40
   \   0000000C   4843               MULS     R0,R1,R0
   \   0000000E   6168               LDR      R1,[R4, #+4]
   \   00000010   0F18               ADDS     R7,R1,R0
    377          
    378                  pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
    379                  UDP_EndOfTransfer(pEndpoint, USB_STATUS_RESET);
   \                     ??UDP_DisableEndpoints_2:
   \   00000012   0321               MOVS     R1,#+3
   \   00000014   3800               MOVS     R0,R7
   \   00000016   ........           BL       UDP_EndOfTransfer
    380                  pEndpoint->dState = endpointStateDisabled;
   \   0000001A   7E62               STR      R6,[R7, #+36]
   \   0000001C   6D1C               ADDS     R5,R5,#+1
   \   0000001E   2D06               LSLS     R5,R5,#+24
   \   00000020   2D0E               LSRS     R5,R5,#+24
   \                     ??UDP_DisableEndpoints_0:
   \   00000022   A168               LDR      R1,[R4, #+8]
   \   00000024   8D42               CMP      R5,R1
   \   00000026   04D2               BCS      ??UDP_DisableEndpoints_3
   \   00000028   2800               MOVS     R0,R5
   \   0000002A   8842               CMP      R0,R1
   \   0000002C   EDD3               BCC      ??UDP_DisableEndpoints_1
   \   0000002E   0027               MOVS     R7,#+0
   \   00000030   EFE7               B        ??UDP_DisableEndpoints_2
    381              }
    382          }
   \                     ??UDP_DisableEndpoints_3:
   \   00000032   F8BC               POP      {R3-R7}
   \   00000034   01BC               POP      {R0}
   \   00000036   0047               BX       R0               ;; return
    383          
    384          //------------------------------------------------------------------------------
    385          // \brief  Endpoint interrupt handler.
    386          //
    387          //         Handle IN/OUT transfers, received SETUP packets and STALLing
    388          // \param  pUsb      Pointer to a S_usb instance
    389          // \param  bEndpoint Index of endpoint
    390          // \see    S_usb
    391          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    392          static void UDP_EndpointHandler(const S_usb *pUsb, unsigned char bEndpoint)
    393          {
   \                     UDP_EndpointHandler:
   \   00000000   F2B5               PUSH     {R1,R4-R7,LR}
   \   00000002   88B0               SUB      SP,SP,#+32
   \   00000004   0400               MOVS     R4,R0
    394              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   00000006   0800               MOVS     R0,R1
   \   00000008   0490               STR      R0,[SP, #+16]
   \   0000000A   A168               LDR      R1,[R4, #+8]
   \   0000000C   8842               CMP      R0,R1
   \   0000000E   01D3               BCC      ??UDP_EndpointHandler_0
   \   00000010   0020               MOVS     R0,#+0
   \   00000012   05E0               B        ??UDP_EndpointHandler_1
   \                     ??UDP_EndpointHandler_0:
   \   00000014   08A8               ADD      R0,SP,#+32
   \   00000016   0078               LDRB     R0,[R0, #+0]
   \   00000018   2821               MOVS     R1,#+40
   \   0000001A   4843               MULS     R0,R1,R0
   \   0000001C   6168               LDR      R1,[R4, #+4]
   \   0000001E   0818               ADDS     R0,R1,R0
   \                     ??UDP_EndpointHandler_1:
   \   00000020   0190               STR      R0,[SP, #+4]
    395              AT91PS_UDP pInterface = UDP_GetDriverInterface(pUsb);
   \   00000022   2068               LDR      R0,[R4, #+0]
   \   00000024   0168               LDR      R1,[R0, #+0]
   \   00000026   0291               STR      R1,[SP, #+8]
    396              unsigned int dStatus = pInterface->UDP_CSR[bEndpoint];
   \   00000028   08A9               ADD      R1,SP,#+32
   \   0000002A   0978               LDRB     R1,[R1, #+0]
   \   0000002C   0091               STR      R1,[SP, #+0]
   \   0000002E   8D00               LSLS     R5,R1,#+2
   \   00000030   0299               LDR      R1,[SP, #+8]
   \   00000032   4919               ADDS     R1,R1,R5
   \   00000034   0E6B               LDR      R6,[R1, #+48]
    397          
    398                                                                                          //TRACE_DEBUG_L("Ept%d ", bEndpoint);
    399          
    400              // Handle interrupts
    401              
    402              // IN packet sent
    403              if (ISSET(dStatus, AT91C_UDP_TXCOMP)) 
   \   00000036   F107               LSLS     R1,R6,#+31
   \   00000038   63D5               BPL      ??UDP_EndpointHandler_2
    404              {
    405          
    406                                                                                          //TRACE_DEBUG_L("Wr ");
    407          
    408                  // Check that endpoint was in Write state
    409                  if (pEndpoint->dState == endpointStateWrite) 
   \   0000003A   019F               LDR      R7,[SP, #+4]
   \   0000003C   3F1D               ADDS     R7,R7,#+4
   \   0000003E   396A               LDR      R1,[R7, #+32]
   \   00000040   0229               CMP      R1,#+2
   \   00000042   58D1               BNE      ??UDP_EndpointHandler_3
   \   00000044   7968               LDR      R1,[R7, #+4]
   \   00000046   E022               MOVS     R2,#+224
   \   00000048   D200               LSLS     R2,R2,#+3        ;; #+1792
   \   0000004A   7B69               LDR      R3,[R7, #+20]
   \   0000004C   9942               CMP      R1,R3
   \   0000004E   07D3               BCC      ??UDP_EndpointHandler_4
   \   00000050   1642               TST      R6,R2
   \   00000052   19D0               BEQ      ??UDP_EndpointHandler_5
   \   00000054   3B68               LDR      R3,[R7, #+0]
   \   00000056   002B               CMP      R3,#+0
   \   00000058   16D1               BNE      ??UDP_EndpointHandler_5
   \   0000005A   7B69               LDR      R3,[R7, #+20]
   \   0000005C   9942               CMP      R1,R3
   \   0000005E   13D1               BNE      ??UDP_EndpointHandler_5
    410                  {
    411                                                                                          
    412                   
    413                                                                                          
    414                      // End of transfer ?
    415                      if ((pEndpoint->dBytesBuffered < pEndpoint->wMaxPacketSize)
    416          
    417                          ||
    418                          (!ISCLEARED(dStatus, AT91C_UDP_EPTYPE)
    419                           && (pEndpoint->dBytesRemaining == 0)
    420                           && (pEndpoint->dBytesBuffered == pEndpoint->wMaxPacketSize))) 
    421                      {
    422          
    423                                                                                          
    424                                                                                         // TRACE_DEBUG_L("%d ", pEndpoint->dBytesBuffered);
    425          
    426                          pEndpoint->dBytesTransferred += pEndpoint->dBytesBuffered;
   \                     ??UDP_EndpointHandler_4:
   \   00000060   B868               LDR      R0,[R7, #+8]
   \   00000062   4018               ADDS     R0,R0,R1
   \   00000064   B860               STR      R0,[R7, #+8]
    427                          pEndpoint->dBytesBuffered = 0;
   \   00000066   0020               MOVS     R0,#+0
   \   00000068   7860               STR      R0,[R7, #+4]
    428          
    429                          // Disable interrupt if this is not a control endpoint
    430                          if (!ISCLEARED(dStatus, AT91C_UDP_EPTYPE)) 
   \   0000006A   1642               TST      R6,R2
   \   0000006C   07D0               BEQ      ??UDP_EndpointHandler_6
    431                          {
    432                                                                                          
    433                              SET(pInterface->UDP_IDR, 1 << bEndpoint);
   \   0000006E   0298               LDR      R0,[SP, #+8]
   \   00000070   4169               LDR      R1,[R0, #+20]
   \   00000072   0122               MOVS     R2,#+1
   \   00000074   08AB               ADD      R3,SP,#+32
   \   00000076   1B78               LDRB     R3,[R3, #+0]
   \   00000078   9A40               LSLS     R2,R2,R3
   \   0000007A   0A43               ORRS     R2,R2,R1
   \   0000007C   4261               STR      R2,[R0, #+20]
    434                          }
    435          
    436                          UDP_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
   \                     ??UDP_EndpointHandler_6:
   \   0000007E   0021               MOVS     R1,#+0
   \   00000080   0198               LDR      R0,[SP, #+4]
   \   00000082   ........           BL       UDP_EndOfTransfer
   \   00000086   36E0               B        ??UDP_EndpointHandler_3
    437                      }
    438                      
    439                      else 
    440                      {
    441                                                                                          
    442                     
    443                          // Transfer remaining data
    444                                                                                          TRACE_DEBUG_L("%d ", pEndpoint->wMaxPacketSize);
    445          
    446                          pEndpoint->dBytesTransferred += pEndpoint->wMaxPacketSize;
   \                     ??UDP_EndpointHandler_5:
   \   00000088   BA68               LDR      R2,[R7, #+8]
   \   0000008A   7B69               LDR      R3,[R7, #+20]
   \   0000008C   D218               ADDS     R2,R2,R3
   \   0000008E   BA60               STR      R2,[R7, #+8]
    447                          pEndpoint->dBytesBuffered -= pEndpoint->wMaxPacketSize;
   \   00000090   C91A               SUBS     R1,R1,R3
   \   00000092   7960               STR      R1,[R7, #+4]
   \   00000094   397F               LDRB     R1,[R7, #+28]
   \   00000096   0129               CMP      R1,#+1
   \   00000098   1BD1               BNE      ??UDP_EndpointHandler_7
    448          
    449                          // Send next packet
    450                          if (pEndpoint->dNumFIFO == 1) {
    451          
    452                              // No double buffering
    453                              UDP_WritePayload(pUsb, bEndpoint);
   \   0000009A   08A8               ADD      R0,SP,#+32
   \   0000009C   0178               LDRB     R1,[R0, #+0]
   \   0000009E   2000               MOVS     R0,R4
   \   000000A0   ........           BL       UDP_WritePayload
    454                              UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_TXPKTRDY);
   \                     ??UDP_EndpointHandler_8:
   \   000000A4   2068               LDR      R0,[R4, #+0]
   \   000000A6   0168               LDR      R1,[R0, #+0]
   \   000000A8   4919               ADDS     R1,R1,R5
   \   000000AA   096B               LDR      R1,[R1, #+48]
   \   000000AC   1022               MOVS     R2,#+16
   \   000000AE   1142               TST      R1,R2
   \   000000B0   21D1               BNE      ??UDP_EndpointHandler_3
   \   000000B2   0168               LDR      R1,[R0, #+0]
   \   000000B4   4919               ADDS     R1,R1,R5
   \   000000B6   0068               LDR      R0,[R0, #+0]
   \   000000B8   4019               ADDS     R0,R0,R5
   \   000000BA   006B               LDR      R0,[R0, #+48]
   \   000000BC   0243               ORRS     R2,R2,R0
   \   000000BE   0A63               STR      R2,[R1, #+48]
   \   000000C0   F0E7               B        ??UDP_EndpointHandler_8
    455                          }
    456                          else {
    457          
    458                              // Double buffering
    459                              UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_TXPKTRDY);
   \                     ??UDP_EndpointHandler_9:
   \   000000C2   0168               LDR      R1,[R0, #+0]
   \   000000C4   4919               ADDS     R1,R1,R5
   \   000000C6   0268               LDR      R2,[R0, #+0]
   \   000000C8   5219               ADDS     R2,R2,R5
   \   000000CA   126B               LDR      R2,[R2, #+48]
   \   000000CC   1023               MOVS     R3,#+16
   \   000000CE   1343               ORRS     R3,R3,R2
   \   000000D0   0B63               STR      R3,[R1, #+48]
   \                     ??UDP_EndpointHandler_7:
   \   000000D2   0168               LDR      R1,[R0, #+0]
   \   000000D4   4919               ADDS     R1,R1,R5
   \   000000D6   096B               LDR      R1,[R1, #+48]
   \   000000D8   1022               MOVS     R2,#+16
   \   000000DA   1142               TST      R1,R2
   \   000000DC   F1D0               BEQ      ??UDP_EndpointHandler_9
    460                              UDP_WritePayload(pUsb, bEndpoint);
   \   000000DE   08A8               ADD      R0,SP,#+32
   \   000000E0   0178               LDRB     R1,[R0, #+0]
   \   000000E2   2000               MOVS     R0,R4
   \   000000E4   ........           BL       UDP_WritePayload
   \   000000E8   05E0               B        ??UDP_EndpointHandler_3
    461                          }
    462                      }
    463                  }
    464          
    465                  
    466                  
    467                  
    468                  // Acknowledge interrupt
    469                  UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_TXCOMP);
   \                     ??UDP_EndpointHandler_10:
   \   000000EA   0068               LDR      R0,[R0, #+0]
   \   000000EC   4019               ADDS     R0,R0,R5
   \   000000EE   016B               LDR      R1,[R0, #+48]
   \   000000F0   0122               MOVS     R2,#+1
   \   000000F2   9143               BICS     R1,R1,R2
   \   000000F4   0163               STR      R1,[R0, #+48]
   \                     ??UDP_EndpointHandler_3:
   \   000000F6   2068               LDR      R0,[R4, #+0]
   \   000000F8   0168               LDR      R1,[R0, #+0]
   \   000000FA   4919               ADDS     R1,R1,R5
   \   000000FC   096B               LDR      R1,[R1, #+48]
   \   000000FE   C907               LSLS     R1,R1,#+31
   \   00000100   F3D4               BMI      ??UDP_EndpointHandler_10
    470              }
    471              
    472              
    473              
    474                                                                                          
    475          
    476          
    477          
    478              // OUT packet received
    479              if (ISSET(dStatus, AT91C_UDP_RX_DATA_BK0)
    480                  || ISSET(dStatus, AT91C_UDP_RX_DATA_BK1)) 
   \                     ??UDP_EndpointHandler_2:
   \   00000102   4221               MOVS     R1,#+66
   \   00000104   0E42               TST      R6,R1
   \   00000106   6FD0               BEQ      ??UDP_EndpointHandler_11
    481              {
    482                                                                                                                                                                   
    483                  // Check that the endpoint is in Read state
    484                  if (pEndpoint->dState != endpointStateRead) {
   \   00000108   019F               LDR      R7,[SP, #+4]
   \   0000010A   3F1D               ADDS     R7,R7,#+4
   \   0000010C   386A               LDR      R0,[R7, #+32]
   \   0000010E   0328               CMP      R0,#+3
   \   00000110   19D0               BEQ      ??UDP_EndpointHandler_12
    485          
    486                                                                                              
    487                      // Endpoint is NOT in Read state
    488                      if (ISCLEARED(dStatus, AT91C_UDP_EPTYPE)
    489                          && ISCLEARED(dStatus, 0xFFFF0000)) 
   \   00000112   6B48               LDR      R0,??UDP_EndpointHandler_13  ;; 0xffff0700
   \   00000114   3040               ANDS     R0,R0,R6
   \   00000116   05D1               BNE      ??UDP_EndpointHandler_14
    490                      {
    491                                                                                          
    492                          // Control endpoint, 0 bytes received
    493                          // Acknowledge the data and finish the current transfer
    494                                                                                          TRACE_DEBUG_L("Ack ");
    495                          UDP_ClearRXFlag(pUsb, bEndpoint);
   \   00000118   08A8               ADD      R0,SP,#+32
   \   0000011A   0178               LDRB     R1,[R0, #+0]
   \   0000011C   2000               MOVS     R0,R4
   \   0000011E   ........           BL       UDP_ClearRXFlag
    496          
    497                          UDP_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
   \   00000122   5DE0               B.N      ??UDP_EndpointHandler_15
    498                      }
    499                   
    500                      else if (ISSET(dStatus, AT91C_UDP_FORCESTALL)) 
   \                     ??UDP_EndpointHandler_14:
   \   00000124   B006               LSLS     R0,R6,#+26
   \   00000126   05D5               BPL      ??UDP_EndpointHandler_16
    501                      {
    502                                                                                          
    503                          // Non-control endpoint
    504                          // Discard stalled data
    505                                                                                          TRACE_DEBUG_L("Disc ");
    506                          UDP_ClearRXFlag(pUsb, bEndpoint);
   \   00000128   08A8               ADD      R0,SP,#+32
   \   0000012A   0178               LDRB     R1,[R0, #+0]
   \   0000012C   2000               MOVS     R0,R4
   \   0000012E   ........           BL       UDP_ClearRXFlag
   \   00000132   59E0               B        ??UDP_EndpointHandler_11
    507                      }
    508                      else 
    509                      {
    510                                                                                          
    511                          // Non-control endpoint
    512                          // Nak data
    513                                                                                         // TRACE_DEBUG_L("Nak ");
    514                          SET(pInterface->UDP_IDR, 1 << bEndpoint);
   \                     ??UDP_EndpointHandler_16:
   \   00000134   0298               LDR      R0,[SP, #+8]
   \   00000136   4169               LDR      R1,[R0, #+20]
   \   00000138   0122               MOVS     R2,#+1
   \   0000013A   08AB               ADD      R3,SP,#+32
   \   0000013C   1B78               LDRB     R3,[R3, #+0]
   \   0000013E   9A40               LSLS     R2,R2,R3
   \   00000140   0A43               ORRS     R2,R2,R1
   \   00000142   4261               STR      R2,[R0, #+20]
   \   00000144   50E0               B        ??UDP_EndpointHandler_11
    515                      }
    516                  }
    517                  else 
    518                  {
    519          
    520                                                                                         
    521                    // Endpoint is in Read state
    522                      // Retrieve data and store it into the current transfer buffer
    523                      unsigned short wPacketSize = (unsigned short) (dStatus >> 16);
   \                     ??UDP_EndpointHandler_12:
   \   00000146   300C               LSRS     R0,R6,#+16
   \   00000148   0590               STR      R0,[SP, #+20]
    524                                                                                          //TRACE_DEBUG_L("%d ", wPacketSize);
    525                      //importuje dane z 
    526                      UDP_GetPayload(pUsb, bEndpoint, wPacketSize);
   \   0000014A   6846               MOV      R0,SP
   \   0000014C   0599               LDR      R1,[SP, #+20]
   \   0000014E   8181               STRH     R1,[R0, #+12]
   \   00000150   2068               LDR      R0,[R4, #+0]
   \   00000152   0068               LDR      R0,[R0, #+0]
   \   00000154   0690               STR      R0,[SP, #+24]
   \   00000156   0498               LDR      R0,[SP, #+16]
   \   00000158   A168               LDR      R1,[R4, #+8]
   \   0000015A   8842               CMP      R0,R1
   \   0000015C   01D3               BCC      ??UDP_EndpointHandler_17
   \   0000015E   0020               MOVS     R0,#+0
   \   00000160   04E0               B        ??UDP_EndpointHandler_18
   \                     ??UDP_EndpointHandler_17:
   \   00000162   0098               LDR      R0,[SP, #+0]
   \   00000164   2821               MOVS     R1,#+40
   \   00000166   4843               MULS     R0,R1,R0
   \   00000168   6168               LDR      R1,[R4, #+4]
   \   0000016A   0818               ADDS     R0,R1,R0
   \                     ??UDP_EndpointHandler_18:
   \   0000016C   6946               MOV      R1,SP
   \   0000016E   8989               LDRH     R1,[R1, #+12]
   \   00000170   4268               LDR      R2,[R0, #+4]
   \   00000172   8A42               CMP      R2,R1
   \   00000174   00D9               BLS      ??UDP_EndpointHandler_19
   \   00000176   0A00               MOVS     R2,R1
   \                     ??UDP_EndpointHandler_19:
   \   00000178   0092               STR      R2,[SP, #+0]
   \   0000017A   1100               MOVS     R1,R2
   \   0000017C   09D0               BEQ      ??UDP_EndpointHandler_20
   \                     ??UDP_EndpointHandler_21:
   \   0000017E   0268               LDR      R2,[R0, #+0]
   \   00000180   069B               LDR      R3,[SP, #+24]
   \   00000182   5B19               ADDS     R3,R3,R5
   \   00000184   1B6D               LDR      R3,[R3, #+80]
   \   00000186   1370               STRB     R3,[R2, #+0]
   \   00000188   0268               LDR      R2,[R0, #+0]
   \   0000018A   521C               ADDS     R2,R2,#+1
   \   0000018C   0260               STR      R2,[R0, #+0]
   \   0000018E   491E               SUBS     R1,R1,#+1
   \   00000190   F5D1               BNE      ??UDP_EndpointHandler_21
   \                     ??UDP_EndpointHandler_20:
   \   00000192   4168               LDR      R1,[R0, #+4]
   \   00000194   009A               LDR      R2,[SP, #+0]
   \   00000196   891A               SUBS     R1,R1,R2
   \   00000198   4160               STR      R1,[R0, #+4]
   \   0000019A   C168               LDR      R1,[R0, #+12]
   \   0000019C   009A               LDR      R2,[SP, #+0]
   \   0000019E   8918               ADDS     R1,R1,R2
   \   000001A0   C160               STR      R1,[R0, #+12]
   \   000001A2   8168               LDR      R1,[R0, #+8]
   \   000001A4   6A46               MOV      R2,SP
   \   000001A6   9289               LDRH     R2,[R2, #+12]
   \   000001A8   8918               ADDS     R1,R1,R2
   \   000001AA   009A               LDR      R2,[SP, #+0]
   \   000001AC   891A               SUBS     R1,R1,R2
   \   000001AE   8160               STR      R1,[R0, #+8]
    527                      
    528          
    529                                                                                         
    530                                                                                         
    531                                                                                          
    532                      UDP_ClearRXFlag(pUsb, bEndpoint);
   \   000001B0   08A8               ADD      R0,SP,#+32
   \   000001B2   0178               LDRB     R1,[R0, #+0]
   \   000001B4   2000               MOVS     R0,R4
   \   000001B6   ........           BL       UDP_ClearRXFlag
    533          
    534                      if ((pEndpoint->dBytesRemaining == 0)
    535                          || (wPacketSize < pEndpoint->wMaxPacketSize)) 
   \   000001BA   3868               LDR      R0,[R7, #+0]
   \   000001BC   0028               CMP      R0,#+0
   \   000001BE   03D0               BEQ      ??UDP_EndpointHandler_22
   \   000001C0   0598               LDR      R0,[SP, #+20]
   \   000001C2   7969               LDR      R1,[R7, #+20]
   \   000001C4   8842               CMP      R0,R1
   \   000001C6   0FD2               BCS      ??UDP_EndpointHandler_11
    536                      {
    537                                                                                         
    538                          // Disable interrupt if this is not a control endpoint
    539                          if (!ISCLEARED(dStatus, AT91C_UDP_EPTYPE)) {
   \                     ??UDP_EndpointHandler_22:
   \   000001C8   E020               MOVS     R0,#+224
   \   000001CA   C000               LSLS     R0,R0,#+3        ;; #+1792
   \   000001CC   0642               TST      R6,R0
   \   000001CE   07D0               BEQ      ??UDP_EndpointHandler_15
    540          
    541                              SET(pInterface->UDP_IDR, 1 << bEndpoint);
   \   000001D0   0298               LDR      R0,[SP, #+8]
   \   000001D2   4169               LDR      R1,[R0, #+20]
   \   000001D4   0122               MOVS     R2,#+1
   \   000001D6   08AB               ADD      R3,SP,#+32
   \   000001D8   1B78               LDRB     R3,[R3, #+0]
   \   000001DA   9A40               LSLS     R2,R2,R3
   \   000001DC   0A43               ORRS     R2,R2,R1
   \   000001DE   4261               STR      R2,[R0, #+20]
    542                          }
    543          
    544                          UDP_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
   \                     ??UDP_EndpointHandler_15:
   \   000001E0   0021               MOVS     R1,#+0
   \   000001E2   0198               LDR      R0,[SP, #+4]
   \   000001E4   ........           BL       UDP_EndOfTransfer
   \                     ??UDP_EndpointHandler_11:
   \   000001E8   0421               MOVS     R1,#+4
   \   000001EA   0E42               TST      R6,R1
   \   000001EC   43D0               BEQ      ??UDP_EndpointHandler_23
    545                          
    546                      }
    547                  }
    548                  
    549                  
    550              }
    551              
    552              
    553              
    554              
    555              
    556              
    557              // SETUP packet received
    558              if (ISSET(dStatus, AT91C_UDP_RXSETUP)) 
    559              {
    560          
    561                                                                                          TRACE_DEBUG_L("Stp ");
    562                                                                                         
    563                  // If a transfer was pending, complete it
    564                  // Handle the case where during the status phase of a control write
    565                  // transfer, the host receives the device ZLP and ack it, but the ack
    566                  // is not received by the device
    567                  if ((pEndpoint->dState == endpointStateWrite)
    568                      || (pEndpoint->dState == endpointStateRead)) {
   \   000001EE   019F               LDR      R7,[SP, #+4]
   \   000001F0   3F1D               ADDS     R7,R7,#+4
   \   000001F2   386A               LDR      R0,[R7, #+32]
   \   000001F4   0228               CMP      R0,#+2
   \   000001F6   02D0               BEQ      ??UDP_EndpointHandler_24
   \   000001F8   386A               LDR      R0,[R7, #+32]
   \   000001FA   0328               CMP      R0,#+3
   \   000001FC   03D1               BNE      ??UDP_EndpointHandler_25
    569                                                                                          
    570                      UDP_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
   \                     ??UDP_EndpointHandler_24:
   \   000001FE   0021               MOVS     R1,#+0
   \   00000200   0198               LDR      R0,[SP, #+4]
   \   00000202   ........           BL       UDP_EndOfTransfer
    571                  }
    572          
    573                  // Copy the setup packet in S_usb
    574                  UDP_GetSetup(pUsb);
   \                     ??UDP_EndpointHandler_25:
   \   00000206   2069               LDR      R0,[R4, #+16]
   \   00000208   2168               LDR      R1,[R4, #+0]
   \   0000020A   0968               LDR      R1,[R1, #+0]
   \   0000020C   0222               MOVS     R2,#+2
   \                     ??UDP_EndpointHandler_26:
   \   0000020E   0B6D               LDR      R3,[R1, #+80]
   \   00000210   0370               STRB     R3,[R0, #+0]
   \   00000212   0B6D               LDR      R3,[R1, #+80]
   \   00000214   4370               STRB     R3,[R0, #+1]
   \   00000216   0B6D               LDR      R3,[R1, #+80]
   \   00000218   8370               STRB     R3,[R0, #+2]
   \   0000021A   0B6D               LDR      R3,[R1, #+80]
   \   0000021C   C370               STRB     R3,[R0, #+3]
   \   0000021E   001D               ADDS     R0,R0,#+4
   \   00000220   521E               SUBS     R2,R2,#+1
   \   00000222   F4D1               BNE      ??UDP_EndpointHandler_26
    575          
    576                  // Set the DIR bit before clearing RXSETUP in Control IN sequence
    577                  if (USB_GetSetup(pUsb)->bmRequestType & 0x80) {
   \   00000224   8020               MOVS     R0,#+128
   \   00000226   2169               LDR      R1,[R4, #+16]
   \   00000228   0978               LDRB     R1,[R1, #+0]
   \   0000022A   0142               TST      R1,R0
   \   0000022C   07D1               BNE      ??UDP_EndpointHandler_27
   \   0000022E   0CE0               B        ??UDP_EndpointHandler_28
    578                                                                                          
    579                      UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_DIR);
   \                     ??UDP_EndpointHandler_29:
   \   00000230   1168               LDR      R1,[R2, #+0]
   \   00000232   4919               ADDS     R1,R1,R5
   \   00000234   1268               LDR      R2,[R2, #+0]
   \   00000236   5219               ADDS     R2,R2,R5
   \   00000238   126B               LDR      R2,[R2, #+48]
   \   0000023A   0243               ORRS     R2,R2,R0
   \   0000023C   0A63               STR      R2,[R1, #+48]
   \                     ??UDP_EndpointHandler_27:
   \   0000023E   2268               LDR      R2,[R4, #+0]
   \   00000240   1168               LDR      R1,[R2, #+0]
   \   00000242   4919               ADDS     R1,R1,R5
   \   00000244   096B               LDR      R1,[R1, #+48]
   \   00000246   0142               TST      R1,R0
   \   00000248   F2D0               BEQ      ??UDP_EndpointHandler_29
    580                  }
    581          
    582                  UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_RXSETUP);
   \                     ??UDP_EndpointHandler_28:
   \   0000024A   2268               LDR      R2,[R4, #+0]
   \   0000024C   1068               LDR      R0,[R2, #+0]
   \   0000024E   4019               ADDS     R0,R0,R5
   \   00000250   006B               LDR      R0,[R0, #+48]
   \   00000252   0421               MOVS     R1,#+4
   \   00000254   0842               TST      R0,R1
   \   00000256   06D0               BEQ      ??UDP_EndpointHandler_30
   \   00000258   1068               LDR      R0,[R2, #+0]
   \   0000025A   4019               ADDS     R0,R0,R5
   \   0000025C   016B               LDR      R1,[R0, #+48]
   \   0000025E   0422               MOVS     R2,#+4
   \   00000260   9143               BICS     R1,R1,R2
   \   00000262   0163               STR      R1,[R0, #+48]
   \   00000264   F1E7               B        ??UDP_EndpointHandler_28
    583          
    584                  // Forward the request to the upper layer
    585                  USB_NewRequestCallback(pUsb);
   \                     ??UDP_EndpointHandler_30:
   \   00000266   E168               LDR      R1,[R4, #+12]
   \   00000268   0869               LDR      R0,[R1, #+16]
   \   0000026A   0028               CMP      R0,#+0
   \   0000026C   03D0               BEQ      ??UDP_EndpointHandler_23
   \   0000026E   2000               MOVS     R0,R4
   \   00000270   0969               LDR      R1,[R1, #+16]
   \   00000272   ........           BL       __iar_via_R1
    586                  
    587              }// koniec -  SETUP packet received
    588              
    589              
    590              
    591              
    592              // STALL sent
    593              if (ISSET(dStatus, AT91C_UDP_STALLSENT)) 
   \                     ??UDP_EndpointHandler_23:
   \   00000276   0820               MOVS     R0,#+8
   \   00000278   0642               TST      R6,R0
   \   0000027A   05D1               BNE      ??UDP_EndpointHandler_31
   \   0000027C   1BE0               B        ??UDP_EndpointHandler_32
    594              {
    595                                                                                          
    596                  TRACE_WARNING("Sta ");
    597          
    598                  // Acknowledge the stall flag
    599                  UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_STALLSENT);
   \                     ??UDP_EndpointHandler_33:
   \   0000027E   0968               LDR      R1,[R1, #+0]
   \   00000280   4919               ADDS     R1,R1,R5
   \   00000282   0A6B               LDR      R2,[R1, #+48]
   \   00000284   8243               BICS     R2,R2,R0
   \   00000286   0A63               STR      R2,[R1, #+48]
   \                     ??UDP_EndpointHandler_31:
   \   00000288   2168               LDR      R1,[R4, #+0]
   \   0000028A   0A68               LDR      R2,[R1, #+0]
   \   0000028C   5219               ADDS     R2,R2,R5
   \   0000028E   126B               LDR      R2,[R2, #+48]
   \   00000290   0242               TST      R2,R0
   \   00000292   F4D1               BNE      ??UDP_EndpointHandler_33
    600          
    601                  // If the endpoint is not halted, clear the stall condition
    602                  if (pEndpoint->dState != endpointStateHalted) {
   \   00000294   0198               LDR      R0,[SP, #+4]
   \   00000296   001D               ADDS     R0,R0,#+4
   \   00000298   006A               LDR      R0,[R0, #+32]
   \   0000029A   0428               CMP      R0,#+4
   \   0000029C   06D1               BNE      ??UDP_EndpointHandler_34
   \   0000029E   0AE0               B        ??UDP_EndpointHandler_32
    603                                                                                         
    604                      UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_FORCESTALL);
   \                     ??UDP_EndpointHandler_35:
   \   000002A0   0868               LDR      R0,[R1, #+0]
   \   000002A2   4019               ADDS     R0,R0,R5
   \   000002A4   026B               LDR      R2,[R0, #+48]
   \   000002A6   2023               MOVS     R3,#+32
   \   000002A8   9A43               BICS     R2,R2,R3
   \   000002AA   0263               STR      R2,[R0, #+48]
   \                     ??UDP_EndpointHandler_34:
   \   000002AC   0868               LDR      R0,[R1, #+0]
   \   000002AE   4019               ADDS     R0,R0,R5
   \   000002B0   006B               LDR      R0,[R0, #+48]
   \   000002B2   8006               LSLS     R0,R0,#+26
   \   000002B4   F4D4               BMI      ??UDP_EndpointHandler_35
    605                  }
    606                }// koniec - STALL sent
    607              
    608                                                                                          //TRACE_DEBUG_L("a1 ");
    609                                                                                          //TRACE_DEBUG_L("KON_Ept%d ", bEndpoint);
    610          
    611          }
   \                     ??UDP_EndpointHandler_32:
   \   000002B6   09B0               ADD      SP,SP,#+36
   \   000002B8   F0BC               POP      {R4-R7}
   \   000002BA   01BC               POP      {R0}
   \   000002BC   0047               BX       R0               ;; return
   \   000002BE   C046               Nop      
   \                     ??UDP_EndpointHandler_13:
   \   000002C0   0007FFFF           DC32     0xffff0700
    612          
    613          //------------------------------------------------------------------------------
    614          //      Exported functions
    615          //------------------------------------------------------------------------------
    616          //------------------------------------------------------------------------------
    617          // \brief  Configure an endpoint with the provided endpoint descriptor
    618          // \param  pUsb    Pointer to a S_usb instance
    619          // \param  pEpDesc Pointer to the endpoint descriptor
    620          // \return true if the endpoint is now configured, false otherwise
    621          // \see    S_usb_endpoint_descriptor
    622          // \see    S_usb
    623          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    624          bool UDP_ConfigureEndpoint(const S_usb                     *pUsb,
    625                                     const S_usb_endpoint_descriptor *pEpDesc)
    626          {
   \                     UDP_ConfigureEndpoint:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
    627              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0468               LDR      R4,[R0, #+0]
    628              S_usb_endpoint *pEndpoint;
    629              unsigned char  bEndpoint;
    630              unsigned char  bType;
    631              bool           isINEndpoint;
    632              unsigned int   dFlags;
    633          
    634              // NULL descriptor -> Control endpoint 0
    635              if (pEpDesc == 0) {
   \   00000008   0029               CMP      R1,#+0
   \   0000000A   03D1               BNE      ??UDP_ConfigureEndpoint_0
    636          
    637                  bEndpoint = 0;
   \   0000000C   0026               MOVS     R6,#+0
   \   0000000E   0096               STR      R6,[SP, #+0]
    638                  bType = ENDPOINT_TYPE_CONTROL;
   \   00000010   0025               MOVS     R5,#+0
    639                  isINEndpoint = false;
   \   00000012   0CE0               B        ??UDP_ConfigureEndpoint_1
    640              }
    641              else {
    642          
    643                  bEndpoint = (unsigned char) (pEpDesc->bEndpointAddress & 0x7);
   \                     ??UDP_ConfigureEndpoint_0:
   \   00000014   8878               LDRB     R0,[R1, #+2]
   \   00000016   4207               LSLS     R2,R0,#+29
   \   00000018   520F               LSRS     R2,R2,#+29
   \   0000001A   0092               STR      R2,[SP, #+0]
    644                  bType = (unsigned char) (pEpDesc->bmAttributes & 0x3);
   \   0000001C   CA78               LDRB     R2,[R1, #+3]
   \   0000001E   9507               LSLS     R5,R2,#+30
   \   00000020   AD0F               LSRS     R5,R5,#+30
    645          
    646                  if (ISSET(pEpDesc->bEndpointAddress, 1 << 7)) {
    647          
    648                      isINEndpoint = true;
    649                  }
    650                  else {
    651          
    652                      isINEndpoint = false;
   \   00000022   8022               MOVS     R2,#+128
   \   00000024   0240               ANDS     R2,R2,R0
   \   00000026   561E               SUBS     R6,R2,#+1
   \   00000028   B641               SBCS     R6,R6,R6
   \   0000002A   F643               MVNS     R6,R6
   \   0000002C   F60F               LSRS     R6,R6,#+31
    653                  }
    654              }
    655          
    656              // Get pointer on endpoint
    657              pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \                     ??UDP_ConfigureEndpoint_1:
   \   0000002E   0098               LDR      R0,[SP, #+0]
   \   00000030   0006               LSLS     R0,R0,#+24
   \   00000032   000E               LSRS     R0,R0,#+24
   \   00000034   029A               LDR      R2,[SP, #+8]
   \   00000036   9268               LDR      R2,[R2, #+8]
   \   00000038   9042               CMP      R0,R2
   \   0000003A   01D3               BCC      ??UDP_ConfigureEndpoint_2
   \   0000003C   0020               MOVS     R0,#+0
   \   0000003E   04E0               B        ??UDP_ConfigureEndpoint_3
   \                     ??UDP_ConfigureEndpoint_2:
   \   00000040   2822               MOVS     R2,#+40
   \   00000042   5043               MULS     R0,R2,R0
   \   00000044   029A               LDR      R2,[SP, #+8]
   \   00000046   5268               LDR      R2,[R2, #+4]
   \   00000048   1018               ADDS     R0,R2,R0
    658              if (pEndpoint == 0) {
   \                     ??UDP_ConfigureEndpoint_3:
   \   0000004A   0028               CMP      R0,#+0
   \   0000004C   40D0               BEQ      ??UDP_ConfigureEndpoint_4
    659          
    660                  return false;
    661              }
    662          
    663              // Configure wMaxPacketSize
    664              if (pEpDesc != 0) {
   \   0000004E   0029               CMP      R1,#+0
   \   00000050   05D0               BEQ      ??UDP_ConfigureEndpoint_5
    665          
    666                  pEndpoint->wMaxPacketSize = pEpDesc->wMaxPacketSize;
   \   00000052   0A79               LDRB     R2,[R1, #+4]
   \   00000054   4B79               LDRB     R3,[R1, #+5]
   \   00000056   1B06               LSLS     R3,R3,#+24
   \   00000058   1B0C               LSRS     R3,R3,#+16
   \   0000005A   1A43               ORRS     R2,R2,R3
   \   0000005C   00E0               B        ??UDP_ConfigureEndpoint_6
    667              }
    668              else {
    669          
    670                  pEndpoint->wMaxPacketSize = USB_ENDPOINT0_MAXPACKETSIZE;
   \                     ??UDP_ConfigureEndpoint_5:
   \   0000005E   0822               MOVS     R2,#+8
   \                     ??UDP_ConfigureEndpoint_6:
   \   00000060   0700               MOVS     R7,R0
   \   00000062   1837               ADDS     R7,R7,#+24
   \   00000064   3A60               STR      R2,[R7, #+0]
    671              }
    672          
    673              // Abort the current transfer is the endpoint was configured and in
    674              // Write or Read state
    675              if ((pEndpoint->dState == endpointStateRead)
    676                  || (pEndpoint->dState == endpointStateWrite)) {
   \   00000066   F968               LDR      R1,[R7, #+12]
   \   00000068   0329               CMP      R1,#+3
   \   0000006A   02D0               BEQ      ??UDP_ConfigureEndpoint_7
   \   0000006C   F968               LDR      R1,[R7, #+12]
   \   0000006E   0229               CMP      R1,#+2
   \   00000070   02D1               BNE      ??UDP_ConfigureEndpoint_8
    677          
    678                  UDP_EndOfTransfer(pEndpoint, USB_STATUS_RESET);
   \                     ??UDP_ConfigureEndpoint_7:
   \   00000072   0321               MOVS     R1,#+3
   \   00000074   ........           BL       UDP_EndOfTransfer
    679              }
    680          
    681              // Enter IDLE state
    682              pEndpoint->dState = endpointStateIdle;
   \                     ??UDP_ConfigureEndpoint_8:
   \   00000078   0120               MOVS     R0,#+1
   \   0000007A   F860               STR      R0,[R7, #+12]
    683          
    684              // Reset Endpoint Fifos
    685              SET(pInterface->UDP_RSTEP, 1 << bEndpoint);
   \   0000007C   0099               LDR      R1,[SP, #+0]
   \   0000007E   8840               LSLS     R0,R0,R1
   \   00000080   A16A               LDR      R1,[R4, #+40]
   \   00000082   0143               ORRS     R1,R1,R0
   \   00000084   A162               STR      R1,[R4, #+40]
    686              CLEAR(pInterface->UDP_RSTEP, 1 << bEndpoint);
   \   00000086   A16A               LDR      R1,[R4, #+40]
   \   00000088   8143               BICS     R1,R1,R0
   \   0000008A   A162               STR      R1,[R4, #+40]
    687          
    688              // Configure endpoint
    689              dFlags = AT91C_UDP_EPEDS;
    690              SET(dFlags, bType << UDP_EPTYPE_INDEX);
   \   0000008C   2A02               LSLS     R2,R5,#+8
   \   0000008E   8021               MOVS     R1,#+128
   \   00000090   0902               LSLS     R1,R1,#+8        ;; #+32768
   \   00000092   1143               ORRS     R1,R1,R2
    691          
    692              if (isINEndpoint) {
   \   00000094   002E               CMP      R6,#+0
   \   00000096   03D0               BEQ      ??UDP_ConfigureEndpoint_9
    693          
    694                  SET(dFlags, 1 << UDP_EPDIR_INDEX);
   \   00000098   0A00               MOVS     R2,R1
   \   0000009A   8021               MOVS     R1,#+128
   \   0000009C   C900               LSLS     R1,R1,#+3        ;; #+1024
   \   0000009E   1143               ORRS     R1,R1,R2
    695              }
    696          
    697              if (bType == ENDPOINT_TYPE_CONTROL) {
   \                     ??UDP_ConfigureEndpoint_9:
   \   000000A0   002D               CMP      R5,#+0
   \   000000A2   0AD1               BNE      ??UDP_ConfigureEndpoint_10
    698          
    699                  SET(pInterface->UDP_IER, 1 << bEndpoint);
   \   000000A4   2269               LDR      R2,[R4, #+16]
   \   000000A6   1043               ORRS     R0,R0,R2
   \   000000A8   2061               STR      R0,[R4, #+16]
   \   000000AA   06E0               B        ??UDP_ConfigureEndpoint_10
    700              }
    701          
    702                                                                                          //TRACE_DEBUG_L("CfgEpt%d ", bEndpoint);
    703          
    704              UDP_SETEPFLAGS(pUsb, bEndpoint, dFlags);
   \                     ??UDP_ConfigureEndpoint_11:
   \   000000AC   1368               LDR      R3,[R2, #+0]
   \   000000AE   1B18               ADDS     R3,R3,R0
   \   000000B0   1268               LDR      R2,[R2, #+0]
   \   000000B2   1018               ADDS     R0,R2,R0
   \   000000B4   006B               LDR      R0,[R0, #+48]
   \   000000B6   0843               ORRS     R0,R0,R1
   \   000000B8   1863               STR      R0,[R3, #+48]
   \                     ??UDP_ConfigureEndpoint_10:
   \   000000BA   0098               LDR      R0,[SP, #+0]
   \   000000BC   0006               LSLS     R0,R0,#+24
   \   000000BE   800D               LSRS     R0,R0,#+22
   \   000000C0   029A               LDR      R2,[SP, #+8]
   \   000000C2   1268               LDR      R2,[R2, #+0]
   \   000000C4   1368               LDR      R3,[R2, #+0]
   \   000000C6   1B18               ADDS     R3,R3,R0
   \   000000C8   1B6B               LDR      R3,[R3, #+48]
   \   000000CA   0B40               ANDS     R3,R3,R1
   \   000000CC   EED0               BEQ      ??UDP_ConfigureEndpoint_11
    705          
    706              return true;
   \   000000CE   0120               MOVS     R0,#+1
   \                     ??UDP_ConfigureEndpoint_4:
   \   000000D0   FEBC               POP      {R1-R7}
   \   000000D2   02BC               POP      {R1}
   \   000000D4   0847               BX       R1               ;; return
    707          }
    708          
    709          //------------------------------------------------------------------------------
    710          // \brief  UDP interrupt handler
    711          //
    712          //         Manages device resume, suspend, end of bus reset. Forwards endpoint
    713          //         interrupts to the appropriate handler.
    714          // \param  pUsb Pointer to a S_usb instance
    715          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    716          void UDP_Handler(const S_usb *pUsb)
    717          {
   \                     UDP_Handler:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
    718              AT91PS_UDP          pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   2068               LDR      R0,[R4, #+0]
   \   00000006   0568               LDR      R5,[R0, #+0]
    719              unsigned int        dStatus;
    720              unsigned char       bEndpoint;
    721          
    722              
    723              if ( (!ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED))
    724                 && (ISSET(USB_GetState(pUsb), USB_STATE_POWERED))){
   \   00000008   6069               LDR      R0,[R4, #+20]
   \   0000000A   0168               LDR      R1,[R0, #+0]
   \   0000000C   2022               MOVS     R2,#+32
   \   0000000E   1142               TST      R1,R2
   \   00000010   00D1               BNE      ??UDP_Handler_0
   \   00000012   0068               LDR      R0,[R0, #+0]
   \                     ??UDP_Handler_0:
   \   00000014   E869               LDR      R0,[R5, #+28]
   \   00000016   A969               LDR      R1,[R5, #+24]
   \   00000018   0140               ANDS     R1,R1,R0
   \   0000001A   8F04               LSLS     R7,R1,#+18
   \   0000001C   BF0C               LSRS     R7,R7,#+18
   \   0000001E   00D1               BNE      .+4
   \   00000020   0DE1               B        ??UDP_Handler_1
   \   00000022   0026               MOVS     R6,#+0
    725          
    726                  LED_TOGGLE(LED_USB);
    727              }
    728          
    729                                                                                         //TRACE_DEBUG_L("Hlr ");
    730          
    731              // Get interrupts status
    732              dStatus = pInterface->UDP_ISR & pInterface->UDP_IMR & ISR_MASK;
    733          
    734              // Handle all UDP interrupts
    735              while (dStatus != 0) 
    736              {
    737          
    738                  // Start Of Frame (SOF)
    739                  if (ISSET(dStatus, AT91C_UDP_SOFINT)) {
   \                     ??UDP_Handler_2:
   \   00000024   8020               MOVS     R0,#+128
   \   00000026   0001               LSLS     R0,R0,#+4        ;; #+2048
   \   00000028   0742               TST      R7,R0
   \   0000002A   0CD0               BEQ      ??UDP_Handler_3
    740                                                                                           
    741                                                                                          //TRACE_DEBUG_L("SOF ");
    742          
    743                      // Invoke the SOF callback
    744                      USB_StartOfFrameCallback(pUsb);
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   E168               LDR      R1,[R4, #+12]
   \   00000030   4969               LDR      R1,[R1, #+20]
   \   00000032   ........           BL       __iar_via_R1
    745          
    746                      // Acknowledge interrupt
    747                      SET(pInterface->UDP_ICR, AT91C_UDP_SOFINT);
   \   00000036   286A               LDR      R0,[R5, #+32]
   \   00000038   8021               MOVS     R1,#+128
   \   0000003A   0901               LSLS     R1,R1,#+4        ;; #+2048
   \   0000003C   0143               ORRS     R1,R1,R0
   \   0000003E   2962               STR      R1,[R5, #+32]
    748                      CLEAR(dStatus, AT91C_UDP_SOFINT);
   \   00000040   3800               MOVS     R0,R7
   \   00000042   834F               LDR      R7,??UDP_Handler_4  ;; 0xfffff7ff
   \   00000044   0740               ANDS     R7,R7,R0
    749                  }
    750          
    751                  // Suspend
    752                  if (dStatus == AT91C_UDP_RXSUSP) 
   \                     ??UDP_Handler_3:
   \   00000046   8020               MOVS     R0,#+128
   \   00000048   4000               LSLS     R0,R0,#+1        ;; #+256
   \   0000004A   8742               CMP      R7,R0
   \   0000004C   2ED1               BNE      ??UDP_Handler_5
    753                  {                                                                       //TRACE_DEBUG_L("Susp ");
    754          
    755                      if (!ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED)) 
   \   0000004E   6069               LDR      R0,[R4, #+20]
   \   00000050   0168               LDR      R1,[R0, #+0]
   \   00000052   2022               MOVS     R2,#+32
   \   00000054   1142               TST      R1,R2
   \   00000056   00D0               BEQ      .+4
   \   00000058   E0E0               B        ??UDP_Handler_6
    756                      {
    757                                                                                          //TRACE_DEBUG_L("Susp_in ");
    758                          // The device enters the Suspended state                        
    759                          //      MCK + UDPCK must be off
    760                          //      Pull-Up must be connected
    761                          //      Transceiver must be disabled
    762          
    763                          // Enable wakeup
    764                          SET(pInterface->UDP_IER, AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM);
   \   0000005A   2969               LDR      R1,[R5, #+16]
   \   0000005C   8822               MOVS     R2,#+136
   \   0000005E   9201               LSLS     R2,R2,#+6        ;; #+8704
   \   00000060   0A43               ORRS     R2,R2,R1
   \   00000062   2A61               STR      R2,[R5, #+16]
    765          
    766                          // Acknowledge interrupt
    767                          SET(pInterface->UDP_ICR, AT91C_UDP_RXSUSP);
   \   00000064   296A               LDR      R1,[R5, #+32]
   \   00000066   8022               MOVS     R2,#+128
   \   00000068   5200               LSLS     R2,R2,#+1        ;; #+256
   \   0000006A   0A43               ORRS     R2,R2,R1
   \   0000006C   2A62               STR      R2,[R5, #+32]
    768          
    769                          SET(*(pUsb->pState), USB_STATE_SUSPENDED);
   \   0000006E   0168               LDR      R1,[R0, #+0]
   \   00000070   2022               MOVS     R2,#+32
   \   00000072   0A43               ORRS     R2,R2,R1
   \   00000074   0260               STR      R2,[R0, #+0]
    770                          UDP_DisableTransceiver(pUsb);
   \   00000076   2068               LDR      R0,[R4, #+0]
   \   00000078   0168               LDR      R1,[R0, #+0]
   \   0000007A   4A6F               LDR      R2,[R1, #+116]
   \   0000007C   8023               MOVS     R3,#+128
   \   0000007E   5B00               LSLS     R3,R3,#+1        ;; #+256
   \   00000080   1343               ORRS     R3,R3,R2
   \   00000082   4B67               STR      R3,[R1, #+116]
    771                          UDP_DisableMCK(pUsb);
   \   00000084   7349               LDR      R1,??UDP_Handler_4+0x4  ;; 0xfffffc14
   \   00000086   0122               MOVS     R2,#+1
   \   00000088   C368               LDR      R3,[R0, #+12]
   \   0000008A   9A40               LSLS     R2,R2,R3
   \   0000008C   0A60               STR      R2,[R1, #+0]
    772                          UDP_DisableUDPCK(pUsb);
   \   0000008E   7249               LDR      R1,??UDP_Handler_4+0x8  ;; 0xfffffc04
   \   00000090   0A68               LDR      R2,[R1, #+0]
   \   00000092   0069               LDR      R0,[R0, #+16]
   \   00000094   1043               ORRS     R0,R0,R2
   \   00000096   0860               STR      R0,[R1, #+0]
    773          
    774                          // Invoke the Suspend callback
    775                          USB_SuspendCallback(pUsb);
   \   00000098   E168               LDR      R1,[R4, #+12]
   \   0000009A   8868               LDR      R0,[R1, #+8]
   \   0000009C   0028               CMP      R0,#+0
   \   0000009E   00D1               BNE      .+4
   \   000000A0   BCE0               B        ??UDP_Handler_6
   \   000000A2   2000               MOVS     R0,R4
   \   000000A4   8968               LDR      R1,[R1, #+8]
   \   000000A6   ........           BL       __iar_via_R1
   \   000000AA   B7E0               B        ??UDP_Handler_6
    776          
    777                      }
    778                      
    779                      
    780                      
    781                  }//End of Suspend
    782                  // Resume
    783                  else if (ISSET(dStatus, AT91C_UDP_WAKEUP)
    784                        || ISSET(dStatus, AT91C_UDP_RXRSM)) 
   \                     ??UDP_Handler_5:
   \   000000AC   8820               MOVS     R0,#+136
   \   000000AE   8001               LSLS     R0,R0,#+6        ;; #+8704
   \   000000B0   0742               TST      R7,R0
   \   000000B2   2FD0               BEQ      ??UDP_Handler_7
    785                  {
    786          
    787                      // Invoke the Resume callback
    788                      USB_ResumeCallback(pUsb);
   \   000000B4   E168               LDR      R1,[R4, #+12]
   \   000000B6   C868               LDR      R0,[R1, #+12]
   \   000000B8   0028               CMP      R0,#+0
   \   000000BA   03D0               BEQ      ??UDP_Handler_8
   \   000000BC   2000               MOVS     R0,R4
   \   000000BE   C968               LDR      R1,[R1, #+12]
   \   000000C0   ........           BL       __iar_via_R1
    789          
    790                                                                                          //TRACE_DEBUG_L("Res ");
    791          
    792                      // The device enters Configured state
    793                      //      MCK + UDPCK must be on
    794                      //      Pull-Up must be connected
    795                      //      Transceiver must be enabled
    796          
    797                      if (ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED)) 
   \                     ??UDP_Handler_8:
   \   000000C4   6069               LDR      R0,[R4, #+20]
   \   000000C6   0168               LDR      R1,[R0, #+0]
   \   000000C8   2022               MOVS     R2,#+32
   \   000000CA   1142               TST      R1,R2
   \   000000CC   17D0               BEQ      ??UDP_Handler_9
    798                      {
    799          
    800                          // Powered state
    801                          UDP_EnableMCK(pUsb);
   \   000000CE   2168               LDR      R1,[R4, #+0]
   \   000000D0   624A               LDR      R2,??UDP_Handler_4+0xC  ;; 0xfffffc10
   \   000000D2   0123               MOVS     R3,#+1
   \   000000D4   CF68               LDR      R7,[R1, #+12]
   \   000000D6   BB40               LSLS     R3,R3,R7
   \   000000D8   1360               STR      R3,[R2, #+0]
    802                          UDP_EnableUDPCK(pUsb);
   \   000000DA   614A               LDR      R2,??UDP_Handler_4+0x10  ;; 0xfffffc00
   \   000000DC   1368               LDR      R3,[R2, #+0]
   \   000000DE   0F69               LDR      R7,[R1, #+16]
   \   000000E0   1F43               ORRS     R7,R7,R3
   \   000000E2   1760               STR      R7,[R2, #+0]
    803          
    804                          // Default state
    805                          if (ISSET(USB_GetState(pUsb), USB_STATE_DEFAULT)) 
   \   000000E4   0268               LDR      R2,[R0, #+0]
   \   000000E6   0423               MOVS     R3,#+4
   \   000000E8   1A42               TST      R2,R3
   \   000000EA   04D0               BEQ      ??UDP_Handler_10
    806                          {
    807          
    808                              UDP_EnableTransceiver(pUsb);
   \   000000EC   0968               LDR      R1,[R1, #+0]
   \   000000EE   4A6F               LDR      R2,[R1, #+116]
   \   000000F0   5C4B               LDR      R3,??UDP_Handler_4+0x14  ;; 0xfffffeff
   \   000000F2   1340               ANDS     R3,R3,R2
   \   000000F4   4B67               STR      R3,[R1, #+116]
    809                          }
    810          
    811                          CLEAR(*(pUsb->pState), USB_STATE_SUSPENDED);
   \                     ??UDP_Handler_10:
   \   000000F6   0168               LDR      R1,[R0, #+0]
   \   000000F8   2022               MOVS     R2,#+32
   \   000000FA   9143               BICS     R1,R1,R2
   \   000000FC   0160               STR      R1,[R0, #+0]
    812                      }
    813                      SET(pInterface->UDP_ICR,
    814                          AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM | AT91C_UDP_RXSUSP);
   \                     ??UDP_Handler_9:
   \   000000FE   286A               LDR      R0,[R5, #+32]
   \   00000100   8C21               MOVS     R1,#+140
   \   00000102   8901               LSLS     R1,R1,#+6        ;; #+8960
   \   00000104   0143               ORRS     R1,R1,R0
   \   00000106   2962               STR      R1,[R5, #+32]
    815                      SET(pInterface->UDP_IDR, AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM);
   \   00000108   6869               LDR      R0,[R5, #+20]
   \   0000010A   8821               MOVS     R1,#+136
   \   0000010C   8901               LSLS     R1,R1,#+6        ;; #+8704
   \   0000010E   0143               ORRS     R1,R1,R0
   \   00000110   6961               STR      R1,[R5, #+20]
   \   00000112   83E0               B        ??UDP_Handler_6
    816                  }
    817                  // End of bus reset
    818                  else if (ISSET(dStatus, AT91C_UDP_ENDBUSRES)) 
   \                     ??UDP_Handler_7:
   \   00000114   8020               MOVS     R0,#+128
   \   00000116   4001               LSLS     R0,R0,#+5        ;; #+4096
   \   00000118   0742               TST      R7,R0
   \   0000011A   7DD0               BEQ      ??UDP_Handler_11
    819                  {
    820          
    821                                                                                          //TRACE_DEBUG_L("EoBRes ");
    822          
    823                      // The device enters the Default state
    824                      //      MCK + UDPCK are already enabled
    825                      //      Pull-Up is already connected
    826                      //      Transceiver must be enabled
    827                      //      Endpoint 0 must be enabled
    828                      SET(*(pUsb->pState), USB_STATE_DEFAULT);
   \   0000011C   6069               LDR      R0,[R4, #+20]
   \   0000011E   0168               LDR      R1,[R0, #+0]
   \   00000120   0422               MOVS     R2,#+4
   \   00000122   0A43               ORRS     R2,R2,R1
   \   00000124   0260               STR      R2,[R0, #+0]
    829                      UDP_EnableTransceiver(pUsb);
   \   00000126   2168               LDR      R1,[R4, #+0]
   \   00000128   0968               LDR      R1,[R1, #+0]
   \   0000012A   4A6F               LDR      R2,[R1, #+116]
   \   0000012C   4D4B               LDR      R3,??UDP_Handler_4+0x14  ;; 0xfffffeff
   \   0000012E   1340               ANDS     R3,R3,R2
   \   00000130   4B67               STR      R3,[R1, #+116]
    830          
    831                      // The device leaves the Address & Configured states
    832                      CLEAR(*(pUsb->pState), USB_STATE_ADDRESS | USB_STATE_CONFIGURED);
   \   00000132   0168               LDR      R1,[R0, #+0]
   \   00000134   1822               MOVS     R2,#+24
   \   00000136   9143               BICS     R1,R1,R2
   \   00000138   0160               STR      R1,[R0, #+0]
    833                      UDP_ResetEndpoints(pUsb);
   \   0000013A   0020               MOVS     R0,#+0
   \   0000013C   0FE0               B        ??UDP_Handler_12
   \                     ??UDP_Handler_13:
   \   0000013E   2822               MOVS     R2,#+40
   \   00000140   5143               MULS     R1,R2,R1
   \   00000142   6268               LDR      R2,[R4, #+4]
   \   00000144   5118               ADDS     R1,R2,R1
   \                     ??UDP_Handler_14:
   \   00000146   0E60               STR      R6,[R1, #+0]
   \   00000148   4E60               STR      R6,[R1, #+4]
   \   0000014A   CE60               STR      R6,[R1, #+12]
   \   0000014C   8E60               STR      R6,[R1, #+8]
   \   0000014E   0E61               STR      R6,[R1, #+16]
   \   00000150   4E61               STR      R6,[R1, #+20]
   \   00000152   0222               MOVS     R2,#+2
   \   00000154   CA61               STR      R2,[R1, #+28]
   \   00000156   4E62               STR      R6,[R1, #+36]
   \   00000158   401C               ADDS     R0,R0,#+1
   \   0000015A   0006               LSLS     R0,R0,#+24
   \   0000015C   000E               LSRS     R0,R0,#+24
   \                     ??UDP_Handler_12:
   \   0000015E   A268               LDR      R2,[R4, #+8]
   \   00000160   9042               CMP      R0,R2
   \   00000162   04D2               BCS      ??UDP_Handler_15
   \   00000164   0100               MOVS     R1,R0
   \   00000166   9142               CMP      R1,R2
   \   00000168   E9D3               BCC      ??UDP_Handler_13
   \   0000016A   0021               MOVS     R1,#+0
   \   0000016C   EBE7               B        ??UDP_Handler_14
    834                      UDP_DisableEndpoints(pUsb);
   \                     ??UDP_Handler_15:
   \   0000016E   2000               MOVS     R0,R4
   \   00000170   ........           BL       UDP_DisableEndpoints
    835                      UDP_ConfigureEndpoint(pUsb, 0);
   \   00000174   0021               MOVS     R1,#+0
   \   00000176   2000               MOVS     R0,R4
   \   00000178   ........           BL       UDP_ConfigureEndpoint
    836          
    837                      // Flush and enable the Suspend interrupt
    838                      SET(pInterface->UDP_ICR,
    839                          AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM | AT91C_UDP_RXSUSP);
   \   0000017C   286A               LDR      R0,[R5, #+32]
   \   0000017E   8C21               MOVS     R1,#+140
   \   00000180   8901               LSLS     R1,R1,#+6        ;; #+8960
   \   00000182   0143               ORRS     R1,R1,R0
   \   00000184   2962               STR      R1,[R5, #+32]
    840          
    841                      // Enable the Start Of Frame (SOF) interrupt if needed
    842                      if (pUsb->pCallbacks->startOfFrame != 0) {
   \   00000186   E168               LDR      R1,[R4, #+12]
   \   00000188   4869               LDR      R0,[R1, #+20]
   \   0000018A   0028               CMP      R0,#+0
   \   0000018C   04D0               BEQ      ??UDP_Handler_16
    843          
    844                          SET(pInterface->UDP_IER, AT91C_UDP_SOFINT);
   \   0000018E   2869               LDR      R0,[R5, #+16]
   \   00000190   8022               MOVS     R2,#+128
   \   00000192   1201               LSLS     R2,R2,#+4        ;; #+2048
   \   00000194   0243               ORRS     R2,R2,R0
   \   00000196   2A61               STR      R2,[R5, #+16]
    845                      }
    846          
    847                      // Invoke the Reset callback
    848                      USB_ResetCallback(pUsb);
   \                     ??UDP_Handler_16:
   \   00000198   4868               LDR      R0,[R1, #+4]
   \   0000019A   0028               CMP      R0,#+0
   \   0000019C   03D0               BEQ      ??UDP_Handler_17
   \   0000019E   2000               MOVS     R0,R4
   \   000001A0   4968               LDR      R1,[R1, #+4]
   \   000001A2   ........           BL       __iar_via_R1
    849          
    850                      // Acknowledge end of bus reset interrupt
    851                      SET(pInterface->UDP_ICR, AT91C_UDP_ENDBUSRES);
   \                     ??UDP_Handler_17:
   \   000001A6   286A               LDR      R0,[R5, #+32]
   \   000001A8   8021               MOVS     R1,#+128
   \   000001AA   4901               LSLS     R1,R1,#+5        ;; #+4096
   \   000001AC   0143               ORRS     R1,R1,R0
   \   000001AE   2962               STR      R1,[R5, #+32]
   \   000001B0   34E0               B        ??UDP_Handler_6
    852                  }
    853                  // Endpoint interrupts
    854                  else {
    855                                                                                                                                                     
    856                      while (dStatus != 0) 
    857                      {
    858                                                                                          //TRACE_DEBUG_L("E_it ");   
    859                          // Get endpoint index
    860                          bEndpoint = lastSetBit(dStatus);
   \                     ??UDP_Handler_18:
   \   000001B2   3900               MOVS     R1,R7
   \   000001B4   0020               MOVS     R0,#+0
   \   000001B6   C043               MVNS     R0,R0            ;; #-1
   \   000001B8   0A0C               LSRS     R2,R1,#+16
   \   000001BA   1204               LSLS     R2,R2,#+16
   \   000001BC   01D0               BEQ      ??UDP_Handler_19
   \   000001BE   0F20               MOVS     R0,#+15
   \   000001C0   090C               LSRS     R1,R1,#+16
   \                     ??UDP_Handler_19:
   \   000001C2   FF22               MOVS     R2,#+255
   \   000001C4   1202               LSLS     R2,R2,#+8        ;; #+65280
   \   000001C6   1142               TST      R1,R2
   \   000001C8   03D0               BEQ      ??UDP_Handler_20
   \   000001CA   0830               ADDS     R0,R0,#+8
   \   000001CC   0006               LSLS     R0,R0,#+24
   \   000001CE   0016               ASRS     R0,R0,#+24
   \   000001D0   090A               LSRS     R1,R1,#+8
   \                     ??UDP_Handler_20:
   \   000001D2   F023               MOVS     R3,#+240
   \   000001D4   1942               TST      R1,R3
   \   000001D6   03D0               BEQ      ??UDP_Handler_21
   \   000001D8   001D               ADDS     R0,R0,#+4
   \   000001DA   0006               LSLS     R0,R0,#+24
   \   000001DC   0016               ASRS     R0,R0,#+24
   \   000001DE   0909               LSRS     R1,R1,#+4
   \                     ??UDP_Handler_21:
   \   000001E0   0C23               MOVS     R3,#+12
   \   000001E2   1942               TST      R1,R3
   \   000001E4   03D0               BEQ      ??UDP_Handler_22
   \   000001E6   801C               ADDS     R0,R0,#+2
   \   000001E8   0006               LSLS     R0,R0,#+24
   \   000001EA   0016               ASRS     R0,R0,#+24
   \   000001EC   8908               LSRS     R1,R1,#+2
   \                     ??UDP_Handler_22:
   \   000001EE   0223               MOVS     R3,#+2
   \   000001F0   1942               TST      R1,R3
   \   000001F2   03D0               BEQ      ??UDP_Handler_23
   \   000001F4   401C               ADDS     R0,R0,#+1
   \   000001F6   0006               LSLS     R0,R0,#+24
   \   000001F8   0016               ASRS     R0,R0,#+24
   \   000001FA   4908               LSRS     R1,R1,#+1
   \                     ??UDP_Handler_23:
   \   000001FC   C907               LSLS     R1,R1,#+31
   \   000001FE   00D5               BPL      ??UDP_Handler_24
   \   00000200   401C               ADDS     R0,R0,#+1
   \                     ??UDP_Handler_24:
   \   00000202   0006               LSLS     R0,R0,#+24
   \   00000204   000E               LSRS     R0,R0,#+24
   \   00000206   0090               STR      R0,[SP, #+0]
    861                          UDP_EndpointHandler(pUsb, bEndpoint);
   \   00000208   0100               MOVS     R1,R0
   \   0000020A   2000               MOVS     R0,R4
   \   0000020C   ........           BL       UDP_EndpointHandler
    862                                                                                          
    863                          /*CLEAR(pInterface->UDP_CSR[bEndpoint],
    864                                AT91C_UDP_TXCOMP | AT91C_UDP_RX_DATA_BK0
    865                              | AT91C_UDP_RX_DATA_BK1 | AT91C_UDP_RXSETUP
    866                              | AT91C_UDP_STALLSENT);*/
    867          
    868                          CLEAR(dStatus, 1 << bEndpoint);
   \   00000210   0120               MOVS     R0,#+1
   \   00000212   0099               LDR      R1,[SP, #+0]
   \   00000214   8840               LSLS     R0,R0,R1
   \   00000216   8743               BICS     R7,R7,R0
    869          
    870                          if (dStatus != 0) {
    871                                                                                          
    872                                                                                          //TRACE_DEBUG_L("\n\r  - ");
    873          
    874                          }
    875                      }
   \                     ??UDP_Handler_11:
   \   00000218   002F               CMP      R7,#+0
   \   0000021A   CAD1               BNE      ??UDP_Handler_18
    876                                                                                         
    877                  }
    878                  
    879                                                                                         
    880                  
    881          
    882                  // Retrieve new interrupt status
    883                  dStatus = pInterface->UDP_ISR & pInterface->UDP_IMR & ISR_MASK;
   \                     ??UDP_Handler_6:
   \   0000021C   A869               LDR      R0,[R5, #+24]
   \   0000021E   E969               LDR      R1,[R5, #+28]
   \   00000220   0140               ANDS     R1,R1,R0
   \   00000222   8F04               LSLS     R7,R1,#+18
   \   00000224   BF0C               LSRS     R7,R7,#+18
    884          
    885                  // Mask unneeded interrupts
    886                  if (!ISSET(USB_GetState(pUsb), USB_STATE_DEFAULT)) {
   \   00000226   6069               LDR      R0,[R4, #+20]
   \   00000228   0068               LDR      R0,[R0, #+0]
   \   0000022A   0421               MOVS     R1,#+4
   \   0000022C   0842               TST      R0,R1
   \   0000022E   03D1               BNE      ??UDP_Handler_25
    887          
    888                      dStatus &= AT91C_UDP_ENDBUSRES | AT91C_UDP_SOFINT;
   \   00000230   3800               MOVS     R0,R7
   \   00000232   C027               MOVS     R7,#+192
   \   00000234   7F01               LSLS     R7,R7,#+5        ;; #+6144
   \   00000236   0740               ANDS     R7,R7,R0
    889                  }
    890                                                                                         
    891                  //TRACE_DEBUG_L("\n\r");
    892                                                                                          
    893                  if (dStatus != 0) {
    894          
    895                                                                                          //TRACE_DEBUG_L("  - ");
    896                  }
    897              }
   \                     ??UDP_Handler_25:
   \   00000238   002F               CMP      R7,#+0
   \   0000023A   00D0               BEQ      .+4
   \   0000023C   F2E6               B        ??UDP_Handler_2
    898          
    899              if ( (!ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED))
    900                 && (ISSET(USB_GetState(pUsb), USB_STATE_POWERED))){
   \                     ??UDP_Handler_1:
   \   0000023E   6069               LDR      R0,[R4, #+20]
   \   00000240   0168               LDR      R1,[R0, #+0]
   \   00000242   2022               MOVS     R2,#+32
   \   00000244   1142               TST      R1,R2
   \   00000246   00D1               BNE      ??UDP_Handler_26
   \   00000248   0068               LDR      R0,[R0, #+0]
    901          
    902                  LED_TOGGLE(LED_USB);
    903              }
    904              
    905                                                                                         //TRACE_DEBUG_L("KON_Hdl ");
    906                                                                                         //TRACE_DEBUG_L("\n\r");
    907              
    908          }
   \                     ??UDP_Handler_26:
   \   0000024A   F8BC               POP      {R3-R7}
   \   0000024C   01BC               POP      {R0}
   \   0000024E   0047               BX       R0               ;; return
   \                     ??UDP_Handler_4:
   \   00000250   FFF7FFFF           DC32     0xfffff7ff
   \   00000254   14FCFFFF           DC32     0xfffffc14
   \   00000258   04FCFFFF           DC32     0xfffffc04
   \   0000025C   10FCFFFF           DC32     0xfffffc10
   \   00000260   00FCFFFF           DC32     0xfffffc00
   \   00000264   FFFEFFFF           DC32     0xfffffeff
    909          
    910          //------------------------------------------------------------------------------
    911          // \brief  Sends data through an USB endpoint
    912          //
    913          //         Sets up the transfer descriptor, write one or two data payloads
    914          //         (depending on the number of FIFO banks for the endpoint) and then
    915          //         starts the actual transfer. The operation is complete when all
    916          //         the data has been sent.
    917          // \param  pUsb      Pointer to a S_usb instance
    918          // \param  bEndpoint Index of endpoint
    919          // \param  pData     Pointer to a buffer containing the data to send
    920          // \param  dLength   Length of the data buffer
    921          // \param  fCallback Optional function to invoke when the transfer finishes
    922          // \param  pArgument Optional argument for the callback function
    923          // \return Operation result code
    924          // \see    Operation result codes
    925          // \see    Callback_f
    926          // \see    S_usb
    927          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    928          char UDP_Write(const S_usb   *pUsb,
    929                         unsigned char bEndpoint,
    930                         const void    *pData,
    931                         unsigned int  dLength,
    932                         Callback_f    fCallback,
    933                         void          *pArgument)
    934          {
   \                     UDP_Write:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   0698               LDR      R0,[SP, #+24]
   \   00000008   0799               LDR      R1,[SP, #+28]
    935              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   0000000A   A668               LDR      R6,[R4, #+8]
   \   0000000C   B542               CMP      R5,R6
   \   0000000E   01D3               BCC      ??UDP_Write_0
   \   00000010   0026               MOVS     R6,#+0
   \   00000012   03E0               B        ??UDP_Write_1
   \                     ??UDP_Write_0:
   \   00000014   2826               MOVS     R6,#+40
   \   00000016   6E43               MULS     R6,R5,R6
   \   00000018   6768               LDR      R7,[R4, #+4]
   \   0000001A   BE19               ADDS     R6,R7,R6
    936              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \                     ??UDP_Write_1:
   \   0000001C   2768               LDR      R7,[R4, #+0]
   \   0000001E   3F68               LDR      R7,[R7, #+0]
   \   00000020   0097               STR      R7,[SP, #+0]
   \   00000022   3700               MOVS     R7,R6
   \   00000024   2037               ADDS     R7,R7,#+32
   \   00000026   7F68               LDR      R7,[R7, #+4]
   \   00000028   012F               CMP      R7,#+1
   \   0000002A   01D0               BEQ      ??UDP_Write_2
    937          
    938              // Check that the endpoint is in Idle state
    939              if (pEndpoint->dState != endpointStateIdle) {
    940          
    941                  return USB_STATUS_LOCKED;
   \   0000002C   0120               MOVS     R0,#+1
   \   0000002E   30E0               B        ??UDP_Write_3
    942              }
    943          
    944                                                                                         // TRACE_DEBUG_L("Write%d(%d) ", bEndpoint, dLength);
    945          
    946              // Setup the transfer descriptor
    947              pEndpoint->pData = (char *) pData;
   \                     ??UDP_Write_2:
   \   00000030   3260               STR      R2,[R6, #+0]
    948              pEndpoint->dBytesRemaining = dLength;
   \   00000032   7360               STR      R3,[R6, #+4]
    949              pEndpoint->dBytesBuffered = 0;
   \   00000034   0022               MOVS     R2,#+0
   \   00000036   B260               STR      R2,[R6, #+8]
    950              pEndpoint->dBytesTransferred = 0;
   \   00000038   F260               STR      R2,[R6, #+12]
    951              pEndpoint->fCallback = fCallback;
   \   0000003A   3061               STR      R0,[R6, #+16]
    952              pEndpoint->pArgument = pArgument;
   \   0000003C   7161               STR      R1,[R6, #+20]
    953          
    954              // Send one packet
    955              pEndpoint->dState = endpointStateWrite;
   \   0000003E   3000               MOVS     R0,R6
   \   00000040   2030               ADDS     R0,R0,#+32
   \   00000042   0221               MOVS     R1,#+2
   \   00000044   4160               STR      R1,[R0, #+4]
    956              UDP_WritePayload(pUsb, bEndpoint);
   \   00000046   2900               MOVS     R1,R5
   \   00000048   2000               MOVS     R0,R4
   \   0000004A   ........           BL       UDP_WritePayload
   \   0000004E   A800               LSLS     R0,R5,#+2
   \   00000050   06E0               B        ??UDP_Write_4
    957              UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_TXPKTRDY);
   \                     ??UDP_Write_5:
   \   00000052   1A68               LDR      R2,[R3, #+0]
   \   00000054   1218               ADDS     R2,R2,R0
   \   00000056   1B68               LDR      R3,[R3, #+0]
   \   00000058   1B18               ADDS     R3,R3,R0
   \   0000005A   1B6B               LDR      R3,[R3, #+48]
   \   0000005C   1943               ORRS     R1,R1,R3
   \   0000005E   1163               STR      R1,[R2, #+48]
   \                     ??UDP_Write_4:
   \   00000060   2368               LDR      R3,[R4, #+0]
   \   00000062   1021               MOVS     R1,#+16
   \   00000064   1A68               LDR      R2,[R3, #+0]
   \   00000066   1218               ADDS     R2,R2,R0
   \   00000068   126B               LDR      R2,[R2, #+48]
   \   0000006A   0A42               TST      R2,R1
   \   0000006C   F1D0               BEQ      ??UDP_Write_5
    958          
    959              // If double buffering is enabled and there is data remaining,
    960              // prepare another packet
    961              if ((pEndpoint->dNumFIFO > 1) && (pEndpoint->dBytesRemaining > 0)) {
   \   0000006E   2020               MOVS     R0,#+32
   \   00000070   305C               LDRB     R0,[R6, R0]
   \   00000072   0228               CMP      R0,#+2
   \   00000074   06D3               BCC      ??UDP_Write_6
   \   00000076   7068               LDR      R0,[R6, #+4]
   \   00000078   0028               CMP      R0,#+0
   \   0000007A   03D0               BEQ      ??UDP_Write_6
    962          
    963                  UDP_WritePayload(pUsb, bEndpoint);
   \   0000007C   2900               MOVS     R1,R5
   \   0000007E   2000               MOVS     R0,R4
   \   00000080   ........           BL       UDP_WritePayload
    964              }
    965          
    966              // Enable interrupt on endpoint
    967              SET(pInterface->UDP_IER, 1 << bEndpoint);
   \                     ??UDP_Write_6:
   \   00000084   0098               LDR      R0,[SP, #+0]
   \   00000086   0169               LDR      R1,[R0, #+16]
   \   00000088   0122               MOVS     R2,#+1
   \   0000008A   AA40               LSLS     R2,R2,R5
   \   0000008C   0A43               ORRS     R2,R2,R1
   \   0000008E   0261               STR      R2,[R0, #+16]
    968                                                                                         //TRACE_DEBUG_L("KON_USB_Write ");
    969                                                                                         //TRACE_DEBUG_L("\n\r");
    970              return USB_STATUS_SUCCESS;
   \   00000090   0020               MOVS     R0,#+0
   \                     ??UDP_Write_3:
   \   00000092   F8BC               POP      {R3-R7}
   \   00000094   02BC               POP      {R1}
   \   00000096   0847               BX       R1               ;; return
    971              
    972              
    973          }
    974          
    975          //------------------------------------------------------------------------------
    976          // \brief  Reads incoming data on an USB endpoint
    977          //
    978          //         This methods sets the transfer descriptor and activate the endpoint
    979          //         interrupt. The actual transfer is then carried out by the endpoint
    980          //         interrupt handler. The Read operation finishes either when the
    981          //         buffer is full, or a short packet (inferior to endpoint maximum
    982          //         packet size) is received.
    983          // \param  pUsb      Pointer to a S_usb instance
    984          // \param  bEndpoint Index of endpoint
    985          // \param  pData     Pointer to a buffer to store the received data
    986          // \param  dLength   Length of the receive buffer
    987          // \param  fCallback Optional callback function
    988          // \param  pArgument Optional callback argument
    989          // \return Operation result code
    990          // \see    Callback_f
    991          // \see    S_usb
    992          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    993          char UDP_Read(const S_usb   *pUsb,
    994                        unsigned char bEndpoint,
    995                        void          *pData,
    996                        unsigned int  dLength,
    997                        Callback_f    fCallback,
    998                        void          *pArgument)
    999          {
   \                     UDP_Read:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   069C               LDR      R4,[SP, #+24]
   \   00000004   079D               LDR      R5,[SP, #+28]
   1000              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000006   0668               LDR      R6,[R0, #+0]
   \   00000008   3668               LDR      R6,[R6, #+0]
   1001              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   0000000A   8768               LDR      R7,[R0, #+8]
   \   0000000C   B942               CMP      R1,R7
   \   0000000E   01D3               BCC      ??UDP_Read_0
   \   00000010   0020               MOVS     R0,#+0
   \   00000012   03E0               B        ??UDP_Read_1
   \                     ??UDP_Read_0:
   \   00000014   2827               MOVS     R7,#+40
   \   00000016   4F43               MULS     R7,R1,R7
   \   00000018   4068               LDR      R0,[R0, #+4]
   \   0000001A   C019               ADDS     R0,R0,R7
   1002          
   1003              //! Return if the endpoint is not in IDLE state
   1004              if (pEndpoint->dState != endpointStateIdle) {
   \                     ??UDP_Read_1:
   \   0000001C   476A               LDR      R7,[R0, #+36]
   \   0000001E   012F               CMP      R7,#+1
   \   00000020   01D0               BEQ      ??UDP_Read_2
   1005          
   1006                  return USB_STATUS_LOCKED;
   \   00000022   0120               MOVS     R0,#+1
   \   00000024   0EE0               B        ??UDP_Read_3
   1007              }
   1008          
   1009                                                                                          //TRACE_DEBUG_L("Read%d(%d) ", bEndpoint, dLength);
   1010              // Endpoint enters Read state
   1011              pEndpoint->dState = endpointStateRead;
   \                     ??UDP_Read_2:
   \   00000026   0327               MOVS     R7,#+3
   \   00000028   4762               STR      R7,[R0, #+36]
   1012          
   1013              // Set the transfer descriptor
   1014              pEndpoint->pData = (char *) pData;
   \   0000002A   0260               STR      R2,[R0, #+0]
   1015              pEndpoint->dBytesRemaining = dLength;
   \   0000002C   4360               STR      R3,[R0, #+4]
   1016              pEndpoint->dBytesBuffered = 0;
   \   0000002E   0022               MOVS     R2,#+0
   \   00000030   8260               STR      R2,[R0, #+8]
   1017              pEndpoint->dBytesTransferred = 0;
   \   00000032   C260               STR      R2,[R0, #+12]
   1018              pEndpoint->fCallback = fCallback;
   \   00000034   0461               STR      R4,[R0, #+16]
   1019              pEndpoint->pArgument = pArgument;
   \   00000036   4561               STR      R5,[R0, #+20]
   1020          
   1021              // Enable interrupt on endpoint
   1022              SET(pInterface->UDP_IER, 1 << bEndpoint);
   \   00000038   3069               LDR      R0,[R6, #+16]
   \   0000003A   0122               MOVS     R2,#+1
   \   0000003C   8A40               LSLS     R2,R2,R1
   \   0000003E   0243               ORRS     R2,R2,R0
   \   00000040   3261               STR      R2,[R6, #+16]
   1023              
   1024              //znak=USB_STATUS_SUCCESS;
   1025                                                                                         //TRACE_DEBUG_L("KON_USB_Read ");
   1026                                                                                         //TRACE_DEBUG_L("\n\r");
   1027                                                                                        
   1028              return USB_STATUS_SUCCESS;
   \   00000042   0020               MOVS     R0,#+0
   \                     ??UDP_Read_3:
   \   00000044   F8BC               POP      {R3-R7}
   \   00000046   02BC               POP      {R1}
   \   00000048   0847               BX       R1               ;; return
   1029          }
   1030          
   1031          //------------------------------------------------------------------------------
   1032          // \brief  Clears, sets or returns the Halt state on specified endpoint
   1033          //
   1034          //         When in Halt state, an endpoint acknowledges every received packet
   1035          //         with a STALL handshake. This continues until the endpoint is
   1036          //         manually put out of the Halt state by calling this function.
   1037          // \param  pUsb Pointer to a S_usb instance
   1038          // \param  bEndpoint Index of endpoint
   1039          // \param  bRequest  Request to perform
   1040          //                   -> USB_SET_FEATURE, USB_CLEAR_FEATURE, USB_GET_STATUS
   1041          // \return true if the endpoint is currently Halted, false otherwise
   1042          // \see    S_usb
   1043          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1044          bool UDP_Halt(const S_usb   *pUsb,
   1045                        unsigned char bEndpoint,
   1046                        unsigned char bRequest)
   1047          {
   \                     UDP_Halt:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0C00               MOVS     R4,R1
   1048              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   0568               LDR      R5,[R0, #+0]
   1049              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   00000008   0099               LDR      R1,[SP, #+0]
   \   0000000A   8968               LDR      R1,[R1, #+8]
   \   0000000C   8C42               CMP      R4,R1
   \   0000000E   01D3               BCC      ??UDP_Halt_0
   \   00000010   0026               MOVS     R6,#+0
   \   00000012   04E0               B        ??UDP_Halt_1
   \                     ??UDP_Halt_0:
   \   00000014   2821               MOVS     R1,#+40
   \   00000016   6143               MULS     R1,R4,R1
   \   00000018   009B               LDR      R3,[SP, #+0]
   \   0000001A   5B68               LDR      R3,[R3, #+4]
   \   0000001C   5E18               ADDS     R6,R3,R1
   1050          
   1051              // Clear the Halt feature of the endpoint if it is enabled
   1052              if (bRequest == USB_CLEAR_FEATURE) {
   \                     ??UDP_Halt_1:
   \   0000001E   012A               CMP      R2,#+1
   \   00000020   19D1               BNE      ??UDP_Halt_2
   1053          
   1054                                                                                          TRACE_DEBUG_L("Unhalt%d ", bEndpoint);
   1055          
   1056                  // Return endpoint to Idle state
   1057                  pEndpoint->dState = endpointStateIdle;
   \   00000022   0121               MOVS     R1,#+1
   \   00000024   7162               STR      R1,[R6, #+36]
   \   00000026   A100               LSLS     R1,R4,#+2
   \   00000028   2022               MOVS     R2,#+32
   \   0000002A   D243               MVNS     R2,R2            ;; #-33
   \   0000002C   04E0               B        ??UDP_Halt_3
   1058          
   1059                  // Clear FORCESTALL flag
   1060                  UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_FORCESTALL);
   \                     ??UDP_Halt_4:
   \   0000002E   0368               LDR      R3,[R0, #+0]
   \   00000030   5B18               ADDS     R3,R3,R1
   \   00000032   1F6B               LDR      R7,[R3, #+48]
   \   00000034   1740               ANDS     R7,R7,R2
   \   00000036   1F63               STR      R7,[R3, #+48]
   \                     ??UDP_Halt_3:
   \   00000038   0368               LDR      R3,[R0, #+0]
   \   0000003A   5B18               ADDS     R3,R3,R1
   \   0000003C   1B6B               LDR      R3,[R3, #+48]
   \   0000003E   2027               MOVS     R7,#+32
   \   00000040   3B42               TST      R3,R7
   \   00000042   F4D1               BNE      ??UDP_Halt_4
   1061          
   1062                  // Reset Endpoint Fifos, beware this is a 2 steps operation
   1063                  SET(pInterface->UDP_RSTEP, 1 << bEndpoint);
   \   00000044   0120               MOVS     R0,#+1
   \   00000046   A040               LSLS     R0,R0,R4
   \   00000048   A96A               LDR      R1,[R5, #+40]
   \   0000004A   0143               ORRS     R1,R1,R0
   \   0000004C   A962               STR      R1,[R5, #+40]
   1064                  CLEAR(pInterface->UDP_RSTEP, 1 << bEndpoint);
   \   0000004E   A96A               LDR      R1,[R5, #+40]
   \   00000050   8143               BICS     R1,R1,R0
   \   00000052   A962               STR      R1,[R5, #+40]
   \   00000054   24E0               B        ??UDP_Halt_5
   1065              }
   1066              // Set the Halt feature on the endpoint if it is not already enabled
   1067              // and the endpoint is not disabled
   1068              else if ((bRequest == USB_SET_FEATURE)
   1069                       && (pEndpoint->dState != endpointStateHalted)
   1070                       && (pEndpoint->dState != endpointStateDisabled)) {
   \                     ??UDP_Halt_2:
   \   00000056   032A               CMP      R2,#+3
   \   00000058   22D1               BNE      ??UDP_Halt_5
   \   0000005A   706A               LDR      R0,[R6, #+36]
   \   0000005C   0428               CMP      R0,#+4
   \   0000005E   1FD0               BEQ      ??UDP_Halt_5
   \   00000060   706A               LDR      R0,[R6, #+36]
   \   00000062   0028               CMP      R0,#+0
   \   00000064   1CD0               BEQ      ??UDP_Halt_5
   1071          
   1072                                                                                          TRACE_DEBUG_L("Halt%d ", bEndpoint);
   1073          
   1074                  // Abort the current transfer if necessary
   1075                  UDP_EndOfTransfer(pEndpoint, USB_STATUS_ABORTED);
   \   00000066   0221               MOVS     R1,#+2
   \   00000068   3000               MOVS     R0,R6
   \   0000006A   ........           BL       UDP_EndOfTransfer
   \   0000006E   A100               LSLS     R1,R4,#+2
   \   00000070   2020               MOVS     R0,#+32
   \   00000072   2027               MOVS     R7,#+32
   \   00000074   06E0               B        ??UDP_Halt_6
   1076          
   1077                  // Put endpoint into Halt state
   1078                  UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_FORCESTALL);
   \                     ??UDP_Halt_7:
   \   00000076   1A68               LDR      R2,[R3, #+0]
   \   00000078   5218               ADDS     R2,R2,R1
   \   0000007A   1B68               LDR      R3,[R3, #+0]
   \   0000007C   5B18               ADDS     R3,R3,R1
   \   0000007E   1B6B               LDR      R3,[R3, #+48]
   \   00000080   0343               ORRS     R3,R3,R0
   \   00000082   1363               STR      R3,[R2, #+48]
   \                     ??UDP_Halt_6:
   \   00000084   009A               LDR      R2,[SP, #+0]
   \   00000086   1368               LDR      R3,[R2, #+0]
   \   00000088   1A68               LDR      R2,[R3, #+0]
   \   0000008A   5218               ADDS     R2,R2,R1
   \   0000008C   126B               LDR      R2,[R2, #+48]
   \   0000008E   3A42               TST      R2,R7
   \   00000090   F1D0               BEQ      ??UDP_Halt_7
   1079                  pEndpoint->dState = endpointStateHalted;
   \   00000092   0420               MOVS     R0,#+4
   \   00000094   7062               STR      R0,[R6, #+36]
   1080          
   1081                  // Enable the endpoint interrupt
   1082                  SET(pInterface->UDP_IER, 1 << bEndpoint);
   \   00000096   2869               LDR      R0,[R5, #+16]
   \   00000098   0121               MOVS     R1,#+1
   \   0000009A   A140               LSLS     R1,R1,R4
   \   0000009C   0143               ORRS     R1,R1,R0
   \   0000009E   2961               STR      R1,[R5, #+16]
   1083              }
   1084          
   1085              // Return the endpoint halt status
   1086              if (pEndpoint->dState == endpointStateHalted) {
   \                     ??UDP_Halt_5:
   \   000000A0   706A               LDR      R0,[R6, #+36]
   \   000000A2   0428               CMP      R0,#+4
   \   000000A4   01D1               BNE      ??UDP_Halt_8
   1087          
   1088                  return true;
   \   000000A6   0120               MOVS     R0,#+1
   \   000000A8   00E0               B        ??UDP_Halt_9
   1089              }
   1090              else {
   1091          
   1092                  return false;
   \                     ??UDP_Halt_8:
   \   000000AA   0020               MOVS     R0,#+0
   \                     ??UDP_Halt_9:
   \   000000AC   F8BC               POP      {R3-R7}
   \   000000AE   02BC               POP      {R1}
   \   000000B0   0847               BX       R1               ;; return
   1093              }
   1094          }
   1095          
   1096          //------------------------------------------------------------------------------
   1097          // \brief  Causes the endpoint to acknowledge the next received packet with
   1098          //         a STALL handshake.
   1099          //
   1100          //         Further packets are then handled normally.
   1101          // \param  pUsb      Pointer to a S_usb instance
   1102          // \param  bEndpoint Index of endpoint
   1103          // \return Operation result code
   1104          // \see    S_usb
   1105          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1106          char UDP_Stall(const S_usb *pUsb,
   1107                         unsigned char bEndpoint)
   1108          {
   \                     UDP_Stall:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   1109              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   00000002   8268               LDR      R2,[R0, #+8]
   \   00000004   9142               CMP      R1,R2
   \   00000006   01D3               BCC      ??UDP_Stall_0
   \   00000008   0022               MOVS     R2,#+0
   \   0000000A   03E0               B        ??UDP_Stall_1
   \                     ??UDP_Stall_0:
   \   0000000C   2822               MOVS     R2,#+40
   \   0000000E   4A43               MULS     R2,R1,R2
   \   00000010   4368               LDR      R3,[R0, #+4]
   \   00000012   9A18               ADDS     R2,R3,R2
   1110          
   1111              // Check that endpoint is in Idle state
   1112              if (pEndpoint->dState != endpointStateIdle) {
   \                     ??UDP_Stall_1:
   \   00000014   526A               LDR      R2,[R2, #+36]
   \   00000016   012A               CMP      R2,#+1
   \   00000018   08D0               BEQ      ??UDP_Stall_2
   1113          
   1114                  TRACE_WARNING("W: UDP_Stall: Endpoint%d locked\n\r", bEndpoint);
   1115                  return USB_STATUS_LOCKED;
   \   0000001A   0120               MOVS     R0,#+1
   \   0000001C   0FE0               B        ??UDP_Stall_3
   1116              }
   1117          
   1118                                                                                          TRACE_DEBUG_L("Stall%d ", bEndpoint);
   1119          
   1120              UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_FORCESTALL);
   \                     ??UDP_Stall_4:
   \   0000001E   2B68               LDR      R3,[R5, #+0]
   \   00000020   1B19               ADDS     R3,R3,R4
   \   00000022   2D68               LDR      R5,[R5, #+0]
   \   00000024   2C19               ADDS     R4,R5,R4
   \   00000026   246B               LDR      R4,[R4, #+48]
   \   00000028   2243               ORRS     R2,R2,R4
   \   0000002A   1A63               STR      R2,[R3, #+48]
   \                     ??UDP_Stall_2:
   \   0000002C   8C00               LSLS     R4,R1,#+2
   \   0000002E   0568               LDR      R5,[R0, #+0]
   \   00000030   2022               MOVS     R2,#+32
   \   00000032   2B68               LDR      R3,[R5, #+0]
   \   00000034   1B19               ADDS     R3,R3,R4
   \   00000036   1B6B               LDR      R3,[R3, #+48]
   \   00000038   1342               TST      R3,R2
   \   0000003A   F0D0               BEQ      ??UDP_Stall_4
   1121          
   1122              return USB_STATUS_SUCCESS;
   \   0000003C   0020               MOVS     R0,#+0
   \                     ??UDP_Stall_3:
   \   0000003E   70BC               POP      {R4-R6}
   \   00000040   02BC               POP      {R1}
   \   00000042   0847               BX       R1               ;; return
   1123          }
   1124          
   1125          //------------------------------------------------------------------------------
   1126          // \brief  Activates a remote wakeup procedure
   1127          // \param  pUsb Pointer to a S_usb instance
   1128          // \see    S_usb
   1129          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1130          void UDP_RemoteWakeUp(const S_usb *pUsb)
   1131          {
   \                     UDP_RemoteWakeUp:
   \   00000000   11B4               PUSH     {R0,R4}
   1132              AT91PS_UDP pInterface = UDP_GetDriverInterface(pUsb);
   \   00000002   0168               LDR      R1,[R0, #+0]
   \   00000004   0868               LDR      R0,[R1, #+0]
   1133          
   1134              UDP_EnableMCK(pUsb);
   \   00000006   0C4A               LDR      R2,??UDP_RemoteWakeUp_0  ;; 0xfffffc10
   \   00000008   0123               MOVS     R3,#+1
   \   0000000A   CC68               LDR      R4,[R1, #+12]
   \   0000000C   A340               LSLS     R3,R3,R4
   \   0000000E   1360               STR      R3,[R2, #+0]
   1135              UDP_EnableUDPCK(pUsb);
   \   00000010   0A4A               LDR      R2,??UDP_RemoteWakeUp_0+0x4  ;; 0xfffffc00
   \   00000012   1368               LDR      R3,[R2, #+0]
   \   00000014   0C69               LDR      R4,[R1, #+16]
   \   00000016   1C43               ORRS     R4,R4,R3
   \   00000018   1460               STR      R4,[R2, #+0]
   1136              UDP_EnableTransceiver(pUsb);
   \   0000001A   0968               LDR      R1,[R1, #+0]
   \   0000001C   4A6F               LDR      R2,[R1, #+116]
   \   0000001E   084B               LDR      R3,??UDP_RemoteWakeUp_0+0x8  ;; 0xfffffeff
   \   00000020   1340               ANDS     R3,R3,R2
   \   00000022   4B67               STR      R3,[R1, #+116]
   1137          
   1138                                                                                          TRACE_DEBUG_L("Remote WakeUp ");
   1139          
   1140              // Activates a remote wakeup (edge on ESR)
   1141              SET(pInterface->UDP_GLBSTATE, AT91C_UDP_ESR);
   \   00000024   4168               LDR      R1,[R0, #+4]
   \   00000026   0422               MOVS     R2,#+4
   \   00000028   0A43               ORRS     R2,R2,R1
   \   0000002A   4260               STR      R2,[R0, #+4]
   1142              // Then clear ESR
   1143              CLEAR(pInterface->UDP_GLBSTATE, AT91C_UDP_ESR);
   \   0000002C   4168               LDR      R1,[R0, #+4]
   \   0000002E   0422               MOVS     R2,#+4
   \   00000030   9143               BICS     R1,R1,R2
   \   00000032   4160               STR      R1,[R0, #+4]
   1144          }
   \   00000034   18BC               POP      {R3,R4}
   \   00000036   7047               BX       LR               ;; return
   \                     ??UDP_RemoteWakeUp_0:
   \   00000038   10FCFFFF           DC32     0xfffffc10
   \   0000003C   00FCFFFF           DC32     0xfffffc00
   \   00000040   FFFEFFFF           DC32     0xfffffeff
   1145          
   1146          //------------------------------------------------------------------------------
   1147          // \brief  Handles attachment or detachment from the USB when the VBus power
   1148          //         line status changes.
   1149          // \param  pUsb Pointer to a S_usb instance
   1150          // \return true if VBus is present, false otherwise
   1151          // \see    S_usb
   1152          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1153          bool UDP_Attach(const S_usb *pUsb)
   1154          {
   \                     UDP_Attach:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   1155              AT91PS_UDP pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   2068               LDR      R0,[R4, #+0]
   \   00000006   0568               LDR      R5,[R0, #+0]
   1156          
   1157                                                                                          TRACE_DEBUG_L("Attach(");
   1158          
   1159              // Check if VBus is present
   1160              if (!ISSET(USB_GetState(pUsb), USB_STATE_POWERED)
   1161                  && BRD_IsVBusConnected(pInterface)) {
   \   00000008   6069               LDR      R0,[R4, #+20]
   \   0000000A   0068               LDR      R0,[R0, #+0]
   \   0000000C   0226               MOVS     R6,#+2
   \   0000000E   3042               TST      R0,R6
   \   00000010   33D1               BNE      ??UDP_Attach_0
   \   00000012   2800               MOVS     R0,R5
   \   00000014   ........           BL       BRD_IsVBusConnected
   \   00000018   0028               CMP      R0,#+0
   \   0000001A   2ED0               BEQ      ??UDP_Attach_0
   1162          
   1163                  // Powered state:
   1164                  //      MCK + UDPCK must be on
   1165                  //      Pull-Up must be connected
   1166                  //      Transceiver must be disabled
   1167          
   1168                  // Invoke the Resume callback
   1169                  USB_ResumeCallback(pUsb);
   \   0000001C   E168               LDR      R1,[R4, #+12]
   \   0000001E   C868               LDR      R0,[R1, #+12]
   \   00000020   0028               CMP      R0,#+0
   \   00000022   03D0               BEQ      ??UDP_Attach_1
   \   00000024   2000               MOVS     R0,R4
   \   00000026   C968               LDR      R1,[R1, #+12]
   \   00000028   ........           BL       __iar_via_R1
   1170          
   1171                  UDP_EnableMCK(pUsb);
   \                     ??UDP_Attach_1:
   \   0000002C   2168               LDR      R1,[R4, #+0]
   \   0000002E   3848               LDR      R0,??UDP_Attach_2  ;; 0xfffffc10
   \   00000030   0122               MOVS     R2,#+1
   \   00000032   CB68               LDR      R3,[R1, #+12]
   \   00000034   9A40               LSLS     R2,R2,R3
   \   00000036   0260               STR      R2,[R0, #+0]
   1172                  UDP_EnableUDPCK(pUsb);
   \   00000038   3648               LDR      R0,??UDP_Attach_2+0x4  ;; 0xfffffc00
   \   0000003A   0268               LDR      R2,[R0, #+0]
   \   0000003C   0B69               LDR      R3,[R1, #+16]
   \   0000003E   1343               ORRS     R3,R3,R2
   \   00000040   0360               STR      R3,[R0, #+0]
   1173          
   1174                  // Reconnect the pull-up if needed
   1175                  if (ISSET(*(pUsb->pState), UDP_STATE_SHOULD_RECONNECT)) {
   \   00000042   6069               LDR      R0,[R4, #+20]
   \   00000044   0068               LDR      R0,[R0, #+0]
   \   00000046   C000               LSLS     R0,R0,#+3
   \   00000048   09D5               BPL      ??UDP_Attach_3
   1176          
   1177                      USB_Connect(pUsb);
   \   0000004A   2000               MOVS     R0,R4
   \   0000004C   4969               LDR      R1,[R1, #+20]
   \   0000004E   C96A               LDR      R1,[R1, #+44]
   \   00000050   ........           BL       __iar_via_R1
   1178                      CLEAR(*(pUsb->pState), UDP_STATE_SHOULD_RECONNECT);
   \   00000054   6069               LDR      R0,[R4, #+20]
   \   00000056   0168               LDR      R1,[R0, #+0]
   \   00000058   2F4A               LDR      R2,??UDP_Attach_2+0x8  ;; 0xefffffff
   \   0000005A   0A40               ANDS     R2,R2,R1
   \   0000005C   0260               STR      R2,[R0, #+0]
   1179                  }
   1180          
   1181                  // Clear the Suspend and Resume interrupts
   1182                  SET(pInterface->UDP_ICR,
   1183                      AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM | AT91C_UDP_RXSUSP);
   \                     ??UDP_Attach_3:
   \   0000005E   286A               LDR      R0,[R5, #+32]
   \   00000060   8C21               MOVS     R1,#+140
   \   00000062   8901               LSLS     R1,R1,#+6        ;; #+8960
   \   00000064   0143               ORRS     R1,R1,R0
   \   00000066   2962               STR      R1,[R5, #+32]
   1184          
   1185                  SET(pInterface->UDP_IER, AT91C_UDP_RXSUSP);
   \   00000068   2869               LDR      R0,[R5, #+16]
   \   0000006A   F101               LSLS     R1,R6,#+7
   \   0000006C   0143               ORRS     R1,R1,R0
   \   0000006E   2961               STR      R1,[R5, #+16]
   1186          
   1187                  // The device is in Powered state
   1188                  SET(*(pUsb->pState), USB_STATE_POWERED);
   \   00000070   6069               LDR      R0,[R4, #+20]
   \   00000072   0168               LDR      R1,[R0, #+0]
   \   00000074   0E43               ORRS     R6,R6,R1
   \   00000076   0660               STR      R6,[R0, #+0]
   \   00000078   42E0               B        ??UDP_Attach_4
   1189          
   1190              }
   1191              else if (ISSET(USB_GetState(pUsb), USB_STATE_POWERED)
   1192                       && !BRD_IsVBusConnected(pInterface)) {
   \                     ??UDP_Attach_0:
   \   0000007A   6069               LDR      R0,[R4, #+20]
   \   0000007C   0068               LDR      R0,[R0, #+0]
   \   0000007E   3042               TST      R0,R6
   \   00000080   3ED0               BEQ      ??UDP_Attach_4
   \   00000082   2800               MOVS     R0,R5
   \   00000084   ........           BL       BRD_IsVBusConnected
   \   00000088   0028               CMP      R0,#+0
   \   0000008A   39D1               BNE      ??UDP_Attach_4
   1193          
   1194                  // Attached state:
   1195                  //      MCK + UDPCK off
   1196                  //      Pull-Up must be disconnected
   1197                  //      Transceiver must be disabled
   1198          
   1199                  // Warning: MCK must be enabled to be able to write in UDP registers
   1200                  // It may have been disabled by the Suspend interrupt, so re-enable it
   1201                  UDP_EnableMCK(pUsb);
   \   0000008C   2048               LDR      R0,??UDP_Attach_2  ;; 0xfffffc10
   \   0000008E   0121               MOVS     R1,#+1
   \   00000090   2268               LDR      R2,[R4, #+0]
   \   00000092   D268               LDR      R2,[R2, #+12]
   \   00000094   9140               LSLS     R1,R1,R2
   \   00000096   0160               STR      R1,[R0, #+0]
   1202          
   1203                  // Disable interrupts
   1204                  SET(pInterface->UDP_IDR, AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM
   1205                                         | AT91C_UDP_RXSUSP | AT91C_UDP_SOFINT);
   \   00000098   6869               LDR      R0,[R5, #+20]
   \   0000009A   AC21               MOVS     R1,#+172
   \   0000009C   8901               LSLS     R1,R1,#+6        ;; #+11008
   \   0000009E   0143               ORRS     R1,R1,R0
   \   000000A0   6961               STR      R1,[R5, #+20]
   1206          
   1207                  UDP_DisableEndpoints(pUsb);
   \   000000A2   2000               MOVS     R0,R4
   \   000000A4   ........           BL       UDP_DisableEndpoints
   1208                  UDP_DisableTransceiver(pUsb);
   \   000000A8   2168               LDR      R1,[R4, #+0]
   \   000000AA   0868               LDR      R0,[R1, #+0]
   \   000000AC   426F               LDR      R2,[R0, #+116]
   \   000000AE   F301               LSLS     R3,R6,#+7
   \   000000B0   1343               ORRS     R3,R3,R2
   \   000000B2   4367               STR      R3,[R0, #+116]
   1209          
   1210                  // Disconnect the pull-up if needed
   1211                  if (ISSET(USB_GetState(pUsb), USB_STATE_DEFAULT)) {
   \   000000B4   6069               LDR      R0,[R4, #+20]
   \   000000B6   0068               LDR      R0,[R0, #+0]
   \   000000B8   4007               LSLS     R0,R0,#+29
   \   000000BA   09D5               BPL      ??UDP_Attach_5
   1212          
   1213                      USB_Disconnect(pUsb);
   \   000000BC   2000               MOVS     R0,R4
   \   000000BE   4969               LDR      R1,[R1, #+20]
   \   000000C0   096B               LDR      R1,[R1, #+48]
   \   000000C2   ........           BL       __iar_via_R1
   1214                      SET(*(pUsb->pState), UDP_STATE_SHOULD_RECONNECT);
   \   000000C6   6069               LDR      R0,[R4, #+20]
   \   000000C8   0168               LDR      R1,[R0, #+0]
   \   000000CA   F206               LSLS     R2,R6,#+27
   \   000000CC   0A43               ORRS     R2,R2,R1
   \   000000CE   0260               STR      R2,[R0, #+0]
   1215                  }
   1216          
   1217                  UDP_DisableMCK(pUsb);
   \                     ??UDP_Attach_5:
   \   000000D0   2068               LDR      R0,[R4, #+0]
   \   000000D2   1249               LDR      R1,??UDP_Attach_2+0xC  ;; 0xfffffc14
   \   000000D4   0122               MOVS     R2,#+1
   \   000000D6   C368               LDR      R3,[R0, #+12]
   \   000000D8   9A40               LSLS     R2,R2,R3
   \   000000DA   0A60               STR      R2,[R1, #+0]
   1218                  UDP_DisableUDPCK(pUsb);
   \   000000DC   1049               LDR      R1,??UDP_Attach_2+0x10  ;; 0xfffffc04
   \   000000DE   0A68               LDR      R2,[R1, #+0]
   \   000000E0   0069               LDR      R0,[R0, #+16]
   \   000000E2   1043               ORRS     R0,R0,R2
   \   000000E4   0860               STR      R0,[R1, #+0]
   1219          
   1220                  // The device leaves the all states except Attached
   1221                  CLEAR(*(pUsb->pState), USB_STATE_POWERED | USB_STATE_DEFAULT
   1222                        | USB_STATE_ADDRESS | USB_STATE_CONFIGURED | USB_STATE_SUSPENDED);
   \   000000E6   6069               LDR      R0,[R4, #+20]
   \   000000E8   0168               LDR      R1,[R0, #+0]
   \   000000EA   3E22               MOVS     R2,#+62
   \   000000EC   9143               BICS     R1,R1,R2
   \   000000EE   0160               STR      R1,[R0, #+0]
   1223          
   1224                  // Invoke the Suspend callback
   1225                  USB_SuspendCallback(pUsb);
   \   000000F0   E168               LDR      R1,[R4, #+12]
   \   000000F2   8868               LDR      R0,[R1, #+8]
   \   000000F4   0028               CMP      R0,#+0
   \   000000F6   03D0               BEQ      ??UDP_Attach_4
   \   000000F8   2000               MOVS     R0,R4
   \   000000FA   8968               LDR      R1,[R1, #+8]
   \   000000FC   ........           BL       __iar_via_R1
   1226              }
   1227          
   1228                                                                                          TRACE_DEBUG_L("%d) ", ISSET(USB_GetState(pUsb), USB_STATE_POWERED));
   1229          
   1230              return (bool)(ISSET(USB_GetState(pUsb), USB_STATE_POWERED));
   \                     ??UDP_Attach_4:
   \   00000100   6069               LDR      R0,[R4, #+20]
   \   00000102   0068               LDR      R0,[R0, #+0]
   \   00000104   4108               LSRS     R1,R0,#+1
   \   00000106   0120               MOVS     R0,#+1
   \   00000108   0840               ANDS     R0,R0,R1
   \   0000010A   70BC               POP      {R4-R6}
   \   0000010C   02BC               POP      {R1}
   \   0000010E   0847               BX       R1               ;; return
   \                     ??UDP_Attach_2:
   \   00000110   10FCFFFF           DC32     0xfffffc10
   \   00000114   00FCFFFF           DC32     0xfffffc00
   \   00000118   FFFFFFEF           DC32     0xefffffff
   \   0000011C   14FCFFFF           DC32     0xfffffc14
   \   00000120   04FCFFFF           DC32     0xfffffc04
   1231          }
   1232          
   1233          //------------------------------------------------------------------------------
   1234          // \brief  Sets or unsets the device address
   1235          //
   1236          //         This function directly accesses the S_usb_request instance located
   1237          //         in the S_usb structure to extract its new address.
   1238          // \param  pUsb Pointer to a S_usb instance
   1239          // \see    S_usb
   1240          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1241          void UDP_SetAddress(S_usb const *pUsb)
   1242          {
   \                     UDP_SetAddress:
   \   00000000   10B5               PUSH     {R4,LR}
   1243              unsigned short wAddress = USB_GetSetup(pUsb)->wValue;
   \   00000002   0169               LDR      R1,[R0, #+16]
   \   00000004   4988               LDRH     R1,[R1, #+2]
   1244              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000006   0268               LDR      R2,[R0, #+0]
   \   00000008   1268               LDR      R2,[R2, #+0]
   1245          
   1246                                                                                          TRACE_DEBUG_L("SetAddr(%d) ", wAddress);
   1247          
   1248              // Set address
   1249              SET(pInterface->UDP_FADDR, AT91C_UDP_FEN | wAddress);
   \   0000000A   9368               LDR      R3,[R2, #+8]
   \   0000000C   8024               MOVS     R4,#+128
   \   0000000E   6400               LSLS     R4,R4,#+1        ;; #+256
   \   00000010   0C43               ORRS     R4,R4,R1
   \   00000012   1C43               ORRS     R4,R4,R3
   \   00000014   9460               STR      R4,[R2, #+8]
   1250          
   1251              if (wAddress == 0) {
   \   00000016   0029               CMP      R1,#+0
   \   00000018   5168               LDR      R1,[R2, #+4]
   \   0000001A   06D1               BNE      ??UDP_SetAddress_0
   1252          
   1253                  SET(pInterface->UDP_GLBSTATE, 0);
   \   0000001C   5160               STR      R1,[R2, #+4]
   1254          
   1255                  // Device enters the Default state
   1256                  CLEAR(*(pUsb->pState), USB_STATE_ADDRESS);
   \   0000001E   4069               LDR      R0,[R0, #+20]
   \   00000020   0168               LDR      R1,[R0, #+0]
   \   00000022   0822               MOVS     R2,#+8
   \   00000024   9143               BICS     R1,R1,R2
   \   00000026   0160               STR      R1,[R0, #+0]
   \   00000028   07E0               B        ??UDP_SetAddress_1
   1257              }
   1258              else {
   1259          
   1260                  SET(pInterface->UDP_GLBSTATE, AT91C_UDP_FADDEN);
   \                     ??UDP_SetAddress_0:
   \   0000002A   0123               MOVS     R3,#+1
   \   0000002C   0B43               ORRS     R3,R3,R1
   \   0000002E   5360               STR      R3,[R2, #+4]
   1261          
   1262                  // The device enters the Address state
   1263                  SET(*(pUsb->pState), USB_STATE_ADDRESS);
   \   00000030   4069               LDR      R0,[R0, #+20]
   \   00000032   0168               LDR      R1,[R0, #+0]
   \   00000034   0822               MOVS     R2,#+8
   \   00000036   0A43               ORRS     R2,R2,R1
   \   00000038   0260               STR      R2,[R0, #+0]
   1264              }
   1265          }
   \                     ??UDP_SetAddress_1:
   \   0000003A   10BC               POP      {R4}
   \   0000003C   01BC               POP      {R0}
   \   0000003E   0047               BX       R0               ;; return
   1266          
   1267          //------------------------------------------------------------------------------
   1268          // \brief  Changes the device state from Address to Configured, or from
   1269          //         Configured to Address.
   1270          //
   1271          //         This method directly access the last received SETUP packet to
   1272          //         decide on what to do.
   1273          // \see    S_usb
   1274          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1275          void UDP_SetConfiguration(S_usb const *pUsb)
   1276          {
   \                     UDP_SetConfiguration:
   \   00000000   10B5               PUSH     {R4,LR}
   1277              unsigned short wValue = USB_GetSetup(pUsb)->wValue;
   \   00000002   0169               LDR      R1,[R0, #+16]
   \   00000004   4A88               LDRH     R2,[R1, #+2]
   1278              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000006   0168               LDR      R1,[R0, #+0]
   \   00000008   0968               LDR      R1,[R1, #+0]
   1279          
   1280                                                                                          TRACE_DEBUG_L("SetCfg() ");
   1281          
   1282              // Check the request
   1283              if (wValue != 0) {
   \   0000000A   002A               CMP      R2,#+0
   \   0000000C   4269               LDR      R2,[R0, #+20]
   \   0000000E   08D0               BEQ      ??UDP_SetConfiguration_0
   1284          
   1285                  // Enter Configured state
   1286                  SET(*(pUsb->pState), USB_STATE_CONFIGURED);
   \   00000010   1068               LDR      R0,[R2, #+0]
   \   00000012   1023               MOVS     R3,#+16
   \   00000014   0343               ORRS     R3,R3,R0
   \   00000016   1360               STR      R3,[R2, #+0]
   1287                  SET(pInterface->UDP_GLBSTATE, AT91C_UDP_CONFG);
   \   00000018   4868               LDR      R0,[R1, #+4]
   \   0000001A   0222               MOVS     R2,#+2
   \   0000001C   0243               ORRS     R2,R2,R0
   \   0000001E   4A60               STR      R2,[R1, #+4]
   \   00000020   09E0               B        ??UDP_SetConfiguration_1
   1288              }
   1289              else {
   1290          
   1291                  // Go back to Address state
   1292                  CLEAR(*(pUsb->pState), USB_STATE_CONFIGURED);
   \                     ??UDP_SetConfiguration_0:
   \   00000022   1368               LDR      R3,[R2, #+0]
   \   00000024   1024               MOVS     R4,#+16
   \   00000026   A343               BICS     R3,R3,R4
   \   00000028   1360               STR      R3,[R2, #+0]
   1293                  SET(pInterface->UDP_GLBSTATE, AT91C_UDP_FADDEN);
   \   0000002A   4A68               LDR      R2,[R1, #+4]
   \   0000002C   0123               MOVS     R3,#+1
   \   0000002E   1343               ORRS     R3,R3,R2
   \   00000030   4B60               STR      R3,[R1, #+4]
   1294          
   1295                  // Abort all transfers
   1296                  UDP_DisableEndpoints(pUsb);
   \   00000032   ........           BL       UDP_DisableEndpoints
   1297              }
   1298          }
   \                     ??UDP_SetConfiguration_1:
   \   00000036   10BC               POP      {R4}
   \   00000038   01BC               POP      {R0}
   \   0000003A   0047               BX       R0               ;; return
   1299          
   1300          //------------------------------------------------------------------------------
   1301          // \brief  Enables the pull-up on the D+ line to connect the device to the USB.
   1302          // \param  pUsb Pointer to a S_usb instance
   1303          // \see    S_usb
   1304          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1305          void UDP_Connect(const S_usb *pUsb)
   1306          {
   \                     UDP_Connect:
   \   00000000   01B5               PUSH     {R0,LR}
   1307          #if defined(UDP_INTERNAL_PULLUP)
   1308              SET(UDP_GetDriverInterface(pUsb)->UDP_TXVC, AT91C_UDP_PUON);
   1309          
   1310          #elif defined(UDP_INTERNAL_PULLUP_BY_MATRIX)
   1311                                                                                          TRACE_DEBUG_L("PUON 1\n\r");
   1312              AT91C_BASE_MATRIX->MATRIX_USBPCR |= AT91C_MATRIX_USBPCR_PUON;
   1313          
   1314          #else
   1315              BRD_ConnectPullUp(UDP_GetDriverInterface(pUsb));
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   0068               LDR      R0,[R0, #+0]
   \   00000006   ........           BL       BRD_ConnectPullUp
   1316          
   1317          #endif
   1318          }
   \   0000000A   08BC               POP      {R3}
   \   0000000C   01BC               POP      {R0}
   \   0000000E   0047               BX       R0               ;; return
   1319          
   1320          //------------------------------------------------------------------------------
   1321          // \brief  Disables the pull-up on the D+ line to disconnect the device from
   1322          //         the bus.
   1323          // \param  pUsb Pointer to a S_usb instance
   1324          // \see    S_usb
   1325          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1326          void UDP_Disconnect(const S_usb *pUsb)
   1327          {
   \                     UDP_Disconnect:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1328          #if defined(UDP_INTERNAL_PULLUP)
   1329              CLEAR(UDP_GetDriverInterface(pUsb)->UDP_TXVC, AT91C_UDP_PUON);
   1330          
   1331          #elif defined(UDP_INTERNAL_PULLUP_BY_MATRIX)
   1332                                                                                          TRACE_DEBUG_L("PUON 0\n\r");
   1333              AT91C_BASE_MATRIX->MATRIX_USBPCR &= ~AT91C_MATRIX_USBPCR_PUON;
   1334          
   1335          #else
   1336              BRD_DisconnectPullUp(UDP_GetDriverInterface(pUsb));
   \   00000004   2068               LDR      R0,[R4, #+0]
   \   00000006   0068               LDR      R0,[R0, #+0]
   \   00000008   ........           BL       BRD_DisconnectPullUp
   1337          
   1338          #endif
   1339              // Device leaves the Default state
   1340              CLEAR(*(pUsb->pState), USB_STATE_DEFAULT);
   \   0000000C   6069               LDR      R0,[R4, #+20]
   \   0000000E   0168               LDR      R1,[R0, #+0]
   \   00000010   0422               MOVS     R2,#+4
   \   00000012   9143               BICS     R1,R1,R2
   \   00000014   0160               STR      R1,[R0, #+0]
   1341          }
   \   00000016   10BC               POP      {R4}
   \   00000018   01BC               POP      {R0}
   \   0000001A   0047               BX       R0               ;; return
   1342          
   1343          //------------------------------------------------------------------------------
   1344          // \brief  Initializes the specified USB driver
   1345          //
   1346          //         This function initializes the current FIFO bank of endpoints,
   1347          //         configures the pull-up and VBus lines, disconnects the pull-up and
   1348          //         then trigger the Init callback.
   1349          // \param  pUsb Pointer to a S_usb instance
   1350          // \see    S_usb
   1351          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1352          void UDP_Init(const S_usb *pUsb)
   1353          {
   \                     UDP_Init:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1354              unsigned int dIndex;
   1355              AT91PS_UDP   pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   2068               LDR      R0,[R4, #+0]
   \   00000006   0568               LDR      R5,[R0, #+0]
   1356          
   1357                                                                                          TRACE_DEBUG_L("Init()\n\r");
   1358          
   1359              // Init data banks
   1360              for (dIndex = 0; dIndex < pUsb->dNumEndpoints; dIndex++) {
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   0221               MOVS     R1,#+2
   \   0000000C   05E0               B        ??UDP_Init_0
   1361          
   1362                  pUsb->pEndpoints[dIndex].dFlag = AT91C_UDP_RX_DATA_BK0;
   \                     ??UDP_Init_1:
   \   0000000E   2822               MOVS     R2,#+40
   \   00000010   4243               MULS     R2,R0,R2
   \   00000012   6368               LDR      R3,[R4, #+4]
   \   00000014   9A18               ADDS     R2,R3,R2
   \   00000016   D161               STR      R1,[R2, #+28]
   1363              }
   \   00000018   401C               ADDS     R0,R0,#+1
   \                     ??UDP_Init_0:
   \   0000001A   A268               LDR      R2,[R4, #+8]
   \   0000001C   9042               CMP      R0,R2
   \   0000001E   F6D3               BCC      ??UDP_Init_1
   1364          
   1365              // External pull-up on D+
   1366              // Configure
   1367              BRD_ConfigurePullUp(pInterface);
   \   00000020   2800               MOVS     R0,R5
   \   00000022   ........           BL       BRD_ConfigurePullUp
   1368          
   1369              // Disable
   1370              UDP_Disconnect(pUsb);
   \   00000026   2000               MOVS     R0,R4
   \   00000028   ........           BL       UDP_Disconnect
   1371          
   1372              // Device is in the Attached state
   1373              *(pUsb->pState) = USB_STATE_ATTACHED;
   \   0000002C   6069               LDR      R0,[R4, #+20]
   \   0000002E   0121               MOVS     R1,#+1
   \   00000030   0160               STR      R1,[R0, #+0]
   1374          
   1375              // Disable the UDP transceiver and interrupts
   1376              UDP_EnableMCK(pUsb);
   \   00000032   2068               LDR      R0,[R4, #+0]
   \   00000034   1349               LDR      R1,??UDP_Init_2  ;; 0xfffffc10
   \   00000036   0122               MOVS     R2,#+1
   \   00000038   C368               LDR      R3,[R0, #+12]
   \   0000003A   9A40               LSLS     R2,R2,R3
   \   0000003C   0A60               STR      R2,[R1, #+0]
   1377              SET(pInterface->UDP_IDR, AT91C_UDP_RXRSM);
   \   0000003E   6969               LDR      R1,[R5, #+20]
   \   00000040   8022               MOVS     R2,#+128
   \   00000042   9200               LSLS     R2,R2,#+2        ;; #+512
   \   00000044   0A43               ORRS     R2,R2,R1
   \   00000046   6A61               STR      R2,[R5, #+20]
   1378              UDP_Connect(pUsb);
   \   00000048   0068               LDR      R0,[R0, #+0]
   \   0000004A   ........           BL       BRD_ConnectPullUp
   1379              UDP_DisableTransceiver(pUsb);
   \   0000004E   2068               LDR      R0,[R4, #+0]
   \   00000050   0168               LDR      R1,[R0, #+0]
   \   00000052   4A6F               LDR      R2,[R1, #+116]
   \   00000054   8023               MOVS     R3,#+128
   \   00000056   5B00               LSLS     R3,R3,#+1        ;; #+256
   \   00000058   1343               ORRS     R3,R3,R2
   \   0000005A   4B67               STR      R3,[R1, #+116]
   1380              UDP_DisableMCK(pUsb);
   \   0000005C   0A49               LDR      R1,??UDP_Init_2+0x4  ;; 0xfffffc14
   \   0000005E   0122               MOVS     R2,#+1
   \   00000060   C068               LDR      R0,[R0, #+12]
   \   00000062   8240               LSLS     R2,R2,R0
   \   00000064   0A60               STR      R2,[R1, #+0]
   1381              UDP_Disconnect(pUsb);
   \   00000066   2000               MOVS     R0,R4
   \   00000068   ........           BL       UDP_Disconnect
   1382          
   1383              // Configure interrupts
   1384              USB_InitCallback(pUsb);
   \   0000006C   E168               LDR      R1,[R4, #+12]
   \   0000006E   0868               LDR      R0,[R1, #+0]
   \   00000070   0028               CMP      R0,#+0
   \   00000072   03D0               BEQ      ??UDP_Init_3
   \   00000074   2000               MOVS     R0,R4
   \   00000076   0968               LDR      R1,[R1, #+0]
   \   00000078   ........           BL       __iar_via_R1
   1385          }
   \                     ??UDP_Init_3:
   \   0000007C   38BC               POP      {R3-R5}
   \   0000007E   01BC               POP      {R0}
   \   00000080   0047               BX       R0               ;; return
   \   00000082   C046               Nop      
   \                     ??UDP_Init_2:
   \   00000084   10FCFFFF           DC32     0xfffffc10
   \   00000088   14FCFFFF           DC32     0xfffffc14
   1386          
   1387          //------------------------------------------------------------------------------
   1388          //      Global variables
   1389          //------------------------------------------------------------------------------
   1390          
   1391          // \brief Low-level driver methods to use with the UDP USB controller
   1392          // \see S_driver_methods

   \                                 In section .rodata, align 4
   1393          const S_driver_methods sUDPMethods = {
   \                     sUDPMethods:
   \   00000000   ............       DC32 UDP_Init, UDP_Write, UDP_Read, UDP_Stall, UDP_Halt
   \              ............
   \              ............
   \              ....        
   \   00000014   ............       DC32 UDP_RemoteWakeUp, UDP_ConfigureEndpoint, UDP_Attach
   \              ............
   \   00000020   ............       DC32 UDP_SetAddress, UDP_SetConfiguration, UDP_Handler, UDP_Connect
   \              ............
   \              ........    
   \   00000030   ........           DC32 UDP_Disconnect
   1394          
   1395              UDP_Init,
   1396              UDP_Write,
   1397              UDP_Read,
   1398              UDP_Stall,
   1399              UDP_Halt,
   1400              UDP_RemoteWakeUp,
   1401              UDP_ConfigureEndpoint,
   1402              UDP_Attach,
   1403              UDP_SetAddress,
   1404              UDP_SetConfiguration,
   1405              UDP_Handler,
   1406              UDP_Connect,
   1407              UDP_Disconnect
   1408          };
   1409          
   1410          // \brief  Default driver when an UDP controller is present on a chip

   \                                 In section .rodata, align 4
   1411          const S_usb_driver sDefaultDriver = {
   \                     sDefaultDriver:
   \   00000000   0000FBFF0000       DC32 0FFFB0000H, 0H, 0H, 11, 128, sUDPMethods
   \              000000000000
   \              0B0000008000
   \              0000........
   1412          
   1413              AT91C_BASE_UDP,
   1414              0,
   1415              0,
   1416              AT91C_ID_UDP,
   1417              AT91C_PMC_UDP,
   1418              &sUDPMethods
   1419          };
   1420          
   1421          #endif // UDP
   1422          
   1423          

   Maximum stack usage in bytes:

     Function              .cstack
     --------              -------
     UDP_Attach                16
     UDP_ClearRXFlag           16
     UDP_ConfigureEndpoint     32
     UDP_Connect                8
     UDP_DisableEndpoints      24
     UDP_Disconnect             8
     UDP_EndOfTransfer          8
     UDP_EndpointHandler       56
     UDP_Halt                  24
     UDP_Handler               24
     UDP_Init                  16
     UDP_Read                  24
     UDP_RemoteWakeUp           8
     UDP_SetAddress             8
     UDP_SetConfiguration       8
     UDP_Stall                 16
     UDP_Write                 24
     UDP_WritePayload          16


   Section sizes:

     Function/Label        Bytes
     --------------        -----
     UDP_EndOfTransfer       44
     UDP_ClearRXFlag         74
     UDP_WritePayload        76
     UDP_DisableEndpoints    56
     UDP_EndpointHandler    708
     UDP_ConfigureEndpoint  214
     UDP_Handler            616
     UDP_Write              152
     UDP_Read                74
     UDP_Halt               178
     UDP_Stall               68
     UDP_RemoteWakeUp        68
     UDP_Attach             292
     UDP_SetAddress          64
     UDP_SetConfiguration    60
     UDP_Connect             16
     UDP_Disconnect          28
     UDP_Init               140
     sUDPMethods             52
     sDefaultDriver          24
      Others                  4

 
    76 bytes in section .rodata
 2 932 bytes in section Debug.txt
 
 2 884 bytes of CODE  memory (+ 48 bytes shared)
    76 bytes of CONST memory

Errors: none
Warnings: none
