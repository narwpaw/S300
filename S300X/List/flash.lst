###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           04/Jul/2012  21:50:42 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v0.6 -              #
#                    18.05.2012\Framework\flash.c                             #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v0.6 -             #
#                    18.05.2012\Framework\flash.c" -D AT91SAM7S256 -D         #
#                    AT91SAM7SEK -D iH -D __ALARM -D __WIFI_MODULE -lC        #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.6 -             #
#                    18.05.2012\S300X\List\" --diag_suppress Pa082 -o         #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.6 -             #
#                    18.05.2012\S300X\Obj\" --no_unroll --no_inline           #
#                    --no_tbaa --no_scheduling --debug --endian little --cpu  #
#                    ARM7TDMI -e --fpu None --dlib_config "C:\Program         #
#                    Files\IAR Systems\Embedded Workbench                     #
#                    5.0\ARM\INC\DLib_Config_Normal.h" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.6 -             #
#                    18.05.2012\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.6 -             #
#                    18.05.2012\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.6 -             #
#                    18.05.2012\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v0.6 - 18.05.2012\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v0.6 - 18.05.2012\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.6 -             #
#                    18.05.2012\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v0.6 - 18.05.2012\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.6 -             #
#                    18.05.2012\Framework\Configuration\" -I "C:\Program      #
#                    Files\IAR Systems\Embedded Workbench 5.0\ARM\INC\"       #
#                    --section .text=Debug.txt --interwork --cpu_mode thumb   #
#                    -Om                                                      #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v0.6 -              #
#                    18.05.2012\S300X\List\flash.lst                          #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v0.6 -              #
#                    18.05.2012\S300X\Obj\flash.o                             #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v0.6 - 18.05.2012\Framework\flash.c
      1          #include "flash.h"
      2          #include <intrinsics.h>
      3          
      4          
      5          
      6          

   \                                 In section Debug.txt, align 4, keep-with-next
      7          void InitFlash(void)
      8          {
      9          
     10            AT91C_BASE_MC->MC_FMR = (((0x48)<<16) | AT91C_MC_FWS_2FWS);     // konfiguracja MC_FMR
   \                     InitFlash:
   \   00000000   9F20               MOVS     R0,#+159
   \   00000002   C043               MVNS     R0,R0            ;; #-160
   \   00000004   0349               LDR      R1,??InitFlash_0  ;; 0x480200
   \   00000006   0160               STR      R1,[R0, #+0]
     11          
     12            SET(AT91C_BASE_MC->MC_FMR, ((AT91C_MASTER_CLOCK / 666666)) << 16);
   \   00000008   0168               LDR      R1,[R0, #+0]
   \   0000000A   9022               MOVS     R2,#+144
   \   0000000C   D203               LSLS     R2,R2,#+15       ;; #+4718592
   \   0000000E   0A43               ORRS     R2,R2,R1
   \   00000010   0260               STR      R2,[R0, #+0]
     13              
     14            
     15          }
   \   00000012   7047               BX       LR               ;; return
   \                     ??InitFlash_0:
   \   00000014   00024800           DC32     0x480200
     16          
     17          
     18          
     19          
     20          //*-----------------------------------------------------------------------------
     21          //* Nazwa funkcji :    at91flashWrite
     22          //* Funkcja zapisu do flash
     23          //*-----------------------------------------------------------------------------
     24          //*  ofset  - przesuniêcie
     25          //*  cell   - pierwsza komórka zapisu
     26          //*  value  - wartoœæ do zapisu
     27          //*  length - wielkoœæ danych
     28          //*----------------------------------------------------------------------------
     29          

   \                                 In section .textrw, align 4, keep-with-next
     30          __ramfunc void at91flashWrite(  unsigned int ofset, unsigned int cell, char *value,  int length)
     31           {
   \                     at91flashWrite:
   \   00000000   F4B5               PUSH     {R2,R4-R7,LR}
   \   00000002   C2B0               SUB      SP,SP,#+264
   \   00000004   0A00               MOVS     R2,R1
     32             
     33             unsigned int Page=ofset+cell/256;
   \   00000006   090A               LSRS     R1,R1,#+8
   \   00000008   4118               ADDS     R1,R0,R1
     34             unsigned int komorka=ofset+cell%256;
   \   0000000A   1206               LSLS     R2,R2,#+24
   \   0000000C   120E               LSRS     R2,R2,#+24
   \   0000000E   8018               ADDS     R0,R0,R2
   \   00000010   0090               STR      R0,[SP, #+0]
   \   00000012   0024               MOVS     R4,#+0
     35             int length_tmp;
     36             int data = 0; 
     37             unsigned long *memory;
     38             
     39          
     40             
     41            // TRACE_INFO("\n\r---  FlashWrite  --- Ofset: %d, Komorka: %d, Rozmar: %dB\n\r",ofset,cell,length );  
     42             
     43             union 
     44             {
     45                         char tab_B[256];
     46                unsigned long tab_DW[64];
     47             };
     48          
     49             do
     50             {
     51               if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
   \                     ??at91flashWrite_0:
   \   00000014   0098               LDR      R0,[SP, #+0]
   \   00000016   C018               ADDS     R0,R0,R3
   \   00000018   FF22               MOVS     R2,#+255
   \   0000001A   921C               ADDS     R2,R2,#+2        ;; #+257
   \   0000001C   9042               CMP      R0,R2
   \   0000001E   03D3               BCC      ??at91flashWrite_1
   \   00000020   501E               SUBS     R0,R2,#+1
   \   00000022   009A               LDR      R2,[SP, #+0]
   \   00000024   821A               SUBS     R2,R0,R2
   \   00000026   00E0               B        ??at91flashWrite_2
   \                     ??at91flashWrite_1:
   \   00000028   1A00               MOVS     R2,R3
   \                     ??at91flashWrite_2:
   \   0000002A   0802               LSLS     R0,R1,#+8
   \   0000002C   0190               STR      R0,[SP, #+4]
     52          
     53                memory=(unsigned long*) (Page*256);  //zmiana z memory=(unsigned long*) (ofset+page*256);
     54               for (unsigned int i=0; i<=63; i++)
   \   0000002E   0020               MOVS     R0,#+0
   \   00000030   05E0               B        ??at91flashWrite_3
     55                {  
     56                  tab_DW[i]=memory[i];     
   \                     ??at91flashWrite_4:
   \   00000032   8500               LSLS     R5,R0,#+2
   \   00000034   02AE               ADD      R6,SP,#+8
   \   00000036   019F               LDR      R7,[SP, #+4]
   \   00000038   7F59               LDR      R7,[R7, R5]
   \   0000003A   7751               STR      R7,[R6, R5]
     57                }  
   \   0000003C   401C               ADDS     R0,R0,#+1
   \                     ??at91flashWrite_3:
   \   0000003E   4028               CMP      R0,#+64
   \   00000040   F7D3               BCC      ??at91flashWrite_4
     58               
     59               for (int i=komorka; i<=komorka+length_tmp-1; i++)
   \   00000042   0098               LDR      R0,[SP, #+0]
   \   00000044   05E0               B        ??at91flashWrite_5
     60                {
     61                  tab_B[i]=(unsigned long)value[data];
   \                     ??at91flashWrite_6:
   \   00000046   02AD               ADD      R5,SP,#+8
   \   00000048   429E               LDR      R6,[SP, #+264]
   \   0000004A   365D               LDRB     R6,[R6, R4]
   \   0000004C   2E54               STRB     R6,[R5, R0]
     62                  data++;
   \   0000004E   641C               ADDS     R4,R4,#+1
     63                }
   \   00000050   401C               ADDS     R0,R0,#+1
   \                     ??at91flashWrite_5:
   \   00000052   009D               LDR      R5,[SP, #+0]
   \   00000054   AD18               ADDS     R5,R5,R2
   \   00000056   6D1E               SUBS     R5,R5,#+1
   \   00000058   8542               CMP      R5,R0
   \   0000005A   F4D2               BCS      ??at91flashWrite_6
     64            
     65               for (unsigned int i=0; i<=63; i++)
   \   0000005C   0020               MOVS     R0,#+0
   \   0000005E   06E0               B        ??at91flashWrite_7
     66                {
     67                  AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
   \                     ??at91flashWrite_8:
   \   00000060   8500               LSLS     R5,R0,#+2
   \   00000062   9826               MOVS     R6,#+152
   \   00000064   7603               LSLS     R6,R6,#+13       ;; #+1245184
   \   00000066   02AF               ADD      R7,SP,#+8
   \   00000068   7F59               LDR      R7,[R7, R5]
   \   0000006A   7751               STR      R7,[R6, R5]
     68                }  
   \   0000006C   401C               ADDS     R0,R0,#+1
   \                     ??at91flashWrite_7:
   \   0000006E   4028               CMP      R0,#+64
   \   00000070   F6D3               BCC      ??at91flashWrite_8
     69             
     70               unsigned int Status = AT91C_BASE_MC->MC_FSR;
   \   00000072   9725               MOVS     R5,#+151
   \   00000074   ED43               MVNS     R5,R5            ;; #-152
   \   00000076   2868               LDR      R0,[R5, #+0]
     71          
     72               SET(AT91C_BASE_MC->MC_FCR,
     73                  AT91C_MC_CORRECT_KEY
     74                  | AT91C_MC_FCMD_START_PROG
     75                  | (((Page) << 8) & AT91C_MC_PAGEN));   //zmaina page+(ofset/256)
   \   00000078   9B26               MOVS     R6,#+155
   \   0000007A   F643               MVNS     R6,R6            ;; #-156
   \   0000007C   3068               LDR      R0,[R6, #+0]
   \   0000007E   8446               MOV      R12,R0
   \   00000080   0F02               LSLS     R7,R1,#+8
   \   00000082   ....               LDR      R0,??DataTable4  ;; 0x3ff00
   \   00000084   3840               ANDS     R0,R0,R7
   \   00000086   ....               LDR      R7,??DataTable5  ;; 0x5a000001
   \   00000088   0743               ORRS     R7,R7,R0
   \   0000008A   6046               MOV      R0,R12
   \   0000008C   0743               ORRS     R7,R7,R0
   \   0000008E   3760               STR      R7,[R6, #+0]
     76              
     77               while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);   
   \                     ??at91flashWrite_9:
   \   00000090   2868               LDR      R0,[R5, #+0]
   \   00000092   C007               LSLS     R0,R0,#+31
   \   00000094   FCD5               BPL      ??at91flashWrite_9
     78              
     79               komorka = 0;
   \   00000096   0020               MOVS     R0,#+0
   \   00000098   0090               STR      R0,[SP, #+0]
     80               length = length-length_tmp;
   \   0000009A   9B1A               SUBS     R3,R3,R2
     81               Page++;
   \   0000009C   491C               ADDS     R1,R1,#+1
     82              
     83             }while (length>0); 
   \   0000009E   012B               CMP      R3,#+1
   \   000000A0   B8DA               BGE      ??at91flashWrite_0
     84              
     85          
     86          }
   \   000000A2   43B0               ADD      SP,SP,#+268
   \   000000A4   F0BC               POP      {R4-R7}
   \   000000A6   01BC               POP      {R0}
   \   000000A8   0047               BX       R0               ;; return
     87          
     88          
     89          
     90          
     91          
     92          
     93          //*-----------------------------------------------------------------------------
     94          //* Nazwa funkcji :    FlashWrite
     95          //* Funkcja zapisu do flash
     96          //*-----------------------------------------------------------------------------
     97          //*  ofset  - przesuniêcie
     98          //*  cell   - pierwsza komórka zapisu
     99          //*  ptrMem - wskaŸnik na komórke pamiêci flash
    100          //*  value  - wartoœæ do zapisu
    101          //*  length - wielkoœæ danych
    102          //*-----------------------------------------------------------------------------

   \                                 In section .textrw, align 4, keep-with-next
    103          __ramfunc void FlashWrite(volatile char *ptrMem,volatile char *value,volatile int length)
    104           {
   \                     FlashWrite:
   \   00000000   F4B5               PUSH     {R2,R4-R7,LR}
   \   00000002   D6B0               SUB      SP,SP,#+344
   \   00000004   0F00               MOVS     R7,R1
    105             volatile int page=     (int)ptrMem/256;
   \   00000006   0100               MOVS     R1,R0
   \   00000008   C911               ASRS     R1,R1,#+7
   \   0000000A   090E               LSRS     R1,R1,#+24
   \   0000000C   0918               ADDS     R1,R1,R0
   \   0000000E   0912               ASRS     R1,R1,#+8
   \   00000010   0291               STR      R1,[SP, #+8]
    106             volatile int komorka = (int)ptrMem%256;   
   \   00000012   0902               LSLS     R1,R1,#+8
   \   00000014   411A               SUBS     R1,R0,R1
   \   00000016   0191               STR      R1,[SP, #+4]
    107             volatile int PtrInt=(int)ptrMem;
   \   00000018   0090               STR      R0,[SP, #+0]
    108             volatile int length_tmp;
    109             volatile int data = 0; 
   \   0000001A   0026               MOVS     R6,#+0
   \   0000001C   0396               STR      R6,[SP, #+12]
    110             volatile int *UptrMem;
    111             volatile char* ptrMem2;
    112          
    113             if ((PtrInt>0x00140000) || (PtrInt<0x00120000) || (komorka>0xFF))
   \   0000001E   0099               LDR      R1,[SP, #+0]
   \   00000020   474A               LDR      R2,??FlashWrite_0  ;; 0x140001
   \   00000022   9142               CMP      R1,R2
   \   00000024   09DA               BGE      ??FlashWrite_1
   \   00000026   0098               LDR      R0,[SP, #+0]
   \   00000028   9021               MOVS     R1,#+144
   \   0000002A   4903               LSLS     R1,R1,#+13       ;; #+1179648
   \   0000002C   8842               CMP      R0,R1
   \   0000002E   04DB               BLT      ??FlashWrite_1
   \   00000030   8025               MOVS     R5,#+128
   \   00000032   6D00               LSLS     R5,R5,#+1        ;; #+256
   \   00000034   0198               LDR      R0,[SP, #+4]
   \   00000036   A842               CMP      R0,R5
   \   00000038   08DB               BLT      ??FlashWrite_2
    114             {
    115                 char mess[]="Blad zapisu. Przekroczenie dozwolonego obszaru";
   \                     ??FlashWrite_1:
   \   0000003A   44A8               ADD      R0,SP,#+272
   \   0000003C   4149               LDR      R1,??FlashWrite_0+0x4  ;; `?<Constant "Blad zapisu. Przekroc...">`
   \   0000003E   3022               MOVS     R2,#+48
   \   00000040   ........           BL       __aeabi_memcpy4
    116                 MESSAGE(mess); 
                        ^
Warning[Pe223]: function "MESSAGE" declared implicitly

         MESSAGE(mess); 
         ^
"D:\Zeuron\Projekty\S300\S300-program v0.6 - 18.05.2012\Framework\flash.c",116  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function
   \   00000044   44A8               ADD      R0,SP,#+272
   \   00000046   ........           BL       MESSAGE
   \   0000004A   75E0               B        ??FlashWrite_3
    117             }else{
    118           
    119                 union 
    120                 {
    121                             char B[256];
    122                    unsigned long DW[64];
    123                 }tab;
    124              
    125                 do
    126                 {
    127                   if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
   \                     ??FlashWrite_2:
   \   0000004C   0198               LDR      R0,[SP, #+4]
   \   0000004E   5699               LDR      R1,[SP, #+344]
   \   00000050   4018               ADDS     R0,R0,R1
   \   00000052   691C               ADDS     R1,R5,#+1
   \   00000054   8842               CMP      R0,R1
   \   00000056   03DB               BLT      ??FlashWrite_4
   \   00000058   0198               LDR      R0,[SP, #+4]
   \   0000005A   281A               SUBS     R0,R5,R0
   \   0000005C   0090               STR      R0,[SP, #+0]
   \   0000005E   01E0               B        ??FlashWrite_5
   \                     ??FlashWrite_4:
   \   00000060   5698               LDR      R0,[SP, #+344]
   \   00000062   0090               STR      R0,[SP, #+0]
    128                   
    129                   //przepisanie strony pamiêci do RAMu
    130                   ptrMem2=(char*)(page*256);
   \                     ??FlashWrite_5:
   \   00000064   0298               LDR      R0,[SP, #+8]
   \   00000066   0002               LSLS     R0,R0,#+8
    131                   for (short i=0; i<256; i++)
   \   00000068   3100               MOVS     R1,R6
   \   0000006A   05E0               B        ??FlashWrite_6
    132                    {  
    133                      tab.B[i]=ptrMem2[i];     
   \                     ??FlashWrite_7:
   \   0000006C   04AA               ADD      R2,SP,#+16
   \   0000006E   435C               LDRB     R3,[R0, R1]
   \   00000070   5354               STRB     R3,[R2, R1]
    134                    }  
   \   00000072   491C               ADDS     R1,R1,#+1
   \   00000074   0904               LSLS     R1,R1,#+16
   \   00000076   0914               ASRS     R1,R1,#+16
   \                     ??FlashWrite_6:
   \   00000078   A942               CMP      R1,R5
   \   0000007A   F7DB               BLT      ??FlashWrite_7
    135                   
    136                      //dodanie nowych danych
    137                      for (int i=komorka; i<=komorka+length_tmp-1; i++)
   \   0000007C   0198               LDR      R0,[SP, #+4]
   \   0000007E   07E0               B        ??FlashWrite_8
    138                      {
    139                        tab.B[i]=value[data];
   \                     ??FlashWrite_9:
   \   00000080   04A9               ADD      R1,SP,#+16
   \   00000082   039A               LDR      R2,[SP, #+12]
   \   00000084   BA5C               LDRB     R2,[R7, R2]
   \   00000086   0A54               STRB     R2,[R1, R0]
    140                        data++;
   \   00000088   0399               LDR      R1,[SP, #+12]
   \   0000008A   491C               ADDS     R1,R1,#+1
   \   0000008C   0391               STR      R1,[SP, #+12]
    141                      }
   \   0000008E   401C               ADDS     R0,R0,#+1
   \                     ??FlashWrite_8:
   \   00000090   0199               LDR      R1,[SP, #+4]
   \   00000092   009A               LDR      R2,[SP, #+0]
   \   00000094   8918               ADDS     R1,R1,R2
   \   00000096   491E               SUBS     R1,R1,#+1
   \   00000098   8142               CMP      R1,R0
   \   0000009A   F1DA               BGE      ??FlashWrite_9
    142                
    143                      //UptrMem=(int*)ptrMem;  
    144                      UptrMem=(int*)(page*256);
   \   0000009C   0298               LDR      R0,[SP, #+8]
   \   0000009E   0002               LSLS     R0,R0,#+8
    145                        
    146                      //zapis do tymczasowego obszar
    147                      //for (unsigned int i=0; i<=63; i++) AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    148                      for (unsigned int i=0; i<=63; i++) UptrMem[i]=tab.DW[i];
   \   000000A0   3100               MOVS     R1,R6
   \   000000A2   04E0               B        ??FlashWrite_10
   \                     ??FlashWrite_11:
   \   000000A4   8A00               LSLS     R2,R1,#+2
   \   000000A6   04AB               ADD      R3,SP,#+16
   \   000000A8   9B58               LDR      R3,[R3, R2]
   \   000000AA   8350               STR      R3,[R0, R2]
   \   000000AC   491C               ADDS     R1,R1,#+1
   \                     ??FlashWrite_10:
   \   000000AE   4029               CMP      R1,#+64
   \   000000B0   F8D3               BCC      ??FlashWrite_11
    149                 
    150                      //oczekiwanie na flagê FRDY 
    151                      while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
   \                     ??FlashWrite_12:
   \   000000B2   9724               MOVS     R4,#+151
   \   000000B4   E443               MVNS     R4,R4            ;; #-152
   \   000000B6   2068               LDR      R0,[R4, #+0]
   \   000000B8   C007               LSLS     R0,R0,#+31
   \   000000BA   FAD5               BPL      ??FlashWrite_12
    152                      //volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    153                      
    154                      //Zapis FCMD i PAGENB do MC_FCR
    155                      SET(AT91C_BASE_MC->MC_FCR,
    156                          AT91C_MC_CORRECT_KEY
    157                          | AT91C_MC_FCMD_START_PROG
    158                          | ((page << 8) & AT91C_MC_PAGEN)); 
   \   000000BC   9B20               MOVS     R0,#+155
   \   000000BE   C043               MVNS     R0,R0            ;; #-156
   \   000000C0   0168               LDR      R1,[R0, #+0]
   \   000000C2   029A               LDR      R2,[SP, #+8]
   \   000000C4   1302               LSLS     R3,R2,#+8
   \   000000C6   ....               LDR      R2,??DataTable4  ;; 0x3ff00
   \   000000C8   1A40               ANDS     R2,R2,R3
   \   000000CA   ....               LDR      R3,??DataTable5  ;; 0x5a000001
   \   000000CC   1343               ORRS     R3,R3,R2
   \   000000CE   0B43               ORRS     R3,R3,R1
   \   000000D0   0360               STR      R3,[R0, #+0]
    159                  
    160                      //oczekiwanie na flagê FRDY 
    161                      long long MaxCount=0;
   \   000000D2   3000               MOVS     R0,R6
   \   000000D4   0100               MOVS     R1,R0
   \   000000D6   02E0               B        ??FlashWrite_13
    162                      while(((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY) || (MaxCount>0xFFFE)) {MaxCount++;};  
   \                     ??FlashWrite_14:
   \   000000D8   0022               MOVS     R2,#+0
   \   000000DA   401C               ADDS     R0,R0,#+1
   \   000000DC   5141               ADCS     R1,R1,R2
   \                     ??FlashWrite_13:
   \   000000DE   2268               LDR      R2,[R4, #+0]
   \   000000E0   D207               LSLS     R2,R2,#+31
   \   000000E2   F9D5               BPL      ??FlashWrite_14
   \   000000E4   220C               LSRS     R2,R4,#+16
   \   000000E6   3300               MOVS     R3,R6
   \   000000E8   9942               CMP      R1,R3
   \   000000EA   F5DC               BGT      ??FlashWrite_14
   \   000000EC   01DB               BLT      ??FlashWrite_15
   \   000000EE   9042               CMP      R0,R2
   \   000000F0   F2D2               BCS      ??FlashWrite_14
    163                      if (MaxCount==0xFFFF)  
   \                     ??FlashWrite_15:
   \   000000F2   9942               CMP      R1,R3
   \   000000F4   09D1               BNE      ??FlashWrite_16
   \   000000F6   9042               CMP      R0,R2
   \   000000F8   07D1               BNE      ??FlashWrite_16
    164                      {
    165                        char mess[]="Blad zapisu do flash";
   \   000000FA   50A8               ADD      R0,SP,#+320
   \   000000FC   1249               LDR      R1,??FlashWrite_0+0x8  ;; `?<Constant "Blad zapisu. Przekroc...">` + 48
   \   000000FE   1822               MOVS     R2,#+24
   \   00000100   ........           BL       __aeabi_memcpy4
    166                        MESSAGE(mess); 
                               ^
Warning[Pe223]: function "MESSAGE" declared implicitly

                MESSAGE(mess); 
                ^
"D:\Zeuron\Projekty\S300\S300-program v0.6 - 18.05.2012\Framework\flash.c",166  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function
   \   00000104   50A8               ADD      R0,SP,#+320
   \   00000106   ........           BL       MESSAGE
    167                      }
    168                      //Sprawdzenie czy nie naruszona blokada regionu
    169                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_LOCKE) 
   \                     ??FlashWrite_16:
   \   0000010A   2068               LDR      R0,[R4, #+0]
   \   0000010C   4007               LSLS     R0,R0,#+29
   \   0000010E   02D5               BPL      ??FlashWrite_17
    170                      {
    171                         MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
                                ^
Warning[Pe223]: function "MESSAGE" declared implicitly

                 MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
                 ^
"D:\Zeuron\Projekty\S300\S300-program v0.6 - 18.05.2012\Framework\flash.c",171  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function
   \   00000110   0E48               LDR      R0,??FlashWrite_0+0xC  ;; `?<Constant "Blad zapisu. Przekroc...">` + 72
   \   00000112   ........           BL       MESSAGE
    172                      }
    173                      
    174                      //Sprawdzenie czy zapis wykonany poprawnie
    175                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_PROGE) 
   \                     ??FlashWrite_17:
   \   00000116   2068               LDR      R0,[R4, #+0]
   \   00000118   0007               LSLS     R0,R0,#+28
   \   0000011A   02D5               BPL      ??FlashWrite_18
    176                      {
    177                        MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
                               ^
Warning[Pe223]: function "MESSAGE" declared implicitly

                MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
                ^
"D:\Zeuron\Projekty\S300\S300-program v0.6 - 18.05.2012\Framework\flash.c",177  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function

         char mess[]="Blad zapisu. Przekroczenie dozwolonego obszaru";
                    ^
"D:\Zeuron\Projekty\S300\S300-program v0.6 - 18.05.2012\Framework\flash.c",115  Warning[Ta022]: 
          Possible rom access (<Constant "Blad zapisu. Przekroc...">) from
          within a __ramfunc function

                char mess[]="Blad zapisu do flash";
                           ^
"D:\Zeuron\Projekty\S300\S300-program v0.6 - 18.05.2012\Framework\flash.c",165  Warning[Ta022]: 
          Possible rom access (<Constant "Blad zapisu. Przekroc...">) from
          within a __ramfunc function

                 MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
                 ^
"D:\Zeuron\Projekty\S300\S300-program v0.6 - 18.05.2012\Framework\flash.c",171  Warning[Ta022]: 
          Possible rom access (<Constant "Blad zapisu. Przekroc...">) from
          within a __ramfunc function

                MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
                ^
"D:\Zeuron\Projekty\S300\S300-program v0.6 - 18.05.2012\Framework\flash.c",177  Warning[Ta022]: 
          Possible rom access (<Constant "Blad zapisu. Przekroc...">) from
          within a __ramfunc function
   \   0000011C   0C48               LDR      R0,??FlashWrite_0+0x10  ;; `?<Constant "Blad zapisu. Przekroc...">` + 116
   \   0000011E   ........           BL       MESSAGE
    178                      }
    179                      
    180                   komorka = 0;
   \                     ??FlashWrite_18:
   \   00000122   0196               STR      R6,[SP, #+4]
    181                   length = length-length_tmp;
   \   00000124   5698               LDR      R0,[SP, #+344]
   \   00000126   0099               LDR      R1,[SP, #+0]
   \   00000128   401A               SUBS     R0,R0,R1
   \   0000012A   5690               STR      R0,[SP, #+344]
    182                   page++;
   \   0000012C   0298               LDR      R0,[SP, #+8]
   \   0000012E   401C               ADDS     R0,R0,#+1
   \   00000130   0290               STR      R0,[SP, #+8]
    183                  
    184                 }while (length>0); 
   \   00000132   5698               LDR      R0,[SP, #+344]
   \   00000134   0128               CMP      R0,#+1
   \   00000136   89DA               BGE      ??FlashWrite_2
    185             }
    186              
    187          }
   \                     ??FlashWrite_3:
   \   00000138   57B0               ADD      SP,SP,#+348
   \   0000013A   F0BC               POP      {R4-R7}
   \   0000013C   01BC               POP      {R0}
   \   0000013E   0047               BX       R0               ;; return
   \                     ??FlashWrite_0:
   \   00000140   01001400           DC32     0x140001
   \   00000144   ........           DC32     `?<Constant "Blad zapisu. Przekroc...">`
   \   00000148   ........           DC32     `?<Constant "Blad zapisu. Przekroc...">` + 48
   \   0000014C   ........           DC32     `?<Constant "Blad zapisu. Przekroc...">` + 72
   \   00000150   ........           DC32     `?<Constant "Blad zapisu. Przekroc...">` + 116
    188          
    189          
    190          
    191          
    192          
    193          

   \                                 In section .textrw, align 4, keep-with-next
    194          __ramfunc void CleanFlash(char *ptrMem, int length)
    195           {
   \                     CleanFlash:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   C2B0               SUB      SP,SP,#+264
    196             int page=     (int)ptrMem/256;
   \   00000004   0300               MOVS     R3,R0
   \   00000006   C011               ASRS     R0,R0,#+7
   \   00000008   000E               LSRS     R0,R0,#+24
   \   0000000A   C018               ADDS     R0,R0,R3
   \   0000000C   0200               MOVS     R2,R0
   \   0000000E   1212               ASRS     R2,R2,#+8
    197             int komorka = (int)ptrMem%256;   
   \   00000010   1002               LSLS     R0,R2,#+8
   \   00000012   181A               SUBS     R0,R3,R0
    198             int length_tmp;
    199             int data = 0; 
    200             int *UptrMem;
    201          
    202             union 
    203             {
    204                         char B[256];
    205                unsigned long DW[64];
    206             }tab;
    207          
    208             do
    209             {
    210               if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
   \                     ??CleanFlash_0:
   \   00000014   4318               ADDS     R3,R0,R1
   \   00000016   FF24               MOVS     R4,#+255
   \   00000018   A41C               ADDS     R4,R4,#+2        ;; #+257
   \   0000001A   A342               CMP      R3,R4
   \   0000001C   02DB               BLT      ??CleanFlash_1
   \   0000001E   631E               SUBS     R3,R4,#+1
   \   00000020   1B1A               SUBS     R3,R3,R0
   \   00000022   00E0               B        ??CleanFlash_2
   \                     ??CleanFlash_1:
   \   00000024   0B00               MOVS     R3,R1
   \                     ??CleanFlash_2:
   \   00000026   1402               LSLS     R4,R2,#+8
   \   00000028   0094               STR      R4,[SP, #+0]
   \   0000002A   009C               LDR      R4,[SP, #+0]
   \   0000002C   4294               STR      R4,[SP, #+264]
    211               
    212               //przepisanie strony pamiêci do RAMu
    213               ptrMem=(char*)(page*256);
    214               for (short i=0; i<256; i++)
   \   0000002E   0024               MOVS     R4,#+0
   \   00000030   2500               MOVS     R5,R4
   \   00000032   06E0               B        ??CleanFlash_3
    215                {  
    216                  tab.B[i]=ptrMem[i];     
   \                     ??CleanFlash_4:
   \   00000034   01AE               ADD      R6,SP,#+4
   \   00000036   429F               LDR      R7,[SP, #+264]
   \   00000038   7F5D               LDRB     R7,[R7, R5]
   \   0000003A   7755               STRB     R7,[R6, R5]
    217                }  
   \   0000003C   6D1C               ADDS     R5,R5,#+1
   \   0000003E   2D04               LSLS     R5,R5,#+16
   \   00000040   2D14               ASRS     R5,R5,#+16
   \                     ??CleanFlash_3:
   \   00000042   FF2D               CMP      R5,#+255
   \   00000044   F6DD               BLE      ??CleanFlash_4
    218               
    219                  //dodanie nowych danych
    220                  for (int i=komorka; i<=komorka+length_tmp-1; i++)
   \   00000046   0500               MOVS     R5,R0
   \   00000048   03E0               B        ??CleanFlash_5
    221                  {
    222                    tab.B[i]=0;
   \                     ??CleanFlash_6:
   \   0000004A   01AE               ADD      R6,SP,#+4
   \   0000004C   2700               MOVS     R7,R4
   \   0000004E   7755               STRB     R7,[R6, R5]
    223                    data++;
    224                  }
   \   00000050   6D1C               ADDS     R5,R5,#+1
   \                     ??CleanFlash_5:
   \   00000052   C618               ADDS     R6,R0,R3
   \   00000054   761E               SUBS     R6,R6,#+1
   \   00000056   AE42               CMP      R6,R5
   \   00000058   F7DA               BGE      ??CleanFlash_6
    225            
    226                  //UptrMem=(int*)ptrMem;  
    227                  UptrMem=(int*)(page*256);
   \   0000005A   0098               LDR      R0,[SP, #+0]
    228                    
    229                  //zapis do tymczasowego obszar
    230                  //for (unsigned int i=0; i<=63; i++) AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    231                  for (unsigned int i=0; i<=63; i++) UptrMem[i]=tab.DW[i];
   \   0000005C   2500               MOVS     R5,R4
   \   0000005E   04E0               B        ??CleanFlash_7
   \                     ??CleanFlash_8:
   \   00000060   AE00               LSLS     R6,R5,#+2
   \   00000062   01AF               ADD      R7,SP,#+4
   \   00000064   BF59               LDR      R7,[R7, R6]
   \   00000066   8751               STR      R7,[R0, R6]
   \   00000068   6D1C               ADDS     R5,R5,#+1
   \                     ??CleanFlash_7:
   \   0000006A   402D               CMP      R5,#+64
   \   0000006C   F8D3               BCC      ??CleanFlash_8
    232             
    233                  //oczekiwanie na flagê FRDY 
    234                  while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
   \                     ??CleanFlash_9:
   \   0000006E   9725               MOVS     R5,#+151
   \   00000070   ED43               MVNS     R5,R5            ;; #-152
   \   00000072   2868               LDR      R0,[R5, #+0]
   \   00000074   C007               LSLS     R0,R0,#+31
   \   00000076   FAD5               BPL      ??CleanFlash_9
    235                  //volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    236                  
    237                  //Zapis FCMD i PAGENB do MC_FCR
    238                  SET(AT91C_BASE_MC->MC_FCR,
    239                      AT91C_MC_CORRECT_KEY
    240                      | AT91C_MC_FCMD_START_PROG
    241                      | ((page << 8) & AT91C_MC_PAGEN)); 
   \   00000078   9B26               MOVS     R6,#+155
   \   0000007A   F643               MVNS     R6,R6            ;; #-156
   \   0000007C   3068               LDR      R0,[R6, #+0]
   \   0000007E   8446               MOV      R12,R0
   \   00000080   1702               LSLS     R7,R2,#+8
   \   00000082   ....               LDR      R0,??DataTable4  ;; 0x3ff00
   \   00000084   3840               ANDS     R0,R0,R7
   \   00000086   ....               LDR      R7,??DataTable5  ;; 0x5a000001
   \   00000088   0743               ORRS     R7,R7,R0
   \   0000008A   6046               MOV      R0,R12
   \   0000008C   0743               ORRS     R7,R7,R0
   \   0000008E   3760               STR      R7,[R6, #+0]
    242              
    243                  //oczekiwanie na flagê FRDY 
    244                  while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
   \                     ??CleanFlash_10:
   \   00000090   2868               LDR      R0,[R5, #+0]
   \   00000092   C007               LSLS     R0,R0,#+31
   \   00000094   FCD5               BPL      ??CleanFlash_10
    245                  
    246                  //Sprawdzenie czy nie naruszona blokada regionu
    247                  if (AT91C_BASE_MC->MC_FSR & AT91C_MC_LOCKE) 
   \   00000096   2868               LDR      R0,[R5, #+0]
    248                  {
    249                    // MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
    250                  }
    251                  
    252                  //Sprawdzenie czy zapis wykonany poprawnie
    253                  if (AT91C_BASE_MC->MC_FSR & AT91C_MC_PROGE) 
   \   00000098   2868               LDR      R0,[R5, #+0]
    254                  {
    255                    //MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
    256                  }
    257                  
    258               komorka = 0;
   \   0000009A   2000               MOVS     R0,R4
    259               length = length-length_tmp;
   \   0000009C   C91A               SUBS     R1,R1,R3
    260               page++;
   \   0000009E   521C               ADDS     R2,R2,#+1
    261              
    262             }while (length>0); 
   \   000000A0   0129               CMP      R1,#+1
   \   000000A2   B7DA               BGE      ??CleanFlash_0
    263          
    264              
    265          }
   \   000000A4   43B0               ADD      SP,SP,#+268
   \   000000A6   F0BC               POP      {R4-R7}
   \   000000A8   01BC               POP      {R0}
   \   000000AA   0047               BX       R0               ;; return
    266          
    267          
    268          
    269          /*
    270          __ramfunc void CleanFlash(int ofset,unsigned int cell, int length)
    271            {
    272             int page=     cell/256;
    273             int komorka = cell%256;
    274             int length_tmp;
    275             int data = 0; 
    276             unsigned long *memory;
    277             bool find; 
    278             int tmp_i =0;
    279             
    280             
    281           //  TRACE_INFO("\n\r---  CleanFlash  --- Ofset: %d, Komorka: %d, Rozmar: %dB\n\r",ofset,cell,length );
    282          
    283             
    284             union 
    285             {
    286                         char tab_B[256];
    287                unsigned long tab_DW[64];
    288             };
    289          
    290             do
    291             {
    292               if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
    293               
    294               
    295                memory=(unsigned long*) (ofset+page*256);
    296          
    297               find = false;
    298          
    299                tmp_i=0;
    300                do 
    301                {
    302                  if (memory[tmp_i]>0)
    303                  {
    304                    find = true;
    305                    break;
    306                  }
    307                  tmp_i++;
    308                } while (tmp_i<=63);
    309          
    310                
    311               if (find==true)    
    312               {
    313                  data=0;
    314                  for (int i=komorka; i<=komorka+length_tmp-1; i++)
    315                    {
    316                      tab_B[i]=0;
    317                      data++;
    318                    }
    319            
    320                  for (unsigned int i=0; i<=63; i++)
    321                    {
    322                      AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    323                    }  
    324             
    325                  volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    326          
    327                  SET(AT91C_BASE_MC->MC_FCR,
    328                      AT91C_MC_CORRECT_KEY
    329                      | AT91C_MC_FCMD_START_PROG
    330                      | (((page+(ofset/256)) << 8) & AT91C_MC_PAGEN)); 
    331              
    332                  while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);   
    333                }
    334               
    335               komorka = 0;
    336               length = length-length_tmp;
    337               page++;
    338              
    339             }while (length>0); 
    340              
    341           //  TRACE_INFO("\n\r ---Koniec  CleanFlash  --- \n\r");
    342          }
    343          
    344          */
    345          
    346          
    347          
    348          

   \                                 In section Debug.txt, align 4, keep-with-next
    349           void at91flashErase(void)
    350           {
   \                     at91flashErase:
   \   00000000   01B5               PUSH     {R0,LR}
    351             // erase flash
    352               AT91C_BASE_MC->MC_FCR =(0x5A<<24) | AT91C_MC_FCMD_ERASE_ALL;
   \   00000002   9B20               MOVS     R0,#+155
   \   00000004   C043               MVNS     R0,R0            ;; #-156
   \   00000006   0549               LDR      R1,??at91flashErase_0  ;; 0x5a000008
   \   00000008   0160               STR      R1,[R0, #+0]
    353               // wait for flash done/ready
    354               while(!(AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY));
   \                     ??at91flashErase_1:
   \   0000000A   9720               MOVS     R0,#+151
   \   0000000C   C043               MVNS     R0,R0            ;; #-152
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   C007               LSLS     R0,R0,#+31
   \   00000012   FAD5               BPL      ??at91flashErase_1
    355          
    356           }
   \   00000014   08BC               POP      {R3}
   \   00000016   01BC               POP      {R0}
   \   00000018   0047               BX       R0               ;; return
   \   0000001A   C046               Nop      
   \                     ??at91flashErase_0:
   \   0000001C   0800005A           DC32     0x5a000008

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   00FF0300           DC32     0x3ff00

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0100005A           DC32     0x5a000001

   \                                 In section .rodata, align 4
   \                     `?<Constant "Blad zapisu. Przekroc...">`:
   \   00000000   426C6164207A       DC8 "Blad zapisu. Przekroczenie dozwolonego obszaru"
   \              61706973752E
   \              2050727A656B
   \              726F637A656E
   \              696520646F7A
   \              776F6C6F6E65
   \              676F206F6273
   \              7A61727500  
   \   0000002F   00                 DC8 0
   \   00000030   426C6164207A       DC8 "Blad zapisu do flash"
   \              617069737520
   \              646F20666C61
   \              736800      
   \   00000045   000000             DC8 0, 0, 0
   \   00000048   42B3B964206E       DC8 "B³¹d naruszenia zablokowanego regionu flash"
   \              617275737A65
   \              6E6961207A61
   \              626C6F6B6F77
   \              616E65676F20
   \              726567696F6E
   \              7520666C6173
   \              6800        
   \   00000074   5AB379206B6C       DC8 "Z³y klucz lub b³edna komenda zapisu flash"
   \              75637A206C75
   \              622062B36564
   \              6E61206B6F6D
   \              656E6461207A
   \              617069737520
   \              666C61736800
   \   0000009E   0000               DC8 0, 0
    357          

   Maximum stack usage in bytes:

     Function       .cstack
     --------       -------
     CleanFlash        288
     FlashWrite        368
     InitFlash           0
     at91flashErase      8
     at91flashWrite    288


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     InitFlash                        24
     at91flashWrite                  170
     FlashWrite                      340
     CleanFlash                      172
     at91flashErase                   32
     ??DataTable4                      4
     ??DataTable5                      4
     ?<Constant "Blad zapisu. Przekroc...">
                                     160

 
 160 bytes in section .rodata
 690 bytes in section .textrw
  56 bytes in section Debug.txt
 
 746 bytes of CODE  memory
 160 bytes of CONST memory

Errors: none
Warnings: 12
