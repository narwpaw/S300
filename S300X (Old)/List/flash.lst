###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           11/Sep/2013  19:44:40 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v1.4 -              #
#                    12.06.2013\Framework\flash.c                             #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\Framework\flash.c" -D AT91SAM7S256 -D         #
#                    AT91SAM7SEK -D iH -D _LCD_NEGATIV_OLD_ -D __ALARM -D     #
#                    __WIFI_MODULE -D _DEBUG_ -D S300iOld -D _ADMINISTRATOR_  #
#                    -lC "D:\Zeuron\Projekty\S300\S300-program v1.4 -         #
#                    12.06.2013\S300X (Old)\List\" --diag_suppress Pa082 -o   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\S300X (Old)\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian little --cpu ARM7TDMI   #
#                    -e --fpu None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 5.0\ARM\INC\DLib_Config_Norma #
#                    l.h" -I "D:\Zeuron\Projekty\S300\S300-program v1.4 -     #
#                    12.06.2013\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v1.4 - 12.06.2013\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v1.4 - 12.06.2013\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v1.4 - 12.06.2013\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\Framework\Configuration\" -I "C:\Program      #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\INC\" --section .text=Debug.txt --interwork      #
#                    --cpu_mode thumb -Ol                                     #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v1.4 -              #
#                    12.06.2013\S300X (Old)\List\flash.lst                    #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v1.4 -              #
#                    12.06.2013\S300X (Old)\Obj\flash.o                       #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\flash.c
      1          #include "flash.h"
      2          #include <intrinsics.h>
      3          
      4          
      5          
      6          

   \                                 In section Debug.txt, align 4, keep-with-next
      7          void InitFlash(void)
      8          {
      9          
     10            AT91C_BASE_MC->MC_FMR = (((0x48)<<16) | AT91C_MC_FWS_2FWS);     // konfiguracja MC_FMR
   \                     InitFlash:
   \   00000000   9F20               MOVS     R0,#+159
   \   00000002   C043               MVNS     R0,R0            ;; #-160
   \   00000004   0549               LDR      R1,??InitFlash_0  ;; 0x480200
   \   00000006   0160               STR      R1,[R0, #+0]
     11          
     12            SET(AT91C_BASE_MC->MC_FMR, ((AT91C_MASTER_CLOCK / 666666)) << 16);
   \   00000008   9F20               MOVS     R0,#+159
   \   0000000A   C043               MVNS     R0,R0            ;; #-160
   \   0000000C   9F21               MOVS     R1,#+159
   \   0000000E   C943               MVNS     R1,R1            ;; #-160
   \   00000010   0968               LDR      R1,[R1, #+0]
   \   00000012   9022               MOVS     R2,#+144
   \   00000014   D203               LSLS     R2,R2,#+15       ;; #+4718592
   \   00000016   0A43               ORRS     R2,R2,R1
   \   00000018   0260               STR      R2,[R0, #+0]
     13              
     14            
     15          }
   \   0000001A   7047               BX       LR               ;; return
   \                     ??InitFlash_0:
   \   0000001C   00024800           DC32     0x480200
     16          
     17          
     18          
     19          
     20          //*-----------------------------------------------------------------------------
     21          //* Nazwa funkcji :    at91flashWrite
     22          //* Funkcja zapisu do flash
     23          //*-----------------------------------------------------------------------------
     24          //*  ofset  - przesuniêcie
     25          //*  cell   - pierwsza komórka zapisu
     26          //*  value  - wartoœæ do zapisu
     27          //*  length - wielkoœæ danych
     28          //*----------------------------------------------------------------------------
     29          

   \                                 In section .textrw, align 4, keep-with-next
     30          __ramfunc void at91flashWrite(  unsigned int ofset, unsigned int cell, char *value,  int length)
     31           {
   \                     at91flashWrite:
   \   00000000   F4B5               PUSH     {R2,R4-R7,LR}
   \   00000002   C2B0               SUB      SP,SP,#+264
   \   00000004   1C00               MOVS     R4,R3
     32             
     33             unsigned int Page=ofset+cell/256;
   \   00000006   0A00               MOVS     R2,R1
   \   00000008   120A               LSRS     R2,R2,#+8
   \   0000000A   8518               ADDS     R5,R0,R2
     34             unsigned int komorka=ofset+cell%256;
   \   0000000C   0600               MOVS     R6,R0
   \   0000000E   0800               MOVS     R0,R1
   \   00000010   8021               MOVS     R1,#+128
   \   00000012   4900               LSLS     R1,R1,#+1        ;; #+256
   \   00000014   ........           BL       __aeabi_uidivmod
   \   00000018   3000               MOVS     R0,R6
   \   0000001A   4018               ADDS     R0,R0,R1
     35             int length_tmp;
     36             int data = 0; 
   \   0000001C   0021               MOVS     R1,#+0
     37             unsigned long *memory;
     38             
     39          
     40             
     41            // TRACE_INFO("\n\r---  FlashWrite  --- Ofset: %d, Komorka: %d, Rozmar: %dB\n\r",ofset,cell,length );  
     42             
     43             union 
     44             {
     45                         char tab_B[256];
     46                unsigned long tab_DW[64];
     47             };
     48          
     49             do
     50             {
     51               if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
   \                     ??at91flashWrite_0:
   \   0000001E   0219               ADDS     R2,R0,R4
   \   00000020   FF23               MOVS     R3,#+255
   \   00000022   9B1C               ADDS     R3,R3,#+2        ;; #+257
   \   00000024   9A42               CMP      R2,R3
   \   00000026   04D3               BCC      ??at91flashWrite_1
   \   00000028   8022               MOVS     R2,#+128
   \   0000002A   5200               LSLS     R2,R2,#+1        ;; #+256
   \   0000002C   121A               SUBS     R2,R2,R0
   \   0000002E   0092               STR      R2,[SP, #+0]
   \   00000030   00E0               B        ??at91flashWrite_2
   \                     ??at91flashWrite_1:
   \   00000032   0094               STR      R4,[SP, #+0]
     52          
     53                memory=(unsigned long*) (Page*256);  //zmiana z memory=(unsigned long*) (ofset+page*256);
   \                     ??at91flashWrite_2:
   \   00000034   8022               MOVS     R2,#+128
   \   00000036   5200               LSLS     R2,R2,#+1        ;; #+256
   \   00000038   6A43               MULS     R2,R5,R2
   \   0000003A   0192               STR      R2,[SP, #+4]
     54               for (unsigned int i=0; i<=63; i++)
   \   0000003C   0022               MOVS     R2,#+0
   \   0000003E   0AE0               B        ??at91flashWrite_3
     55                {  
     56                  tab_DW[i]=memory[i];     
   \                     ??at91flashWrite_4:
   \   00000040   0427               MOVS     R7,#+4
   \   00000042   5743               MULS     R7,R2,R7
   \   00000044   02AE               ADD      R6,SP,#+8
   \   00000046   B446               MOV      R12,R6
   \   00000048   0426               MOVS     R6,#+4
   \   0000004A   5643               MULS     R6,R2,R6
   \   0000004C   019B               LDR      R3,[SP, #+4]
   \   0000004E   9B59               LDR      R3,[R3, R6]
   \   00000050   6646               MOV      R6,R12
   \   00000052   F351               STR      R3,[R6, R7]
     57                }  
   \   00000054   521C               ADDS     R2,R2,#+1
   \                     ??at91flashWrite_3:
   \   00000056   402A               CMP      R2,#+64
   \   00000058   F2D3               BCC      ??at91flashWrite_4
     58               
     59               for (int i=komorka; i<=komorka+length_tmp-1; i++)
   \   0000005A   0200               MOVS     R2,R0
   \   0000005C   05E0               B        ??at91flashWrite_5
     60                {
     61                  tab_B[i]=(unsigned long)value[data];
   \                     ??at91flashWrite_6:
   \   0000005E   02AB               ADD      R3,SP,#+8
   \   00000060   429E               LDR      R6,[SP, #+264]
   \   00000062   765C               LDRB     R6,[R6, R1]
   \   00000064   9E54               STRB     R6,[R3, R2]
     62                  data++;
   \   00000066   491C               ADDS     R1,R1,#+1
     63                }
   \   00000068   521C               ADDS     R2,R2,#+1
   \                     ??at91flashWrite_5:
   \   0000006A   009B               LDR      R3,[SP, #+0]
   \   0000006C   C318               ADDS     R3,R0,R3
   \   0000006E   5B1E               SUBS     R3,R3,#+1
   \   00000070   9342               CMP      R3,R2
   \   00000072   F4D2               BCS      ??at91flashWrite_6
     64            
     65               for (unsigned int i=0; i<=63; i++)
   \   00000074   0020               MOVS     R0,#+0
   \   00000076   09E0               B        ??at91flashWrite_7
     66                {
     67                  AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
   \                     ??at91flashWrite_8:
   \   00000078   0422               MOVS     R2,#+4
   \   0000007A   4243               MULS     R2,R0,R2
   \   0000007C   9823               MOVS     R3,#+152
   \   0000007E   5B03               LSLS     R3,R3,#+13       ;; #+1245184
   \   00000080   0426               MOVS     R6,#+4
   \   00000082   4643               MULS     R6,R0,R6
   \   00000084   02AF               ADD      R7,SP,#+8
   \   00000086   BE59               LDR      R6,[R7, R6]
   \   00000088   9E50               STR      R6,[R3, R2]
     68                }  
   \   0000008A   401C               ADDS     R0,R0,#+1
   \                     ??at91flashWrite_7:
   \   0000008C   4028               CMP      R0,#+64
   \   0000008E   F3D3               BCC      ??at91flashWrite_8
     69             
     70               unsigned int Status = AT91C_BASE_MC->MC_FSR;
   \   00000090   9720               MOVS     R0,#+151
   \   00000092   C043               MVNS     R0,R0            ;; #-152
   \   00000094   0068               LDR      R0,[R0, #+0]
     71          
     72               SET(AT91C_BASE_MC->MC_FCR,
     73                  AT91C_MC_CORRECT_KEY
     74                  | AT91C_MC_FCMD_START_PROG
     75                  | (((Page) << 8) & AT91C_MC_PAGEN));   //zmaina page+(ofset/256)
   \   00000096   9B22               MOVS     R2,#+155
   \   00000098   D243               MVNS     R2,R2            ;; #-156
   \   0000009A   9B23               MOVS     R3,#+155
   \   0000009C   DB43               MVNS     R3,R3            ;; #-156
   \   0000009E   1B68               LDR      R3,[R3, #+0]
   \   000000A0   2F02               LSLS     R7,R5,#+8
   \   000000A2   ....               LDR      R6,??DataTable6  ;; 0x3ff00
   \   000000A4   3E40               ANDS     R6,R6,R7
   \   000000A6   ....               LDR      R7,??DataTable7  ;; 0x5a000001
   \   000000A8   3743               ORRS     R7,R7,R6
   \   000000AA   1F43               ORRS     R7,R7,R3
   \   000000AC   1760               STR      R7,[R2, #+0]
     76              
     77               while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);   
   \                     ??at91flashWrite_9:
   \   000000AE   9720               MOVS     R0,#+151
   \   000000B0   C043               MVNS     R0,R0            ;; #-152
   \   000000B2   0068               LDR      R0,[R0, #+0]
   \   000000B4   C007               LSLS     R0,R0,#+31
   \   000000B6   FAD5               BPL      ??at91flashWrite_9
     78              
     79               komorka = 0;
   \   000000B8   0020               MOVS     R0,#+0
     80               length = length-length_tmp;
   \   000000BA   009A               LDR      R2,[SP, #+0]
   \   000000BC   A41A               SUBS     R4,R4,R2
     81               Page++;
   \   000000BE   6D1C               ADDS     R5,R5,#+1
     82              
     83             }while (length>0); 
   \   000000C0   012C               CMP      R4,#+1
   \   000000C2   ACDA               BGE      ??at91flashWrite_0
     84              
     85          
     86          }
   \   000000C4   43B0               ADD      SP,SP,#+268
   \   000000C6   F0BC               POP      {R4-R7}
   \   000000C8   01BC               POP      {R0}
   \   000000CA   0047               BX       R0               ;; return
     87          
     88          
     89          
     90          
     91          
     92          
     93          
     94          
     95          
     96          
     97          
     98          
     99          #define FLASH_PAGE_SIZE_BYTE 512
    100          
    101          
    102          
    103          
    104          //*---------------------------------------------------------------------------- 
    105          //* \fn    AT91F_Flash_Ready 
    106          //* \brief Czekanie na zapis Flash'a 
    107          //*---------------------------------------------------------------------------- 

   \                                 In section .textrw, align 4, keep-with-next
    108          __ramfunc int AT91F_Flash_Ready (void) 
    109          { 
   \                     AT91F_Flash_Ready:
   \   00000000   01B5               PUSH     {R0,LR}
    110              unsigned int status; 
    111              status = 0; 
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   02E0               B        ??AT91F_Flash_Ready_0
    112          
    113              // Wait the end of command 
    114                  while ((status & AT91C_MC_FRDY) != AT91C_MC_FRDY ) 
    115                  { 
    116                    status = AT91C_BASE_MC->MC_FSR; 
   \                     ??AT91F_Flash_Ready_1:
   \   00000006   9720               MOVS     R0,#+151
   \   00000008   C043               MVNS     R0,R0            ;; #-152
   \   0000000A   0068               LDR      R0,[R0, #+0]
    117                  } 
   \                     ??AT91F_Flash_Ready_0:
   \   0000000C   C107               LSLS     R1,R0,#+31
   \   0000000E   FAD5               BPL      ??AT91F_Flash_Ready_1
    118                  return status; 
   \   00000010   01B0               ADD      SP,SP,#+4
   \   00000012   02BC               POP      {R1}
   \   00000014   0847               BX       R1               ;; return
    119          } 
    120          
    121          
    122          

   \                                 In section .textrw, align 4, keep-with-next
    123          __ramfunc int AT91F_Flash_Write( unsigned int Flash_Address ,int size ,unsigned int * buff) 
    124          { 
   \                     AT91F_Flash_Write:
   \   00000000   70B5               PUSH     {R4-R6,LR}
    125              // set the Flash controller base address 
    126              AT91PS_MC ptMC = AT91C_BASE_MC; 
   \   00000002   FF23               MOVS     R3,#+255
   \   00000004   DB43               MVNS     R3,R3            ;; #-256
    127              unsigned int i, page, status; 
    128              unsigned int * Flash; 
    129              
    130              // init flash pointer 
    131              Flash = (unsigned int *) Flash_Address; 
    132              // Get the Flash page number 
    133              page = ((Flash_Address - (unsigned int)AT91C_IFLASH ) /FLASH_PAGE_SIZE_BYTE); 
   \   00000006   1B4C               LDR      R4,??AT91F_Flash_Write_0  ;; 0xfff00000
   \   00000008   0419               ADDS     R4,R0,R4
   \   0000000A   640A               LSRS     R4,R4,#+9
    134              // copy the new value 
    135              
    136          
    137              
    138              
    139              for (i=0; (i < FLASH_PAGE_SIZE_BYTE) & (size > 0) ;i++, Flash++,buff++,size-=4 )
   \   0000000C   0025               MOVS     R5,#+0
   \   0000000E   05E0               B        ??AT91F_Flash_Write_1
    140              { 
    141              *Flash=*buff; 
   \                     ??AT91F_Flash_Write_2:
   \   00000010   1668               LDR      R6,[R2, #+0]
   \   00000012   0660               STR      R6,[R0, #+0]
    142              } 
   \   00000014   6D1C               ADDS     R5,R5,#+1
   \   00000016   001D               ADDS     R0,R0,#+4
   \   00000018   121D               ADDS     R2,R2,#+4
   \   0000001A   091F               SUBS     R1,R1,#+4
   \                     ??AT91F_Flash_Write_1:
   \   0000001C   8026               MOVS     R6,#+128
   \   0000001E   B600               LSLS     R6,R6,#+2        ;; #+512
   \   00000020   B542               CMP      R5,R6
   \   00000022   04D2               BCS      ??AT91F_Flash_Write_3
   \   00000024   0126               MOVS     R6,#+1
   \   00000026   0129               CMP      R1,#+1
   \   00000028   01DB               BLT      ??AT91F_Flash_Write_3
   \   0000002A   F607               LSLS     R6,R6,#+31
   \   0000002C   F0D4               BMI      ??AT91F_Flash_Write_2
    143              
    144              
    145              __disable_interrupt();
   \                     ??AT91F_Flash_Write_3:
   \   0000002E   ........           BL       __iar_disable_interrupt
    146              unsigned long ulIntrStat = AT91C_BASE_AIC->AIC_IMR; 
   \   00000032   1148               LDR      R0,??AT91F_Flash_Write_0+0x4  ;; 0xfffff110
   \   00000034   0068               LDR      R0,[R0, #+0]
    147              AT91C_BASE_AIC->AIC_IDCR = 0xFFFFFFFF; 
   \   00000036   1149               LDR      R1,??AT91F_Flash_Write_0+0x8  ;; 0xfffff124
   \   00000038   0022               MOVS     R2,#+0
   \   0000003A   D243               MVNS     R2,R2            ;; #-1
   \   0000003C   0A60               STR      R2,[R1, #+0]
    148              
    149              // Write the write page command 
    150              ptMC->MC_FCR = AT91C_MC_CORRECT_KEY | AT91C_MC_FCMD_START_PROG | (AT91C_MC_PAGEN & (page <<8)) ; 
   \   0000003E   2102               LSLS     R1,R4,#+8
   \   00000040   ....               LDR      R2,??DataTable6  ;; 0x3ff00
   \   00000042   0A40               ANDS     R2,R2,R1
   \   00000044   ....               LDR      R1,??DataTable7  ;; 0x5a000001
   \   00000046   1143               ORRS     R1,R1,R2
   \   00000048   5966               STR      R1,[R3, #+100]
    151              
    152              //for a certain ammount of time you cant do any operation over flash memory. 
    153              for(i=0;i<100000;i++) asm("nop"); 
   \   0000004A   0025               MOVS     R5,#+0
   \   0000004C   01E0               B        ??AT91F_Flash_Write_4
   \                     ??AT91F_Flash_Write_5:
   \   0000004E   C046               nop              
   \   00000050   6D1C               ADDS     R5,R5,#+1
   \                     ??AT91F_Flash_Write_4:
   \   00000052   0B49               LDR      R1,??AT91F_Flash_Write_0+0xC  ;; 0x186a0
   \   00000054   8D42               CMP      R5,R1
   \   00000056   FAD3               BCC      ??AT91F_Flash_Write_5
    154              
    155              //Enable ints 
    156              AT91C_BASE_AIC->AIC_IECR = ulIntrStat; 
   \   00000058   0A49               LDR      R1,??AT91F_Flash_Write_0+0x10  ;; 0xfffff120
   \   0000005A   0860               STR      R0,[R1, #+0]
    157              
    158              // Wait the end of command 
    159              status = AT91F_Flash_Ready(); 
   \   0000005C   ........           BL       AT91F_Flash_Ready
    160              
    161               __enable_interrupt();
   \   00000060   ........           BL       __iar_enable_interrupt
    162              // Check the result 
    163              if ( (status & ( AT91C_MC_PROGE | AT91C_MC_LOCKE ))!=0) 
   \   00000064   0C21               MOVS     R1,#+12
   \   00000066   0140               ANDS     R1,R1,R0
   \   00000068   481E               SUBS     R0,R1,#+1
   \   0000006A   8041               SBCS     R0,R0,R0
   \   0000006C   C00F               LSRS     R0,R0,#+31
    164              return false; 
    165              return true; 
   \   0000006E   70BC               POP      {R4-R6}
   \   00000070   02BC               POP      {R1}
   \   00000072   0847               BX       R1               ;; return
   \                     ??AT91F_Flash_Write_0:
   \   00000074   0000F0FF           DC32     0xfff00000
   \   00000078   10F1FFFF           DC32     0xfffff110
   \   0000007C   24F1FFFF           DC32     0xfffff124
   \   00000080   A0860100           DC32     0x186a0
   \   00000084   20F1FFFF           DC32     0xfffff120
    166          } 
    167          
    168          
    169          
    170          
    171             /*
    172          
    173          //__ramfunc int AT91F_Flash_Write( unsigned int Flash_Address ,int size ,unsigned int * buff) 
    174          __ramfunc  void FlashWrite(volatile char *ptrMem,volatile char *value,volatile int length)
    175          { 
    176            
    177          
    178              // set the Flash controller base address 
    179              AT91PS_MC ptMC = AT91C_BASE_MC; 
    180              unsigned int i, page, status; 
    181              unsigned int * Flash; 
    182              
    183              // init flash pointer 
    184              Flash = (unsigned int *) Flash_Address; 
    185              // Get the Flash page number 
    186              page = ((Flash_Address - (unsigned int)AT91C_IFLASH ) /FLASH_PAGE_SIZE_BYTE); 
    187              // copy the new value 
    188          
    189          
    190          
    191          
    192            volatile int page=     (int)ptrMem/256;
    193             volatile int komorka = (int)ptrMem%256;   
    194             volatile int PtrInt=(int)ptrMem;
    195             volatile int length_tmp;
    196             volatile int data = 0; 
    197             volatile int *UptrMem;
    198             volatile char* ptrMem2;
    199          
    200             if ((PtrInt>0x00140000) || (PtrInt<0x00120000) || (komorka>0xFF))
    201             {
    202                 char mess[]="Blad zapisu. Przekroczenie dozwolonego obszaru";
    203                 MESSAGE(mess); 
    204             }else{
    205           
    206                 union 
    207                 {
    208                             char B[256];
    209                    unsigned long DW[64];
    210                 }tab;
    211              
    212                 do
    213                 {
    214                   if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
    215                   
    216                   //przepisanie strony pamiêci do RAMu
    217                   ptrMem2=(char*)(page*256);
    218                   for (short i=0; i<256; i++)
    219                    {  
    220                      tab.B[i]=ptrMem2[i];     
    221                    }  
    222                   
    223                      //dodanie nowych danych
    224                      for (int i=komorka; i<=komorka+length_tmp-1; i++)
    225                      {
    226                        tab.B[i]=value[data];
    227                        data++;
    228                      }
    229                
    230                      //UptrMem=(int*)ptrMem;  
    231                      UptrMem=(int*)(page*256);
    232                        
    233                      //zapis do tymczasowego obszar
    234                      //for (unsigned int i=0; i<=63; i++) AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    235                      for (unsigned int i=0; i<=63; i++) UptrMem[i]=tab.DW[i];
    236                 
    237                      //oczekiwanie na flagê FRDY 
    238                      while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
    239                      //volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    240                      
    241                      //Zapis FCMD i PAGENB do MC_FCR
    242                      SET(AT91C_BASE_MC->MC_FCR,
    243                          AT91C_MC_CORRECT_KEY
    244                          | AT91C_MC_FCMD_START_PROG
    245                          | ((page << 8) & AT91C_MC_PAGEN)); 
    246                  
    247                      //oczekiwanie na flagê FRDY 
    248                      long long MaxCount=0;
    249                      while(((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY) || (MaxCount>0xFFFE)) {MaxCount++;};  
    250                      if (MaxCount==0xFFFF)  
    251                      {
    252                        char mess[]="Blad zapisu do flash";
    253                        MESSAGE(mess); 
    254                      }
    255                      //Sprawdzenie czy nie naruszona blokada regionu
    256                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_LOCKE) 
    257                      {
    258                         MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
    259                      }
    260                      
    261                      //Sprawdzenie czy zapis wykonany poprawnie
    262                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_PROGE) 
    263                      {
    264                        MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
    265                      }
    266                      
    267                   komorka = 0;
    268                   length = length-length_tmp;
    269                   page++;
    270                  
    271                 }while (length>0); 
    272             }
    273            
    274          }
    275          */    
    276              
    277              
    278          
    279          
    280          
    281          
    282          
    283          
    284          //*-----------------------------------------------------------------------------
    285          //* Nazwa funkcji :    FlashWrite
    286          //* Funkcja zapisu do flash
    287          //*-----------------------------------------------------------------------------
    288          //*  ofset  - przesuniêcie
    289          //*  cell   - pierwsza komórka zapisu
    290          //*  ptrMem - wskaŸnik na komórke pamiêci flash
    291          //*  value  - wartoœæ do zapisu
    292          //*  length - wielkoœæ danych
    293          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    294          void FlashWrite( char *ptrMem, char *value, int length)
    295           {
   \                     FlashWrite:
   \   00000000   7FB5               PUSH     {R0-R6,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    296             volatile int page    = (int)ptrMem/256;
   \   00000008   2000               MOVS     R0,R4
   \   0000000A   8021               MOVS     R1,#+128
   \   0000000C   4900               LSLS     R1,R1,#+1        ;; #+256
   \   0000000E   ........           BL       __aeabi_idivmod
   \   00000012   0090               STR      R0,[SP, #+0]
    297             volatile int komorka = (int)ptrMem%256; 
   \   00000014   2000               MOVS     R0,R4
   \   00000016   8021               MOVS     R1,#+128
   \   00000018   4900               LSLS     R1,R1,#+1        ;; #+256
   \   0000001A   ........           BL       __aeabi_idivmod
   \   0000001E   0191               STR      R1,[SP, #+4]
    298             volatile int PtrInt  = (int)ptrMem;
   \   00000020   0294               STR      R4,[SP, #+8]
    299             
    300             FlashWriteExe(PtrInt, page, komorka, value, length);
   \   00000022   82B0               SUB      SP,SP,#+8
   \   00000024   0096               STR      R6,[SP, #+0]
   \   00000026   2B00               MOVS     R3,R5
   \   00000028   039A               LDR      R2,[SP, #+12]
   \   0000002A   0299               LDR      R1,[SP, #+8]
   \   0000002C   0498               LDR      R0,[SP, #+16]
   \   0000002E   ........           BL       FlashWriteExe
   \   00000032   02B0               ADD      SP,SP,#+8
    301           } 
   \   00000034   04B0               ADD      SP,SP,#+16
   \   00000036   70BC               POP      {R4-R6}
   \   00000038   01BC               POP      {R0}
   \   0000003A   0047               BX       R0               ;; return
    302             
    303          
    304          

   \                                 In section .textrw, align 4, keep-with-next
    305          __ramfunc  void FlashWriteExe(volatile int  PtrInt,  volatile int  page, volatile int  komorka, char *value, int length)
    306           {
   \                     FlashWriteExe:
   \   00000000   77B5               PUSH     {R0-R2,R4-R6,LR}
   \   00000002   D5B0               SUB      SP,SP,#+340
   \   00000004   1D00               MOVS     R5,R3
   \   00000006   5C9C               LDR      R4,[SP, #+368]
    307          
    308             volatile int length_tmp;
    309             volatile int data = 0; 
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   0190               STR      R0,[SP, #+4]
    310             volatile int *UptrMem;
    311             volatile char* ptrMem2;
    312          
    313             if ((PtrInt>(int)0x00140000) || (PtrInt<(int)0x00120000) || (komorka>0xFF))
   \   0000000C   5598               LDR      R0,[SP, #+340]
   \   0000000E   5249               LDR      R1,??FlashWriteExe_0  ;; 0x140001
   \   00000010   8842               CMP      R0,R1
   \   00000012   07DA               BGE      ??FlashWriteExe_1
   \   00000014   5598               LDR      R0,[SP, #+340]
   \   00000016   9021               MOVS     R1,#+144
   \   00000018   4903               LSLS     R1,R1,#+13       ;; #+1179648
   \   0000001A   8842               CMP      R0,R1
   \   0000001C   02DB               BLT      ??FlashWriteExe_1
   \   0000001E   5798               LDR      R0,[SP, #+348]
   \   00000020   FF28               CMP      R0,#+255
   \   00000022   08DD               BLE      ??FlashWriteExe_2
    314             {
    315                 char mess[]="Blad zapisu. Przekroczenie dozwolonego obszaru";
   \                     ??FlashWriteExe_1:
   \   00000024   48A8               ADD      R0,SP,#+288
   \   00000026   4D49               LDR      R1,??FlashWriteExe_0+0x4  ;; `?<Constant "Blad zapisu. Przekroc...">`
   \   00000028   3022               MOVS     R2,#+48
   \   0000002A   ........           BL       __aeabi_memcpy4
    316                 MESSAGE(mess); 
                        ^
Warning[Pe223]: function "MESSAGE" declared implicitly

         MESSAGE(mess); 
         ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\flash.c",316  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function
   \   0000002E   48A8               ADD      R0,SP,#+288
   \   00000030   ........           BL       MESSAGE
   \   00000034   8CE0               B        ??FlashWriteExe_3
    317             }else{
    318           
    319                 union 
    320                 {
    321                             char B[256];
    322                    unsigned long DW[64];
    323                 }tab;
    324              
    325                 do
    326                 {
    327                   if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
   \                     ??FlashWriteExe_2:
   \                     ??FlashWriteExe_4:
   \   00000036   5798               LDR      R0,[SP, #+348]
   \   00000038   0019               ADDS     R0,R0,R4
   \   0000003A   FF21               MOVS     R1,#+255
   \   0000003C   891C               ADDS     R1,R1,#+2        ;; #+257
   \   0000003E   8842               CMP      R0,R1
   \   00000040   05DB               BLT      ??FlashWriteExe_5
   \   00000042   8020               MOVS     R0,#+128
   \   00000044   4000               LSLS     R0,R0,#+1        ;; #+256
   \   00000046   5799               LDR      R1,[SP, #+348]
   \   00000048   401A               SUBS     R0,R0,R1
   \   0000004A   0090               STR      R0,[SP, #+0]
   \   0000004C   00E0               B        ??FlashWriteExe_6
   \                     ??FlashWriteExe_5:
   \   0000004E   0094               STR      R4,[SP, #+0]
    328                   
    329                   //przepisanie strony pamiêci do RAMu
    330                   ptrMem2=(char*)(page*256);
   \                     ??FlashWriteExe_6:
   \   00000050   5698               LDR      R0,[SP, #+344]
   \   00000052   8021               MOVS     R1,#+128
   \   00000054   4900               LSLS     R1,R1,#+1        ;; #+256
   \   00000056   4843               MULS     R0,R1,R0
    331                   for (short i=0; i<256; i++)
   \   00000058   0021               MOVS     R1,#+0
   \   0000005A   07E0               B        ??FlashWriteExe_7
    332                    {  
    333                      tab.B[i]=ptrMem2[i];     
   \                     ??FlashWriteExe_8:
   \   0000005C   0904               LSLS     R1,R1,#+16       ;; SignExtS R1,R1,#+16,#+16
   \   0000005E   0914               ASRS     R1,R1,#+16
   \   00000060   08AA               ADD      R2,SP,#+32
   \   00000062   0904               LSLS     R1,R1,#+16       ;; SignExtS R1,R1,#+16,#+16
   \   00000064   0914               ASRS     R1,R1,#+16
   \   00000066   435C               LDRB     R3,[R0, R1]
   \   00000068   5354               STRB     R3,[R2, R1]
    334                    }  
   \   0000006A   491C               ADDS     R1,R1,#+1
   \                     ??FlashWriteExe_7:
   \   0000006C   8022               MOVS     R2,#+128
   \   0000006E   5200               LSLS     R2,R2,#+1        ;; #+256
   \   00000070   0904               LSLS     R1,R1,#+16       ;; SignExtS R1,R1,#+16,#+16
   \   00000072   0914               ASRS     R1,R1,#+16
   \   00000074   9142               CMP      R1,R2
   \   00000076   F1DB               BLT      ??FlashWriteExe_8
    335                   
    336                      //dodanie nowych danych
    337                      for (int i=komorka; i<=komorka+length_tmp-1; i++)
   \   00000078   5798               LDR      R0,[SP, #+348]
   \   0000007A   07E0               B        ??FlashWriteExe_9
    338                      {
    339                        tab.B[i]=value[data];
   \                     ??FlashWriteExe_10:
   \   0000007C   08A9               ADD      R1,SP,#+32
   \   0000007E   019A               LDR      R2,[SP, #+4]
   \   00000080   AA5C               LDRB     R2,[R5, R2]
   \   00000082   0A54               STRB     R2,[R1, R0]
    340                        data++;
   \   00000084   0199               LDR      R1,[SP, #+4]
   \   00000086   491C               ADDS     R1,R1,#+1
   \   00000088   0191               STR      R1,[SP, #+4]
    341                      }
   \   0000008A   401C               ADDS     R0,R0,#+1
   \                     ??FlashWriteExe_9:
   \   0000008C   5799               LDR      R1,[SP, #+348]
   \   0000008E   009A               LDR      R2,[SP, #+0]
   \   00000090   8918               ADDS     R1,R1,R2
   \   00000092   491E               SUBS     R1,R1,#+1
   \   00000094   8142               CMP      R1,R0
   \   00000096   F1DA               BGE      ??FlashWriteExe_10
    342                
    343                      //UptrMem=(int*)ptrMem;  
    344                      UptrMem=(int*)(page*256);
   \   00000098   5698               LDR      R0,[SP, #+344]
   \   0000009A   8021               MOVS     R1,#+128
   \   0000009C   4900               LSLS     R1,R1,#+1        ;; #+256
   \   0000009E   4843               MULS     R0,R1,R0
    345                        
    346                      //zapis do tymczasowego obszar
    347                      //for (unsigned int i=0; i<=63; i++) AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    348                      for (unsigned int i=0; i<=63; i++) UptrMem[i]=tab.DW[i];
   \   000000A0   0021               MOVS     R1,#+0
   \   000000A2   07E0               B        ??FlashWriteExe_11
   \                     ??FlashWriteExe_12:
   \   000000A4   0422               MOVS     R2,#+4
   \   000000A6   4A43               MULS     R2,R1,R2
   \   000000A8   0423               MOVS     R3,#+4
   \   000000AA   4B43               MULS     R3,R1,R3
   \   000000AC   08AE               ADD      R6,SP,#+32
   \   000000AE   F358               LDR      R3,[R6, R3]
   \   000000B0   8350               STR      R3,[R0, R2]
   \   000000B2   491C               ADDS     R1,R1,#+1
   \                     ??FlashWriteExe_11:
   \   000000B4   4029               CMP      R1,#+64
   \   000000B6   F5D3               BCC      ??FlashWriteExe_12
    349                 
    350                      //oczekiwanie na flagê FRDY 
    351                      while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
   \                     ??FlashWriteExe_13:
   \   000000B8   9720               MOVS     R0,#+151
   \   000000BA   C043               MVNS     R0,R0            ;; #-152
   \   000000BC   0068               LDR      R0,[R0, #+0]
   \   000000BE   C007               LSLS     R0,R0,#+31
   \   000000C0   FAD5               BPL      ??FlashWriteExe_13
    352                      //volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    353                      
    354                      //Zapis FCMD i PAGENB do MC_FCR
    355                      SET(AT91C_BASE_MC->MC_FCR,
    356                          AT91C_MC_CORRECT_KEY
    357                          | AT91C_MC_FCMD_START_PROG
    358                          | ((page << 8) & AT91C_MC_PAGEN)); 
   \   000000C2   9B20               MOVS     R0,#+155
   \   000000C4   C043               MVNS     R0,R0            ;; #-156
   \   000000C6   9B21               MOVS     R1,#+155
   \   000000C8   C943               MVNS     R1,R1            ;; #-156
   \   000000CA   0968               LDR      R1,[R1, #+0]
   \   000000CC   569A               LDR      R2,[SP, #+344]
   \   000000CE   1202               LSLS     R2,R2,#+8
   \   000000D0   ....               LDR      R3,??DataTable6  ;; 0x3ff00
   \   000000D2   1340               ANDS     R3,R3,R2
   \   000000D4   ....               LDR      R2,??DataTable7  ;; 0x5a000001
   \   000000D6   1A43               ORRS     R2,R2,R3
   \   000000D8   0A43               ORRS     R2,R2,R1
   \   000000DA   0260               STR      R2,[R0, #+0]
    359                  
    360                      //oczekiwanie na flagê FRDY 
    361                      long long MaxCount=0;
   \   000000DC   0020               MOVS     R0,#+0
   \   000000DE   0021               MOVS     R1,#+0
   \   000000E0   02E0               B        ??FlashWriteExe_14
    362                      while(((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY) || (MaxCount>0xFFFE)) {MaxCount++;};  
   \                     ??FlashWriteExe_15:
   \   000000E2   0022               MOVS     R2,#+0
   \   000000E4   401C               ADDS     R0,R0,#+1
   \   000000E6   5141               ADCS     R1,R1,R2
   \                     ??FlashWriteExe_14:
   \   000000E8   9722               MOVS     R2,#+151
   \   000000EA   D243               MVNS     R2,R2            ;; #-152
   \   000000EC   1268               LDR      R2,[R2, #+0]
   \   000000EE   D207               LSLS     R2,R2,#+31
   \   000000F0   F7D5               BPL      ??FlashWriteExe_15
   \   000000F2   1B4A               LDR      R2,??FlashWriteExe_0+0x8  ;; 0xffff
   \   000000F4   0023               MOVS     R3,#+0
   \   000000F6   9942               CMP      R1,R3
   \   000000F8   F3DC               BGT      ??FlashWriteExe_15
   \   000000FA   01DB               BLT      ??FlashWriteExe_16
   \   000000FC   9042               CMP      R0,R2
   \   000000FE   F0D2               BCS      ??FlashWriteExe_15
    363                      if (MaxCount==0xFFFF)  
   \                     ??FlashWriteExe_16:
   \   00000100   174A               LDR      R2,??FlashWriteExe_0+0x8  ;; 0xffff
   \   00000102   0023               MOVS     R3,#+0
   \   00000104   9942               CMP      R1,R3
   \   00000106   09D1               BNE      ??FlashWriteExe_17
   \   00000108   9042               CMP      R0,R2
   \   0000010A   07D1               BNE      ??FlashWriteExe_17
    364                      {
    365                        char mess[]="Blad zapisu do flash";
   \   0000010C   02A8               ADD      R0,SP,#+8
   \   0000010E   1549               LDR      R1,??FlashWriteExe_0+0xC  ;; `?<Constant "Blad zapisu do flash">`
   \   00000110   1822               MOVS     R2,#+24
   \   00000112   ........           BL       __aeabi_memcpy4
    366                        MESSAGE(mess); 
                               ^
Warning[Pe223]: function "MESSAGE" declared implicitly

                MESSAGE(mess); 
                ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\flash.c",366  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function
   \   00000116   02A8               ADD      R0,SP,#+8
   \   00000118   ........           BL       MESSAGE
    367                      }
    368                      //Sprawdzenie czy nie naruszona blokada regionu
    369                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_LOCKE) 
   \                     ??FlashWriteExe_17:
   \   0000011C   9720               MOVS     R0,#+151
   \   0000011E   C043               MVNS     R0,R0            ;; #-152
   \   00000120   0068               LDR      R0,[R0, #+0]
   \   00000122   4007               LSLS     R0,R0,#+29
   \   00000124   02D5               BPL      ??FlashWriteExe_18
    370                      {
    371                         MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
                                ^
Warning[Pe223]: function "MESSAGE" declared implicitly

                 MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
                 ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\flash.c",371  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function
   \   00000126   1048               LDR      R0,??FlashWriteExe_0+0x10  ;; `?<Constant "B³¹d naruszenia zablo...">`
   \   00000128   ........           BL       MESSAGE
    372                      }
    373                      
    374                      //Sprawdzenie czy zapis wykonany poprawnie
    375                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_PROGE) 
   \                     ??FlashWriteExe_18:
   \   0000012C   9720               MOVS     R0,#+151
   \   0000012E   C043               MVNS     R0,R0            ;; #-152
   \   00000130   0068               LDR      R0,[R0, #+0]
   \   00000132   0007               LSLS     R0,R0,#+28
   \   00000134   02D5               BPL      ??FlashWriteExe_19
    376                      {
    377                        MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
                               ^
Warning[Pe223]: function "MESSAGE" declared implicitly

                MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
                ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\flash.c",377  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function

     unsigned int komorka=ofset+cell%256;
                         ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\flash.c",34  Warning[Ta021]: 
          Library call (__aeabi_uidivmod) from within a __ramfunc function

      __disable_interrupt();
      ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\flash.c",145  Warning[Ta021]: 
          Library call (__iar_disable_interrupt) from within a __ramfunc
          function

       __enable_interrupt();
       ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\flash.c",161  Warning[Ta021]: 
          Library call (__iar_enable_interrupt) from within a __ramfunc
          function

         char mess[]="Blad zapisu. Przekroczenie dozwolonego obszaru";
                    ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\flash.c",315  Warning[Ta022]: 
          Possible rom access (<Constant "Blad zapisu. Przekroc...">) from
          within a __ramfunc function

                char mess[]="Blad zapisu do flash";
                           ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\flash.c",365  Warning[Ta022]: 
          Possible rom access (<Constant "Blad zapisu do flash">) from within
          a __ramfunc function

                 MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
                 ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\flash.c",371  Warning[Ta022]: 
          Possible rom access (<Constant "B³¹d naruszenia zablo...">) from
          within a __ramfunc function

                MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
                ^
"D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\Framework\flash.c",377  Warning[Ta022]: 
          Possible rom access (<Constant "Z³y klucz lub b³edna ...">) from
          within a __ramfunc function
   \   00000136   0D48               LDR      R0,??FlashWriteExe_0+0x14  ;; `?<Constant "Z³y klucz lub b³edna ...">`
   \   00000138   ........           BL       MESSAGE
    378                      }
    379                      
    380                   komorka = 0;
   \                     ??FlashWriteExe_19:
   \   0000013C   0020               MOVS     R0,#+0
   \   0000013E   5790               STR      R0,[SP, #+348]
    381                   length = length-length_tmp;
   \   00000140   0098               LDR      R0,[SP, #+0]
   \   00000142   241A               SUBS     R4,R4,R0
    382                   page++;
   \   00000144   5698               LDR      R0,[SP, #+344]
   \   00000146   401C               ADDS     R0,R0,#+1
   \   00000148   5690               STR      R0,[SP, #+344]
    383                  
    384                 }while (length>0); 
   \   0000014A   012C               CMP      R4,#+1
   \   0000014C   00DB               BLT      .+4
   \   0000014E   72E7               B        ??FlashWriteExe_4
    385             }
    386              
    387          }
   \                     ??FlashWriteExe_3:
   \   00000150   58B0               ADD      SP,SP,#+352
   \   00000152   70BC               POP      {R4-R6}
   \   00000154   01BC               POP      {R0}
   \   00000156   0047               BX       R0               ;; return
   \                     ??FlashWriteExe_0:
   \   00000158   01001400           DC32     0x140001
   \   0000015C   ........           DC32     `?<Constant "Blad zapisu. Przekroc...">`
   \   00000160   FFFF0000           DC32     0xffff
   \   00000164   ........           DC32     `?<Constant "Blad zapisu do flash">`
   \   00000168   ........           DC32     `?<Constant "B³¹d naruszenia zablo...">`
   \   0000016C   ........           DC32     `?<Constant "Z³y klucz lub b³edna ...">`
    388          
    389          
    390          
    391          
    392          
    393          
    394          

   \                                 In section .textrw, align 4, keep-with-next
    395          __ramfunc void CleanFlash(char *ptrMem, int length)
    396           {
   \                     CleanFlash:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   C0B0               SUB      SP,SP,#+256
   \   00000004   0C00               MOVS     R4,R1
    397             int page=     (int)ptrMem/256;
                                                 ^
Warning[Ta021]: Library call (__aeabi_idivmod) from within a __ramfunc function
   \   00000006   4098               LDR      R0,[SP, #+256]
   \   00000008   8021               MOVS     R1,#+128
   \   0000000A   4900               LSLS     R1,R1,#+1        ;; #+256
   \   0000000C   ........           BL       __aeabi_idivmod
   \   00000010   0500               MOVS     R5,R0
    398             int komorka = (int)ptrMem%256;   
                                                 ^
Warning[Ta021]: Library call (__aeabi_idivmod) from within a __ramfunc function
   \   00000012   4098               LDR      R0,[SP, #+256]
   \   00000014   8021               MOVS     R1,#+128
   \   00000016   4900               LSLS     R1,R1,#+1        ;; #+256
   \   00000018   ........           BL       __aeabi_idivmod
   \   0000001C   0A00               MOVS     R2,R1
    399             int length_tmp;
    400             int data = 0; 
   \   0000001E   0021               MOVS     R1,#+0
    401             int *UptrMem;
    402          
    403             union 
    404             {
    405                         char B[256];
    406                unsigned long DW[64];
    407             }tab;
    408          
    409             do
    410             {
    411               if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
   \                     ??CleanFlash_0:
   \   00000020   1019               ADDS     R0,R2,R4
   \   00000022   FF23               MOVS     R3,#+255
   \   00000024   9B1C               ADDS     R3,R3,#+2        ;; #+257
   \   00000026   9842               CMP      R0,R3
   \   00000028   03DB               BLT      ??CleanFlash_1
   \   0000002A   8020               MOVS     R0,#+128
   \   0000002C   4000               LSLS     R0,R0,#+1        ;; #+256
   \   0000002E   801A               SUBS     R0,R0,R2
   \   00000030   00E0               B        ??CleanFlash_2
   \                     ??CleanFlash_1:
   \   00000032   2000               MOVS     R0,R4
    412               
    413               //przepisanie strony pamiêci do RAMu
    414               ptrMem=(char*)(page*256);
   \                     ??CleanFlash_2:
   \   00000034   8023               MOVS     R3,#+128
   \   00000036   5B00               LSLS     R3,R3,#+1        ;; #+256
   \   00000038   6B43               MULS     R3,R5,R3
   \   0000003A   4093               STR      R3,[SP, #+256]
    415               for (short i=0; i<256; i++)
   \   0000003C   0023               MOVS     R3,#+0
   \   0000003E   08E0               B        ??CleanFlash_3
    416                {  
    417                  tab.B[i]=ptrMem[i];     
   \                     ??CleanFlash_4:
   \   00000040   1B04               LSLS     R3,R3,#+16       ;; SignExtS R3,R3,#+16,#+16
   \   00000042   1B14               ASRS     R3,R3,#+16
   \   00000044   6E46               MOV      R6,SP
   \   00000046   1B04               LSLS     R3,R3,#+16       ;; SignExtS R3,R3,#+16,#+16
   \   00000048   1B14               ASRS     R3,R3,#+16
   \   0000004A   409F               LDR      R7,[SP, #+256]
   \   0000004C   FF5C               LDRB     R7,[R7, R3]
   \   0000004E   F754               STRB     R7,[R6, R3]
    418                }  
   \   00000050   5B1C               ADDS     R3,R3,#+1
   \                     ??CleanFlash_3:
   \   00000052   8026               MOVS     R6,#+128
   \   00000054   7600               LSLS     R6,R6,#+1        ;; #+256
   \   00000056   1B04               LSLS     R3,R3,#+16       ;; SignExtS R3,R3,#+16,#+16
   \   00000058   1B14               ASRS     R3,R3,#+16
   \   0000005A   B342               CMP      R3,R6
   \   0000005C   F0DB               BLT      ??CleanFlash_4
    419               
    420                  //dodanie nowych danych
    421                  for (int i=komorka; i<=komorka+length_tmp-1; i++)
   \   0000005E   1300               MOVS     R3,R2
   \   00000060   04E0               B        ??CleanFlash_5
    422                  {
    423                    tab.B[i]=0;
   \                     ??CleanFlash_6:
   \   00000062   6E46               MOV      R6,SP
   \   00000064   0027               MOVS     R7,#+0
   \   00000066   F754               STRB     R7,[R6, R3]
    424                    data++;
   \   00000068   491C               ADDS     R1,R1,#+1
    425                  }
   \   0000006A   5B1C               ADDS     R3,R3,#+1
   \                     ??CleanFlash_5:
   \   0000006C   1618               ADDS     R6,R2,R0
   \   0000006E   761E               SUBS     R6,R6,#+1
   \   00000070   9E42               CMP      R6,R3
   \   00000072   F6DA               BGE      ??CleanFlash_6
    426            
    427                  //UptrMem=(int*)ptrMem;  
    428                  UptrMem=(int*)(page*256);
   \   00000074   8022               MOVS     R2,#+128
   \   00000076   5200               LSLS     R2,R2,#+1        ;; #+256
   \   00000078   6A43               MULS     R2,R5,R2
    429                    
    430                  //zapis do tymczasowego obszar
    431                  //for (unsigned int i=0; i<=63; i++) AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    432                  for (unsigned int i=0; i<=63; i++) UptrMem[i]=tab.DW[i];
   \   0000007A   0023               MOVS     R3,#+0
   \   0000007C   09E0               B        ??CleanFlash_7
   \                     ??CleanFlash_8:
   \   0000007E   0427               MOVS     R7,#+4
   \   00000080   5F43               MULS     R7,R3,R7
   \   00000082   BC46               MOV      R12,R7
   \   00000084   0427               MOVS     R7,#+4
   \   00000086   5F43               MULS     R7,R3,R7
   \   00000088   6E46               MOV      R6,SP
   \   0000008A   F659               LDR      R6,[R6, R7]
   \   0000008C   6746               MOV      R7,R12
   \   0000008E   D651               STR      R6,[R2, R7]
   \   00000090   5B1C               ADDS     R3,R3,#+1
   \                     ??CleanFlash_7:
   \   00000092   402B               CMP      R3,#+64
   \   00000094   F3D3               BCC      ??CleanFlash_8
    433             
    434                  //oczekiwanie na flagê FRDY 
    435                  while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
   \                     ??CleanFlash_9:
   \   00000096   9722               MOVS     R2,#+151
   \   00000098   D243               MVNS     R2,R2            ;; #-152
   \   0000009A   1268               LDR      R2,[R2, #+0]
   \   0000009C   D207               LSLS     R2,R2,#+31
   \   0000009E   FAD5               BPL      ??CleanFlash_9
    436                  //volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    437                  
    438                  //Zapis FCMD i PAGENB do MC_FCR
    439                  SET(AT91C_BASE_MC->MC_FCR,
    440                      AT91C_MC_CORRECT_KEY
    441                      | AT91C_MC_FCMD_START_PROG
    442                      | ((page << 8) & AT91C_MC_PAGEN)); 
   \   000000A0   9B22               MOVS     R2,#+155
   \   000000A2   D243               MVNS     R2,R2            ;; #-156
   \   000000A4   9B23               MOVS     R3,#+155
   \   000000A6   DB43               MVNS     R3,R3            ;; #-156
   \   000000A8   1B68               LDR      R3,[R3, #+0]
   \   000000AA   2F02               LSLS     R7,R5,#+8
   \   000000AC   ....               LDR      R6,??DataTable6  ;; 0x3ff00
   \   000000AE   3E40               ANDS     R6,R6,R7
   \   000000B0   ....               LDR      R7,??DataTable7  ;; 0x5a000001
   \   000000B2   3743               ORRS     R7,R7,R6
   \   000000B4   1F43               ORRS     R7,R7,R3
   \   000000B6   1760               STR      R7,[R2, #+0]
    443              
    444                  //oczekiwanie na flagê FRDY 
    445                  while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
   \                     ??CleanFlash_10:
   \   000000B8   9722               MOVS     R2,#+151
   \   000000BA   D243               MVNS     R2,R2            ;; #-152
   \   000000BC   1268               LDR      R2,[R2, #+0]
   \   000000BE   D207               LSLS     R2,R2,#+31
   \   000000C0   FAD5               BPL      ??CleanFlash_10
    446                  
    447                  //Sprawdzenie czy nie naruszona blokada regionu
    448                  if (AT91C_BASE_MC->MC_FSR & AT91C_MC_LOCKE) 
   \   000000C2   9722               MOVS     R2,#+151
   \   000000C4   D243               MVNS     R2,R2            ;; #-152
   \   000000C6   1368               LDR      R3,[R2, #+0]
    449                  {
    450                    // MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
    451                  }
    452                  
    453                  //Sprawdzenie czy zapis wykonany poprawnie
    454                  if (AT91C_BASE_MC->MC_FSR & AT91C_MC_PROGE) 
   \   000000C8   9722               MOVS     R2,#+151
   \   000000CA   D243               MVNS     R2,R2            ;; #-152
   \   000000CC   1668               LDR      R6,[R2, #+0]
    455                  {
    456                    //MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
    457                  }
    458                  
    459               komorka = 0;
   \   000000CE   0022               MOVS     R2,#+0
    460               length = length-length_tmp;
   \   000000D0   241A               SUBS     R4,R4,R0
    461               page++;
   \   000000D2   6D1C               ADDS     R5,R5,#+1
    462              
    463             }while (length>0); 
   \   000000D4   012C               CMP      R4,#+1
   \   000000D6   A3DA               BGE      ??CleanFlash_0
    464          
    465              
    466          }
   \   000000D8   41B0               ADD      SP,SP,#+260
   \   000000DA   F0BC               POP      {R4-R7}
   \   000000DC   01BC               POP      {R0}
   \   000000DE   0047               BX       R0               ;; return
    467          
    468          
    469          
    470          /*
    471          __ramfunc void CleanFlash(int ofset,unsigned int cell, int length)
    472            {
    473             int page=     cell/256;
    474             int komorka = cell%256;
    475             int length_tmp;
    476             int data = 0; 
    477             unsigned long *memory;
    478             bool find; 
    479             int tmp_i =0;
    480             
    481             
    482           //  TRACE_INFO("\n\r---  CleanFlash  --- Ofset: %d, Komorka: %d, Rozmar: %dB\n\r",ofset,cell,length );
    483          
    484             
    485             union 
    486             {
    487                         char tab_B[256];
    488                unsigned long tab_DW[64];
    489             };
    490          
    491             do
    492             {
    493               if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
    494               
    495               
    496                memory=(unsigned long*) (ofset+page*256);
    497          
    498               find = false;
    499          
    500                tmp_i=0;
    501                do 
    502                {
    503                  if (memory[tmp_i]>0)
    504                  {
    505                    find = true;
    506                    break;
    507                  }
    508                  tmp_i++;
    509                } while (tmp_i<=63);
    510          
    511                
    512               if (find==true)    
    513               {
    514                  data=0;
    515                  for (int i=komorka; i<=komorka+length_tmp-1; i++)
    516                    {
    517                      tab_B[i]=0;
    518                      data++;
    519                    }
    520            
    521                  for (unsigned int i=0; i<=63; i++)
    522                    {
    523                      AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    524                    }  
    525             
    526                  volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    527          
    528                  SET(AT91C_BASE_MC->MC_FCR,
    529                      AT91C_MC_CORRECT_KEY
    530                      | AT91C_MC_FCMD_START_PROG
    531                      | (((page+(ofset/256)) << 8) & AT91C_MC_PAGEN)); 
    532              
    533                  while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);   
    534                }
    535               
    536               komorka = 0;
    537               length = length-length_tmp;
    538               page++;
    539              
    540             }while (length>0); 
    541              
    542           //  TRACE_INFO("\n\r ---Koniec  CleanFlash  --- \n\r");
    543          }
    544          
    545          */
    546          
    547          
    548          
    549          

   \                                 In section Debug.txt, align 4, keep-with-next
    550           void at91flashErase(void)
    551           {
   \                     at91flashErase:
   \   00000000   01B5               PUSH     {R0,LR}
    552             // erase flash
    553               AT91C_BASE_MC->MC_FCR =(0x5A<<24) | AT91C_MC_FCMD_ERASE_ALL;
   \   00000002   9B20               MOVS     R0,#+155
   \   00000004   C043               MVNS     R0,R0            ;; #-156
   \   00000006   0549               LDR      R1,??at91flashErase_0  ;; 0x5a000008
   \   00000008   0160               STR      R1,[R0, #+0]
    554               // wait for flash done/ready
    555               while(!(AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY));
   \                     ??at91flashErase_1:
   \   0000000A   9720               MOVS     R0,#+151
   \   0000000C   C043               MVNS     R0,R0            ;; #-152
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   C007               LSLS     R0,R0,#+31
   \   00000012   FAD5               BPL      ??at91flashErase_1
    556          
    557           }
   \   00000014   01B0               ADD      SP,SP,#+4
   \   00000016   01BC               POP      {R0}
   \   00000018   0047               BX       R0               ;; return
   \   0000001A   C046               Nop      
   \                     ??at91flashErase_0:
   \   0000001C   0800005A           DC32     0x5a000008

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   00FF0300           DC32     0x3ff00

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0100005A           DC32     0x5a000001

   \                                 In section .rodata, align 4
   \                     `?<Constant "Blad zapisu. Przekroc...">`:
   \   00000000   426C6164207A       DC8 "Blad zapisu. Przekroczenie dozwolonego obszaru"
   \              61706973752E
   \              2050727A656B
   \              726F637A656E
   \              696520646F7A
   \              776F6C6F6E65
   \              676F206F6273
   \              7A61727500  
   \   0000002F   00                 DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "Blad zapisu do flash">`:
   \   00000000   426C6164207A       DC8 "Blad zapisu do flash"
   \              617069737520
   \              646F20666C61
   \              736800      
   \   00000015   000000             DC8 0, 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "B³¹d naruszenia zablo...">`:
   \   00000000   42B3B964206E       DC8 "B³¹d naruszenia zablokowanego regionu flash"
   \              617275737A65
   \              6E6961207A61
   \              626C6F6B6F77
   \              616E65676F20
   \              726567696F6E
   \              7520666C6173
   \              6800        

   \                                 In section .rodata, align 4
   \                     `?<Constant "Z³y klucz lub b³edna ...">`:
   \   00000000   5AB379206B6C       DC8 "Z³y klucz lub b³edna komenda zapisu flash"
   \              75637A206C75
   \              622062B36564
   \              6E61206B6F6D
   \              656E6461207A
   \              617069737520
   \              666C61736800
   \   0000002A   0000               DC8 0, 0
    558          

   Maximum stack usage in bytes:

     Function          .cstack
     --------          -------
     AT91F_Flash_Ready      8
     AT91F_Flash_Write     16
     CleanFlash           280
     FlashWrite            40
     FlashWriteExe        368
     InitFlash              0
     at91flashErase         8
     at91flashWrite       288


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     InitFlash                        32
     at91flashWrite                  204
     AT91F_Flash_Ready                22
     AT91F_Flash_Write               136
     FlashWrite                       60
     FlashWriteExe                   368
     CleanFlash                      224
     at91flashErase                   32
     ??DataTable6                      4
     ??DataTable7                      4
     ?<Constant "Blad zapisu. Przekroc...">
                                      48
     ?<Constant "Blad zapisu do flash">
                                      24
     ?<Constant "B³¹d naruszenia zablo...">
                                      44
     ?<Constant "Z³y klucz lub b³edna ...">
                                      44
      Others                          32

 
 160 bytes in section .rodata
 962 bytes in section .textrw
 156 bytes in section Debug.txt
 
 1 086 bytes of CODE  memory (+ 32 bytes shared)
   160 bytes of CONST memory

Errors: none
Warnings: 17
