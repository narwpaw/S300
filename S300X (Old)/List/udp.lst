###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           11/Sep/2013  19:44:41 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v1.4 -              #
#                    12.06.2013\core\udp.c                                    #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\core\udp.c" -D AT91SAM7S256 -D AT91SAM7SEK    #
#                    -D iH -D _LCD_NEGATIV_OLD_ -D __ALARM -D __WIFI_MODULE   #
#                    -D _DEBUG_ -D S300iOld -D _ADMINISTRATOR_ -lC            #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\S300X (Old)\List\" --diag_suppress Pa082 -o   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\S300X (Old)\Obj\" --no_cse --no_unroll        #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian little --cpu ARM7TDMI   #
#                    -e --fpu None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 5.0\ARM\INC\DLib_Config_Norma #
#                    l.h" -I "D:\Zeuron\Projekty\S300\S300-program v1.4 -     #
#                    12.06.2013\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v1.4 - 12.06.2013\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v1.4 - 12.06.2013\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v1.4 - 12.06.2013\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.4 -             #
#                    12.06.2013\Framework\Configuration\" -I "C:\Program      #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\INC\" --section .text=Debug.txt --interwork      #
#                    --cpu_mode thumb -Ol                                     #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v1.4 -              #
#                    12.06.2013\S300X (Old)\List\udp.lst                      #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v1.4 -              #
#                    12.06.2013\S300X (Old)\Obj\udp.o                         #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v1.4 - 12.06.2013\core\udp.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support  -  ROUSSET  -
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2006, Atmel Corporation
      5          
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaiimer below.
     13           *
     14           * - Redistributions in binary form must reproduce the above copyright notice,
     15           * this list of conditions and the disclaimer below in the documentation and/or
     16           * other materials provided with the distribution.
     17           *
     18           * Atmel's name may not be used to endorse or promote products derived from
     19           * this software without specific prior written permission.
     20           *
     21           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     22           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     23           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     24           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     25           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     26           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     27           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     28           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     29           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     30           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     31           * ----------------------------------------------------------------------------
     32           */
     33          
     34          
     35          extern char znak;
     36          
     37          /*
     38          $Id: udp.c,v 1.1.2.1 2006/12/05 08:33:25 danielru Exp $
     39          */
     40          
     41          //------------------------------------------------------------------------------
     42          //      Includes
     43          //------------------------------------------------------------------------------
     44          
     45          #include "common.h"

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork unsigned int min(unsigned int, unsigned int)
   \                     min:
   \   00000000   8842               CMP      R0,R1
   \   00000002   00D9               BLS      ??min_0
   \   00000004   0800               MOVS     R0,R1
   \                     ??min_0:
   \   00000006   7047               BX       LR               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork signed char lastSetBit(unsigned int)
   \                     lastSetBit:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0100               MOVS     R1,R0
   \   00000004   0020               MOVS     R0,#+0
   \   00000006   C043               MVNS     R0,R0            ;; #-1
   \   00000008   0A0C               LSRS     R2,R1,#+16
   \   0000000A   1204               LSLS     R2,R2,#+16
   \   0000000C   002A               CMP      R2,#+0
   \   0000000E   01D0               BEQ      ??lastSetBit_0
   \   00000010   1030               ADDS     R0,R0,#+16
   \   00000012   090C               LSRS     R1,R1,#+16
   \                     ??lastSetBit_0:
   \   00000014   FF22               MOVS     R2,#+255
   \   00000016   1202               LSLS     R2,R2,#+8        ;; #+65280
   \   00000018   1142               TST      R1,R2
   \   0000001A   01D0               BEQ      ??lastSetBit_1
   \   0000001C   0830               ADDS     R0,R0,#+8
   \   0000001E   090A               LSRS     R1,R1,#+8
   \                     ??lastSetBit_1:
   \   00000020   0A00               MOVS     R2,R1
   \   00000022   F023               MOVS     R3,#+240
   \   00000024   1A42               TST      R2,R3
   \   00000026   01D0               BEQ      ??lastSetBit_2
   \   00000028   001D               ADDS     R0,R0,#+4
   \   0000002A   0909               LSRS     R1,R1,#+4
   \                     ??lastSetBit_2:
   \   0000002C   0A00               MOVS     R2,R1
   \   0000002E   0C23               MOVS     R3,#+12
   \   00000030   1A42               TST      R2,R3
   \   00000032   01D0               BEQ      ??lastSetBit_3
   \   00000034   801C               ADDS     R0,R0,#+2
   \   00000036   8908               LSRS     R1,R1,#+2
   \                     ??lastSetBit_3:
   \   00000038   0A00               MOVS     R2,R1
   \   0000003A   9207               LSLS     R2,R2,#+30
   \   0000003C   01D5               BPL      ??lastSetBit_4
   \   0000003E   401C               ADDS     R0,R0,#+1
   \   00000040   4908               LSRS     R1,R1,#+1
   \                     ??lastSetBit_4:
   \   00000042   C907               LSLS     R1,R1,#+31
   \   00000044   00D5               BPL      ??lastSetBit_5
   \   00000046   401C               ADDS     R0,R0,#+1
   \                     ??lastSetBit_5:
   \   00000048   0006               LSLS     R0,R0,#+24       ;; SignExtS R0,R0,#+24,#+24
   \   0000004A   0016               ASRS     R0,R0,#+24
   \   0000004C   01B0               ADD      SP,SP,#+4
   \   0000004E   02BC               POP      {R1}
   \   00000050   0847               BX       R1               ;; return
     46          #include "device.h"
     47          #include "board.h"
     48          #include "trace.h"
     49          #include "usb.h"

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork struct <unnamed> *USB_GetEndpoint(S_usb const *, unsigned char)
   \                     USB_GetEndpoint:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000004   090E               LSRS     R1,R1,#+24
   \   00000006   8268               LDR      R2,[R0, #+8]
   \   00000008   9142               CMP      R1,R2
   \   0000000A   01D3               BCC      ??USB_GetEndpoint_0
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   05E0               B        ??USB_GetEndpoint_1
   \                     ??USB_GetEndpoint_0:
   \   00000010   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000012   090E               LSRS     R1,R1,#+24
   \   00000014   2822               MOVS     R2,#+40
   \   00000016   5143               MULS     R1,R2,R1
   \   00000018   4068               LDR      R0,[R0, #+4]
   \   0000001A   4018               ADDS     R0,R0,R1
   \                     ??USB_GetEndpoint_1:
   \   0000001C   01B0               ADD      SP,SP,#+4
   \   0000001E   02BC               POP      {R1}
   \   00000020   0847               BX       R1               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork struct <unnamed> *USB_GetSetup(S_usb const *)
   \                     USB_GetSetup:
   \   00000000   0069               LDR      R0,[R0, #+16]
   \   00000002   7047               BX       LR               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork unsigned int USB_GetDriverID(S_usb const *)
   \                     USB_GetDriverID:
   \   00000000   0068               LDR      R0,[R0, #+0]
   \   00000002   C068               LDR      R0,[R0, #+12]
   \   00000004   7047               BX       LR               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork unsigned int USB_GetDriverPMC(S_usb const *)
   \                     USB_GetDriverPMC:
   \   00000000   0068               LDR      R0,[R0, #+0]
   \   00000002   0069               LDR      R0,[R0, #+16]
   \   00000004   7047               BX       LR               ;; return

   \                                 In section Debug.txt, align 4, keep-with-next
   \   static __??Code16?? __code __interwork void USB_InitCallback(S_usb const *)
   \                     USB_InitCallback:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   C168               LDR      R1,[R0, #+12]
   \   00000004   0968               LDR      R1,[R1, #+0]
   \   00000006   0029               CMP      R1,#+0
   \   00000008   03D0               BEQ      ??USB_InitCallback_0
   \   0000000A   C168               LDR      R1,[R0, #+12]
   \   0000000C   0968               LDR      R1,[R1, #+0]
   \   0000000E   ........           BL       __iar_via_R1
   \                     ??USB_InitCallback_0:
   \   00000012   01B0               ADD      SP,SP,#+4
   \   00000014   01BC               POP      {R0}
   \   00000016   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4, keep-with-next
   \   static __??Code16?? __code __interwork void USB_ResetCallback(S_usb const *)
   \                     USB_ResetCallback:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   C168               LDR      R1,[R0, #+12]
   \   00000004   4968               LDR      R1,[R1, #+4]
   \   00000006   0029               CMP      R1,#+0
   \   00000008   03D0               BEQ      ??USB_ResetCallback_0
   \   0000000A   C168               LDR      R1,[R0, #+12]
   \   0000000C   4968               LDR      R1,[R1, #+4]
   \   0000000E   ........           BL       __iar_via_R1
   \                     ??USB_ResetCallback_0:
   \   00000012   01B0               ADD      SP,SP,#+4
   \   00000014   01BC               POP      {R0}
   \   00000016   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4, keep-with-next
   \   static __??Code16?? __code __interwork void USB_SuspendCallback(S_usb const *)
   \                     USB_SuspendCallback:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   C168               LDR      R1,[R0, #+12]
   \   00000004   8968               LDR      R1,[R1, #+8]
   \   00000006   0029               CMP      R1,#+0
   \   00000008   03D0               BEQ      ??USB_SuspendCallback_0
   \   0000000A   C168               LDR      R1,[R0, #+12]
   \   0000000C   8968               LDR      R1,[R1, #+8]
   \   0000000E   ........           BL       __iar_via_R1
   \                     ??USB_SuspendCallback_0:
   \   00000012   01B0               ADD      SP,SP,#+4
   \   00000014   01BC               POP      {R0}
   \   00000016   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4, keep-with-next
   \   static __??Code16?? __code __interwork void USB_ResumeCallback(S_usb const *)
   \                     USB_ResumeCallback:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   C168               LDR      R1,[R0, #+12]
   \   00000004   C968               LDR      R1,[R1, #+12]
   \   00000006   0029               CMP      R1,#+0
   \   00000008   03D0               BEQ      ??USB_ResumeCallback_0
   \   0000000A   C168               LDR      R1,[R0, #+12]
   \   0000000C   C968               LDR      R1,[R1, #+12]
   \   0000000E   ........           BL       __iar_via_R1
   \                     ??USB_ResumeCallback_0:
   \   00000012   01B0               ADD      SP,SP,#+4
   \   00000014   01BC               POP      {R0}
   \   00000016   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4, keep-with-next
   \   static __??Code16?? __code __interwork void USB_NewRequestCallback(S_usb const *)
   \                     USB_NewRequestCallback:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   C168               LDR      R1,[R0, #+12]
   \   00000004   0969               LDR      R1,[R1, #+16]
   \   00000006   0029               CMP      R1,#+0
   \   00000008   03D0               BEQ      ??USB_NewRequestCallback_0
   \   0000000A   C168               LDR      R1,[R0, #+12]
   \   0000000C   0969               LDR      R1,[R1, #+16]
   \   0000000E   ........           BL       __iar_via_R1
   \                     ??USB_NewRequestCallback_0:
   \   00000012   01B0               ADD      SP,SP,#+4
   \   00000014   01BC               POP      {R0}
   \   00000016   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4, keep-with-next
   \   static __??Code16?? __code __interwork void USB_StartOfFrameCallback(S_usb const *)
   \                     USB_StartOfFrameCallback:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   C168               LDR      R1,[R0, #+12]
   \   00000004   4969               LDR      R1,[R1, #+20]
   \   00000006   ........           BL       __iar_via_R1
   \   0000000A   01B0               ADD      SP,SP,#+4
   \   0000000C   01BC               POP      {R0}
   \   0000000E   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork void USB_Connect(S_usb const *)
   \                     USB_Connect:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0168               LDR      R1,[R0, #+0]
   \   00000004   4969               LDR      R1,[R1, #+20]
   \   00000006   C96A               LDR      R1,[R1, #+44]
   \   00000008   ........           BL       __iar_via_R1
   \   0000000C   01B0               ADD      SP,SP,#+4
   \   0000000E   01BC               POP      {R0}
   \   00000010   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork void USB_Disconnect(S_usb const *)
   \                     USB_Disconnect:
   \   00000000   01B5               PUSH     {R0,LR}
   \   00000002   0168               LDR      R1,[R0, #+0]
   \   00000004   4969               LDR      R1,[R1, #+20]
   \   00000006   096B               LDR      R1,[R1, #+48]
   \   00000008   ........           BL       __iar_via_R1
   \   0000000C   01B0               ADD      SP,SP,#+4
   \   0000000E   01BC               POP      {R0}
   \   00000010   0047               BX       R0               ;; return

   \                                 In section Debug.txt, align 4
   \   __??Code16?? __code __interwork unsigned int USB_GetState(S_usb const *)
   \                     USB_GetState:
   \   00000000   4069               LDR      R0,[R0, #+20]
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   0004               LSLS     R0,R0,#+16       ;; ZeroExtS R0,R0,#+16,#+16
   \   00000006   000C               LSRS     R0,R0,#+16
   \   00000008   7047               BX       LR               ;; return
     50          
     51          #ifdef UDP
     52          
     53          #define UDP_STATE_SHOULD_RECONNECT      0x10000000
     54          #define UDP_EPTYPE_INDEX                8
     55          #define UDP_EPDIR_INDEX                 10
     56          
     57          #define ISR_MASK                      0x00003FFF
     58          
     59          //------------------------------------------------------------------------------
     60          //      Structures
     61          //------------------------------------------------------------------------------
     62          
     63          // \brief  Endpoint states
     64          typedef enum {
     65          
     66              endpointStateDisabled,
     67              endpointStateIdle,
     68              endpointStateWrite,
     69              endpointStateRead,
     70              endpointStateHalted
     71          
     72          } EndpointState_t;
     73          
     74          //------------------------------------------------------------------------------
     75          //      Macros
     76          //------------------------------------------------------------------------------
     77          
     78          // \brief  Clear flags in the UDP_CSR register and waits for synchronization
     79          // \param  pUsb      Pointer to a S_usb instance
     80          // \param  bEndpoint Index of endpoint
     81          // \param  dFlags    Flags to clear
     82          #define UDP_CLEAREPFLAGS(pUsb, bEndpoint, dFlags) { \
     83              while (!ISCLEARED(UDP_GetDriverInterface(pUsb)->UDP_CSR[bEndpoint], dFlags)) \
     84                  CLEAR(UDP_GetDriverInterface(pUsb)->UDP_CSR[bEndpoint], dFlags); \
     85          }
     86          
     87          // \brief  Set flags in the UDP_CSR register and waits for synchronization
     88          // \param  pUsb      Pointer to a S_usb instance
     89          // \param  bEndpoint Index of endpoint
     90          // \param  dFlags    Flags to clear
     91          #define UDP_SETEPFLAGS(pUsb, bEndpoint, dFlags) { \
     92              while (ISCLEARED(UDP_GetDriverInterface(pUsb)->UDP_CSR[bEndpoint], dFlags)) \
     93                  SET(UDP_GetDriverInterface(pUsb)->UDP_CSR[bEndpoint], dFlags); \
     94          }
     95          
     96          //------------------------------------------------------------------------------
     97          //      Internal Functions
     98          //------------------------------------------------------------------------------
     99          //------------------------------------------------------------------------------
    100          // \brief  Returns a pointer to the UDP controller interface used by an USB
    101          //         driver
    102          //
    103          //         The pointer is cast to the correct type (AT91PS_UDP).
    104          // \param  pUsb Pointer to a S_usb instance
    105          // \return Pointer to the USB controller interface
    106          // \see    S_usb
    107          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    108          extern __inline AT91PS_UDP UDP_GetDriverInterface(const S_usb *pUsb)
    109          {
    110              return (AT91PS_UDP) pUsb->pDriver->pInterface;
   \                     UDP_GetDriverInterface:
   \   00000000   0068               LDR      R0,[R0, #+0]
   \   00000002   0068               LDR      R0,[R0, #+0]
   \   00000004   7047               BX       LR               ;; return
    111          }
    112          
    113          //------------------------------------------------------------------------------
    114          // \brief  Enables the peripheral clock of the USB controller associated with
    115          //         the specified USB driver
    116          // \param  pUsb Pointer to a S_usb instance
    117          // \see    S_usb
    118          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    119          extern __inline void UDP_EnableMCK(const S_usb *pUsb)
    120          {
   \                     UDP_EnableMCK:
   \   00000000   10B5               PUSH     {R4,LR}
    121              AT91C_BASE_PMC->PMC_PCER = 1 << USB_GetDriverID(pUsb);
   \   00000002   0124               MOVS     R4,#+1
   \   00000004   ........           BL       USB_GetDriverID
   \   00000008   8440               LSLS     R4,R4,R0
   \   0000000A   0248               LDR      R0,??UDP_EnableMCK_0  ;; 0xfffffc10
   \   0000000C   0460               STR      R4,[R0, #+0]
    122          }
   \   0000000E   10BC               POP      {R4}
   \   00000010   01BC               POP      {R0}
   \   00000012   0047               BX       R0               ;; return
   \                     ??UDP_EnableMCK_0:
   \   00000014   10FCFFFF           DC32     0xfffffc10
    123          
    124          //------------------------------------------------------------------------------
    125          // \brief  Disables the peripheral clock of the USB controller associated with
    126          //         the specified USB driver
    127          // \param  pUsb Pointer to a S_usb instance
    128          // \see    S_usb
    129          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    130          extern __inline void UDP_DisableMCK(const S_usb *pUsb)
    131          {
   \                     UDP_DisableMCK:
   \   00000000   10B5               PUSH     {R4,LR}
    132              AT91C_BASE_PMC->PMC_PCDR = 1 << USB_GetDriverID(pUsb);
   \   00000002   0124               MOVS     R4,#+1
   \   00000004   ........           BL       USB_GetDriverID
   \   00000008   8440               LSLS     R4,R4,R0
   \   0000000A   0248               LDR      R0,??UDP_DisableMCK_0  ;; 0xfffffc14
   \   0000000C   0460               STR      R4,[R0, #+0]
    133          }
   \   0000000E   10BC               POP      {R4}
   \   00000010   01BC               POP      {R0}
   \   00000012   0047               BX       R0               ;; return
   \                     ??UDP_DisableMCK_0:
   \   00000014   14FCFFFF           DC32     0xfffffc14
    134          
    135          //------------------------------------------------------------------------------
    136          // \brief  Enables the 48MHz clock of the USB controller associated with
    137          //         the specified USB driver
    138          // \param  pUsb Pointer to a S_usb instance
    139          // \see    S_usb
    140          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    141          extern __inline void UDP_EnableUDPCK(const S_usb *pUsb)
    142          {
   \                     UDP_EnableUDPCK:
   \   00000000   10B5               PUSH     {R4,LR}
    143              SET(AT91C_BASE_PMC->PMC_SCER, USB_GetDriverPMC(pUsb));
   \   00000002   0549               LDR      R1,??UDP_EnableUDPCK_0  ;; 0xfffffc00
   \   00000004   0C68               LDR      R4,[R1, #+0]
   \   00000006   ........           BL       USB_GetDriverPMC
   \   0000000A   2043               ORRS     R0,R0,R4
   \   0000000C   0249               LDR      R1,??UDP_EnableUDPCK_0  ;; 0xfffffc00
   \   0000000E   0860               STR      R0,[R1, #+0]
    144          }
   \   00000010   10BC               POP      {R4}
   \   00000012   01BC               POP      {R0}
   \   00000014   0047               BX       R0               ;; return
   \   00000016   C046               Nop      
   \                     ??UDP_EnableUDPCK_0:
   \   00000018   00FCFFFF           DC32     0xfffffc00
    145          
    146          //------------------------------------------------------------------------------
    147          // \brief  Disables the 48MHz clock of the USB controller associated with
    148          //         the specified USB driver
    149          // \param  pUsb Pointer to a S_usb instance
    150          // \see    S_usb
    151          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    152          extern __inline void UDP_DisableUDPCK(const S_usb *pUsb)
    153          {
   \                     UDP_DisableUDPCK:
   \   00000000   10B5               PUSH     {R4,LR}
    154              SET(AT91C_BASE_PMC->PMC_SCDR, USB_GetDriverPMC(pUsb));
   \   00000002   0549               LDR      R1,??UDP_DisableUDPCK_0  ;; 0xfffffc04
   \   00000004   0C68               LDR      R4,[R1, #+0]
   \   00000006   ........           BL       USB_GetDriverPMC
   \   0000000A   2043               ORRS     R0,R0,R4
   \   0000000C   0249               LDR      R1,??UDP_DisableUDPCK_0  ;; 0xfffffc04
   \   0000000E   0860               STR      R0,[R1, #+0]
    155          }
   \   00000010   10BC               POP      {R4}
   \   00000012   01BC               POP      {R0}
   \   00000014   0047               BX       R0               ;; return
   \   00000016   C046               Nop      
   \                     ??UDP_DisableUDPCK_0:
   \   00000018   04FCFFFF           DC32     0xfffffc04
    156          
    157          //------------------------------------------------------------------------------
    158          // \brief  Enables the transceiver of the USB controller associated with
    159          //         the specified USB driver
    160          // \param  pUsb Pointer to a S_usb instance
    161          // \see    S_usb
    162          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    163          extern __inline void UDP_EnableTransceiver(const S_usb *pUsb)
    164          {
   \                     UDP_EnableTransceiver:
   \   00000000   01B5               PUSH     {R0,LR}
    165              CLEAR(UDP_GetDriverInterface(pUsb)->UDP_TXVC, AT91C_UDP_TXVDIS);
   \   00000002   ........           BL       UDP_GetDriverInterface
   \   00000006   416F               LDR      R1,[R0, #+116]
   \   00000008   024A               LDR      R2,??UDP_EnableTransceiver_0  ;; 0xfffffeff
   \   0000000A   0A40               ANDS     R2,R2,R1
   \   0000000C   4267               STR      R2,[R0, #+116]
    166          }
   \   0000000E   01B0               ADD      SP,SP,#+4
   \   00000010   01BC               POP      {R0}
   \   00000012   0047               BX       R0               ;; return
   \                     ??UDP_EnableTransceiver_0:
   \   00000014   FFFEFFFF           DC32     0xfffffeff
    167          
    168          //------------------------------------------------------------------------------
    169          // \brief  Disables the transceiver of the USB controller associated with
    170          //         the specified USB driver
    171          // \param  pUsb Pointer to a S_usb instance
    172          // \see    S_usb
    173          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    174          extern __inline void UDP_DisableTransceiver(const S_usb *pUsb)
    175          {
   \                     UDP_DisableTransceiver:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    176              SET(UDP_GetDriverInterface(pUsb)->UDP_TXVC, AT91C_UDP_TXVDIS);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       UDP_GetDriverInterface
   \   0000000A   0500               MOVS     R5,R0
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       UDP_GetDriverInterface
   \   00000012   406F               LDR      R0,[R0, #+116]
   \   00000014   8021               MOVS     R1,#+128
   \   00000016   4900               LSLS     R1,R1,#+1        ;; #+256
   \   00000018   0143               ORRS     R1,R1,R0
   \   0000001A   6967               STR      R1,[R5, #+116]
    177          }
   \   0000001C   01B0               ADD      SP,SP,#+4
   \   0000001E   30BC               POP      {R4,R5}
   \   00000020   01BC               POP      {R0}
   \   00000022   0047               BX       R0               ;; return
    178          
    179          //------------------------------------------------------------------------------
    180          // \brief  Invokes the callback associated with a finished transfer on an
    181          //         endpoint
    182          // \param  pEndpoint Pointer to a S_usb_endpoint instance
    183          // \param  bStatus   Status code returned by the transfer operation
    184          // \see    Status codes
    185          // \see    S_usb_endpoint
    186          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4
    187          extern __inline void UDP_EndOfTransfer(S_usb_endpoint *pEndpoint,
    188                                                 char bStatus)
    189          {
   \                     UDP_EndOfTransfer:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
    190              if ((pEndpoint->dState == endpointStateWrite)
    191                  || (pEndpoint->dState == endpointStateRead)) 
   \   00000004   606A               LDR      R0,[R4, #+36]
   \   00000006   0228               CMP      R0,#+2
   \   00000008   02D0               BEQ      ??UDP_EndOfTransfer_0
   \   0000000A   606A               LDR      R0,[R4, #+36]
   \   0000000C   0328               CMP      R0,#+3
   \   0000000E   0ED1               BNE      ??UDP_EndOfTransfer_1
    192              {
    193          
    194                                                                                         // TRACE_DEBUG_L("EoT ");
    195          
    196                  // Endpoint returns in Idle state
    197                  pEndpoint->dState = endpointStateIdle;
   \                     ??UDP_EndOfTransfer_0:
   \   00000010   0120               MOVS     R0,#+1
   \   00000012   6062               STR      R0,[R4, #+36]
    198                                                                                          
    199                  // Invoke callback is present
    200                  if (pEndpoint->fCallback != 0) 
   \   00000014   2069               LDR      R0,[R4, #+16]
   \   00000016   0028               CMP      R0,#+0
   \   00000018   09D0               BEQ      ??UDP_EndOfTransfer_1
    201                  {                                                                      
    202          
    203                      pEndpoint->fCallback((unsigned int) pEndpoint->pArgument,
    204                                           (unsigned int) bStatus,
    205                                           pEndpoint->dBytesTransferred,
    206                                           pEndpoint->dBytesRemaining
    207                                           + pEndpoint->dBytesBuffered);
   \   0000001A   6068               LDR      R0,[R4, #+4]
   \   0000001C   A268               LDR      R2,[R4, #+8]
   \   0000001E   8318               ADDS     R3,R0,R2
   \   00000020   E268               LDR      R2,[R4, #+12]
   \   00000022   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000024   090E               LSRS     R1,R1,#+24
   \   00000026   6069               LDR      R0,[R4, #+20]
   \   00000028   2469               LDR      R4,[R4, #+16]
   \   0000002A   ........           BL       __iar_via_R4
    208                                                                                          
    209                  }
    210                  
    211              }
    212                                                                                          //TRACE_DEBUG_L("KON_EoT ");
    213          }
   \                     ??UDP_EndOfTransfer_1:
   \   0000002E   10BC               POP      {R4}
   \   00000030   01BC               POP      {R0}
   \   00000032   0047               BX       R0               ;; return
    214          
    215          //------------------------------------------------------------------------------
    216          // \brief  Clears the correct RX flag in an endpoint status register
    217          // \param  pUsb      Pointer to a S_usb instance
    218          // \param  bEndpoint Index of endpoint
    219          // \see    S_usb_endpoint
    220          // \see    S_usb
    221          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    222          static void UDP_ClearRXFlag(const S_usb * pUsb,
    223                                      unsigned char bEndpoint)
    224          {
   \                     UDP_ClearRXFlag:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    225              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   00000006   2900               MOVS     R1,R5
   \   00000008   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000000A   090E               LSRS     R1,R1,#+24
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       USB_GetEndpoint
   \   00000012   0600               MOVS     R6,R0
   \   00000014   10E0               B        ??UDP_ClearRXFlag_0
    226          
    227              // Clear flag
    228              UDP_CLEAREPFLAGS(pUsb, bEndpoint, pEndpoint->dFlag);
   \                     ??UDP_ClearRXFlag_1:
   \   00000016   2000               MOVS     R0,R4
   \   00000018   ........           BL       UDP_GetDriverInterface
   \   0000001C   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000001E   2D0E               LSRS     R5,R5,#+24
   \   00000020   0421               MOVS     R1,#+4
   \   00000022   6943               MULS     R1,R5,R1
   \   00000024   4118               ADDS     R1,R0,R1
   \   00000026   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000028   2D0E               LSRS     R5,R5,#+24
   \   0000002A   0422               MOVS     R2,#+4
   \   0000002C   6A43               MULS     R2,R5,R2
   \   0000002E   8018               ADDS     R0,R0,R2
   \   00000030   006B               LDR      R0,[R0, #+48]
   \   00000032   F269               LDR      R2,[R6, #+28]
   \   00000034   9043               BICS     R0,R0,R2
   \   00000036   0863               STR      R0,[R1, #+48]
   \                     ??UDP_ClearRXFlag_0:
   \   00000038   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000003A   2D0E               LSRS     R5,R5,#+24
   \   0000003C   0427               MOVS     R7,#+4
   \   0000003E   6F43               MULS     R7,R5,R7
   \   00000040   2000               MOVS     R0,R4
   \   00000042   ........           BL       UDP_GetDriverInterface
   \   00000046   C019               ADDS     R0,R0,R7
   \   00000048   006B               LDR      R0,[R0, #+48]
   \   0000004A   F169               LDR      R1,[R6, #+28]
   \   0000004C   0140               ANDS     R1,R1,R0
   \   0000004E   0029               CMP      R1,#+0
   \   00000050   E1D1               BNE      ??UDP_ClearRXFlag_1
    229          
    230              // Swap banks
    231              if (pEndpoint->dFlag == AT91C_UDP_RX_DATA_BK0) {
   \   00000052   F069               LDR      R0,[R6, #+28]
   \   00000054   0228               CMP      R0,#+2
   \   00000056   06D1               BNE      ??UDP_ClearRXFlag_2
    232          
    233                  if (pEndpoint->dNumFIFO > 1) {
   \   00000058   2020               MOVS     R0,#+32
   \   0000005A   305C               LDRB     R0,[R6, R0]
   \   0000005C   0228               CMP      R0,#+2
   \   0000005E   04D3               BCC      ??UDP_ClearRXFlag_3
    234          
    235                      // Swap bank if in dual-fifo mode
    236                      pEndpoint->dFlag = AT91C_UDP_RX_DATA_BK1;
   \   00000060   4020               MOVS     R0,#+64
   \   00000062   F061               STR      R0,[R6, #+28]
   \   00000064   01E0               B        ??UDP_ClearRXFlag_3
    237                  }
    238              }
    239              else {
    240          
    241                  pEndpoint->dFlag = AT91C_UDP_RX_DATA_BK0;
   \                     ??UDP_ClearRXFlag_2:
   \   00000066   0220               MOVS     R0,#+2
   \   00000068   F061               STR      R0,[R6, #+28]
    242              }
    243          }
   \                     ??UDP_ClearRXFlag_3:
   \   0000006A   01B0               ADD      SP,SP,#+4
   \   0000006C   F0BC               POP      {R4-R7}
   \   0000006E   01BC               POP      {R0}
   \   00000070   0047               BX       R0               ;; return
    244          
    245          //------------------------------------------------------------------------------
    246          // \brief  Transfers a data payload from the current tranfer buffer to the
    247          //         endpoint FIFO.
    248          // \param  pUsb      Pointer to a S_usb instance
    249          // \param  bEndpoint Index of endpoint
    250          // \return Number of bytes transferred
    251          // \see    S_usb
    252          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    253          static unsigned int UDP_WritePayload(const S_usb * pUsb,
    254                                               unsigned char bEndpoint)
    255          {
   \                     UDP_WritePayload:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0600               MOVS     R6,R0
   \   00000004   0C00               MOVS     R4,R1
    256              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000006   3000               MOVS     R0,R6
   \   00000008   ........           BL       UDP_GetDriverInterface
   \   0000000C   0500               MOVS     R5,R0
    257              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   0000000E   2100               MOVS     R1,R4
   \   00000010   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000012   090E               LSRS     R1,R1,#+24
   \   00000014   3000               MOVS     R0,R6
   \   00000016   ........           BL       USB_GetEndpoint
   \   0000001A   0600               MOVS     R6,R0
    258              unsigned int   dBytes;
    259              unsigned int   dCtr;
    260          
    261              // Get the number of bytes to send
    262              dBytes = min(pEndpoint->wMaxPacketSize, pEndpoint->dBytesRemaining);
   \   0000001C   7168               LDR      R1,[R6, #+4]
   \   0000001E   B069               LDR      R0,[R6, #+24]
   \   00000020   ........           BL       min
    263          
    264              // Transfer one packet in the FIFO buffer
    265              for (dCtr = 0; dCtr < dBytes; dCtr++) {
   \   00000024   0021               MOVS     R1,#+0
   \   00000026   0BE0               B        ??UDP_WritePayload_0
    266          
    267                  pInterface->UDP_FDR[bEndpoint] = *(pEndpoint->pData);
   \                     ??UDP_WritePayload_1:
   \   00000028   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   0000002A   240E               LSRS     R4,R4,#+24
   \   0000002C   0422               MOVS     R2,#+4
   \   0000002E   6243               MULS     R2,R4,R2
   \   00000030   AA18               ADDS     R2,R5,R2
   \   00000032   3368               LDR      R3,[R6, #+0]
   \   00000034   1B78               LDRB     R3,[R3, #+0]
   \   00000036   1365               STR      R3,[R2, #+80]
    268                  pEndpoint->pData++;
   \   00000038   3268               LDR      R2,[R6, #+0]
   \   0000003A   521C               ADDS     R2,R2,#+1
   \   0000003C   3260               STR      R2,[R6, #+0]
    269              }
   \   0000003E   491C               ADDS     R1,R1,#+1
   \                     ??UDP_WritePayload_0:
   \   00000040   8142               CMP      R1,R0
   \   00000042   F1D3               BCC      ??UDP_WritePayload_1
    270          
    271              pEndpoint->dBytesBuffered += dBytes;
   \   00000044   B168               LDR      R1,[R6, #+8]
   \   00000046   0918               ADDS     R1,R1,R0
   \   00000048   B160               STR      R1,[R6, #+8]
    272              pEndpoint->dBytesRemaining -= dBytes;
   \   0000004A   7168               LDR      R1,[R6, #+4]
   \   0000004C   091A               SUBS     R1,R1,R0
   \   0000004E   7160               STR      R1,[R6, #+4]
    273          
    274              return dBytes;
   \   00000050   70BC               POP      {R4-R6}
   \   00000052   02BC               POP      {R1}
   \   00000054   0847               BX       R1               ;; return
    275          }
    276          
    277          //------------------------------------------------------------------------------
    278          // \brief  Transfers a data payload from an endpoint FIFO to the current
    279          //         transfer buffer.
    280          // \param  pUsb        Pointer to a S_usb instance
    281          // \param  bEndpoint   Index of endpoint
    282          // \param  wPacketSize Size of received data packet
    283          // \return Number of bytes transferred
    284          // \see    S_usb
    285          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    286          static unsigned int UDP_GetPayload(const S_usb * pUsb,
    287                                             unsigned char bEndpoint,
    288                                             unsigned short wPacketSize)
    289          {
   \                     UDP_GetPayload:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0700               MOVS     R7,R0
   \   00000004   0C00               MOVS     R4,R1
   \   00000006   1500               MOVS     R5,R2
    290              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000008   3800               MOVS     R0,R7
   \   0000000A   ........           BL       UDP_GetDriverInterface
   \   0000000E   0600               MOVS     R6,R0
    291              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   00000010   2100               MOVS     R1,R4
   \   00000012   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000014   090E               LSRS     R1,R1,#+24
   \   00000016   3800               MOVS     R0,R7
   \   00000018   ........           BL       USB_GetEndpoint
   \   0000001C   0700               MOVS     R7,R0
    292              unsigned int   dBytes;
    293              unsigned int   dCtr;
    294          
    295                                                                                          //TRACE_DEBUG_L("IN_GetPayLoad ");
    296              // Get number of bytes to retrieve
    297              dBytes = min(pEndpoint->dBytesRemaining, wPacketSize);
   \   0000001E   2D04               LSLS     R5,R5,#+16       ;; ZeroExtS R5,R5,#+16,#+16
   \   00000020   2D0C               LSRS     R5,R5,#+16
   \   00000022   2900               MOVS     R1,R5
   \   00000024   7868               LDR      R0,[R7, #+4]
   \   00000026   ........           BL       min
    298          
    299              // Retrieve packet
    300              for (dCtr = 0; dCtr < dBytes; dCtr++) {
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   0BE0               B        ??UDP_GetPayload_0
    301          
    302                  *pEndpoint->pData = (char) pInterface->UDP_FDR[bEndpoint];
   \                     ??UDP_GetPayload_1:
   \   0000002E   3A68               LDR      R2,[R7, #+0]
   \   00000030   2406               LSLS     R4,R4,#+24       ;; ZeroExtS R4,R4,#+24,#+24
   \   00000032   240E               LSRS     R4,R4,#+24
   \   00000034   0423               MOVS     R3,#+4
   \   00000036   6343               MULS     R3,R4,R3
   \   00000038   F318               ADDS     R3,R6,R3
   \   0000003A   1B6D               LDR      R3,[R3, #+80]
   \   0000003C   1370               STRB     R3,[R2, #+0]
    303                  pEndpoint->pData++;
   \   0000003E   3A68               LDR      R2,[R7, #+0]
   \   00000040   521C               ADDS     R2,R2,#+1
   \   00000042   3A60               STR      R2,[R7, #+0]
    304                  
    305              }
   \   00000044   491C               ADDS     R1,R1,#+1
   \                     ??UDP_GetPayload_0:
   \   00000046   8142               CMP      R1,R0
   \   00000048   F1D3               BCC      ??UDP_GetPayload_1
    306          
    307              pEndpoint->dBytesRemaining -= dBytes;
   \   0000004A   7968               LDR      R1,[R7, #+4]
   \   0000004C   091A               SUBS     R1,R1,R0
   \   0000004E   7960               STR      R1,[R7, #+4]
    308              pEndpoint->dBytesTransferred += dBytes;
   \   00000050   F968               LDR      R1,[R7, #+12]
   \   00000052   0918               ADDS     R1,R1,R0
   \   00000054   F960               STR      R1,[R7, #+12]
    309              pEndpoint->dBytesBuffered += wPacketSize - dBytes;
   \   00000056   B968               LDR      R1,[R7, #+8]
   \   00000058   2D04               LSLS     R5,R5,#+16       ;; ZeroExtS R5,R5,#+16,#+16
   \   0000005A   2D0C               LSRS     R5,R5,#+16
   \   0000005C   4919               ADDS     R1,R1,R5
   \   0000005E   091A               SUBS     R1,R1,R0
   \   00000060   B960               STR      R1,[R7, #+8]
    310                                                                                          //TRACE_DEBUG_L("KON_GetPayLoad ");
    311              return dBytes;
   \   00000062   01B0               ADD      SP,SP,#+4
   \   00000064   F0BC               POP      {R4-R7}
   \   00000066   02BC               POP      {R1}
   \   00000068   0847               BX       R1               ;; return
    312                                                                                
    313          }
    314          
    315          //------------------------------------------------------------------------------
    316          // \brief  Transfers a received SETUP packet from endpoint 0 FIFO to the
    317          //         S_usb_request structure of an USB driver
    318          // \param  pUsb Pointer to a S_usb instance
    319          // \see    S_usb
    320          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    321          static void UDP_GetSetup(S_usb const *pUsb)
    322          {
   \                     UDP_GetSetup:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    323              char *pData = (char *) USB_GetSetup(pUsb);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       USB_GetSetup
   \   0000000A   0500               MOVS     R5,R0
    324              AT91PS_UDP pInterface = UDP_GetDriverInterface(pUsb);
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       UDP_GetDriverInterface
    325              unsigned int dCtr;
    326          
    327              // Copy packet
    328              for (dCtr = 0; dCtr < 8; dCtr++) {
   \   00000012   0021               MOVS     R1,#+0
   \   00000014   03E0               B        ??UDP_GetSetup_0
    329          
    330                  *pData = (char) pInterface->UDP_FDR[0];
   \                     ??UDP_GetSetup_1:
   \   00000016   026D               LDR      R2,[R0, #+80]
   \   00000018   2A70               STRB     R2,[R5, #+0]
    331                  pData++;
   \   0000001A   6D1C               ADDS     R5,R5,#+1
    332              }
   \   0000001C   491C               ADDS     R1,R1,#+1
   \                     ??UDP_GetSetup_0:
   \   0000001E   0829               CMP      R1,#+8
   \   00000020   F9D3               BCC      ??UDP_GetSetup_1
    333          }
   \   00000022   01B0               ADD      SP,SP,#+4
   \   00000024   30BC               POP      {R4,R5}
   \   00000026   01BC               POP      {R0}
   \   00000028   0047               BX       R0               ;; return
    334          
    335          //------------------------------------------------------------------------------
    336          // \brief  This function reset all endpoint transfer descriptors
    337          // \param  pUsb Pointer to a S_usb instance
    338          // \see    S_usb
    339          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    340          static void UDP_ResetEndpoints(const S_usb *pUsb)
    341          {
   \                     UDP_ResetEndpoints:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
    342              S_usb_endpoint *pEndpoint;
    343              unsigned char bEndpoint;
    344          
    345              // Reset the transfer descriptor of every endpoint
    346              for (bEndpoint = 0; bEndpoint < pUsb->dNumEndpoints; bEndpoint++) {
   \   00000004   0025               MOVS     R5,#+0
   \   00000006   16E0               B        ??UDP_ResetEndpoints_0
    347          
    348                  pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \                     ??UDP_ResetEndpoints_1:
   \   00000008   2900               MOVS     R1,R5
   \   0000000A   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000000C   090E               LSRS     R1,R1,#+24
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   ........           BL       USB_GetEndpoint
    349          
    350                  // Reset endpoint transfer descriptor
    351                  pEndpoint->pData = 0;
   \   00000014   0021               MOVS     R1,#+0
   \   00000016   0160               STR      R1,[R0, #+0]
    352                  pEndpoint->dBytesRemaining = 0;
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   4160               STR      R1,[R0, #+4]
    353                  pEndpoint->dBytesTransferred = 0;
   \   0000001C   0021               MOVS     R1,#+0
   \   0000001E   C160               STR      R1,[R0, #+12]
    354                  pEndpoint->dBytesBuffered = 0;
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   8160               STR      R1,[R0, #+8]
    355                  pEndpoint->fCallback = 0;
   \   00000024   0021               MOVS     R1,#+0
   \   00000026   0161               STR      R1,[R0, #+16]
    356                  pEndpoint->pArgument = 0;
   \   00000028   0021               MOVS     R1,#+0
   \   0000002A   4161               STR      R1,[R0, #+20]
    357          
    358                  // Configure endpoint characteristics
    359                  pEndpoint->dFlag = AT91C_UDP_RX_DATA_BK0;
   \   0000002C   0221               MOVS     R1,#+2
   \   0000002E   C161               STR      R1,[R0, #+28]
    360                  pEndpoint->dState = endpointStateDisabled;
   \   00000030   0021               MOVS     R1,#+0
   \   00000032   4162               STR      R1,[R0, #+36]
    361              }
   \   00000034   6D1C               ADDS     R5,R5,#+1
   \                     ??UDP_ResetEndpoints_0:
   \   00000036   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000038   2D0E               LSRS     R5,R5,#+24
   \   0000003A   A068               LDR      R0,[R4, #+8]
   \   0000003C   8542               CMP      R5,R0
   \   0000003E   E3D3               BCC      ??UDP_ResetEndpoints_1
    362          }
   \   00000040   01B0               ADD      SP,SP,#+4
   \   00000042   30BC               POP      {R4,R5}
   \   00000044   01BC               POP      {R0}
   \   00000046   0047               BX       R0               ;; return
    363          
    364          //------------------------------------------------------------------------------
    365          // \brief  Disable all endpoints (except control endpoint 0), aborting current
    366          //         transfers if necessary.
    367          // \param  pUsb Pointer to a S_usb instance
    368          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    369          static void UDP_DisableEndpoints(const S_usb *pUsb)
    370          {
   \                     UDP_DisableEndpoints:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0400               MOVS     R4,R0
    371              S_usb_endpoint *pEndpoint;
    372              unsigned char bEndpoint;
    373          
    374              // For each endpoint, if it is enabled, disable it and invoke the callback
    375              // Control endpoint 0 is not disabled
    376              for (bEndpoint = 1; bEndpoint < pUsb->dNumEndpoints; bEndpoint++) {
   \   00000004   0125               MOVS     R5,#+1
   \   00000006   0DE0               B        ??UDP_DisableEndpoints_0
    377          
    378                  pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \                     ??UDP_DisableEndpoints_1:
   \   00000008   2900               MOVS     R1,R5
   \   0000000A   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000000C   090E               LSRS     R1,R1,#+24
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   ........           BL       USB_GetEndpoint
   \   00000014   0600               MOVS     R6,R0
    379                  UDP_EndOfTransfer(pEndpoint, USB_STATUS_RESET);
   \   00000016   0321               MOVS     R1,#+3
   \   00000018   3000               MOVS     R0,R6
   \   0000001A   ........           BL       UDP_EndOfTransfer
    380                  pEndpoint->dState = endpointStateDisabled;
   \   0000001E   0020               MOVS     R0,#+0
   \   00000020   7062               STR      R0,[R6, #+36]
    381              }
   \   00000022   6D1C               ADDS     R5,R5,#+1
   \                     ??UDP_DisableEndpoints_0:
   \   00000024   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000026   2D0E               LSRS     R5,R5,#+24
   \   00000028   A068               LDR      R0,[R4, #+8]
   \   0000002A   8542               CMP      R5,R0
   \   0000002C   ECD3               BCC      ??UDP_DisableEndpoints_1
    382          }
   \   0000002E   70BC               POP      {R4-R6}
   \   00000030   01BC               POP      {R0}
   \   00000032   0047               BX       R0               ;; return
    383          
    384          //------------------------------------------------------------------------------
    385          // \brief  Endpoint interrupt handler.
    386          //
    387          //         Handle IN/OUT transfers, received SETUP packets and STALLing
    388          // \param  pUsb      Pointer to a S_usb instance
    389          // \param  bEndpoint Index of endpoint
    390          // \see    S_usb
    391          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    392          static void UDP_EndpointHandler(const S_usb *pUsb, unsigned char bEndpoint)
    393          {
   \                     UDP_EndpointHandler:
   \   00000000   F7B5               PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
    394              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   00000006   2900               MOVS     R1,R5
   \   00000008   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000000A   090E               LSRS     R1,R1,#+24
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       USB_GetEndpoint
   \   00000012   0600               MOVS     R6,R0
    395              AT91PS_UDP pInterface = UDP_GetDriverInterface(pUsb);
   \   00000014   2000               MOVS     R0,R4
   \   00000016   ........           BL       UDP_GetDriverInterface
   \   0000001A   0090               STR      R0,[SP, #+0]
    396              unsigned int dStatus = pInterface->UDP_CSR[bEndpoint];
   \   0000001C   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000001E   2D0E               LSRS     R5,R5,#+24
   \   00000020   0420               MOVS     R0,#+4
   \   00000022   6843               MULS     R0,R5,R0
   \   00000024   0099               LDR      R1,[SP, #+0]
   \   00000026   0818               ADDS     R0,R1,R0
   \   00000028   076B               LDR      R7,[R0, #+48]
    397          
    398                                                                                          //TRACE_DEBUG_L("Ept%d ", bEndpoint);
    399          
    400              // Handle interrupts
    401              
    402              // IN packet sent
    403              if (ISSET(dStatus, AT91C_UDP_TXCOMP)) 
   \   0000002A   F807               LSLS     R0,R7,#+31
   \   0000002C   00D4               BMI      .+4
   \   0000002E   AFE0               B        ??UDP_EndpointHandler_0
    404              {
    405          
    406                                                                                          //TRACE_DEBUG_L("Wr ");
    407          
    408                  // Check that endpoint was in Write state
    409                  if (pEndpoint->dState == endpointStateWrite) 
   \   00000030   706A               LDR      R0,[R6, #+36]
   \   00000032   0228               CMP      R0,#+2
   \   00000034   00D0               BEQ      .+4
   \   00000036   9DE0               B        ??UDP_EndpointHandler_1
    410                  {
    411                                                                                          
    412                   
    413                                                                                          
    414                      // End of transfer ?
    415                      if ((pEndpoint->dBytesBuffered < pEndpoint->wMaxPacketSize)
    416          
    417                          ||
    418                          (!ISCLEARED(dStatus, AT91C_UDP_EPTYPE)
    419                           && (pEndpoint->dBytesRemaining == 0)
    420                           && (pEndpoint->dBytesBuffered == pEndpoint->wMaxPacketSize))) 
   \   00000038   B068               LDR      R0,[R6, #+8]
   \   0000003A   B169               LDR      R1,[R6, #+24]
   \   0000003C   8842               CMP      R0,R1
   \   0000003E   0AD3               BCC      ??UDP_EndpointHandler_2
   \   00000040   E020               MOVS     R0,#+224
   \   00000042   C000               LSLS     R0,R0,#+3        ;; #+1792
   \   00000044   0742               TST      R7,R0
   \   00000046   1CD0               BEQ      ??UDP_EndpointHandler_3
   \   00000048   7068               LDR      R0,[R6, #+4]
   \   0000004A   0028               CMP      R0,#+0
   \   0000004C   19D1               BNE      ??UDP_EndpointHandler_3
   \   0000004E   B068               LDR      R0,[R6, #+8]
   \   00000050   B169               LDR      R1,[R6, #+24]
   \   00000052   8842               CMP      R0,R1
   \   00000054   15D1               BNE      ??UDP_EndpointHandler_3
    421                      {
    422          
    423                                                                                          
    424                                                                                         // TRACE_DEBUG_L("%d ", pEndpoint->dBytesBuffered);
    425          
    426                          pEndpoint->dBytesTransferred += pEndpoint->dBytesBuffered;
   \                     ??UDP_EndpointHandler_2:
   \   00000056   F068               LDR      R0,[R6, #+12]
   \   00000058   B168               LDR      R1,[R6, #+8]
   \   0000005A   4018               ADDS     R0,R0,R1
   \   0000005C   F060               STR      R0,[R6, #+12]
    427                          pEndpoint->dBytesBuffered = 0;
   \   0000005E   0020               MOVS     R0,#+0
   \   00000060   B060               STR      R0,[R6, #+8]
    428          
    429                          // Disable interrupt if this is not a control endpoint
    430                          if (!ISCLEARED(dStatus, AT91C_UDP_EPTYPE)) 
   \   00000062   E020               MOVS     R0,#+224
   \   00000064   C000               LSLS     R0,R0,#+3        ;; #+1792
   \   00000066   0742               TST      R7,R0
   \   00000068   06D0               BEQ      ??UDP_EndpointHandler_4
    431                          {
    432                                                                                          
    433                              SET(pInterface->UDP_IDR, 1 << bEndpoint);
   \   0000006A   0098               LDR      R0,[SP, #+0]
   \   0000006C   0099               LDR      R1,[SP, #+0]
   \   0000006E   4969               LDR      R1,[R1, #+20]
   \   00000070   0122               MOVS     R2,#+1
   \   00000072   AA40               LSLS     R2,R2,R5
   \   00000074   0A43               ORRS     R2,R2,R1
   \   00000076   4261               STR      R2,[R0, #+20]
    434                          }
    435          
    436                          UDP_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
   \                     ??UDP_EndpointHandler_4:
   \   00000078   0021               MOVS     R1,#+0
   \   0000007A   3000               MOVS     R0,R6
   \   0000007C   ........           BL       UDP_EndOfTransfer
   \   00000080   78E0               B        ??UDP_EndpointHandler_1
    437                      }
    438                      
    439                      else 
    440                      {
    441                                                                                          
    442                     
    443                          // Transfer remaining data
    444                                                                                          TRACE_DEBUG_L("%d ", pEndpoint->wMaxPacketSize);
    445          
    446                          pEndpoint->dBytesTransferred += pEndpoint->wMaxPacketSize;
   \                     ??UDP_EndpointHandler_3:
   \   00000082   F068               LDR      R0,[R6, #+12]
   \   00000084   B169               LDR      R1,[R6, #+24]
   \   00000086   4018               ADDS     R0,R0,R1
   \   00000088   F060               STR      R0,[R6, #+12]
    447                          pEndpoint->dBytesBuffered -= pEndpoint->wMaxPacketSize;
   \   0000008A   B068               LDR      R0,[R6, #+8]
   \   0000008C   B169               LDR      R1,[R6, #+24]
   \   0000008E   401A               SUBS     R0,R0,R1
   \   00000090   B060               STR      R0,[R6, #+8]
    448          
    449                          // Send next packet
    450                          if (pEndpoint->dNumFIFO == 1) {
   \   00000092   2020               MOVS     R0,#+32
   \   00000094   305C               LDRB     R0,[R6, R0]
   \   00000096   0128               CMP      R0,#+1
   \   00000098   46D1               BNE      ??UDP_EndpointHandler_5
    451          
    452                              // No double buffering
    453                              UDP_WritePayload(pUsb, bEndpoint);
   \   0000009A   2900               MOVS     R1,R5
   \   0000009C   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000009E   090E               LSRS     R1,R1,#+24
   \   000000A0   2000               MOVS     R0,R4
   \   000000A2   ........           BL       UDP_WritePayload
    454                              UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_TXPKTRDY);
   \                     ??UDP_EndpointHandler_6:
   \   000000A6   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000A8   2D0E               LSRS     R5,R5,#+24
   \   000000AA   0421               MOVS     R1,#+4
   \   000000AC   6943               MULS     R1,R5,R1
   \   000000AE   02B5               PUSH     {R1,LR}
   \   000000B0   2000               MOVS     R0,R4
   \   000000B2   ........           BL       UDP_GetDriverInterface
   \   000000B6   0099               LDR      R1,[SP, #0]
   \   000000B8   02B0               ADD      SP,SP,#+8
   \   000000BA   4018               ADDS     R0,R0,R1
   \   000000BC   006B               LDR      R0,[R0, #+48]
   \   000000BE   C006               LSLS     R0,R0,#+27
   \   000000C0   58D4               BMI      ??UDP_EndpointHandler_1
   \   000000C2   2000               MOVS     R0,R4
   \   000000C4   ........           BL       UDP_GetDriverInterface
   \   000000C8   0290               STR      R0,[SP, #+8]
   \   000000CA   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000CC   2D0E               LSRS     R5,R5,#+24
   \   000000CE   0421               MOVS     R1,#+4
   \   000000D0   6943               MULS     R1,R5,R1
   \   000000D2   02B5               PUSH     {R1,LR}
   \   000000D4   2000               MOVS     R0,R4
   \   000000D6   ........           BL       UDP_GetDriverInterface
   \   000000DA   0099               LDR      R1,[SP, #0]
   \   000000DC   02B0               ADD      SP,SP,#+8
   \   000000DE   4018               ADDS     R0,R0,R1
   \   000000E0   016B               LDR      R1,[R0, #+48]
   \   000000E2   1020               MOVS     R0,#+16
   \   000000E4   0843               ORRS     R0,R0,R1
   \   000000E6   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000E8   2D0E               LSRS     R5,R5,#+24
   \   000000EA   0421               MOVS     R1,#+4
   \   000000EC   6943               MULS     R1,R5,R1
   \   000000EE   029A               LDR      R2,[SP, #+8]
   \   000000F0   5118               ADDS     R1,R2,R1
   \   000000F2   0863               STR      R0,[R1, #+48]
   \   000000F4   D7E7               B        ??UDP_EndpointHandler_6
    455                          }
    456                          else {
    457          
    458                              // Double buffering
    459                              UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_TXPKTRDY);
   \                     ??UDP_EndpointHandler_7:
   \   000000F6   2000               MOVS     R0,R4
   \   000000F8   ........           BL       UDP_GetDriverInterface
   \   000000FC   0290               STR      R0,[SP, #+8]
   \   000000FE   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000100   2D0E               LSRS     R5,R5,#+24
   \   00000102   0421               MOVS     R1,#+4
   \   00000104   6943               MULS     R1,R5,R1
   \   00000106   02B5               PUSH     {R1,LR}
   \   00000108   2000               MOVS     R0,R4
   \   0000010A   ........           BL       UDP_GetDriverInterface
   \   0000010E   0099               LDR      R1,[SP, #0]
   \   00000110   02B0               ADD      SP,SP,#+8
   \   00000112   4018               ADDS     R0,R0,R1
   \   00000114   016B               LDR      R1,[R0, #+48]
   \   00000116   1020               MOVS     R0,#+16
   \   00000118   0843               ORRS     R0,R0,R1
   \   0000011A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000011C   2D0E               LSRS     R5,R5,#+24
   \   0000011E   0421               MOVS     R1,#+4
   \   00000120   6943               MULS     R1,R5,R1
   \   00000122   029A               LDR      R2,[SP, #+8]
   \   00000124   5118               ADDS     R1,R2,R1
   \   00000126   0863               STR      R0,[R1, #+48]
   \                     ??UDP_EndpointHandler_5:
   \   00000128   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000012A   2D0E               LSRS     R5,R5,#+24
   \   0000012C   0421               MOVS     R1,#+4
   \   0000012E   6943               MULS     R1,R5,R1
   \   00000130   02B5               PUSH     {R1,LR}
   \   00000132   2000               MOVS     R0,R4
   \   00000134   ........           BL       UDP_GetDriverInterface
   \   00000138   0099               LDR      R1,[SP, #0]
   \   0000013A   02B0               ADD      SP,SP,#+8
   \   0000013C   4018               ADDS     R0,R0,R1
   \   0000013E   006B               LDR      R0,[R0, #+48]
   \   00000140   C006               LSLS     R0,R0,#+27
   \   00000142   D8D5               BPL      ??UDP_EndpointHandler_7
    460                              UDP_WritePayload(pUsb, bEndpoint);
   \   00000144   2900               MOVS     R1,R5
   \   00000146   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000148   090E               LSRS     R1,R1,#+24
   \   0000014A   2000               MOVS     R0,R4
   \   0000014C   ........           BL       UDP_WritePayload
   \   00000150   10E0               B        ??UDP_EndpointHandler_1
    461                          }
    462                      }
    463                  }
    464          
    465                  
    466                  
    467                  
    468                  // Acknowledge interrupt
    469                  UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_TXCOMP);
   \                     ??UDP_EndpointHandler_8:
   \   00000152   2000               MOVS     R0,R4
   \   00000154   ........           BL       UDP_GetDriverInterface
   \   00000158   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000015A   2D0E               LSRS     R5,R5,#+24
   \   0000015C   0421               MOVS     R1,#+4
   \   0000015E   6943               MULS     R1,R5,R1
   \   00000160   4118               ADDS     R1,R0,R1
   \   00000162   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000164   2D0E               LSRS     R5,R5,#+24
   \   00000166   0422               MOVS     R2,#+4
   \   00000168   6A43               MULS     R2,R5,R2
   \   0000016A   8018               ADDS     R0,R0,R2
   \   0000016C   006B               LDR      R0,[R0, #+48]
   \   0000016E   0122               MOVS     R2,#+1
   \   00000170   9043               BICS     R0,R0,R2
   \   00000172   0863               STR      R0,[R1, #+48]
   \                     ??UDP_EndpointHandler_1:
   \   00000174   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000176   2D0E               LSRS     R5,R5,#+24
   \   00000178   0421               MOVS     R1,#+4
   \   0000017A   6943               MULS     R1,R5,R1
   \   0000017C   02B5               PUSH     {R1,LR}
   \   0000017E   2000               MOVS     R0,R4
   \   00000180   ........           BL       UDP_GetDriverInterface
   \   00000184   0099               LDR      R1,[SP, #0]
   \   00000186   02B0               ADD      SP,SP,#+8
   \   00000188   4018               ADDS     R0,R0,R1
   \   0000018A   006B               LDR      R0,[R0, #+48]
   \   0000018C   C007               LSLS     R0,R0,#+31
   \   0000018E   E0D4               BMI      ??UDP_EndpointHandler_8
    470              }
    471              
    472              
    473              
    474                                                                                          
    475          
    476          
    477          
    478              // OUT packet received
    479              if (ISSET(dStatus, AT91C_UDP_RX_DATA_BK0)
    480                  || ISSET(dStatus, AT91C_UDP_RX_DATA_BK1)) 
   \                     ??UDP_EndpointHandler_0:
   \   00000190   4220               MOVS     R0,#+66
   \   00000192   3840               ANDS     R0,R0,R7
   \   00000194   0028               CMP      R0,#+0
   \   00000196   4BD0               BEQ      ??UDP_EndpointHandler_9
    481              {
    482                                                                                                                                                                   
    483                  // Check that the endpoint is in Read state
    484                  if (pEndpoint->dState != endpointStateRead) {
   \   00000198   706A               LDR      R0,[R6, #+36]
   \   0000019A   0328               CMP      R0,#+3
   \   0000019C   1FD0               BEQ      ??UDP_EndpointHandler_10
    485          
    486                                                                                              
    487                      // Endpoint is NOT in Read state
    488                      if (ISCLEARED(dStatus, AT91C_UDP_EPTYPE)
    489                          && ISCLEARED(dStatus, 0xFFFF0000)) 
   \   0000019E   7648               LDR      R0,??UDP_EndpointHandler_11  ;; 0xffff0700
   \   000001A0   3840               ANDS     R0,R0,R7
   \   000001A2   0028               CMP      R0,#+0
   \   000001A4   0AD1               BNE      ??UDP_EndpointHandler_12
    490                      {
    491                                                                                          
    492                          // Control endpoint, 0 bytes received
    493                          // Acknowledge the data and finish the current transfer
    494                                                                                          TRACE_DEBUG_L("Ack ");
    495                          UDP_ClearRXFlag(pUsb, bEndpoint);
   \   000001A6   2900               MOVS     R1,R5
   \   000001A8   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   000001AA   090E               LSRS     R1,R1,#+24
   \   000001AC   2000               MOVS     R0,R4
   \   000001AE   ........           BL       UDP_ClearRXFlag
    496          
    497                          UDP_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
   \   000001B2   0021               MOVS     R1,#+0
   \   000001B4   3000               MOVS     R0,R6
   \   000001B6   ........           BL       UDP_EndOfTransfer
   \   000001BA   39E0               B        ??UDP_EndpointHandler_9
    498                      }
    499                   
    500                      else if (ISSET(dStatus, AT91C_UDP_FORCESTALL)) 
   \                     ??UDP_EndpointHandler_12:
   \   000001BC   B806               LSLS     R0,R7,#+26
   \   000001BE   06D5               BPL      ??UDP_EndpointHandler_13
    501                      {
    502                                                                                          
    503                          // Non-control endpoint
    504                          // Discard stalled data
    505                                                                                          TRACE_DEBUG_L("Disc ");
    506                          UDP_ClearRXFlag(pUsb, bEndpoint);
   \   000001C0   2900               MOVS     R1,R5
   \   000001C2   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   000001C4   090E               LSRS     R1,R1,#+24
   \   000001C6   2000               MOVS     R0,R4
   \   000001C8   ........           BL       UDP_ClearRXFlag
   \   000001CC   30E0               B        ??UDP_EndpointHandler_9
    507                      }
    508                      else 
    509                      {
    510                                                                                          
    511                          // Non-control endpoint
    512                          // Nak data
    513                                                                                         // TRACE_DEBUG_L("Nak ");
    514                          SET(pInterface->UDP_IDR, 1 << bEndpoint);
   \                     ??UDP_EndpointHandler_13:
   \   000001CE   0098               LDR      R0,[SP, #+0]
   \   000001D0   0099               LDR      R1,[SP, #+0]
   \   000001D2   4969               LDR      R1,[R1, #+20]
   \   000001D4   0122               MOVS     R2,#+1
   \   000001D6   AA40               LSLS     R2,R2,R5
   \   000001D8   0A43               ORRS     R2,R2,R1
   \   000001DA   4261               STR      R2,[R0, #+20]
   \   000001DC   28E0               B        ??UDP_EndpointHandler_9
    515                      }
    516                  }
    517                  else 
    518                  {
    519          
    520                                                                                         
    521                    // Endpoint is in Read state
    522                      // Retrieve data and store it into the current transfer buffer
    523                      unsigned short wPacketSize = (unsigned short) (dStatus >> 16);
   \                     ??UDP_EndpointHandler_10:
   \   000001DE   6846               MOV      R0,SP
   \   000001E0   3900               MOVS     R1,R7
   \   000001E2   090C               LSRS     R1,R1,#+16
   \   000001E4   8180               STRH     R1,[R0, #+4]
    524                                                                                          //TRACE_DEBUG_L("%d ", wPacketSize);
    525                      //importuje dane z 
    526                      UDP_GetPayload(pUsb, bEndpoint, wPacketSize);
   \   000001E6   6846               MOV      R0,SP
   \   000001E8   8288               LDRH     R2,[R0, #+4]
   \   000001EA   2900               MOVS     R1,R5
   \   000001EC   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   000001EE   090E               LSRS     R1,R1,#+24
   \   000001F0   2000               MOVS     R0,R4
   \   000001F2   ........           BL       UDP_GetPayload
    527                      
    528          
    529                                                                                         
    530                                                                                         
    531                                                                                          
    532                      UDP_ClearRXFlag(pUsb, bEndpoint);
   \   000001F6   2900               MOVS     R1,R5
   \   000001F8   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   000001FA   090E               LSRS     R1,R1,#+24
   \   000001FC   2000               MOVS     R0,R4
   \   000001FE   ........           BL       UDP_ClearRXFlag
    533          
    534                      if ((pEndpoint->dBytesRemaining == 0)
    535                          || (wPacketSize < pEndpoint->wMaxPacketSize)) 
   \   00000202   7068               LDR      R0,[R6, #+4]
   \   00000204   0028               CMP      R0,#+0
   \   00000206   04D0               BEQ      ??UDP_EndpointHandler_14
   \   00000208   6846               MOV      R0,SP
   \   0000020A   8088               LDRH     R0,[R0, #+4]
   \   0000020C   B169               LDR      R1,[R6, #+24]
   \   0000020E   8842               CMP      R0,R1
   \   00000210   0ED2               BCS      ??UDP_EndpointHandler_9
    536                      {
    537                                                                                         
    538                          // Disable interrupt if this is not a control endpoint
    539                          if (!ISCLEARED(dStatus, AT91C_UDP_EPTYPE)) {
   \                     ??UDP_EndpointHandler_14:
   \   00000212   E020               MOVS     R0,#+224
   \   00000214   C000               LSLS     R0,R0,#+3        ;; #+1792
   \   00000216   0742               TST      R7,R0
   \   00000218   06D0               BEQ      ??UDP_EndpointHandler_15
    540          
    541                              SET(pInterface->UDP_IDR, 1 << bEndpoint);
   \   0000021A   0098               LDR      R0,[SP, #+0]
   \   0000021C   0099               LDR      R1,[SP, #+0]
   \   0000021E   4969               LDR      R1,[R1, #+20]
   \   00000220   0122               MOVS     R2,#+1
   \   00000222   AA40               LSLS     R2,R2,R5
   \   00000224   0A43               ORRS     R2,R2,R1
   \   00000226   4261               STR      R2,[R0, #+20]
    542                          }
    543          
    544                          UDP_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
   \                     ??UDP_EndpointHandler_15:
   \   00000228   0021               MOVS     R1,#+0
   \   0000022A   3000               MOVS     R0,R6
   \   0000022C   ........           BL       UDP_EndOfTransfer
    545                          
    546                      }
    547                  }
    548                  
    549                  
    550              }
    551              
    552              
    553              
    554              
    555              
    556              
    557              // SETUP packet received
    558              if (ISSET(dStatus, AT91C_UDP_RXSETUP)) 
   \                     ??UDP_EndpointHandler_9:
   \   00000230   7807               LSLS     R0,R7,#+29
   \   00000232   5DD5               BPL      ??UDP_EndpointHandler_16
    559              {
    560          
    561                                                                                          TRACE_DEBUG_L("Stp ");
    562                                                                                         
    563                  // If a transfer was pending, complete it
    564                  // Handle the case where during the status phase of a control write
    565                  // transfer, the host receives the device ZLP and ack it, but the ack
    566                  // is not received by the device
    567                  if ((pEndpoint->dState == endpointStateWrite)
    568                      || (pEndpoint->dState == endpointStateRead)) {
   \   00000234   706A               LDR      R0,[R6, #+36]
   \   00000236   0228               CMP      R0,#+2
   \   00000238   02D0               BEQ      ??UDP_EndpointHandler_17
   \   0000023A   706A               LDR      R0,[R6, #+36]
   \   0000023C   0328               CMP      R0,#+3
   \   0000023E   03D1               BNE      ??UDP_EndpointHandler_18
    569                                                                                          
    570                      UDP_EndOfTransfer(pEndpoint, USB_STATUS_SUCCESS);
   \                     ??UDP_EndpointHandler_17:
   \   00000240   0021               MOVS     R1,#+0
   \   00000242   3000               MOVS     R0,R6
   \   00000244   ........           BL       UDP_EndOfTransfer
    571                  }
    572          
    573                  // Copy the setup packet in S_usb
    574                  UDP_GetSetup(pUsb);
   \                     ??UDP_EndpointHandler_18:
   \   00000248   2000               MOVS     R0,R4
   \   0000024A   ........           BL       UDP_GetSetup
    575          
    576                  // Set the DIR bit before clearing RXSETUP in Control IN sequence
    577                  if (USB_GetSetup(pUsb)->bmRequestType & 0x80) {
   \   0000024E   2000               MOVS     R0,R4
   \   00000250   ........           BL       USB_GetSetup
   \   00000254   0078               LDRB     R0,[R0, #+0]
   \   00000256   0006               LSLS     R0,R0,#+24
   \   00000258   19D4               BMI      ??UDP_EndpointHandler_19
   \   0000025A   26E0               B        ??UDP_EndpointHandler_20
    578                                                                                          
    579                      UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_DIR);
   \                     ??UDP_EndpointHandler_21:
   \   0000025C   2000               MOVS     R0,R4
   \   0000025E   ........           BL       UDP_GetDriverInterface
   \   00000262   0090               STR      R0,[SP, #+0]
   \   00000264   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000266   2D0E               LSRS     R5,R5,#+24
   \   00000268   0421               MOVS     R1,#+4
   \   0000026A   6943               MULS     R1,R5,R1
   \   0000026C   02B5               PUSH     {R1,LR}
   \   0000026E   2000               MOVS     R0,R4
   \   00000270   ........           BL       UDP_GetDriverInterface
   \   00000274   0099               LDR      R1,[SP, #0]
   \   00000276   02B0               ADD      SP,SP,#+8
   \   00000278   4018               ADDS     R0,R0,R1
   \   0000027A   016B               LDR      R1,[R0, #+48]
   \   0000027C   8020               MOVS     R0,#+128
   \   0000027E   0843               ORRS     R0,R0,R1
   \   00000280   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000282   2D0E               LSRS     R5,R5,#+24
   \   00000284   0421               MOVS     R1,#+4
   \   00000286   6943               MULS     R1,R5,R1
   \   00000288   009A               LDR      R2,[SP, #+0]
   \   0000028A   5118               ADDS     R1,R2,R1
   \   0000028C   0863               STR      R0,[R1, #+48]
   \                     ??UDP_EndpointHandler_19:
   \   0000028E   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000290   2D0E               LSRS     R5,R5,#+24
   \   00000292   0421               MOVS     R1,#+4
   \   00000294   6943               MULS     R1,R5,R1
   \   00000296   02B5               PUSH     {R1,LR}
   \   00000298   2000               MOVS     R0,R4
   \   0000029A   ........           BL       UDP_GetDriverInterface
   \   0000029E   0099               LDR      R1,[SP, #0]
   \   000002A0   02B0               ADD      SP,SP,#+8
   \   000002A2   4018               ADDS     R0,R0,R1
   \   000002A4   006B               LDR      R0,[R0, #+48]
   \   000002A6   0006               LSLS     R0,R0,#+24
   \   000002A8   D8D5               BPL      ??UDP_EndpointHandler_21
    580                  }
    581          
    582                  UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_RXSETUP);
   \                     ??UDP_EndpointHandler_20:
   \   000002AA   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000002AC   2D0E               LSRS     R5,R5,#+24
   \   000002AE   0421               MOVS     R1,#+4
   \   000002B0   6943               MULS     R1,R5,R1
   \   000002B2   02B5               PUSH     {R1,LR}
   \   000002B4   2000               MOVS     R0,R4
   \   000002B6   ........           BL       UDP_GetDriverInterface
   \   000002BA   0099               LDR      R1,[SP, #0]
   \   000002BC   02B0               ADD      SP,SP,#+8
   \   000002BE   4018               ADDS     R0,R0,R1
   \   000002C0   006B               LDR      R0,[R0, #+48]
   \   000002C2   4007               LSLS     R0,R0,#+29
   \   000002C4   11D5               BPL      ??UDP_EndpointHandler_22
   \   000002C6   2000               MOVS     R0,R4
   \   000002C8   ........           BL       UDP_GetDriverInterface
   \   000002CC   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000002CE   2D0E               LSRS     R5,R5,#+24
   \   000002D0   0421               MOVS     R1,#+4
   \   000002D2   6943               MULS     R1,R5,R1
   \   000002D4   4118               ADDS     R1,R0,R1
   \   000002D6   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000002D8   2D0E               LSRS     R5,R5,#+24
   \   000002DA   0422               MOVS     R2,#+4
   \   000002DC   6A43               MULS     R2,R5,R2
   \   000002DE   8018               ADDS     R0,R0,R2
   \   000002E0   006B               LDR      R0,[R0, #+48]
   \   000002E2   0422               MOVS     R2,#+4
   \   000002E4   9043               BICS     R0,R0,R2
   \   000002E6   0863               STR      R0,[R1, #+48]
   \   000002E8   DFE7               B        ??UDP_EndpointHandler_20
    583          
    584                  // Forward the request to the upper layer
    585                  USB_NewRequestCallback(pUsb);
   \                     ??UDP_EndpointHandler_22:
   \   000002EA   2000               MOVS     R0,R4
   \   000002EC   ........           BL       USB_NewRequestCallback
    586                  
    587              }// koniec -  SETUP packet received
    588              
    589              
    590              
    591              
    592              // STALL sent
    593              if (ISSET(dStatus, AT91C_UDP_STALLSENT)) 
   \                     ??UDP_EndpointHandler_16:
   \   000002F0   3807               LSLS     R0,R7,#+28
   \   000002F2   11D4               BMI      ??UDP_EndpointHandler_23
   \   000002F4   3BE0               B        ??UDP_EndpointHandler_24
    594              {
    595                                                                                          
    596                  TRACE_WARNING("Sta ");
    597          
    598                  // Acknowledge the stall flag
    599                  UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_STALLSENT);
   \                     ??UDP_EndpointHandler_25:
   \   000002F6   2000               MOVS     R0,R4
   \   000002F8   ........           BL       UDP_GetDriverInterface
   \   000002FC   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000002FE   2D0E               LSRS     R5,R5,#+24
   \   00000300   0421               MOVS     R1,#+4
   \   00000302   6943               MULS     R1,R5,R1
   \   00000304   4118               ADDS     R1,R0,R1
   \   00000306   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000308   2D0E               LSRS     R5,R5,#+24
   \   0000030A   0422               MOVS     R2,#+4
   \   0000030C   6A43               MULS     R2,R5,R2
   \   0000030E   8018               ADDS     R0,R0,R2
   \   00000310   006B               LDR      R0,[R0, #+48]
   \   00000312   0822               MOVS     R2,#+8
   \   00000314   9043               BICS     R0,R0,R2
   \   00000316   0863               STR      R0,[R1, #+48]
   \                     ??UDP_EndpointHandler_23:
   \   00000318   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000031A   2D0E               LSRS     R5,R5,#+24
   \   0000031C   0427               MOVS     R7,#+4
   \   0000031E   6F43               MULS     R7,R5,R7
   \   00000320   2000               MOVS     R0,R4
   \   00000322   ........           BL       UDP_GetDriverInterface
   \   00000326   C019               ADDS     R0,R0,R7
   \   00000328   006B               LDR      R0,[R0, #+48]
   \   0000032A   0007               LSLS     R0,R0,#+28
   \   0000032C   E3D4               BMI      ??UDP_EndpointHandler_25
    600          
    601                  // If the endpoint is not halted, clear the stall condition
    602                  if (pEndpoint->dState != endpointStateHalted) {
   \   0000032E   706A               LDR      R0,[R6, #+36]
   \   00000330   0428               CMP      R0,#+4
   \   00000332   11D1               BNE      ??UDP_EndpointHandler_26
   \   00000334   1BE0               B        ??UDP_EndpointHandler_24
    603                                                                                         
    604                      UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_FORCESTALL);
   \                     ??UDP_EndpointHandler_27:
   \   00000336   2000               MOVS     R0,R4
   \   00000338   ........           BL       UDP_GetDriverInterface
   \   0000033C   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000033E   2D0E               LSRS     R5,R5,#+24
   \   00000340   0421               MOVS     R1,#+4
   \   00000342   6943               MULS     R1,R5,R1
   \   00000344   4118               ADDS     R1,R0,R1
   \   00000346   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000348   2D0E               LSRS     R5,R5,#+24
   \   0000034A   0422               MOVS     R2,#+4
   \   0000034C   6A43               MULS     R2,R5,R2
   \   0000034E   8018               ADDS     R0,R0,R2
   \   00000350   006B               LDR      R0,[R0, #+48]
   \   00000352   2022               MOVS     R2,#+32
   \   00000354   9043               BICS     R0,R0,R2
   \   00000356   0863               STR      R0,[R1, #+48]
   \                     ??UDP_EndpointHandler_26:
   \   00000358   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000035A   2D0E               LSRS     R5,R5,#+24
   \   0000035C   0426               MOVS     R6,#+4
   \   0000035E   6E43               MULS     R6,R5,R6
   \   00000360   2000               MOVS     R0,R4
   \   00000362   ........           BL       UDP_GetDriverInterface
   \   00000366   8019               ADDS     R0,R0,R6
   \   00000368   006B               LDR      R0,[R0, #+48]
   \   0000036A   8006               LSLS     R0,R0,#+26
   \   0000036C   E3D4               BMI      ??UDP_EndpointHandler_27
    605                  }
    606                }// koniec - STALL sent
    607              
    608                                                                                          //TRACE_DEBUG_L("a1 ");
    609                                                                                          //TRACE_DEBUG_L("KON_Ept%d ", bEndpoint);
    610          
    611          }
   \                     ??UDP_EndpointHandler_24:
   \   0000036E   03B0               ADD      SP,SP,#+12
   \   00000370   F0BC               POP      {R4-R7}
   \   00000372   01BC               POP      {R0}
   \   00000374   0047               BX       R0               ;; return
   \   00000376   C046               Nop      
   \                     ??UDP_EndpointHandler_11:
   \   00000378   0007FFFF           DC32     0xffff0700
    612          
    613          //------------------------------------------------------------------------------
    614          //      Exported functions
    615          //------------------------------------------------------------------------------
    616          //------------------------------------------------------------------------------
    617          // \brief  Configure an endpoint with the provided endpoint descriptor
    618          // \param  pUsb    Pointer to a S_usb instance
    619          // \param  pEpDesc Pointer to the endpoint descriptor
    620          // \return true if the endpoint is now configured, false otherwise
    621          // \see    S_usb_endpoint_descriptor
    622          // \see    S_usb
    623          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    624          bool UDP_ConfigureEndpoint(const S_usb                     *pUsb,
    625                                     const S_usb_endpoint_descriptor *pEpDesc)
    626          {
   \                     UDP_ConfigureEndpoint:
   \   00000000   F3B5               PUSH     {R0,R1,R4-R7,LR}
   \   00000002   81B0               SUB      SP,SP,#+4
    627              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   0198               LDR      R0,[SP, #+4]
   \   00000006   ........           BL       UDP_GetDriverInterface
   \   0000000A   0400               MOVS     R4,R0
    628              S_usb_endpoint *pEndpoint;
    629              unsigned char  bEndpoint;
    630              unsigned char  bType;
    631              bool           isINEndpoint;
    632              unsigned int   dFlags;
    633          
    634              // NULL descriptor -> Control endpoint 0
    635              if (pEpDesc == 0) {
   \   0000000C   0298               LDR      R0,[SP, #+8]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   05D1               BNE      ??UDP_ConfigureEndpoint_0
    636          
    637                  bEndpoint = 0;
   \   00000012   0025               MOVS     R5,#+0
    638                  bType = ENDPOINT_TYPE_CONTROL;
   \   00000014   0026               MOVS     R6,#+0
    639                  isINEndpoint = false;
   \   00000016   6846               MOV      R0,SP
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   0170               STRB     R1,[R0, #+0]
   \   0000001C   12E0               B        ??UDP_ConfigureEndpoint_1
    640              }
    641              else {
    642          
    643                  bEndpoint = (unsigned char) (pEpDesc->bEndpointAddress & 0x7);
   \                     ??UDP_ConfigureEndpoint_0:
   \   0000001E   0298               LDR      R0,[SP, #+8]
   \   00000020   8078               LDRB     R0,[R0, #+2]
   \   00000022   4507               LSLS     R5,R0,#+29       ;; ZeroExtS R5,R0,#+29,#+29
   \   00000024   6D0F               LSRS     R5,R5,#+29
    644                  bType = (unsigned char) (pEpDesc->bmAttributes & 0x3);
   \   00000026   0298               LDR      R0,[SP, #+8]
   \   00000028   C078               LDRB     R0,[R0, #+3]
   \   0000002A   8607               LSLS     R6,R0,#+30       ;; ZeroExtS R6,R0,#+30,#+30
   \   0000002C   B60F               LSRS     R6,R6,#+30
    645          
    646                  if (ISSET(pEpDesc->bEndpointAddress, 1 << 7)) {
   \   0000002E   6846               MOV      R0,SP
   \   00000030   0299               LDR      R1,[SP, #+8]
   \   00000032   8978               LDRB     R1,[R1, #+2]
   \   00000034   8022               MOVS     R2,#+128
   \   00000036   0A40               ANDS     R2,R2,R1
   \   00000038   1100               MOVS     R1,R2
   \   0000003A   491E               SUBS     R1,R1,#+1
   \   0000003C   8941               SBCS     R1,R1,R1
   \   0000003E   C943               MVNS     R1,R1
   \   00000040   C90F               LSRS     R1,R1,#+31
   \   00000042   0170               STRB     R1,[R0, #+0]
    647          
    648                      isINEndpoint = true;
    649                  }
    650                  else {
    651          
    652                      isINEndpoint = false;
    653                  }
    654              }
    655          
    656              // Get pointer on endpoint
    657              pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \                     ??UDP_ConfigureEndpoint_1:
   \   00000044   2900               MOVS     R1,R5
   \   00000046   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000048   090E               LSRS     R1,R1,#+24
   \   0000004A   0198               LDR      R0,[SP, #+4]
   \   0000004C   ........           BL       USB_GetEndpoint
   \   00000050   0700               MOVS     R7,R0
    658              if (pEndpoint == 0) {
   \   00000052   002F               CMP      R7,#+0
   \   00000054   01D1               BNE      ??UDP_ConfigureEndpoint_2
    659          
    660                  return false;
   \   00000056   0020               MOVS     R0,#+0
   \   00000058   5CE0               B        ??UDP_ConfigureEndpoint_3
    661              }
    662          
    663              // Configure wMaxPacketSize
    664              if (pEpDesc != 0) {
   \                     ??UDP_ConfigureEndpoint_2:
   \   0000005A   0298               LDR      R0,[SP, #+8]
   \   0000005C   0028               CMP      R0,#+0
   \   0000005E   07D0               BEQ      ??UDP_ConfigureEndpoint_4
    665          
    666                  pEndpoint->wMaxPacketSize = pEpDesc->wMaxPacketSize;
   \   00000060   0298               LDR      R0,[SP, #+8]
   \   00000062   0279               LDRB     R2,[R0, #+4]
   \   00000064   4179               LDRB     R1,[R0, #+5]
   \   00000066   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+16
   \   00000068   090C               LSRS     R1,R1,#+16
   \   0000006A   0A43               ORRS     R2,R2,R1
   \   0000006C   BA61               STR      R2,[R7, #+24]
   \   0000006E   01E0               B        ??UDP_ConfigureEndpoint_5
    667              }
    668              else {
    669          
    670                  pEndpoint->wMaxPacketSize = USB_ENDPOINT0_MAXPACKETSIZE;
   \                     ??UDP_ConfigureEndpoint_4:
   \   00000070   0820               MOVS     R0,#+8
   \   00000072   B861               STR      R0,[R7, #+24]
    671              }
    672          
    673              // Abort the current transfer is the endpoint was configured and in
    674              // Write or Read state
    675              if ((pEndpoint->dState == endpointStateRead)
    676                  || (pEndpoint->dState == endpointStateWrite)) {
   \                     ??UDP_ConfigureEndpoint_5:
   \   00000074   786A               LDR      R0,[R7, #+36]
   \   00000076   0328               CMP      R0,#+3
   \   00000078   02D0               BEQ      ??UDP_ConfigureEndpoint_6
   \   0000007A   786A               LDR      R0,[R7, #+36]
   \   0000007C   0228               CMP      R0,#+2
   \   0000007E   03D1               BNE      ??UDP_ConfigureEndpoint_7
    677          
    678                  UDP_EndOfTransfer(pEndpoint, USB_STATUS_RESET);
   \                     ??UDP_ConfigureEndpoint_6:
   \   00000080   0321               MOVS     R1,#+3
   \   00000082   3800               MOVS     R0,R7
   \   00000084   ........           BL       UDP_EndOfTransfer
    679              }
    680          
    681              // Enter IDLE state
    682              pEndpoint->dState = endpointStateIdle;
   \                     ??UDP_ConfigureEndpoint_7:
   \   00000088   0120               MOVS     R0,#+1
   \   0000008A   7862               STR      R0,[R7, #+36]
    683          
    684              // Reset Endpoint Fifos
    685              SET(pInterface->UDP_RSTEP, 1 << bEndpoint);
   \   0000008C   A06A               LDR      R0,[R4, #+40]
   \   0000008E   0121               MOVS     R1,#+1
   \   00000090   A940               LSLS     R1,R1,R5
   \   00000092   0143               ORRS     R1,R1,R0
   \   00000094   A162               STR      R1,[R4, #+40]
    686              CLEAR(pInterface->UDP_RSTEP, 1 << bEndpoint);
   \   00000096   A06A               LDR      R0,[R4, #+40]
   \   00000098   0121               MOVS     R1,#+1
   \   0000009A   A940               LSLS     R1,R1,R5
   \   0000009C   8843               BICS     R0,R0,R1
   \   0000009E   A062               STR      R0,[R4, #+40]
    687          
    688              // Configure endpoint
    689              dFlags = AT91C_UDP_EPEDS;
   \   000000A0   8027               MOVS     R7,#+128
   \   000000A2   3F02               LSLS     R7,R7,#+8        ;; #+32768
    690              SET(dFlags, bType << UDP_EPTYPE_INDEX);
   \   000000A4   3800               MOVS     R0,R7
   \   000000A6   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   000000A8   360E               LSRS     R6,R6,#+24
   \   000000AA   3702               LSLS     R7,R6,#+8
   \   000000AC   0743               ORRS     R7,R7,R0
    691          
    692              if (isINEndpoint) {
   \   000000AE   6846               MOV      R0,SP
   \   000000B0   0078               LDRB     R0,[R0, #+0]
   \   000000B2   0028               CMP      R0,#+0
   \   000000B4   03D0               BEQ      ??UDP_ConfigureEndpoint_8
    693          
    694                  SET(dFlags, 1 << UDP_EPDIR_INDEX);
   \   000000B6   3800               MOVS     R0,R7
   \   000000B8   8027               MOVS     R7,#+128
   \   000000BA   FF00               LSLS     R7,R7,#+3        ;; #+1024
   \   000000BC   0743               ORRS     R7,R7,R0
    695              }
    696          
    697              if (bType == ENDPOINT_TYPE_CONTROL) {
   \                     ??UDP_ConfigureEndpoint_8:
   \   000000BE   3606               LSLS     R6,R6,#+24       ;; ZeroExtS R6,R6,#+24,#+24
   \   000000C0   360E               LSRS     R6,R6,#+24
   \   000000C2   002E               CMP      R6,#+0
   \   000000C4   19D1               BNE      ??UDP_ConfigureEndpoint_9
    698          
    699                  SET(pInterface->UDP_IER, 1 << bEndpoint);
   \   000000C6   2069               LDR      R0,[R4, #+16]
   \   000000C8   0121               MOVS     R1,#+1
   \   000000CA   A940               LSLS     R1,R1,R5
   \   000000CC   0143               ORRS     R1,R1,R0
   \   000000CE   2161               STR      R1,[R4, #+16]
   \   000000D0   13E0               B        ??UDP_ConfigureEndpoint_9
    700              }
    701          
    702                                                                                          //TRACE_DEBUG_L("CfgEpt%d ", bEndpoint);
    703          
    704              UDP_SETEPFLAGS(pUsb, bEndpoint, dFlags);
   \                     ??UDP_ConfigureEndpoint_10:
   \   000000D2   0198               LDR      R0,[SP, #+4]
   \   000000D4   ........           BL       UDP_GetDriverInterface
   \   000000D8   0400               MOVS     R4,R0
   \   000000DA   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000DC   2D0E               LSRS     R5,R5,#+24
   \   000000DE   0426               MOVS     R6,#+4
   \   000000E0   6E43               MULS     R6,R5,R6
   \   000000E2   0198               LDR      R0,[SP, #+4]
   \   000000E4   ........           BL       UDP_GetDriverInterface
   \   000000E8   8019               ADDS     R0,R0,R6
   \   000000EA   006B               LDR      R0,[R0, #+48]
   \   000000EC   3843               ORRS     R0,R0,R7
   \   000000EE   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000F0   2D0E               LSRS     R5,R5,#+24
   \   000000F2   0421               MOVS     R1,#+4
   \   000000F4   6943               MULS     R1,R5,R1
   \   000000F6   6118               ADDS     R1,R4,R1
   \   000000F8   0863               STR      R0,[R1, #+48]
   \                     ??UDP_ConfigureEndpoint_9:
   \   000000FA   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000FC   2D0E               LSRS     R5,R5,#+24
   \   000000FE   0424               MOVS     R4,#+4
   \   00000100   6C43               MULS     R4,R5,R4
   \   00000102   0198               LDR      R0,[SP, #+4]
   \   00000104   ........           BL       UDP_GetDriverInterface
   \   00000108   0019               ADDS     R0,R0,R4
   \   0000010A   006B               LDR      R0,[R0, #+48]
   \   0000010C   3840               ANDS     R0,R0,R7
   \   0000010E   0028               CMP      R0,#+0
   \   00000110   DFD0               BEQ      ??UDP_ConfigureEndpoint_10
    705          
    706              return true;
   \   00000112   0120               MOVS     R0,#+1
   \                     ??UDP_ConfigureEndpoint_3:
   \   00000114   03B0               ADD      SP,SP,#+12
   \   00000116   F0BC               POP      {R4-R7}
   \   00000118   02BC               POP      {R1}
   \   0000011A   0847               BX       R1               ;; return
    707          }
    708          
    709          //------------------------------------------------------------------------------
    710          // \brief  UDP interrupt handler
    711          //
    712          //         Manages device resume, suspend, end of bus reset. Forwards endpoint
    713          //         interrupts to the appropriate handler.
    714          // \param  pUsb Pointer to a S_usb instance
    715          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    716          void UDP_Handler(const S_usb *pUsb)
    717          {
   \                     UDP_Handler:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
    718              AT91PS_UDP          pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       UDP_GetDriverInterface
   \   0000000A   0500               MOVS     R5,R0
    719              unsigned int        dStatus;
    720              unsigned char       bEndpoint;
    721          
    722              
    723              if ( (!ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED))
    724                 && (ISSET(USB_GetState(pUsb), USB_STATE_POWERED))){
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       USB_GetState
   \   00000012   8006               LSLS     R0,R0,#+26
   \   00000014   02D4               BMI      ??UDP_Handler_0
   \   00000016   2000               MOVS     R0,R4
   \   00000018   ........           BL       USB_GetState
    725          
    726                  LED_TOGGLE(LED_USB);
    727              }
    728          
    729                                                                                         //TRACE_DEBUG_L("Hlr ");
    730          
    731              // Get interrupts status
    732              dStatus = pInterface->UDP_ISR & pInterface->UDP_IMR & ISR_MASK;
   \                     ??UDP_Handler_0:
   \   0000001C   E869               LDR      R0,[R5, #+28]
   \   0000001E   A969               LDR      R1,[R5, #+24]
   \   00000020   0140               ANDS     R1,R1,R0
   \   00000022   8F04               LSLS     R7,R1,#+18       ;; ZeroExtS R7,R1,#+18,#+18
   \   00000024   BF0C               LSRS     R7,R7,#+18
   \   00000026   1CE0               B        ??UDP_Handler_1
    733          
    734              // Handle all UDP interrupts
    735              while (dStatus != 0) 
    736              {
    737          
    738                  // Start Of Frame (SOF)
    739                  if (ISSET(dStatus, AT91C_UDP_SOFINT)) {
    740                                                                                           
    741                                                                                          //TRACE_DEBUG_L("SOF ");
    742          
    743                      // Invoke the SOF callback
    744                      USB_StartOfFrameCallback(pUsb);
    745          
    746                      // Acknowledge interrupt
    747                      SET(pInterface->UDP_ICR, AT91C_UDP_SOFINT);
    748                      CLEAR(dStatus, AT91C_UDP_SOFINT);
    749                  }
    750          
    751                  // Suspend
    752                  if (dStatus == AT91C_UDP_RXSUSP) 
    753                  {                                                                       //TRACE_DEBUG_L("Susp ");
    754          
    755                      if (!ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED)) 
    756                      {
    757                                                                                          //TRACE_DEBUG_L("Susp_in ");
    758                          // The device enters the Suspended state                        
    759                          //      MCK + UDPCK must be off
    760                          //      Pull-Up must be connected
    761                          //      Transceiver must be disabled
    762          
    763                          // Enable wakeup
    764                          SET(pInterface->UDP_IER, AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM);
    765          
    766                          // Acknowledge interrupt
    767                          SET(pInterface->UDP_ICR, AT91C_UDP_RXSUSP);
    768          
    769                          SET(*(pUsb->pState), USB_STATE_SUSPENDED);
    770                          UDP_DisableTransceiver(pUsb);
    771                          UDP_DisableMCK(pUsb);
    772                          UDP_DisableUDPCK(pUsb);
    773          
    774                          // Invoke the Suspend callback
    775                          USB_SuspendCallback(pUsb);
    776          
    777                      }
    778                      
    779                      
    780                      
    781                  }//End of Suspend
    782                  // Resume
    783                  else if (ISSET(dStatus, AT91C_UDP_WAKEUP)
    784                        || ISSET(dStatus, AT91C_UDP_RXRSM)) 
    785                  {
    786          
    787                      // Invoke the Resume callback
    788                      USB_ResumeCallback(pUsb);
    789          
    790                                                                                          //TRACE_DEBUG_L("Res ");
    791          
    792                      // The device enters Configured state
    793                      //      MCK + UDPCK must be on
    794                      //      Pull-Up must be connected
    795                      //      Transceiver must be enabled
    796          
    797                      if (ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED)) 
    798                      {
    799          
    800                          // Powered state
    801                          UDP_EnableMCK(pUsb);
    802                          UDP_EnableUDPCK(pUsb);
    803          
    804                          // Default state
    805                          if (ISSET(USB_GetState(pUsb), USB_STATE_DEFAULT)) 
    806                          {
    807          
    808                              UDP_EnableTransceiver(pUsb);
    809                          }
    810          
    811                          CLEAR(*(pUsb->pState), USB_STATE_SUSPENDED);
    812                      }
    813                      SET(pInterface->UDP_ICR,
    814                          AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM | AT91C_UDP_RXSUSP);
    815                      SET(pInterface->UDP_IDR, AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM);
    816                  }
    817                  // End of bus reset
    818                  else if (ISSET(dStatus, AT91C_UDP_ENDBUSRES)) 
    819                  {
    820          
    821                                                                                          //TRACE_DEBUG_L("EoBRes ");
    822          
    823                      // The device enters the Default state
    824                      //      MCK + UDPCK are already enabled
    825                      //      Pull-Up is already connected
    826                      //      Transceiver must be enabled
    827                      //      Endpoint 0 must be enabled
    828                      SET(*(pUsb->pState), USB_STATE_DEFAULT);
    829                      UDP_EnableTransceiver(pUsb);
    830          
    831                      // The device leaves the Address & Configured states
    832                      CLEAR(*(pUsb->pState), USB_STATE_ADDRESS | USB_STATE_CONFIGURED);
    833                      UDP_ResetEndpoints(pUsb);
    834                      UDP_DisableEndpoints(pUsb);
    835                      UDP_ConfigureEndpoint(pUsb, 0);
    836          
    837                      // Flush and enable the Suspend interrupt
    838                      SET(pInterface->UDP_ICR,
    839                          AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM | AT91C_UDP_RXSUSP);
    840          
    841                      // Enable the Start Of Frame (SOF) interrupt if needed
    842                      if (pUsb->pCallbacks->startOfFrame != 0) {
    843          
    844                          SET(pInterface->UDP_IER, AT91C_UDP_SOFINT);
    845                      }
    846          
    847                      // Invoke the Reset callback
    848                      USB_ResetCallback(pUsb);
    849          
    850                      // Acknowledge end of bus reset interrupt
    851                      SET(pInterface->UDP_ICR, AT91C_UDP_ENDBUSRES);
    852                  }
    853                  // Endpoint interrupts
    854                  else {
    855                                                                                                                                                     
    856                      while (dStatus != 0) 
    857                      {
    858                                                                                          //TRACE_DEBUG_L("E_it ");   
    859                          // Get endpoint index
    860                          bEndpoint = lastSetBit(dStatus);
   \                     ??UDP_Handler_2:
   \   00000028   3800               MOVS     R0,R7
   \   0000002A   ........           BL       lastSetBit
   \   0000002E   0600               MOVS     R6,R0
    861                          UDP_EndpointHandler(pUsb, bEndpoint);
   \   00000030   3100               MOVS     R1,R6
   \   00000032   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000034   090E               LSRS     R1,R1,#+24
   \   00000036   2000               MOVS     R0,R4
   \   00000038   ........           BL       UDP_EndpointHandler
    862                                                                                          
    863                          /*CLEAR(pInterface->UDP_CSR[bEndpoint],
    864                                AT91C_UDP_TXCOMP | AT91C_UDP_RX_DATA_BK0
    865                              | AT91C_UDP_RX_DATA_BK1 | AT91C_UDP_RXSETUP
    866                              | AT91C_UDP_STALLSENT);*/
    867          
    868                          CLEAR(dStatus, 1 << bEndpoint);
   \   0000003C   0120               MOVS     R0,#+1
   \   0000003E   B040               LSLS     R0,R0,R6
   \   00000040   8743               BICS     R7,R7,R0
    869          
    870                          if (dStatus != 0) {
    871                                                                                          
    872                                                                                          //TRACE_DEBUG_L("\n\r  - ");
    873          
    874                          }
    875                      }
   \                     ??UDP_Handler_3:
   \   00000042   002F               CMP      R7,#+0
   \   00000044   F0D1               BNE      ??UDP_Handler_2
    876                                                                                         
    877                  }
    878                  
    879                                                                                         
    880                  
    881          
    882                  // Retrieve new interrupt status
    883                  dStatus = pInterface->UDP_ISR & pInterface->UDP_IMR & ISR_MASK;
   \                     ??UDP_Handler_4:
   \   00000046   E869               LDR      R0,[R5, #+28]
   \   00000048   A969               LDR      R1,[R5, #+24]
   \   0000004A   0140               ANDS     R1,R1,R0
   \   0000004C   8F04               LSLS     R7,R1,#+18       ;; ZeroExtS R7,R1,#+18,#+18
   \   0000004E   BF0C               LSRS     R7,R7,#+18
    884          
    885                  // Mask unneeded interrupts
    886                  if (!ISSET(USB_GetState(pUsb), USB_STATE_DEFAULT)) {
   \   00000050   2000               MOVS     R0,R4
   \   00000052   ........           BL       USB_GetState
   \   00000056   4007               LSLS     R0,R0,#+29
   \   00000058   03D4               BMI      ??UDP_Handler_1
    887          
    888                      dStatus &= AT91C_UDP_ENDBUSRES | AT91C_UDP_SOFINT;
   \   0000005A   3800               MOVS     R0,R7
   \   0000005C   C027               MOVS     R7,#+192
   \   0000005E   7F01               LSLS     R7,R7,#+5        ;; #+6144
   \   00000060   0740               ANDS     R7,R7,R0
    889                  }
   \                     ??UDP_Handler_1:
   \   00000062   002F               CMP      R7,#+0
   \   00000064   00D1               BNE      .+4
   \   00000066   90E0               B        ??UDP_Handler_5
   \   00000068   3805               LSLS     R0,R7,#+20
   \   0000006A   0AD5               BPL      ??UDP_Handler_6
   \   0000006C   2000               MOVS     R0,R4
   \   0000006E   ........           BL       USB_StartOfFrameCallback
   \   00000072   286A               LDR      R0,[R5, #+32]
   \   00000074   8021               MOVS     R1,#+128
   \   00000076   0901               LSLS     R1,R1,#+4        ;; #+2048
   \   00000078   0143               ORRS     R1,R1,R0
   \   0000007A   2962               STR      R1,[R5, #+32]
   \   0000007C   3800               MOVS     R0,R7
   \   0000007E   494F               LDR      R7,??UDP_Handler_7  ;; 0xfffff7ff
   \   00000080   0740               ANDS     R7,R7,R0
   \                     ??UDP_Handler_6:
   \   00000082   8020               MOVS     R0,#+128
   \   00000084   4000               LSLS     R0,R0,#+1        ;; #+256
   \   00000086   8742               CMP      R7,R0
   \   00000088   21D1               BNE      ??UDP_Handler_8
   \   0000008A   2000               MOVS     R0,R4
   \   0000008C   ........           BL       USB_GetState
   \   00000090   8006               LSLS     R0,R0,#+26
   \   00000092   D8D4               BMI      ??UDP_Handler_4
   \   00000094   2869               LDR      R0,[R5, #+16]
   \   00000096   8821               MOVS     R1,#+136
   \   00000098   8901               LSLS     R1,R1,#+6        ;; #+8704
   \   0000009A   0143               ORRS     R1,R1,R0
   \   0000009C   2961               STR      R1,[R5, #+16]
   \   0000009E   286A               LDR      R0,[R5, #+32]
   \   000000A0   8021               MOVS     R1,#+128
   \   000000A2   4900               LSLS     R1,R1,#+1        ;; #+256
   \   000000A4   0143               ORRS     R1,R1,R0
   \   000000A6   2962               STR      R1,[R5, #+32]
   \   000000A8   6069               LDR      R0,[R4, #+20]
   \   000000AA   6169               LDR      R1,[R4, #+20]
   \   000000AC   0968               LDR      R1,[R1, #+0]
   \   000000AE   2022               MOVS     R2,#+32
   \   000000B0   0A43               ORRS     R2,R2,R1
   \   000000B2   0260               STR      R2,[R0, #+0]
   \   000000B4   2000               MOVS     R0,R4
   \   000000B6   ........           BL       UDP_DisableTransceiver
   \   000000BA   2000               MOVS     R0,R4
   \   000000BC   ........           BL       UDP_DisableMCK
   \   000000C0   2000               MOVS     R0,R4
   \   000000C2   ........           BL       UDP_DisableUDPCK
   \   000000C6   2000               MOVS     R0,R4
   \   000000C8   ........           BL       USB_SuspendCallback
   \   000000CC   BBE7               B        ??UDP_Handler_4
   \                     ??UDP_Handler_8:
   \   000000CE   8820               MOVS     R0,#+136
   \   000000D0   8001               LSLS     R0,R0,#+6        ;; #+8704
   \   000000D2   3840               ANDS     R0,R0,R7
   \   000000D4   0028               CMP      R0,#+0
   \   000000D6   26D0               BEQ      ??UDP_Handler_9
   \   000000D8   2000               MOVS     R0,R4
   \   000000DA   ........           BL       USB_ResumeCallback
   \   000000DE   2000               MOVS     R0,R4
   \   000000E0   ........           BL       USB_GetState
   \   000000E4   8006               LSLS     R0,R0,#+26
   \   000000E6   13D5               BPL      ??UDP_Handler_10
   \   000000E8   2000               MOVS     R0,R4
   \   000000EA   ........           BL       UDP_EnableMCK
   \   000000EE   2000               MOVS     R0,R4
   \   000000F0   ........           BL       UDP_EnableUDPCK
   \   000000F4   2000               MOVS     R0,R4
   \   000000F6   ........           BL       USB_GetState
   \   000000FA   4007               LSLS     R0,R0,#+29
   \   000000FC   02D5               BPL      ??UDP_Handler_11
   \   000000FE   2000               MOVS     R0,R4
   \   00000100   ........           BL       UDP_EnableTransceiver
   \                     ??UDP_Handler_11:
   \   00000104   6069               LDR      R0,[R4, #+20]
   \   00000106   6169               LDR      R1,[R4, #+20]
   \   00000108   0968               LDR      R1,[R1, #+0]
   \   0000010A   2022               MOVS     R2,#+32
   \   0000010C   9143               BICS     R1,R1,R2
   \   0000010E   0160               STR      R1,[R0, #+0]
   \                     ??UDP_Handler_10:
   \   00000110   286A               LDR      R0,[R5, #+32]
   \   00000112   8C21               MOVS     R1,#+140
   \   00000114   8901               LSLS     R1,R1,#+6        ;; #+8960
   \   00000116   0143               ORRS     R1,R1,R0
   \   00000118   2962               STR      R1,[R5, #+32]
   \   0000011A   6869               LDR      R0,[R5, #+20]
   \   0000011C   8821               MOVS     R1,#+136
   \   0000011E   8901               LSLS     R1,R1,#+6        ;; #+8704
   \   00000120   0143               ORRS     R1,R1,R0
   \   00000122   6961               STR      R1,[R5, #+20]
   \   00000124   8FE7               B        ??UDP_Handler_4
   \                     ??UDP_Handler_9:
   \   00000126   F804               LSLS     R0,R7,#+19
   \   00000128   8BD5               BPL      ??UDP_Handler_3
   \   0000012A   6069               LDR      R0,[R4, #+20]
   \   0000012C   6169               LDR      R1,[R4, #+20]
   \   0000012E   0968               LDR      R1,[R1, #+0]
   \   00000130   0422               MOVS     R2,#+4
   \   00000132   0A43               ORRS     R2,R2,R1
   \   00000134   0260               STR      R2,[R0, #+0]
   \   00000136   2000               MOVS     R0,R4
   \   00000138   ........           BL       UDP_EnableTransceiver
   \   0000013C   6069               LDR      R0,[R4, #+20]
   \   0000013E   6169               LDR      R1,[R4, #+20]
   \   00000140   0968               LDR      R1,[R1, #+0]
   \   00000142   1822               MOVS     R2,#+24
   \   00000144   9143               BICS     R1,R1,R2
   \   00000146   0160               STR      R1,[R0, #+0]
   \   00000148   2000               MOVS     R0,R4
   \   0000014A   ........           BL       UDP_ResetEndpoints
   \   0000014E   2000               MOVS     R0,R4
   \   00000150   ........           BL       UDP_DisableEndpoints
   \   00000154   0021               MOVS     R1,#+0
   \   00000156   2000               MOVS     R0,R4
   \   00000158   ........           BL       UDP_ConfigureEndpoint
   \   0000015C   286A               LDR      R0,[R5, #+32]
   \   0000015E   8C21               MOVS     R1,#+140
   \   00000160   8901               LSLS     R1,R1,#+6        ;; #+8960
   \   00000162   0143               ORRS     R1,R1,R0
   \   00000164   2962               STR      R1,[R5, #+32]
   \   00000166   E068               LDR      R0,[R4, #+12]
   \   00000168   4069               LDR      R0,[R0, #+20]
   \   0000016A   0028               CMP      R0,#+0
   \   0000016C   04D0               BEQ      ??UDP_Handler_12
   \   0000016E   2869               LDR      R0,[R5, #+16]
   \   00000170   8021               MOVS     R1,#+128
   \   00000172   0901               LSLS     R1,R1,#+4        ;; #+2048
   \   00000174   0143               ORRS     R1,R1,R0
   \   00000176   2961               STR      R1,[R5, #+16]
   \                     ??UDP_Handler_12:
   \   00000178   2000               MOVS     R0,R4
   \   0000017A   ........           BL       USB_ResetCallback
   \   0000017E   286A               LDR      R0,[R5, #+32]
   \   00000180   8021               MOVS     R1,#+128
   \   00000182   4901               LSLS     R1,R1,#+5        ;; #+4096
   \   00000184   0143               ORRS     R1,R1,R0
   \   00000186   2962               STR      R1,[R5, #+32]
   \   00000188   5DE7               B        ??UDP_Handler_4
    890                                                                                         
    891                  //TRACE_DEBUG_L("\n\r");
    892                                                                                          
    893                  if (dStatus != 0) {
    894          
    895                                                                                          //TRACE_DEBUG_L("  - ");
    896                  }
    897              }
    898          
    899              if ( (!ISSET(USB_GetState(pUsb), USB_STATE_SUSPENDED))
    900                 && (ISSET(USB_GetState(pUsb), USB_STATE_POWERED))){
   \                     ??UDP_Handler_5:
   \   0000018A   2000               MOVS     R0,R4
   \   0000018C   ........           BL       USB_GetState
   \   00000190   8006               LSLS     R0,R0,#+26
   \   00000192   02D4               BMI      ??UDP_Handler_13
   \   00000194   2000               MOVS     R0,R4
   \   00000196   ........           BL       USB_GetState
    901          
    902                  LED_TOGGLE(LED_USB);
    903              }
    904              
    905                                                                                         //TRACE_DEBUG_L("KON_Hdl ");
    906                                                                                         //TRACE_DEBUG_L("\n\r");
    907              
    908          }
   \                     ??UDP_Handler_13:
   \   0000019A   01B0               ADD      SP,SP,#+4
   \   0000019C   F0BC               POP      {R4-R7}
   \   0000019E   01BC               POP      {R0}
   \   000001A0   0047               BX       R0               ;; return
   \   000001A2   C046               Nop      
   \                     ??UDP_Handler_7:
   \   000001A4   FFF7FFFF           DC32     0xfffff7ff
    909          
    910          //------------------------------------------------------------------------------
    911          // \brief  Sends data through an USB endpoint
    912          //
    913          //         Sets up the transfer descriptor, write one or two data payloads
    914          //         (depending on the number of FIFO banks for the endpoint) and then
    915          //         starts the actual transfer. The operation is complete when all
    916          //         the data has been sent.
    917          // \param  pUsb      Pointer to a S_usb instance
    918          // \param  bEndpoint Index of endpoint
    919          // \param  pData     Pointer to a buffer containing the data to send
    920          // \param  dLength   Length of the data buffer
    921          // \param  fCallback Optional function to invoke when the transfer finishes
    922          // \param  pArgument Optional argument for the callback function
    923          // \return Operation result code
    924          // \see    Operation result codes
    925          // \see    Callback_f
    926          // \see    S_usb
    927          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    928          char UDP_Write(const S_usb   *pUsb,
    929                         unsigned char bEndpoint,
    930                         const void    *pData,
    931                         unsigned int  dLength,
    932                         Callback_f    fCallback,
    933                         void          *pArgument)
    934          {
   \                     UDP_Write:
   \   00000000   FDB5               PUSH     {R0,R2-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   099F               LDR      R7,[SP, #+36]
    935              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   00000008   2900               MOVS     R1,R5
   \   0000000A   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000000C   090E               LSRS     R1,R1,#+24
   \   0000000E   2000               MOVS     R0,R4
   \   00000010   ........           BL       USB_GetEndpoint
   \   00000014   0600               MOVS     R6,R0
    936              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000016   2000               MOVS     R0,R4
   \   00000018   ........           BL       UDP_GetDriverInterface
   \   0000001C   0090               STR      R0,[SP, #+0]
    937          
    938              // Check that the endpoint is in Idle state
    939              if (pEndpoint->dState != endpointStateIdle) {
   \   0000001E   706A               LDR      R0,[R6, #+36]
   \   00000020   0128               CMP      R0,#+1
   \   00000022   01D0               BEQ      ??UDP_Write_0
    940          
    941                  return USB_STATUS_LOCKED;
   \   00000024   0120               MOVS     R0,#+1
   \   00000026   4BE0               B        ??UDP_Write_1
    942              }
    943          
    944                                                                                         // TRACE_DEBUG_L("Write%d(%d) ", bEndpoint, dLength);
    945          
    946              // Setup the transfer descriptor
    947              pEndpoint->pData = (char *) pData;
   \                     ??UDP_Write_0:
   \   00000028   0198               LDR      R0,[SP, #+4]
   \   0000002A   3060               STR      R0,[R6, #+0]
    948              pEndpoint->dBytesRemaining = dLength;
   \   0000002C   0298               LDR      R0,[SP, #+8]
   \   0000002E   7060               STR      R0,[R6, #+4]
    949              pEndpoint->dBytesBuffered = 0;
   \   00000030   0020               MOVS     R0,#+0
   \   00000032   B060               STR      R0,[R6, #+8]
    950              pEndpoint->dBytesTransferred = 0;
   \   00000034   0020               MOVS     R0,#+0
   \   00000036   F060               STR      R0,[R6, #+12]
    951              pEndpoint->fCallback = fCallback;
   \   00000038   0898               LDR      R0,[SP, #+32]
   \   0000003A   3061               STR      R0,[R6, #+16]
    952              pEndpoint->pArgument = pArgument;
   \   0000003C   7761               STR      R7,[R6, #+20]
    953          
    954              // Send one packet
    955              pEndpoint->dState = endpointStateWrite;
   \   0000003E   0220               MOVS     R0,#+2
   \   00000040   7062               STR      R0,[R6, #+36]
    956              UDP_WritePayload(pUsb, bEndpoint);
   \   00000042   2900               MOVS     R1,R5
   \   00000044   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000046   090E               LSRS     R1,R1,#+24
   \   00000048   2000               MOVS     R0,R4
   \   0000004A   ........           BL       UDP_WritePayload
   \   0000004E   17E0               B        ??UDP_Write_2
    957              UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_TXPKTRDY);
   \                     ??UDP_Write_3:
   \   00000050   2000               MOVS     R0,R4
   \   00000052   ........           BL       UDP_GetDriverInterface
   \   00000056   0700               MOVS     R7,R0
   \   00000058   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000005A   2D0E               LSRS     R5,R5,#+24
   \   0000005C   0421               MOVS     R1,#+4
   \   0000005E   6943               MULS     R1,R5,R1
   \   00000060   02B5               PUSH     {R1,LR}
   \   00000062   2000               MOVS     R0,R4
   \   00000064   ........           BL       UDP_GetDriverInterface
   \   00000068   0099               LDR      R1,[SP, #0]
   \   0000006A   02B0               ADD      SP,SP,#+8
   \   0000006C   4018               ADDS     R0,R0,R1
   \   0000006E   006B               LDR      R0,[R0, #+48]
   \   00000070   1021               MOVS     R1,#+16
   \   00000072   0143               ORRS     R1,R1,R0
   \   00000074   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000076   2D0E               LSRS     R5,R5,#+24
   \   00000078   0420               MOVS     R0,#+4
   \   0000007A   6843               MULS     R0,R5,R0
   \   0000007C   3818               ADDS     R0,R7,R0
   \   0000007E   0163               STR      R1,[R0, #+48]
   \                     ??UDP_Write_2:
   \   00000080   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000082   2D0E               LSRS     R5,R5,#+24
   \   00000084   0427               MOVS     R7,#+4
   \   00000086   6F43               MULS     R7,R5,R7
   \   00000088   2000               MOVS     R0,R4
   \   0000008A   ........           BL       UDP_GetDriverInterface
   \   0000008E   C019               ADDS     R0,R0,R7
   \   00000090   006B               LDR      R0,[R0, #+48]
   \   00000092   C006               LSLS     R0,R0,#+27
   \   00000094   DCD5               BPL      ??UDP_Write_3
    958          
    959              // If double buffering is enabled and there is data remaining,
    960              // prepare another packet
    961              if ((pEndpoint->dNumFIFO > 1) && (pEndpoint->dBytesRemaining > 0)) {
   \   00000096   2020               MOVS     R0,#+32
   \   00000098   305C               LDRB     R0,[R6, R0]
   \   0000009A   0228               CMP      R0,#+2
   \   0000009C   08D3               BCC      ??UDP_Write_4
   \   0000009E   7068               LDR      R0,[R6, #+4]
   \   000000A0   0028               CMP      R0,#+0
   \   000000A2   05D0               BEQ      ??UDP_Write_4
    962          
    963                  UDP_WritePayload(pUsb, bEndpoint);
   \   000000A4   2900               MOVS     R1,R5
   \   000000A6   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   000000A8   090E               LSRS     R1,R1,#+24
   \   000000AA   2000               MOVS     R0,R4
   \   000000AC   ........           BL       UDP_WritePayload
    964              }
    965          
    966              // Enable interrupt on endpoint
    967              SET(pInterface->UDP_IER, 1 << bEndpoint);
   \                     ??UDP_Write_4:
   \   000000B0   0098               LDR      R0,[SP, #+0]
   \   000000B2   0099               LDR      R1,[SP, #+0]
   \   000000B4   0969               LDR      R1,[R1, #+16]
   \   000000B6   0122               MOVS     R2,#+1
   \   000000B8   AA40               LSLS     R2,R2,R5
   \   000000BA   0A43               ORRS     R2,R2,R1
   \   000000BC   0261               STR      R2,[R0, #+16]
    968                                                                                         //TRACE_DEBUG_L("KON_USB_Write ");
    969                                                                                         //TRACE_DEBUG_L("\n\r");
    970              return USB_STATUS_SUCCESS;
   \   000000BE   0020               MOVS     R0,#+0
   \                     ??UDP_Write_1:
   \   000000C0   03B0               ADD      SP,SP,#+12
   \   000000C2   F0BC               POP      {R4-R7}
   \   000000C4   02BC               POP      {R1}
   \   000000C6   0847               BX       R1               ;; return
    971              
    972              
    973          }
    974          
    975          //------------------------------------------------------------------------------
    976          // \brief  Reads incoming data on an USB endpoint
    977          //
    978          //         This methods sets the transfer descriptor and activate the endpoint
    979          //         interrupt. The actual transfer is then carried out by the endpoint
    980          //         interrupt handler. The Read operation finishes either when the
    981          //         buffer is full, or a short packet (inferior to endpoint maximum
    982          //         packet size) is received.
    983          // \param  pUsb      Pointer to a S_usb instance
    984          // \param  bEndpoint Index of endpoint
    985          // \param  pData     Pointer to a buffer to store the received data
    986          // \param  dLength   Length of the receive buffer
    987          // \param  fCallback Optional callback function
    988          // \param  pArgument Optional callback argument
    989          // \return Operation result code
    990          // \see    Callback_f
    991          // \see    S_usb
    992          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    993          char UDP_Read(const S_usb   *pUsb,
    994                        unsigned char bEndpoint,
    995                        void          *pData,
    996                        unsigned int  dLength,
    997                        Callback_f    fCallback,
    998                        void          *pArgument)
    999          {
   \                     UDP_Read:
   \   00000000   FDB5               PUSH     {R0,R2-R7,LR}
   \   00000002   0700               MOVS     R7,R0
   \   00000004   0C00               MOVS     R4,R1
   \   00000006   099D               LDR      R5,[SP, #+36]
   1000              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000008   3800               MOVS     R0,R7
   \   0000000A   ........           BL       UDP_GetDriverInterface
   \   0000000E   0600               MOVS     R6,R0
   1001              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   00000010   2100               MOVS     R1,R4
   \   00000012   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000014   090E               LSRS     R1,R1,#+24
   \   00000016   3800               MOVS     R0,R7
   \   00000018   ........           BL       USB_GetEndpoint
   1002          
   1003              //! Return if the endpoint is not in IDLE state
   1004              if (pEndpoint->dState != endpointStateIdle) {
   \   0000001C   416A               LDR      R1,[R0, #+36]
   \   0000001E   0129               CMP      R1,#+1
   \   00000020   01D0               BEQ      ??UDP_Read_0
   1005          
   1006                  return USB_STATUS_LOCKED;
   \   00000022   0120               MOVS     R0,#+1
   \   00000024   12E0               B        ??UDP_Read_1
   1007              }
   1008          
   1009                                                                                          //TRACE_DEBUG_L("Read%d(%d) ", bEndpoint, dLength);
   1010              // Endpoint enters Read state
   1011              pEndpoint->dState = endpointStateRead;
   \                     ??UDP_Read_0:
   \   00000026   0321               MOVS     R1,#+3
   \   00000028   4162               STR      R1,[R0, #+36]
   1012          
   1013              // Set the transfer descriptor
   1014              pEndpoint->pData = (char *) pData;
   \   0000002A   0199               LDR      R1,[SP, #+4]
   \   0000002C   0160               STR      R1,[R0, #+0]
   1015              pEndpoint->dBytesRemaining = dLength;
   \   0000002E   0299               LDR      R1,[SP, #+8]
   \   00000030   4160               STR      R1,[R0, #+4]
   1016              pEndpoint->dBytesBuffered = 0;
   \   00000032   0021               MOVS     R1,#+0
   \   00000034   8160               STR      R1,[R0, #+8]
   1017              pEndpoint->dBytesTransferred = 0;
   \   00000036   0021               MOVS     R1,#+0
   \   00000038   C160               STR      R1,[R0, #+12]
   1018              pEndpoint->fCallback = fCallback;
   \   0000003A   0899               LDR      R1,[SP, #+32]
   \   0000003C   0161               STR      R1,[R0, #+16]
   1019              pEndpoint->pArgument = pArgument;
   \   0000003E   4561               STR      R5,[R0, #+20]
   1020          
   1021              // Enable interrupt on endpoint
   1022              SET(pInterface->UDP_IER, 1 << bEndpoint);
   \   00000040   3069               LDR      R0,[R6, #+16]
   \   00000042   0121               MOVS     R1,#+1
   \   00000044   A140               LSLS     R1,R1,R4
   \   00000046   0143               ORRS     R1,R1,R0
   \   00000048   3161               STR      R1,[R6, #+16]
   1023              
   1024              //znak=USB_STATUS_SUCCESS;
   1025                                                                                         //TRACE_DEBUG_L("KON_USB_Read ");
   1026                                                                                         //TRACE_DEBUG_L("\n\r");
   1027                                                                                        
   1028              return USB_STATUS_SUCCESS;
   \   0000004A   0020               MOVS     R0,#+0
   \                     ??UDP_Read_1:
   \   0000004C   03B0               ADD      SP,SP,#+12
   \   0000004E   F0BC               POP      {R4-R7}
   \   00000050   02BC               POP      {R1}
   \   00000052   0847               BX       R1               ;; return
   1029          }
   1030          
   1031          //------------------------------------------------------------------------------
   1032          // \brief  Clears, sets or returns the Halt state on specified endpoint
   1033          //
   1034          //         When in Halt state, an endpoint acknowledges every received packet
   1035          //         with a STALL handshake. This continues until the endpoint is
   1036          //         manually put out of the Halt state by calling this function.
   1037          // \param  pUsb Pointer to a S_usb instance
   1038          // \param  bEndpoint Index of endpoint
   1039          // \param  bRequest  Request to perform
   1040          //                   -> USB_SET_FEATURE, USB_CLEAR_FEATURE, USB_GET_STATUS
   1041          // \return true if the endpoint is currently Halted, false otherwise
   1042          // \see    S_usb
   1043          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1044          bool UDP_Halt(const S_usb   *pUsb,
   1045                        unsigned char bEndpoint,
   1046                        unsigned char bRequest)
   1047          {
   \                     UDP_Halt:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0D00               MOVS     R5,R1
   \   00000004   1700               MOVS     R7,R2
   1048              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   00000006   0098               LDR      R0,[SP, #+0]
   \   00000008   ........           BL       UDP_GetDriverInterface
   \   0000000C   0600               MOVS     R6,R0
   1049              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   0000000E   2900               MOVS     R1,R5
   \   00000010   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   00000012   090E               LSRS     R1,R1,#+24
   \   00000014   0098               LDR      R0,[SP, #+0]
   \   00000016   ........           BL       USB_GetEndpoint
   \   0000001A   0400               MOVS     R4,R0
   1050          
   1051              // Clear the Halt feature of the endpoint if it is enabled
   1052              if (bRequest == USB_CLEAR_FEATURE) {
   \   0000001C   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   0000001E   3F0E               LSRS     R7,R7,#+24
   \   00000020   012F               CMP      R7,#+1
   \   00000022   29D1               BNE      ??UDP_Halt_0
   1053          
   1054                                                                                          TRACE_DEBUG_L("Unhalt%d ", bEndpoint);
   1055          
   1056                  // Return endpoint to Idle state
   1057                  pEndpoint->dState = endpointStateIdle;
   \   00000024   0120               MOVS     R0,#+1
   \   00000026   6062               STR      R0,[R4, #+36]
   \   00000028   10E0               B        ??UDP_Halt_1
   1058          
   1059                  // Clear FORCESTALL flag
   1060                  UDP_CLEAREPFLAGS(pUsb, bEndpoint, AT91C_UDP_FORCESTALL);
   \                     ??UDP_Halt_2:
   \   0000002A   0098               LDR      R0,[SP, #+0]
   \   0000002C   ........           BL       UDP_GetDriverInterface
   \   00000030   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000032   2D0E               LSRS     R5,R5,#+24
   \   00000034   0421               MOVS     R1,#+4
   \   00000036   6943               MULS     R1,R5,R1
   \   00000038   4118               ADDS     R1,R0,R1
   \   0000003A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000003C   2D0E               LSRS     R5,R5,#+24
   \   0000003E   0422               MOVS     R2,#+4
   \   00000040   6A43               MULS     R2,R5,R2
   \   00000042   8018               ADDS     R0,R0,R2
   \   00000044   006B               LDR      R0,[R0, #+48]
   \   00000046   2022               MOVS     R2,#+32
   \   00000048   9043               BICS     R0,R0,R2
   \   0000004A   0863               STR      R0,[R1, #+48]
   \                     ??UDP_Halt_1:
   \   0000004C   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000004E   2D0E               LSRS     R5,R5,#+24
   \   00000050   0427               MOVS     R7,#+4
   \   00000052   6F43               MULS     R7,R5,R7
   \   00000054   0098               LDR      R0,[SP, #+0]
   \   00000056   ........           BL       UDP_GetDriverInterface
   \   0000005A   C019               ADDS     R0,R0,R7
   \   0000005C   006B               LDR      R0,[R0, #+48]
   \   0000005E   8006               LSLS     R0,R0,#+26
   \   00000060   E3D4               BMI      ??UDP_Halt_2
   1061          
   1062                  // Reset Endpoint Fifos, beware this is a 2 steps operation
   1063                  SET(pInterface->UDP_RSTEP, 1 << bEndpoint);
   \   00000062   B06A               LDR      R0,[R6, #+40]
   \   00000064   0121               MOVS     R1,#+1
   \   00000066   A940               LSLS     R1,R1,R5
   \   00000068   0143               ORRS     R1,R1,R0
   \   0000006A   B162               STR      R1,[R6, #+40]
   1064                  CLEAR(pInterface->UDP_RSTEP, 1 << bEndpoint);
   \   0000006C   B06A               LDR      R0,[R6, #+40]
   \   0000006E   0121               MOVS     R1,#+1
   \   00000070   A940               LSLS     R1,R1,R5
   \   00000072   8843               BICS     R0,R0,R1
   \   00000074   B062               STR      R0,[R6, #+40]
   \   00000076   38E0               B        ??UDP_Halt_3
   1065              }
   1066              // Set the Halt feature on the endpoint if it is not already enabled
   1067              // and the endpoint is not disabled
   1068              else if ((bRequest == USB_SET_FEATURE)
   1069                       && (pEndpoint->dState != endpointStateHalted)
   1070                       && (pEndpoint->dState != endpointStateDisabled)) {
   \                     ??UDP_Halt_0:
   \   00000078   3F06               LSLS     R7,R7,#+24       ;; ZeroExtS R7,R7,#+24,#+24
   \   0000007A   3F0E               LSRS     R7,R7,#+24
   \   0000007C   032F               CMP      R7,#+3
   \   0000007E   34D1               BNE      ??UDP_Halt_3
   \   00000080   606A               LDR      R0,[R4, #+36]
   \   00000082   0428               CMP      R0,#+4
   \   00000084   31D0               BEQ      ??UDP_Halt_3
   \   00000086   606A               LDR      R0,[R4, #+36]
   \   00000088   0028               CMP      R0,#+0
   \   0000008A   2ED0               BEQ      ??UDP_Halt_3
   1071          
   1072                                                                                          TRACE_DEBUG_L("Halt%d ", bEndpoint);
   1073          
   1074                  // Abort the current transfer if necessary
   1075                  UDP_EndOfTransfer(pEndpoint, USB_STATUS_ABORTED);
   \   0000008C   0221               MOVS     R1,#+2
   \   0000008E   2000               MOVS     R0,R4
   \   00000090   ........           BL       UDP_EndOfTransfer
   \   00000094   17E0               B        ??UDP_Halt_4
   1076          
   1077                  // Put endpoint into Halt state
   1078                  UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_FORCESTALL);
   \                     ??UDP_Halt_5:
   \   00000096   0098               LDR      R0,[SP, #+0]
   \   00000098   ........           BL       UDP_GetDriverInterface
   \   0000009C   0700               MOVS     R7,R0
   \   0000009E   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000A0   2D0E               LSRS     R5,R5,#+24
   \   000000A2   0421               MOVS     R1,#+4
   \   000000A4   6943               MULS     R1,R5,R1
   \   000000A6   02B5               PUSH     {R1,LR}
   \   000000A8   0298               LDR      R0,[SP, #+8]
   \   000000AA   ........           BL       UDP_GetDriverInterface
   \   000000AE   0099               LDR      R1,[SP, #0]
   \   000000B0   02B0               ADD      SP,SP,#+8
   \   000000B2   4018               ADDS     R0,R0,R1
   \   000000B4   006B               LDR      R0,[R0, #+48]
   \   000000B6   2021               MOVS     R1,#+32
   \   000000B8   0143               ORRS     R1,R1,R0
   \   000000BA   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000BC   2D0E               LSRS     R5,R5,#+24
   \   000000BE   0420               MOVS     R0,#+4
   \   000000C0   6843               MULS     R0,R5,R0
   \   000000C2   3818               ADDS     R0,R7,R0
   \   000000C4   0163               STR      R1,[R0, #+48]
   \                     ??UDP_Halt_4:
   \   000000C6   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   000000C8   2D0E               LSRS     R5,R5,#+24
   \   000000CA   0427               MOVS     R7,#+4
   \   000000CC   6F43               MULS     R7,R5,R7
   \   000000CE   0098               LDR      R0,[SP, #+0]
   \   000000D0   ........           BL       UDP_GetDriverInterface
   \   000000D4   C019               ADDS     R0,R0,R7
   \   000000D6   006B               LDR      R0,[R0, #+48]
   \   000000D8   8006               LSLS     R0,R0,#+26
   \   000000DA   DCD5               BPL      ??UDP_Halt_5
   1079                  pEndpoint->dState = endpointStateHalted;
   \   000000DC   0420               MOVS     R0,#+4
   \   000000DE   6062               STR      R0,[R4, #+36]
   1080          
   1081                  // Enable the endpoint interrupt
   1082                  SET(pInterface->UDP_IER, 1 << bEndpoint);
   \   000000E0   3069               LDR      R0,[R6, #+16]
   \   000000E2   0121               MOVS     R1,#+1
   \   000000E4   A940               LSLS     R1,R1,R5
   \   000000E6   0143               ORRS     R1,R1,R0
   \   000000E8   3161               STR      R1,[R6, #+16]
   1083              }
   1084          
   1085              // Return the endpoint halt status
   1086              if (pEndpoint->dState == endpointStateHalted) {
   \                     ??UDP_Halt_3:
   \   000000EA   606A               LDR      R0,[R4, #+36]
   \   000000EC   0428               CMP      R0,#+4
   \   000000EE   01D1               BNE      ??UDP_Halt_6
   1087          
   1088                  return true;
   \   000000F0   0120               MOVS     R0,#+1
   \   000000F2   00E0               B        ??UDP_Halt_7
   1089              }
   1090              else {
   1091          
   1092                  return false;
   \                     ??UDP_Halt_6:
   \   000000F4   0020               MOVS     R0,#+0
   \                     ??UDP_Halt_7:
   \   000000F6   01B0               ADD      SP,SP,#+4
   \   000000F8   F0BC               POP      {R4-R7}
   \   000000FA   02BC               POP      {R1}
   \   000000FC   0847               BX       R1               ;; return
   1093              }
   1094          }
   1095          
   1096          //------------------------------------------------------------------------------
   1097          // \brief  Causes the endpoint to acknowledge the next received packet with
   1098          //         a STALL handshake.
   1099          //
   1100          //         Further packets are then handled normally.
   1101          // \param  pUsb      Pointer to a S_usb instance
   1102          // \param  bEndpoint Index of endpoint
   1103          // \return Operation result code
   1104          // \see    S_usb
   1105          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1106          char UDP_Stall(const S_usb *pUsb,
   1107                         unsigned char bEndpoint)
   1108          {
   \                     UDP_Stall:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   1109              S_usb_endpoint *pEndpoint = USB_GetEndpoint(pUsb, bEndpoint);
   \   00000006   2900               MOVS     R1,R5
   \   00000008   0906               LSLS     R1,R1,#+24       ;; ZeroExtS R1,R1,#+24,#+24
   \   0000000A   090E               LSRS     R1,R1,#+24
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       USB_GetEndpoint
   1110          
   1111              // Check that endpoint is in Idle state
   1112              if (pEndpoint->dState != endpointStateIdle) {
   \   00000012   406A               LDR      R0,[R0, #+36]
   \   00000014   0128               CMP      R0,#+1
   \   00000016   16D0               BEQ      ??UDP_Stall_0
   1113          
   1114                  TRACE_WARNING("W: UDP_Stall: Endpoint%d locked\n\r", bEndpoint);
   1115                  return USB_STATUS_LOCKED;
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   20E0               B        ??UDP_Stall_1
   1116              }
   1117          
   1118                                                                                          TRACE_DEBUG_L("Stall%d ", bEndpoint);
   1119          
   1120              UDP_SETEPFLAGS(pUsb, bEndpoint, AT91C_UDP_FORCESTALL);
   \                     ??UDP_Stall_2:
   \   0000001C   2000               MOVS     R0,R4
   \   0000001E   ........           BL       UDP_GetDriverInterface
   \   00000022   0600               MOVS     R6,R0
   \   00000024   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000026   2D0E               LSRS     R5,R5,#+24
   \   00000028   0427               MOVS     R7,#+4
   \   0000002A   6F43               MULS     R7,R5,R7
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   ........           BL       UDP_GetDriverInterface
   \   00000032   C019               ADDS     R0,R0,R7
   \   00000034   006B               LDR      R0,[R0, #+48]
   \   00000036   2021               MOVS     R1,#+32
   \   00000038   0143               ORRS     R1,R1,R0
   \   0000003A   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   0000003C   2D0E               LSRS     R5,R5,#+24
   \   0000003E   0420               MOVS     R0,#+4
   \   00000040   6843               MULS     R0,R5,R0
   \   00000042   3018               ADDS     R0,R6,R0
   \   00000044   0163               STR      R1,[R0, #+48]
   \                     ??UDP_Stall_0:
   \   00000046   2D06               LSLS     R5,R5,#+24       ;; ZeroExtS R5,R5,#+24,#+24
   \   00000048   2D0E               LSRS     R5,R5,#+24
   \   0000004A   0426               MOVS     R6,#+4
   \   0000004C   6E43               MULS     R6,R5,R6
   \   0000004E   2000               MOVS     R0,R4
   \   00000050   ........           BL       UDP_GetDriverInterface
   \   00000054   8019               ADDS     R0,R0,R6
   \   00000056   006B               LDR      R0,[R0, #+48]
   \   00000058   8006               LSLS     R0,R0,#+26
   \   0000005A   DFD5               BPL      ??UDP_Stall_2
   1121          
   1122              return USB_STATUS_SUCCESS;
   \   0000005C   0020               MOVS     R0,#+0
   \                     ??UDP_Stall_1:
   \   0000005E   01B0               ADD      SP,SP,#+4
   \   00000060   F0BC               POP      {R4-R7}
   \   00000062   02BC               POP      {R1}
   \   00000064   0847               BX       R1               ;; return
   1123          }
   1124          
   1125          //------------------------------------------------------------------------------
   1126          // \brief  Activates a remote wakeup procedure
   1127          // \param  pUsb Pointer to a S_usb instance
   1128          // \see    S_usb
   1129          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1130          void UDP_RemoteWakeUp(const S_usb *pUsb)
   1131          {
   \                     UDP_RemoteWakeUp:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0500               MOVS     R5,R0
   1132              AT91PS_UDP pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   2800               MOVS     R0,R5
   \   00000006   ........           BL       UDP_GetDriverInterface
   \   0000000A   0400               MOVS     R4,R0
   1133          
   1134              UDP_EnableMCK(pUsb);
   \   0000000C   2800               MOVS     R0,R5
   \   0000000E   ........           BL       UDP_EnableMCK
   1135              UDP_EnableUDPCK(pUsb);
   \   00000012   2800               MOVS     R0,R5
   \   00000014   ........           BL       UDP_EnableUDPCK
   1136              UDP_EnableTransceiver(pUsb);
   \   00000018   2800               MOVS     R0,R5
   \   0000001A   ........           BL       UDP_EnableTransceiver
   1137          
   1138                                                                                          TRACE_DEBUG_L("Remote WakeUp ");
   1139          
   1140              // Activates a remote wakeup (edge on ESR)
   1141              SET(pInterface->UDP_GLBSTATE, AT91C_UDP_ESR);
   \   0000001E   6068               LDR      R0,[R4, #+4]
   \   00000020   0421               MOVS     R1,#+4
   \   00000022   0143               ORRS     R1,R1,R0
   \   00000024   6160               STR      R1,[R4, #+4]
   1142              // Then clear ESR
   1143              CLEAR(pInterface->UDP_GLBSTATE, AT91C_UDP_ESR);
   \   00000026   6068               LDR      R0,[R4, #+4]
   \   00000028   0421               MOVS     R1,#+4
   \   0000002A   8843               BICS     R0,R0,R1
   \   0000002C   6060               STR      R0,[R4, #+4]
   1144          }
   \   0000002E   01B0               ADD      SP,SP,#+4
   \   00000030   30BC               POP      {R4,R5}
   \   00000032   01BC               POP      {R0}
   \   00000034   0047               BX       R0               ;; return
   1145          
   1146          //------------------------------------------------------------------------------
   1147          // \brief  Handles attachment or detachment from the USB when the VBus power
   1148          //         line status changes.
   1149          // \param  pUsb Pointer to a S_usb instance
   1150          // \return true if VBus is present, false otherwise
   1151          // \see    S_usb
   1152          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1153          bool UDP_Attach(const S_usb *pUsb)
   1154          {
   \                     UDP_Attach:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1155              AT91PS_UDP pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       UDP_GetDriverInterface
   \   0000000A   0500               MOVS     R5,R0
   1156          
   1157                                                                                          TRACE_DEBUG_L("Attach(");
   1158          
   1159              // Check if VBus is present
   1160              if (!ISSET(USB_GetState(pUsb), USB_STATE_POWERED)
   1161                  && BRD_IsVBusConnected(pInterface)) {
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       USB_GetState
   \   00000012   8007               LSLS     R0,R0,#+30
   \   00000014   2BD4               BMI      ??UDP_Attach_0
   \   00000016   2800               MOVS     R0,R5
   \   00000018   ........           BL       BRD_IsVBusConnected
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   26D0               BEQ      ??UDP_Attach_0
   1162          
   1163                  // Powered state:
   1164                  //      MCK + UDPCK must be on
   1165                  //      Pull-Up must be connected
   1166                  //      Transceiver must be disabled
   1167          
   1168                  // Invoke the Resume callback
   1169                  USB_ResumeCallback(pUsb);
   \   00000020   2000               MOVS     R0,R4
   \   00000022   ........           BL       USB_ResumeCallback
   1170          
   1171                  UDP_EnableMCK(pUsb);
   \   00000026   2000               MOVS     R0,R4
   \   00000028   ........           BL       UDP_EnableMCK
   1172                  UDP_EnableUDPCK(pUsb);
   \   0000002C   2000               MOVS     R0,R4
   \   0000002E   ........           BL       UDP_EnableUDPCK
   1173          
   1174                  // Reconnect the pull-up if needed
   1175                  if (ISSET(*(pUsb->pState), UDP_STATE_SHOULD_RECONNECT)) {
   \   00000032   6069               LDR      R0,[R4, #+20]
   \   00000034   0068               LDR      R0,[R0, #+0]
   \   00000036   C000               LSLS     R0,R0,#+3
   \   00000038   08D5               BPL      ??UDP_Attach_1
   1176          
   1177                      USB_Connect(pUsb);
   \   0000003A   2000               MOVS     R0,R4
   \   0000003C   ........           BL       USB_Connect
   1178                      CLEAR(*(pUsb->pState), UDP_STATE_SHOULD_RECONNECT);
   \   00000040   6069               LDR      R0,[R4, #+20]
   \   00000042   6169               LDR      R1,[R4, #+20]
   \   00000044   0968               LDR      R1,[R1, #+0]
   \   00000046   2C4A               LDR      R2,??UDP_Attach_2  ;; 0xefffffff
   \   00000048   0A40               ANDS     R2,R2,R1
   \   0000004A   0260               STR      R2,[R0, #+0]
   1179                  }
   1180          
   1181                  // Clear the Suspend and Resume interrupts
   1182                  SET(pInterface->UDP_ICR,
   1183                      AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM | AT91C_UDP_RXSUSP);
   \                     ??UDP_Attach_1:
   \   0000004C   286A               LDR      R0,[R5, #+32]
   \   0000004E   8C21               MOVS     R1,#+140
   \   00000050   8901               LSLS     R1,R1,#+6        ;; #+8960
   \   00000052   0143               ORRS     R1,R1,R0
   \   00000054   2962               STR      R1,[R5, #+32]
   1184          
   1185                  SET(pInterface->UDP_IER, AT91C_UDP_RXSUSP);
   \   00000056   2869               LDR      R0,[R5, #+16]
   \   00000058   8021               MOVS     R1,#+128
   \   0000005A   4900               LSLS     R1,R1,#+1        ;; #+256
   \   0000005C   0143               ORRS     R1,R1,R0
   \   0000005E   2961               STR      R1,[R5, #+16]
   1186          
   1187                  // The device is in Powered state
   1188                  SET(*(pUsb->pState), USB_STATE_POWERED);
   \   00000060   6069               LDR      R0,[R4, #+20]
   \   00000062   6169               LDR      R1,[R4, #+20]
   \   00000064   0968               LDR      R1,[R1, #+0]
   \   00000066   0222               MOVS     R2,#+2
   \   00000068   0A43               ORRS     R2,R2,R1
   \   0000006A   0260               STR      R2,[R0, #+0]
   \   0000006C   35E0               B        ??UDP_Attach_3
   1189          
   1190              }
   1191              else if (ISSET(USB_GetState(pUsb), USB_STATE_POWERED)
   1192                       && !BRD_IsVBusConnected(pInterface)) {
   \                     ??UDP_Attach_0:
   \   0000006E   2000               MOVS     R0,R4
   \   00000070   ........           BL       USB_GetState
   \   00000074   8007               LSLS     R0,R0,#+30
   \   00000076   30D5               BPL      ??UDP_Attach_3
   \   00000078   2800               MOVS     R0,R5
   \   0000007A   ........           BL       BRD_IsVBusConnected
   \   0000007E   0028               CMP      R0,#+0
   \   00000080   2BD1               BNE      ??UDP_Attach_3
   1193          
   1194                  // Attached state:
   1195                  //      MCK + UDPCK off
   1196                  //      Pull-Up must be disconnected
   1197                  //      Transceiver must be disabled
   1198          
   1199                  // Warning: MCK must be enabled to be able to write in UDP registers
   1200                  // It may have been disabled by the Suspend interrupt, so re-enable it
   1201                  UDP_EnableMCK(pUsb);
   \   00000082   2000               MOVS     R0,R4
   \   00000084   ........           BL       UDP_EnableMCK
   1202          
   1203                  // Disable interrupts
   1204                  SET(pInterface->UDP_IDR, AT91C_UDP_WAKEUP | AT91C_UDP_RXRSM
   1205                                         | AT91C_UDP_RXSUSP | AT91C_UDP_SOFINT);
   \   00000088   6869               LDR      R0,[R5, #+20]
   \   0000008A   AC21               MOVS     R1,#+172
   \   0000008C   8901               LSLS     R1,R1,#+6        ;; #+11008
   \   0000008E   0143               ORRS     R1,R1,R0
   \   00000090   6961               STR      R1,[R5, #+20]
   1206          
   1207                  UDP_DisableEndpoints(pUsb);
   \   00000092   2000               MOVS     R0,R4
   \   00000094   ........           BL       UDP_DisableEndpoints
   1208                  UDP_DisableTransceiver(pUsb);
   \   00000098   2000               MOVS     R0,R4
   \   0000009A   ........           BL       UDP_DisableTransceiver
   1209          
   1210                  // Disconnect the pull-up if needed
   1211                  if (ISSET(USB_GetState(pUsb), USB_STATE_DEFAULT)) {
   \   0000009E   2000               MOVS     R0,R4
   \   000000A0   ........           BL       USB_GetState
   \   000000A4   4007               LSLS     R0,R0,#+29
   \   000000A6   09D5               BPL      ??UDP_Attach_4
   1212          
   1213                      USB_Disconnect(pUsb);
   \   000000A8   2000               MOVS     R0,R4
   \   000000AA   ........           BL       USB_Disconnect
   1214                      SET(*(pUsb->pState), UDP_STATE_SHOULD_RECONNECT);
   \   000000AE   6069               LDR      R0,[R4, #+20]
   \   000000B0   6169               LDR      R1,[R4, #+20]
   \   000000B2   0968               LDR      R1,[R1, #+0]
   \   000000B4   8022               MOVS     R2,#+128
   \   000000B6   5205               LSLS     R2,R2,#+21       ;; #+268435456
   \   000000B8   0A43               ORRS     R2,R2,R1
   \   000000BA   0260               STR      R2,[R0, #+0]
   1215                  }
   1216          
   1217                  UDP_DisableMCK(pUsb);
   \                     ??UDP_Attach_4:
   \   000000BC   2000               MOVS     R0,R4
   \   000000BE   ........           BL       UDP_DisableMCK
   1218                  UDP_DisableUDPCK(pUsb);
   \   000000C2   2000               MOVS     R0,R4
   \   000000C4   ........           BL       UDP_DisableUDPCK
   1219          
   1220                  // The device leaves the all states except Attached
   1221                  CLEAR(*(pUsb->pState), USB_STATE_POWERED | USB_STATE_DEFAULT
   1222                        | USB_STATE_ADDRESS | USB_STATE_CONFIGURED | USB_STATE_SUSPENDED);
   \   000000C8   6069               LDR      R0,[R4, #+20]
   \   000000CA   6169               LDR      R1,[R4, #+20]
   \   000000CC   0968               LDR      R1,[R1, #+0]
   \   000000CE   3E22               MOVS     R2,#+62
   \   000000D0   9143               BICS     R1,R1,R2
   \   000000D2   0160               STR      R1,[R0, #+0]
   1223          
   1224                  // Invoke the Suspend callback
   1225                  USB_SuspendCallback(pUsb);
   \   000000D4   2000               MOVS     R0,R4
   \   000000D6   ........           BL       USB_SuspendCallback
   1226              }
   1227          
   1228                                                                                          TRACE_DEBUG_L("%d) ", ISSET(USB_GetState(pUsb), USB_STATE_POWERED));
   1229          
   1230              return (bool)(ISSET(USB_GetState(pUsb), USB_STATE_POWERED));
   \                     ??UDP_Attach_3:
   \   000000DA   2000               MOVS     R0,R4
   \   000000DC   ........           BL       USB_GetState
   \   000000E0   0221               MOVS     R1,#+2
   \   000000E2   0140               ANDS     R1,R1,R0
   \   000000E4   481E               SUBS     R0,R1,#+1
   \   000000E6   8041               SBCS     R0,R0,R0
   \   000000E8   C043               MVNS     R0,R0
   \   000000EA   C00F               LSRS     R0,R0,#+31
   \   000000EC   0006               LSLS     R0,R0,#+24       ;; ZeroExtS R0,R0,#+24,#+24
   \   000000EE   000E               LSRS     R0,R0,#+24
   \   000000F0   01B0               ADD      SP,SP,#+4
   \   000000F2   30BC               POP      {R4,R5}
   \   000000F4   02BC               POP      {R1}
   \   000000F6   0847               BX       R1               ;; return
   \                     ??UDP_Attach_2:
   \   000000F8   FFFFFFEF           DC32     0xefffffff
   1231          }
   1232          
   1233          //------------------------------------------------------------------------------
   1234          // \brief  Sets or unsets the device address
   1235          //
   1236          //         This function directly accesses the S_usb_request instance located
   1237          //         in the S_usb structure to extract its new address.
   1238          // \param  pUsb Pointer to a S_usb instance
   1239          // \see    S_usb
   1240          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1241          void UDP_SetAddress(S_usb const *pUsb)
   1242          {
   \                     UDP_SetAddress:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1243              unsigned short wAddress = USB_GetSetup(pUsb)->wValue;
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       USB_GetSetup
   \   0000000A   4588               LDRH     R5,[R0, #+2]
   1244              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       UDP_GetDriverInterface
   1245          
   1246                                                                                          TRACE_DEBUG_L("SetAddr(%d) ", wAddress);
   1247          
   1248              // Set address
   1249              SET(pInterface->UDP_FADDR, AT91C_UDP_FEN | wAddress);
   \   00000012   8168               LDR      R1,[R0, #+8]
   \   00000014   2D04               LSLS     R5,R5,#+16       ;; ZeroExtS R5,R5,#+16,#+16
   \   00000016   2D0C               LSRS     R5,R5,#+16
   \   00000018   8022               MOVS     R2,#+128
   \   0000001A   5200               LSLS     R2,R2,#+1        ;; #+256
   \   0000001C   2A43               ORRS     R2,R2,R5
   \   0000001E   0A43               ORRS     R2,R2,R1
   \   00000020   8260               STR      R2,[R0, #+8]
   1250          
   1251              if (wAddress == 0) {
   \   00000022   2D04               LSLS     R5,R5,#+16       ;; ZeroExtS R5,R5,#+16,#+16
   \   00000024   2D0C               LSRS     R5,R5,#+16
   \   00000026   002D               CMP      R5,#+0
   \   00000028   08D1               BNE      ??UDP_SetAddress_0
   1252          
   1253                  SET(pInterface->UDP_GLBSTATE, 0);
   \   0000002A   4168               LDR      R1,[R0, #+4]
   \   0000002C   4160               STR      R1,[R0, #+4]
   1254          
   1255                  // Device enters the Default state
   1256                  CLEAR(*(pUsb->pState), USB_STATE_ADDRESS);
   \   0000002E   6069               LDR      R0,[R4, #+20]
   \   00000030   6169               LDR      R1,[R4, #+20]
   \   00000032   0968               LDR      R1,[R1, #+0]
   \   00000034   0822               MOVS     R2,#+8
   \   00000036   9143               BICS     R1,R1,R2
   \   00000038   0160               STR      R1,[R0, #+0]
   \   0000003A   09E0               B        ??UDP_SetAddress_1
   1257              }
   1258              else {
   1259          
   1260                  SET(pInterface->UDP_GLBSTATE, AT91C_UDP_FADDEN);
   \                     ??UDP_SetAddress_0:
   \   0000003C   4168               LDR      R1,[R0, #+4]
   \   0000003E   0122               MOVS     R2,#+1
   \   00000040   0A43               ORRS     R2,R2,R1
   \   00000042   4260               STR      R2,[R0, #+4]
   1261          
   1262                  // The device enters the Address state
   1263                  SET(*(pUsb->pState), USB_STATE_ADDRESS);
   \   00000044   6069               LDR      R0,[R4, #+20]
   \   00000046   6169               LDR      R1,[R4, #+20]
   \   00000048   0968               LDR      R1,[R1, #+0]
   \   0000004A   0822               MOVS     R2,#+8
   \   0000004C   0A43               ORRS     R2,R2,R1
   \   0000004E   0260               STR      R2,[R0, #+0]
   1264              }
   1265          }
   \                     ??UDP_SetAddress_1:
   \   00000050   01B0               ADD      SP,SP,#+4
   \   00000052   30BC               POP      {R4,R5}
   \   00000054   01BC               POP      {R0}
   \   00000056   0047               BX       R0               ;; return
   1266          
   1267          //------------------------------------------------------------------------------
   1268          // \brief  Changes the device state from Address to Configured, or from
   1269          //         Configured to Address.
   1270          //
   1271          //         This method directly access the last received SETUP packet to
   1272          //         decide on what to do.
   1273          // \see    S_usb
   1274          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1275          void UDP_SetConfiguration(S_usb const *pUsb)
   1276          {
   \                     UDP_SetConfiguration:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1277              unsigned short wValue = USB_GetSetup(pUsb)->wValue;
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       USB_GetSetup
   \   0000000A   4588               LDRH     R5,[R0, #+2]
   1278              AT91PS_UDP     pInterface = UDP_GetDriverInterface(pUsb);
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       UDP_GetDriverInterface
   1279          
   1280                                                                                          TRACE_DEBUG_L("SetCfg() ");
   1281          
   1282              // Check the request
   1283              if (wValue != 0) {
   \   00000012   2D04               LSLS     R5,R5,#+16       ;; ZeroExtS R5,R5,#+16,#+16
   \   00000014   2D0C               LSRS     R5,R5,#+16
   \   00000016   002D               CMP      R5,#+0
   \   00000018   0AD0               BEQ      ??UDP_SetConfiguration_0
   1284          
   1285                  // Enter Configured state
   1286                  SET(*(pUsb->pState), USB_STATE_CONFIGURED);
   \   0000001A   6169               LDR      R1,[R4, #+20]
   \   0000001C   6269               LDR      R2,[R4, #+20]
   \   0000001E   1268               LDR      R2,[R2, #+0]
   \   00000020   1023               MOVS     R3,#+16
   \   00000022   1343               ORRS     R3,R3,R2
   \   00000024   0B60               STR      R3,[R1, #+0]
   1287                  SET(pInterface->UDP_GLBSTATE, AT91C_UDP_CONFG);
   \   00000026   4168               LDR      R1,[R0, #+4]
   \   00000028   0222               MOVS     R2,#+2
   \   0000002A   0A43               ORRS     R2,R2,R1
   \   0000002C   4260               STR      R2,[R0, #+4]
   \   0000002E   0CE0               B        ??UDP_SetConfiguration_1
   1288              }
   1289              else {
   1290          
   1291                  // Go back to Address state
   1292                  CLEAR(*(pUsb->pState), USB_STATE_CONFIGURED);
   \                     ??UDP_SetConfiguration_0:
   \   00000030   6169               LDR      R1,[R4, #+20]
   \   00000032   6269               LDR      R2,[R4, #+20]
   \   00000034   1268               LDR      R2,[R2, #+0]
   \   00000036   1023               MOVS     R3,#+16
   \   00000038   9A43               BICS     R2,R2,R3
   \   0000003A   0A60               STR      R2,[R1, #+0]
   1293                  SET(pInterface->UDP_GLBSTATE, AT91C_UDP_FADDEN);
   \   0000003C   4168               LDR      R1,[R0, #+4]
   \   0000003E   0122               MOVS     R2,#+1
   \   00000040   0A43               ORRS     R2,R2,R1
   \   00000042   4260               STR      R2,[R0, #+4]
   1294          
   1295                  // Abort all transfers
   1296                  UDP_DisableEndpoints(pUsb);
   \   00000044   2000               MOVS     R0,R4
   \   00000046   ........           BL       UDP_DisableEndpoints
   1297              }
   1298          }
   \                     ??UDP_SetConfiguration_1:
   \   0000004A   01B0               ADD      SP,SP,#+4
   \   0000004C   30BC               POP      {R4,R5}
   \   0000004E   01BC               POP      {R0}
   \   00000050   0047               BX       R0               ;; return
   1299          
   1300          //------------------------------------------------------------------------------
   1301          // \brief  Enables the pull-up on the D+ line to connect the device to the USB.
   1302          // \param  pUsb Pointer to a S_usb instance
   1303          // \see    S_usb
   1304          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1305          void UDP_Connect(const S_usb *pUsb)
   1306          {
   \                     UDP_Connect:
   \   00000000   01B5               PUSH     {R0,LR}
   1307          #if defined(UDP_INTERNAL_PULLUP)
   1308              SET(UDP_GetDriverInterface(pUsb)->UDP_TXVC, AT91C_UDP_PUON);
   1309          
   1310          #elif defined(UDP_INTERNAL_PULLUP_BY_MATRIX)
   1311                                                                                          TRACE_DEBUG_L("PUON 1\n\r");
   1312              AT91C_BASE_MATRIX->MATRIX_USBPCR |= AT91C_MATRIX_USBPCR_PUON;
   1313          
   1314          #else
   1315              BRD_ConnectPullUp(UDP_GetDriverInterface(pUsb));
   \   00000002   ........           BL       UDP_GetDriverInterface
   \   00000006   ........           BL       BRD_ConnectPullUp
   1316          
   1317          #endif
   1318          }
   \   0000000A   01B0               ADD      SP,SP,#+4
   \   0000000C   01BC               POP      {R0}
   \   0000000E   0047               BX       R0               ;; return
   1319          
   1320          //------------------------------------------------------------------------------
   1321          // \brief  Disables the pull-up on the D+ line to disconnect the device from
   1322          //         the bus.
   1323          // \param  pUsb Pointer to a S_usb instance
   1324          // \see    S_usb
   1325          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1326          void UDP_Disconnect(const S_usb *pUsb)
   1327          {
   \                     UDP_Disconnect:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0400               MOVS     R4,R0
   1328          #if defined(UDP_INTERNAL_PULLUP)
   1329              CLEAR(UDP_GetDriverInterface(pUsb)->UDP_TXVC, AT91C_UDP_PUON);
   1330          
   1331          #elif defined(UDP_INTERNAL_PULLUP_BY_MATRIX)
   1332                                                                                          TRACE_DEBUG_L("PUON 0\n\r");
   1333              AT91C_BASE_MATRIX->MATRIX_USBPCR &= ~AT91C_MATRIX_USBPCR_PUON;
   1334          
   1335          #else
   1336              BRD_DisconnectPullUp(UDP_GetDriverInterface(pUsb));
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       UDP_GetDriverInterface
   \   0000000A   ........           BL       BRD_DisconnectPullUp
   1337          
   1338          #endif
   1339              // Device leaves the Default state
   1340              CLEAR(*(pUsb->pState), USB_STATE_DEFAULT);
   \   0000000E   6069               LDR      R0,[R4, #+20]
   \   00000010   6169               LDR      R1,[R4, #+20]
   \   00000012   0968               LDR      R1,[R1, #+0]
   \   00000014   0422               MOVS     R2,#+4
   \   00000016   9143               BICS     R1,R1,R2
   \   00000018   0160               STR      R1,[R0, #+0]
   1341          }
   \   0000001A   10BC               POP      {R4}
   \   0000001C   01BC               POP      {R0}
   \   0000001E   0047               BX       R0               ;; return
   1342          
   1343          //------------------------------------------------------------------------------
   1344          // \brief  Initializes the specified USB driver
   1345          //
   1346          //         This function initializes the current FIFO bank of endpoints,
   1347          //         configures the pull-up and VBus lines, disconnects the pull-up and
   1348          //         then trigger the Init callback.
   1349          // \param  pUsb Pointer to a S_usb instance
   1350          // \see    S_usb
   1351          //------------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1352          void UDP_Init(const S_usb *pUsb)
   1353          {
   \                     UDP_Init:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1354              unsigned int dIndex;
   1355              AT91PS_UDP   pInterface = UDP_GetDriverInterface(pUsb);
   \   00000004   2000               MOVS     R0,R4
   \   00000006   ........           BL       UDP_GetDriverInterface
   \   0000000A   0500               MOVS     R5,R0
   1356          
   1357                                                                                          TRACE_DEBUG_L("Init()\n\r");
   1358          
   1359              // Init data banks
   1360              for (dIndex = 0; dIndex < pUsb->dNumEndpoints; dIndex++) {
   \   0000000C   0020               MOVS     R0,#+0
   \   0000000E   06E0               B        ??UDP_Init_0
   1361          
   1362                  pUsb->pEndpoints[dIndex].dFlag = AT91C_UDP_RX_DATA_BK0;
   \                     ??UDP_Init_1:
   \   00000010   2821               MOVS     R1,#+40
   \   00000012   4143               MULS     R1,R0,R1
   \   00000014   6268               LDR      R2,[R4, #+4]
   \   00000016   5118               ADDS     R1,R2,R1
   \   00000018   0222               MOVS     R2,#+2
   \   0000001A   CA61               STR      R2,[R1, #+28]
   1363              }
   \   0000001C   401C               ADDS     R0,R0,#+1
   \                     ??UDP_Init_0:
   \   0000001E   A168               LDR      R1,[R4, #+8]
   \   00000020   8842               CMP      R0,R1
   \   00000022   F5D3               BCC      ??UDP_Init_1
   1364          
   1365              // External pull-up on D+
   1366              // Configure
   1367              BRD_ConfigurePullUp(pInterface);
   \   00000024   2800               MOVS     R0,R5
   \   00000026   ........           BL       BRD_ConfigurePullUp
   1368          
   1369              // Disable
   1370              UDP_Disconnect(pUsb);
   \   0000002A   2000               MOVS     R0,R4
   \   0000002C   ........           BL       UDP_Disconnect
   1371          
   1372              // Device is in the Attached state
   1373              *(pUsb->pState) = USB_STATE_ATTACHED;
   \   00000030   6069               LDR      R0,[R4, #+20]
   \   00000032   0121               MOVS     R1,#+1
   \   00000034   0160               STR      R1,[R0, #+0]
   1374          
   1375              // Disable the UDP transceiver and interrupts
   1376              UDP_EnableMCK(pUsb);
   \   00000036   2000               MOVS     R0,R4
   \   00000038   ........           BL       UDP_EnableMCK
   1377              SET(pInterface->UDP_IDR, AT91C_UDP_RXRSM);
   \   0000003C   6869               LDR      R0,[R5, #+20]
   \   0000003E   8021               MOVS     R1,#+128
   \   00000040   8900               LSLS     R1,R1,#+2        ;; #+512
   \   00000042   0143               ORRS     R1,R1,R0
   \   00000044   6961               STR      R1,[R5, #+20]
   1378              UDP_Connect(pUsb);
   \   00000046   2000               MOVS     R0,R4
   \   00000048   ........           BL       UDP_Connect
   1379              UDP_DisableTransceiver(pUsb);
   \   0000004C   2000               MOVS     R0,R4
   \   0000004E   ........           BL       UDP_DisableTransceiver
   1380              UDP_DisableMCK(pUsb);
   \   00000052   2000               MOVS     R0,R4
   \   00000054   ........           BL       UDP_DisableMCK
   1381              UDP_Disconnect(pUsb);
   \   00000058   2000               MOVS     R0,R4
   \   0000005A   ........           BL       UDP_Disconnect
   1382          
   1383              // Configure interrupts
   1384              USB_InitCallback(pUsb);
   \   0000005E   2000               MOVS     R0,R4
   \   00000060   ........           BL       USB_InitCallback
   1385          }
   \   00000064   01B0               ADD      SP,SP,#+4
   \   00000066   30BC               POP      {R4,R5}
   \   00000068   01BC               POP      {R0}
   \   0000006A   0047               BX       R0               ;; return
   1386          
   1387          //------------------------------------------------------------------------------
   1388          //      Global variables
   1389          //------------------------------------------------------------------------------
   1390          
   1391          // \brief Low-level driver methods to use with the UDP USB controller
   1392          // \see S_driver_methods

   \                                 In section .rodata, align 4
   1393          const S_driver_methods sUDPMethods = {
   \                     sUDPMethods:
   \   00000000   ............       DC32 UDP_Init, UDP_Write, UDP_Read, UDP_Stall, UDP_Halt
   \              ............
   \              ............
   \              ....        
   \   00000014   ............       DC32 UDP_RemoteWakeUp, UDP_ConfigureEndpoint, UDP_Attach
   \              ............
   \   00000020   ............       DC32 UDP_SetAddress, UDP_SetConfiguration, UDP_Handler, UDP_Connect
   \              ............
   \              ........    
   \   00000030   ........           DC32 UDP_Disconnect
   1394          
   1395              UDP_Init,
   1396              UDP_Write,
   1397              UDP_Read,
   1398              UDP_Stall,
   1399              UDP_Halt,
   1400              UDP_RemoteWakeUp,
   1401              UDP_ConfigureEndpoint,
   1402              UDP_Attach,
   1403              UDP_SetAddress,
   1404              UDP_SetConfiguration,
   1405              UDP_Handler,
   1406              UDP_Connect,
   1407              UDP_Disconnect
   1408          };
   1409          
   1410          // \brief  Default driver when an UDP controller is present on a chip

   \                                 In section .rodata, align 4
   1411          const S_usb_driver sDefaultDriver = {
   \                     sDefaultDriver:
   \   00000000   0000FBFF0000       DC32 0FFFB0000H, 0H, 0H, 11, 128, sUDPMethods
   \              000000000000
   \              0B0000008000
   \              0000........
   1412          
   1413              AT91C_BASE_UDP,
   1414              0,
   1415              0,
   1416              AT91C_ID_UDP,
   1417              AT91C_PMC_UDP,
   1418              &sUDPMethods
   1419          };
   1420          
   1421          #endif // UDP
   1422          
   1423          

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     UDP_Attach                   16
     UDP_ClearRXFlag              24
     UDP_ConfigureEndpoint        32
     UDP_Connect                   8
     UDP_DisableEndpoints         16
     UDP_DisableMCK                8
     UDP_DisableTransceiver       16
     UDP_DisableUDPCK              8
     UDP_Disconnect                8
     UDP_EnableMCK                 8
     UDP_EnableTransceiver         8
     UDP_EnableUDPCK               8
     UDP_EndOfTransfer             8
     UDP_EndpointHandler          40
     UDP_GetDriverInterface        0
     UDP_GetPayload               24
     UDP_GetSetup                 16
     UDP_Halt                     32
     UDP_Handler                  24
     UDP_Init                     16
     UDP_Read                     32
     UDP_RemoteWakeUp             16
     UDP_ResetEndpoints           16
     UDP_SetAddress               16
     UDP_SetConfiguration         16
     UDP_Stall                    24
     UDP_Write                    40
     UDP_WritePayload             16
     USB_Connect                   8
     USB_Disconnect                8
     USB_GetDriverID               0
     USB_GetDriverPMC              0
     USB_GetEndpoint               8
     USB_GetSetup                  0
     USB_GetState                  0
     USB_InitCallback              8
     USB_NewRequestCallback        8
     USB_ResetCallback             8
     USB_ResumeCallback            8
     USB_StartOfFrameCallback      8
     USB_SuspendCallback           8
     lastSetBit                    8
     min                           0


   Section sizes:

     Function/Label           Bytes
     --------------           -----
     min                         8
     lastSetBit                 82
     USB_GetEndpoint            34
     USB_GetSetup                4
     USB_GetDriverID             6
     USB_GetDriverPMC            6
     USB_InitCallback           24
     USB_ResetCallback          24
     USB_SuspendCallback        24
     USB_ResumeCallback         24
     USB_NewRequestCallback     24
     USB_StartOfFrameCallback   16
     USB_Connect                18
     USB_Disconnect             18
     USB_GetState               10
     UDP_GetDriverInterface      6
     UDP_EnableMCK              24
     UDP_DisableMCK             24
     UDP_EnableUDPCK            28
     UDP_DisableUDPCK           28
     UDP_EnableTransceiver      24
     UDP_DisableTransceiver     36
     UDP_EndOfTransfer          52
     UDP_ClearRXFlag           114
     UDP_WritePayload           86
     UDP_GetPayload            106
     UDP_GetSetup               42
     UDP_ResetEndpoints         72
     UDP_DisableEndpoints       52
     UDP_EndpointHandler       892
     UDP_ConfigureEndpoint     284
     UDP_Handler               424
     UDP_Write                 200
     UDP_Read                   84
     UDP_Halt                  254
     UDP_Stall                 102
     UDP_RemoteWakeUp           54
     UDP_Attach                252
     UDP_SetAddress             88
     UDP_SetConfiguration       82
     UDP_Connect                16
     UDP_Disconnect             32
     UDP_Init                  108
     sUDPMethods                52
     sDefaultDriver             24
      Others                     4

 
    76 bytes in section .rodata
 3 892 bytes in section Debug.txt
 
 3 480 bytes of CODE  memory (+ 412 bytes shared)
    76 bytes of CONST memory

Errors: none
Warnings: none
