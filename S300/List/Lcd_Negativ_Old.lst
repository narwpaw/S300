###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           23/Oct/2012  20:58:15 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v0.9 -              #
#                    23.10.2012\Framework\Lcd_Negativ_Old.c                   #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v0.9 -             #
#                    23.10.2012\Framework\Lcd_Negativ_Old.c" -D AT91SAM7S256  #
#                    -D AT91SAM7SEK -D iH -D __ALARM -D S300 -lC              #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.9 -             #
#                    23.10.2012\S300\List\" --diag_suppress Pa082 -o          #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.9 -             #
#                    23.10.2012\S300\Obj\" --no_unroll --no_inline --no_tbaa  #
#                    --no_scheduling --debug --endian little --cpu ARM7TDMI   #
#                    -e --fpu None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 5.0\ARM\INC\DLib_Config_Norma #
#                    l.h" -I "D:\Zeuron\Projekty\S300\S300-program v0.9 -     #
#                    23.10.2012\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.9 -             #
#                    23.10.2012\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.9 -             #
#                    23.10.2012\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v0.9 - 23.10.2012\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v0.9 - 23.10.2012\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.9 -             #
#                    23.10.2012\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v0.9 - 23.10.2012\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.9 -             #
#                    23.10.2012\Framework\Configuration\" -I "C:\Program      #
#                    Files\IAR Systems\Embedded Workbench 5.0\ARM\INC\"       #
#                    --section .text=Debug.txt --interwork --cpu_mode thumb   #
#                    -Om                                                      #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v0.9 -              #
#                    23.10.2012\S300\List\Lcd_Negativ_Old.lst                 #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v0.9 -              #
#                    23.10.2012\S300\Obj\Lcd_Negativ_Old.o                    #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v0.9 - 23.10.2012\Framework\Lcd_Negativ_Old.c
      1          //****************************************************************************//
      2          //*--------------------------------------------------------------------------*//
      3          //*                                 CEURON                                   *//                     
      4          //*--------------------------------------------------------------------------*//
      5          //*--------------------------------------------------------------------------*//
      6          //*  Nazwa pliku                  : LCD.c                                    *//
      7          //*  Opis                         : Plik obs³ugi wyœwietlacza LCD            *//
      8          //*  Autor                        : Pawe³ Narwojsz                           *//
      9          //*  Data utrzorzenia             : 15.09.2007                               *//
     10          //*  Data ostatniej modyfikacji   : --.--.----                               *//
     11          //*--------------------------------------------------------------------------*//
     12          //*                                                                          *//
     13          //*--------------------------------------------------------------------------*//
     14          //* Rejestr zmian  (data - opis):                                            *//
     15          //*                                                                          *//
     16          //*                               Brak zmian                                 *//
     17          //*                                                                          *//
     18          //*__________________________________________________________________________*// 
     19          //****************************************************************************//
     20          //****************************************************************************//
     21          
     22          
     23          
     24          
     25          
     26          
     27          
     28          // Pliki do³¹czane -------------------------------------------------------------
     29               #include "common.h"
     30               #include "core/device.h"                                                   //aduje bibliotreki dla odpowiedniego procesora
     31               //#include "AT91SAM7S256.h"
     32               #include "core/trace.h"
     33               #include "LCD.h"
     34               #include "Framework.h "
     35               #include <stdarg.h>
     36          
     37          //-----------------------Koniec plików do³¹czanych -----------------------------
     38          
     39          #ifdef _LCD_NEGATIV_OLD_
     40          #define LCD_delay 40
     41          
     42          //Zmienne globalne -------------------------------------------------------------
     43            _Correct korekta_Y=1;
     44            _Correct korekta_X=1;
     45          //___________________________Koniec zmiennych globalnych________________________
     46          
     47          
     48          extern void Delay (unsigned long a);
     49          //extern MenuPaint(void);
     50          extern long long int g_counter;
     51          extern int MenuLevel;
     52          extern char AlarmOn; 
     53          extern char g_info;
     54          //Definicje --------------------------------------------------------------------
     55                AT91PS_PIO    m_pPio   = AT91C_BASE_PIOA;
     56                AT91PS_PIO    TS_pPio  = AT91C_BASE_PIOA;
     57                //TouchScreen
     58          
     59          #define  TS_ADC             AT91C_BASE_PDC_ADC
     60          #define  TS_ADC_CH0         AT91C_ADC_CH0
     61          #define  TS_ADC_CH1         AT91C_ADC_CH1
     62          #define  TS_ADC_CH2         AT91C_ADC_CH2
     63          #define  TS_ADC_CH3         AT91C_ADC_CH3
     64          #define  TS_PIO             AT91C_BASE_PIOA
     65          #define  TS_PIO_CH0         AT91C_PIO_PA17
     66          #define  TS_PIO_CH1         AT91C_PIO_PA18
     67          #define  TS_PIO_CH2         AT91C_PIO_PA19
     68          #define  TS_PIO_CH3         AT91C_PIO_PA20
     69          
     70          #define  TS_ADC_ID         AT91C_ID_ADC        
     71          // Leds
     72          //___________________________Koniec definicji___________________________________
     73          
     74          
     75                
     76          extern signed short X_down;
     77          extern signed short Y_down;
     78          extern signed short X_up;
     79          extern signed short Y_up;
     80          
     81          
     82          char LCD_Canvas[8][128] = {
     83                            {254,1,1,1,1,1,1,1,131,69,125,69,41,41,17,1,1,169,1,1,1,1,1,1,1,1,1,1,131,69,125,69,41,41,17,1,1,169,1,1,1,1,1,1,1,1,1,1,131,69,125,69,41,41,17,1,1,169,1,1,1,1,1,1,1,1,1,1,131,69,125,69,41,41,17,1,1,169,1,1,1,1,1,1,1,1,1,1,131,69,125,69,41,41,17,1,1,169,1,1,1,1,1,1,1,1,1,1,131,69,125,69,41,41,17,1,1,1,255,7,243,107,155,155,107,243,6,252},
     84                            {255,164,160,144,160,164,24,0,66,66,66,66,66,99,66,0,0,170,0,0,32,32,32,32,32,48,32,0,66,66,66,66,66,99,66,0,0,170,0,0,28,36,36,36,36,36,24,0,66,66,66,66,66,99,66,0,0,170,0,0,16,16,16,16,16,24,16,0,66,66,66,66,66,99,66,0,0,170,0,0,60,8,16,16,32,36,24,0,66,66,66,66,66,99,66,0,0,170,0,0,152,164,160,144,160,164,24,0,66,66,66,66,66,99,66,0,0,0,255,254,60,189,125,253,189,60,254,255},
     85                            {255,148,148,148,148,148,99,0,130,68,124,68,40,40,16,0,0,170,0,0,207,34,4,132,8,41,198,0,124,4,4,124,4,4,124,0,0,170,0,1,9,136,136,144,144,160,60,0,60,68,68,68,68,68,60,0,0,170,0,1,61,136,16,16,32,164,24,0,56,68,4,4,4,68,56,0,0,170,0,0,34,34,34,66,66,131,242,0,28,36,36,60,36,36,28,0,0,170,0,0,115,148,148,148,148,148,99,0,130,68,124,68,40,40,16,0,0,0,255,255,36,117,87,38,37,36,255,255},
     86                            {255,4,8,8,16,18,12,0,0,0,0,0,0,0,0,0,0,170,0,0,32,161,125,164,169,49,32,0,0,0,0,0,0,0,0,0,0,170,0,0,99,148,132,148,115,36,227,0,0,0,0,0,0,0,0,0,0,170,0,0,131,132,244,146,164,196,131,0,0,0,0,0,0,0,0,0,0,170,0,0,16,16,254,82,148,24,16,0,0,0,0,0,0,0,0,0,0,170,0,0,158,4,8,8,16,18,12,0,0,0,0,0,0,0,0,0,0,0,255,255,159,223,63,191,127,63,255,255},
     87                            {255,68,72,136,80,82,140,0,0,0,0,0,0,0,0,0,0,170,0,0,99,148,148,148,115,145,103,0,0,0,0,0,0,0,0,0,0,170,0,0,208,80,126,82,84,88,144,0,0,0,0,0,0,0,0,0,0,170,0,0,142,82,147,82,82,82,140,0,0,0,0,0,0,0,0,0,0,170,0,16,210,130,7,2,2,67,130,0,0,0,0,0,0,0,0,0,0,170,0,0,158,68,72,136,80,82,140,0,0,0,0,0,0,0,0,0,0,0,255,255,180,149,150,166,167,147,255,255},
     88                            {255,18,18,33,34,66,121,0,0,0,0,0,0,0,0,0,0,170,0,128,132,4,4,8,8,16,30,0,0,0,0,0,0,0,0,0,0,170,0,0,57,74,74,74,74,74,49,0,0,0,0,0,0,0,0,0,0,170,0,0,49,74,75,50,74,74,49,0,0,0,0,0,0,0,0,0,0,170,0,0,51,72,65,33,66,74,49,0,0,0,0,0,0,0,0,0,0,170,0,0,17,18,18,33,34,66,121,0,0,0,0,0,0,0,0,0,0,0,255,255,36,110,113,117,123,57,255,255},
     89                            {255,201,72,68,72,73,70,64,64,64,64,64,64,64,64,192,192,202,64,192,78,210,82,210,82,210,76,192,64,192,64,192,64,192,64,192,64,202,64,192,71,201,73,201,73,201,70,192,64,192,64,192,64,192,64,192,64,202,64,192,70,201,73,198,73,201,70,192,64,192,64,192,64,192,64,192,64,202,64,192,200,200,223,201,202,204,200,192,192,192,192,64,64,192,64,192,64,202,64,192,70,201,72,196,200,73,70,64,64,64,64,64,64,64,64,64,64,192,255,255,248,251,255,255,255,254,255,255},
     90                            {255,192,128,128,128,128,128,140,158,191,191,128,128,128,128,192,255,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,128,255,255,255,255,192,222,222,192,255,255,255,255,128,213,170,213,170,213,170,213,170,213,170,213,255,192,128,128,128,191,191,158,140,128,128,128,128,128,192,255,255,255,255,255,255,255,255,127,63}
     91                            };
     92          
     93          
     94          
     95          
     96          
     97          //===================================================================================================================================================================//
     98          //===================================================================================================================================================================//
     99          //===================================================================================================================================================================//
    100          //===================================================================================================================================================================//
    101          //============================================================      F U N K C J E      ==============================================================================//
    102          //===================================================================================================================================================================//
    103          //===================================================================================================================================================================//
    104          
    105          
    106          
    107          //*-----------------------------------------------------------------------------
    108          //* Nazwa funkcji :    RepaintLCD
    109          //* Funkcja g³ówna wyrysowywania tabeli LCD_Canvas na ekran LCD
    110          //*-----------------------------------------------------------------------------
    111          //* Konieczne zdefiniowanie zmiennej globalnej "char LCD_Canvas[8][128];"
    112          //*-----------------------------------------------------------------------------
    113          
    114          char chipSelect=1;
    115          void RepaintLCD(void)
    116          {
    117            
    118          
    119          char lcdData=0;
    120          //char lcdStartPage=0;
    121          //char chipSelect=0;
    122          char displayY=0;
    123            
    124          //  for (char chipSelect=1; chipSelect<=2; chipSelect++)
    125          //{
    126          
    127             if (chipSelect<2) {chipSelect=2;} else {chipSelect=1;}
    128               at91ChipSelect(chipSelect);   
    129          
    130               at91DisplayYAdress(displayY);
    131               Delay(50);  
    132               
    133                for (char lcdStartPage=0; lcdStartPage<8; lcdStartPage++)
    134                {
    135                   
    136                  at91DisplayStartPage(lcdStartPage); 
    137                  Delay(50);
    138                  for (lcdData=(64*chipSelect-64); lcdData<(64*chipSelect); lcdData++)
    139                  {
    140                    
    141                    at91DisplayData(LCD_Canvas[lcdStartPage][lcdData]);
    142                    Delay(50);
    143                  }
    144                }
    145           //}
    146          
    147          }//_______________________ Koniec funkcji RepaintLCD __________________________
    148          
    149          
    150          
    151          
    152          
    153          
    154          //*-----------------------------------------------------------------------------
    155          //* Nazwa funkcji :    CleanCanvas
    156          //* Funkcja czyszczenia bufora ekranu. 
    157          //*-----------------------------------------------------------------------------
    158          //* Efekt widoczny po odœwierzeniu LCD (RepaintLCD)
    159          //*-----------------------------------------------------------------------------
    160          void CleanCanvas(void)
    161          {
    162            for (int i=0; i<=7; i++)
    163            {
    164              for (int j=0; j<=127; j++)
    165              {
    166                LCD_Canvas[i][j] =0; 
    167              }
    168            }
    169          }//_______________________ Koniec funkcji CleanCanvas __________________________
    170          
    171          
    172          
    173          
    174          
    175          //*-----------------------------------------------------------------------------
    176          //* Nazwa funkcji :    HalfCleanCanvas
    177          //* Funkcja szatkowania bufora ekranu. 
    178          //*-----------------------------------------------------------------------------
    179          //* Efekt widoczny po odœwierzeniu LCD (RepaintLCD)
    180          //*-----------------------------------------------------------------------------
    181          void HalfCleanCanvas(void)
    182          {
    183            for (int i=0; i<=7; i++)
    184            {
    185              for (int j=0; j<=127; j++)
    186              {
    187                if ((j+i)%2) 
    188                {
    189                  LCD_Canvas[i][j] &=0xAA; 
    190                }
    191                else
    192                {
    193                  LCD_Canvas[i][j] &=0x55; 
    194                } 
    195              }
    196            }
    197          }//_______________________ Koniec funkcji HalfCleanCanvas __________________________
    198          
    199          
    200          
    201          //*-----------------------------------------------------------------------------
    202          //* Nazwa funkcji :    CleanCanvasArea
    203          //* Funkcja czyszczenia okreœlonego obszaru
    204          //* Colour  -  0= bia³y, 1=czarny
    205          //*-----------------------------------------------------------------------------
    206          //* Efekt widoczny po odœwierzeniu LCD (RepaintLCD)
    207          //*-----------------------------------------------------------------------------
    208          void CleanCanvasArea(char X, char Y, char X_Lenght, char Y_Lenght, char Colour)
    209          {
    210          
    211            char kol=0;
    212            char bit=0;
    213            char linia=Y;
    214            
    215          if ( Colour == 0 )
    216          {
    217            for (int i=0; i<=Y_Lenght-1; i++)
    218             { 
    219               kol=(X)/8;
    220               bit=(X)%8;
    221               
    222          
    223              
    224               for (int j=0; j<=X_Lenght-1; j++)
    225                {
    226                     LCD_Canvas[kol][linia] &=~(1<<bit);  
    227                     if (bit<7)  { bit++;}  else {bit=0;   kol++;  }
    228                }   
    229                linia++;
    230             }
    231          }
    232          else
    233          {
    234            for (int i=0; i<=Y_Lenght-1; i++)
    235             { 
    236               kol=(X)/8;
    237               bit=(X)%8;
    238               
    239               for (int j=0; j<=X_Lenght-1; j++)
    240                {
    241                     LCD_Canvas[kol][linia] |=(1<<bit);  
    242                     if (bit<7)  { bit++;}  else {bit=0;   kol++;  }
    243                }   
    244                linia++;
    245             }
    246          }
    247            
    248          }//_______________________ Koniec funkcji CleanCanvasArea __________________________
    249          
    250          
    251          
    252          
    253          //*-----------------------------------------------------------------------------
    254          //* Nazwa funkcji :    CleanCanvasArea
    255          //* Funkcja czyszczenia okreœlonego obszaru
    256          //* Colour  -  0= bia³y, 1=czarny
    257          //*-----------------------------------------------------------------------------
    258          //* Efekt widoczny po odœwierzeniu LCD (RepaintLCD)
    259          //*-----------------------------------------------------------------------------
    260          void CanvasPixel(char X, char Y, char Colour)
    261          {
    262               char kol=(X)/8;
    263               char bit=(X)%8;
    264               
    265               if ( Colour == 0 )
    266               {
    267                 LCD_Canvas[kol][Y] &=~(1<<bit); 
    268               }
    269               else
    270               {
    271                 LCD_Canvas[kol][Y] |=(1<<bit);  
    272               }
    273          }//_______________________ Koniec funkcji CleanCanvasArea __________________________
    274          
    275          
    276          
    277          
    278          
    279          
    280          //*-----------------------------------------------------------------------------
    281          //* Nazwa funkcji :    CopyToCanvas
    282          //* Funkcja kopiowania dowolnej tablicy[8][128] do bufora wyœwietlacza 
    283          //*-----------------------------------------------------------------------------
    284          //* Efekt widoczny po odœwierzeniu LCD (RepaintLCD)
    285          //*-----------------------------------------------------------------------------
    286          void CopyToCanvas(char Tabela[8][128])
    287          {
    288            for (int i=0; i<=7; i++)
    289            {
    290              for (int j=0; j<=127; j++)
    291              {
    292                LCD_Canvas[i][j] =Tabela[i][j]; 
    293              }
    294            }
    295          }//_______________________ Koniec funkcji CopyToCanvas __________________________
    296          
    297          
    298          
    299          
    300          
    301          
    302          //*-----------------------------------------------------------------------------
    303          //* Nazwa funkcji :    CopyToCanvas
    304          //* Funkcja kopiowania dowolnej tablicy[8][128] do bufora wyœwietlacza 
    305          //*-----------------------------------------------------------------------------
    306          //* Efekt widoczny po odœwierzeniu LCD (RepaintLCD)
    307          //*-----------------------------------------------------------------------------
    308          void CopyToCanvasPoint(char *Tabela, char X, char Y, char X_Lenght, char Y_Lenght)
    309          {
    310          
    311            char kol=0;
    312            char bit=0;
    313            char kol2=0;
    314            char bit2=0;
    315            char linia=Y;
    316            
    317            for (int i=0; i<=Y_Lenght-1; i++)
    318             {
    319          
    320               
    321               kol=(X)/8;
    322               bit=(X)%8;
    323               
    324               kol2=0;
    325               bit2=0;
    326                 
    327               for (int j=0; j<=X_Lenght-1; j++)
    328                {
    329                   if (((Tabela[(kol2*Y_Lenght)+(i)]>>bit2)&0x1)>0)
    330                    {
    331                       
    332                       LCD_Canvas[kol][linia] |=(1<<bit); 
    333                    }
    334                    else
    335                    {
    336                       LCD_Canvas[kol][linia] &=~(1<<bit);  
    337                    }
    338                   
    339            
    340                     if (bit<7)  { bit++;}  else {bit=0;   kol++;  }
    341                     if (bit2<7) { bit2++;} else {bit2=0;  kol2++; }           
    342                }   
    343               
    344                linia++;
    345             }
    346          
    347          }//_______________________ Koniec funkcji CopyToCanvas __________________________
    348          
    349          
    350          
    351          
    352          //*-----------------------------------------------------------------------------
    353          //* Nazwa funkcji :    at91DisplayOnOff
    354          //* Funkcja za³¹czania/wy³¹czania LCD
    355          //*-----------------------------------------------------------------------------
    356          //////////////////////////////////////////////////////
    357          // R/W  D/I  DB7  DB6  DB5  DB4  DB3  DB2  DB1  DB0 //
    358          //  RW   DI  DB7  DB6  DB5  DB4  DB3  DB2  DB1  DB0 //
    359          //   0    0    0    0    1    1    1    1    1    D //
    360          //                                                  //
    361          // on_off - "0" - OFF                               //
    362          //        - "1" - ON                                //
    363          //////////////////////////////////////////////////////
    364          //*-----------------------------------------------------------------------------
    365          
    366           void at91DisplayOnOff(char on_off)
    367           {
    368              m_pPio->PIO_SODR =  LCD_BUS_MASK;                         // zeruje piny
    369          
    370             
    371              //m_pPio->PIO_CODR = DB5 | DB4 | DB3 | DB2 | DB1 | on_off << 3;  // "1" na wyœwietlaczu
    372             if (on_off)
    373             {
    374                m_pPio->PIO_CODR = DB5 | DB4 | DB3 | DB2 | DB1 | DB0;  // "1" na wyœwietlaczu
    375             }
    376             else
    377             {
    378                m_pPio->PIO_CODR = DB5 | DB4 | DB3 | DB2 | DB1;  // "1" na wyœwietlaczu 
    379             }
    380             
    381             m_pPio->PIO_SODR = DI;
    382              m_pPio->PIO_CODR = ENABLE;
    383              Delay(2);
    384              m_pPio->PIO_SODR = ENABLE;
    385             m_pPio->PIO_SODR =  LCD_BUS_MASK;                         // "0" na wyœwietlaczu
    386          
    387          }//_______________________ Koniec funkcji at91DisplayOnOff ______________________
    388           
    389           
    390          
    391          
    392          
    393          
    394          
    395           
    396          //*-----------------------------------------------------------------------------
    397          //* Nazwa funkcji :    at91DisplayStartLine
    398          //* Funkcja ustawienia lini startowej
    399          //*-----------------------------------------------------------------------------
    400          //////////////////////////////////////////////////////
    401          // R/W  D/I  DB7  DB6  DB5  DB4  DB3  DB2  DB1  DB0 //
    402          //  RW   DI  DB7  DB6  DB5  DB4  DB3  DB2  DB1  DB0 //
    403          //   0    0    1    1    A    A    A    A    A    A //
    404          //                                                  //
    405          // AAAAAA - przesuniêcie w górê strony testowej     //
    406          //////////////////////////////////////////////////////
    407          //*-----------------------------------------------------------------------------
    408           void at91DisplayStartLine(void)
    409           {
    410             m_pPio->PIO_SODR =  LCD_BUS_MASK;                         // zeruje piny
    411          
    412             
    413              m_pPio->PIO_CODR =  DB7 | DB6 ;  // "1" na wyœwietlaczu
    414              m_pPio->PIO_SODR = DI ;
    415              m_pPio->PIO_CODR = ENABLE;
    416              Delay(2);
    417              m_pPio->PIO_SODR = ENABLE;
    418              m_pPio->PIO_SODR =  LCD_BUS_MASK;                         // "0" na wyœwietlaczu
    419          
    420          }//_____________________ Koniec funkcji at91DisplayStartLine ___________________
    421          
    422          
    423          
    424          
    425          
    426          
    427          
    428          
    429           
    430          //*-----------------------------------------------------------------------------
    431          //* Nazwa funkcji :    at91DisplayStartPage
    432          //* Funkcja ustawienia strony
    433          //*-----------------------------------------------------------------------------
    434          //////////////////////////////////////////////////////
    435          // R/W  D/I  DB7  DB6  DB5  DB4  DB3  DB2  DB1  DB0 //
    436          //  RW   DI  DB7  DB6  DB5  DB4  DB3  DB2  DB1  DB0 //
    437          //   0    0    1    0    1    1    1    A    A    A //
    438          //                                                  //
    439          // AAA - numer zapisywanej strony                   //
    440          //////////////////////////////////////////////////////
    441          //*-----------------------------------------------------------------------------
    442          
    443           void at91DisplayStartPage(char lcd_start_page)
    444           {
    445              char data=lcd_start_page; 
    446              
    447              m_pPio->PIO_SODR =  LCD_BUS_MASK;                         // zeruje piny
    448          
    449                
    450              //m_pPio->PIO_CODR = DB7 | DB5 | DB4 | DB3 | lcd_start_page << 3;  // "1" na wyœwietlaczu
    451              m_pPio->PIO_CODR = DB7 | DB5 | DB4 | DB3 | (((data>>2)&0x1)<<mDB2) | (((data>>1)&0x1)<<mDB1) | (((data>>0)&0x1)<<mDB0) ;  // "1" na wyœwietlaczu
    452              m_pPio->PIO_SODR = DI ;
    453              m_pPio->PIO_CODR = ENABLE;
    454              Delay(LCD_delay);
    455              m_pPio->PIO_SODR = ENABLE;
    456             m_pPio->PIO_SODR =  LCD_BUS_MASK;                         // "0" na wyœwietlaczu
    457          
    458          }//_____________________ Koniec funkcji at91DisplayStartPage ___________________
    459          
    460          
    461          
    462          
    463          
    464          
    465          
    466          
    467          
    468          //*-----------------------------------------------------------------------------
    469          //* Nazwa funkcji :    at91DisplayYAdress
    470          //* Funkcja okreœla wspó³rzêdne X od których ma zacz¹æ 
    471          //*         zapisywaæ, automatycznie inkrementowane    
    472          //*         po kazdej operacji zapisu/odczytu
    473          //*-----------------------------------------------------------------------------      
    474          //////////////////////////////////////////////////////
    475          // R/W  D/I  DB7  DB6  DB5  DB4  DB3  DB2  DB1  DB0 //
    476          //  RW   DI  DB7  DB6  DB5  DB4  DB3  DB2  DB1  DB0 //
    477          //   0    0    0    1    A    A    A    A    A    A //
    478          //                                                  //
    479          // AAAAAA-przesuniêcie zapisywanej kolumny w prawo  //
    480          //////////////////////////////////////////////////////
    481          //*-----------------------------------------------------------------------------
    482          
    483           void at91DisplayYAdress(char display_Y)
    484           {
    485             char data=(0x3F-display_Y); 
    486             
    487             m_pPio->PIO_SODR =  LCD_BUS_MASK;                         // zeruje piny
    488          
    489          
    490              m_pPio->PIO_CODR = DB6 | (((display_Y>>5)&0x1)<<mDB5) | (((display_Y>>4)&0x1)<<mDB4) | (((display_Y>>3)&0x1)<<mDB3) | (((display_Y>>2)&0x1)<<mDB2) | (((display_Y>>1)&0x1)<<mDB1) | (((display_Y>>0)&0x1)<<mDB0);             // "0" na wyœwietlaczu // "1" na wyœwietlaczu
    491              m_pPio->PIO_SODR = DI | (((data>>5)&0x1)<<mDB5) | (((data>>4)&0x1)<<mDB4) | (((data>>3)&0x1)<<mDB3) | (((data>>2)&0x1)<<mDB2) | (((data>>1)&0x1)<<mDB1) | (((data>>0)&0x1)<<mDB0);             // "0" na wyœwietlaczu
    492              
    493              m_pPio->PIO_CODR = ENABLE;
    494              Delay(1);
    495              m_pPio->PIO_SODR = ENABLE;
    496              m_pPio->PIO_SODR =  LCD_BUS_MASK;                       // "0" na wyœwietlaczu
    497          }//_______________________ Koniec funkcji at91DisplayYAdress ___________________
    498          
    499           
    500           
    501          
    502           
    503          
    504          
    505          
    506          //*-----------------------------------------------------------------------------
    507          //* Nazwa funkcji :    at91DisplayData
    508          //* Funkcja wpisywania danych do Ram LCD
    509          //*-----------------------------------------------------------------------------
    510          //* R/W  D/I  DB7  DB6  DB5  DB4  DB3  DB2  DB1  DB0 
    511          //*  RW   DI  DB7  DB6  DB5  DB4  DB3  DB2  DB1  DB0 
    512          //*  0    1    A    A    A    A    A    A    A    A 
    513          //*                                                  
    514          //*  AAAAAAAA - dane                                  
    515          //*-----------------------------------------------------------------------------
    516          
    517          inline void at91DisplayData(char lcd_data)
    518           {
    519          
    520             char data=(0xFF-lcd_data); 
    521             m_pPio->PIO_SODR =  LCD_BUS_MASK;                         // zeruje piny
    522             
    523                m_pPio->PIO_CODR = DI | (((lcd_data>>7)&0x1)<<mDB7) | (((lcd_data>>6)&0x1)<<mDB6) | (((lcd_data>>5)&0x1)<<mDB5) | (((lcd_data>>4)&0x1)<<mDB4) | (((lcd_data>>3)&0x1)<<mDB3) | (((lcd_data>>2)&0x1)<<mDB2) | (((lcd_data>>1)&0x1)<<mDB1) | (((lcd_data>>0)&0x1)<<mDB0); 
    524                m_pPio->PIO_SODR = (((data>>7)&0x1)<<mDB7) | (((data>>6)&0x1)<<mDB6) | (((data>>5)&0x1)<<mDB5) | (((data>>4)&0x1)<<mDB4) | (((data>>3)&0x1)<<mDB3) | (((data>>2)&0x1)<<mDB2) | (((data>>1)&0x1)<<mDB1) | (((data>>0)&0x1)<<mDB0); 
    525             
    526          
    527              
    528             m_pPio->PIO_CODR = ENABLE;
    529          
    530              Delay(18);
    531              m_pPio->PIO_SODR = ENABLE;
    532          
    533             // m_pPio->PIO_SODR =  LCD_BUS_MASK;                         // zeruje piny
    534          
    535          }//_______________________ Koniec funkcji at91DisplayData ______________________
    536          
    537          
    538           
    539           
    540           
    541          //*-----------------------------------------------------------------------------
    542          //* Nazwa funkcji :    at91ChipSelect
    543          //* Funkcja wyboru kontrolera 1z2
    544          //*-----------------------------------------------------------------------------
    545          //* chip_select - "1" - CS1                   
    546          //*             - "2" - CS2      
    547          //*-----------------------------------------------------------------------------
    548          
    549           void at91ChipSelect(char chip_select)
    550           {
    551             unsigned long cs_set;
    552             unsigned long cs_clr;
    553             
    554             m_pPio->PIO_SODR =  LCD_BUS_MASK;                         // zeruje piny
    555          
    556             
    557             if (chip_select==2) 
    558                {
    559                  cs_set=CS2;
    560                  cs_clr=CS1;
    561                }
    562           
    563             if (chip_select==1) 
    564                {
    565                  cs_set=CS1;
    566                  cs_clr=CS2;
    567                }
    568             
    569          
    570          
    571             
    572              m_pPio->PIO_SODR = cs_clr;   
    573              m_pPio->PIO_CODR = cs_set;                           // "1" na wyœwietlaczu
    574              
    575              
    576              
    577          at91DisplayOnOff(1); 
    578            
    579            
    580          
    581          }//_______________________ Koniec funkcji at91ChipSelect __________________________
    582          
    583           
    584           
    585          
    586          
    587          
    588          
    589          
    590          //*-----------------------------------------------------------------------------
    591          //* Nazwa funkcji :    ReadTP
    592          //* Funkcja obs³ugi TouchPanel`a
    593          //*-----------------------------------------------------------------------------
    594          //*  !!! Czas trwania funkcji 15us
    595          //*-----------------------------------------------------------------------------
    596          
    597          void ReadTP(_TPoint *Point)
    598          {
    599            unsigned pomX, pomY;
    600            pomX=0;
    601            pomY=0;
    602          
    603              //POMIAR X -------------------------------------------------------------------
    604            AT91F_PIO_CfgOutput(TS_PIO, TS_PIO_CH1);
    605            AT91F_PIO_CfgOutput(TS_PIO, TS_PIO_CH3);
    606           
    607            AT91F_PIO_CfgInput(TS_PIO, TS_PIO_CH0);
    608            TS_PIO->PIO_PPUDR=TS_PIO_CH0;
    609            
    610            TS_pPio->PIO_SODR = TS_PIO_CH1; 
    611            TS_pPio->PIO_CODR = TS_PIO_CH3;         
    612              
    613            pomX =  ReadADC(2);
    614            
    615          
    616            
    617            //POMIAR Y -------------------------------------------------------------------
    618            AT91F_PIO_CfgOutput(TS_PIO, TS_PIO_CH0);
    619            AT91F_PIO_CfgOutput(TS_PIO, TS_PIO_CH2);
    620            
    621            AT91F_PIO_CfgInput(TS_PIO, TS_PIO_CH3);
    622            TS_PIO->PIO_PPUDR=TS_PIO_CH3;
    623            
    624            TS_pPio->PIO_SODR = TS_PIO_CH2; 
    625            TS_pPio->PIO_CODR = TS_PIO_CH0;        
    626            
    627            
    628            pomY =  ReadADC(1);
    629          
    630            //walidacja / wykrycie dotkniêcia
    631            if ((pomY>900) || (pomY<=0) || (pomX>900) || (pomX<=0) )
    632            {
    633              pomY=0;
    634              pomX=0;
    635            }
    636          
    637            //kalibracja -----------------------------------------------------------------
    638          
    639          
    640            //przepisanie pomiarów
    641            Point->y=pomY;
    642            Point->x=pomX;
    643          }
    644          //END Touth panel ----------------------------------------------------------  
    645          
    646          
    647          
    648          
    649          
    650          
    651          //*-----------------------------------------------------------------------------
    652          //* Nazwa funkcji :    ReadADC
    653          //*-----------------------------------------------------------------------------
    654          //*-----------------------------------------------------------------------------
    655              unsigned short odp=0; 
    656          
    657          unsigned short ReadADC (char Channel) 
    658          { 
    659          
    660           
    661          
    662              //enable channel and set PIN to ADCx function (no need to write PIO!!) 
    663            AT91C_BASE_ADC->ADC_CR = AT91C_ADC_SWRST; 
    664          AT91C_BASE_ADC->ADC_MR = (15<24)|(11<<16)|(4<<8); 
    665          AT91C_BASE_ADC->ADC_CHDR =0xFF;   
    666            
    667            //AT91C_BASE_ADC->ADC_CHDR =0xFF; 
    668              AT91C_BASE_ADC->ADC_CHER = (1<< Channel);    
    669              
    670          
    671              //start first conversion 
    672              AT91C_BASE_ADC->ADC_CR = AT91C_ADC_START; 
    673           
    674              while ((AT91C_BASE_ADC->ADC_SR &(1 << Channel))==0){};
    675              //while ((AT91C_BASE_ADC->ADC_SR & AT91C_ADC_DRDY)==0){};
    676          
    677                switch (Channel){
    678                  case 0: odp=AT91C_BASE_ADC->ADC_CDR0; break; 
    679                  case 1: odp=AT91C_BASE_ADC->ADC_CDR1; break;  
    680                  case 2: odp=AT91C_BASE_ADC->ADC_CDR2; break;  
    681                  case 3: odp=AT91C_BASE_ADC->ADC_CDR3; break;  
    682                  case 4: odp=AT91C_BASE_ADC->ADC_CDR4; break;  
    683                  case 5: odp=AT91C_BASE_ADC->ADC_CDR5; break;  
    684                } 
    685                
    686                
    687           while ((AT91C_BASE_ADC->ADC_SR &(1 << Channel))==1){};
    688               
    689               // odp=AT91C_BASE_ADC->ADC_LCDR;
    690          
    691          
    692                
    693               // AT91C_BASE_ADC->ADC_CR = AT91C_ADC_SWRST; 
    694                
    695               // AT91C_BASE_ADC->ADC_CHDR = (1<< Channel);
    696              return odp;
    697          }
    698          //*-----------------------------------------------------------------------------   
    699             
    700          
    701          
    702          //*-----------------------------------------------------------------------------
    703          //* Nazwa funkcji :    InitTS
    704          //* Funkcja inicjalizacji obs³ugi touchopanel`a
    705          //*-----------------------------------------------------------------------------
    706          //*-----------------------------------------------------------------------------
    707          void Init_LCD_TS(void) 
    708          { 
    709          //LCD panel ----------------------------------------------------------  
    710           AT91F_PIO_ClearOutput(LCD_PIO,(unsigned int)LightLCD);
    711            AT91F_PIO_CfgOutput(LCD_PIO,(unsigned int)LightLCD);      //AT91PS_PIO pPio, unsigned int pioEnable
    712          
    713            at91DisplayOnOff(1);     // 0-OFF, 1-ON   
    714            at91DisplayStartPage(0);
    715            at91DisplayStartLine();  // set start line 
    716             //  at91DisplayStartPage(0);
    717             //at91DisplayYAdress(0);
    718            
    719          //Touth panel ----------------------------------------------------------   
    720             
    721          AT91C_BASE_PIOA->PIO_PPUDR|= TS_PIO_CH0;    //Pull-up enable enable reg.
    722          AT91C_BASE_PIOA->PIO_PPUDR|= TS_PIO_CH1;    //Pull-up enable enable reg.
    723          AT91C_BASE_PIOA->PIO_PPUDR|= TS_PIO_CH2;    //Pull-up enable enable reg.
    724          AT91C_BASE_PIOA->PIO_PPUDR|= TS_PIO_CH3;    //Pull-up enable enable reg.
    725            
    726          AT91C_BASE_ADC->ADC_MR = (3<24)|(11<<16)|(4<<8); 
    727          
    728          }//_______________________ Koniec funkcji InitTS __________________________
    729          
    730          
    731          
    732          
    733          
    734          
    735          
    736          
    737          
    738          
    739          
    740          const char Arial_7[101][10] = {
    741                            {7,127,127,62,62,62,28,28,8,8},        //30   ""
    742                            {7,8,8,28,28,62,62,62,127,127},        //31   ""
    743                            {0,0,0,0,0,0,0,0,0,0},        //32   " "
    744                            {1,0,1,0,1,1,1,1,1,0},        //33   "!"
    745                            {3,0,0,0,0,0,0,5,5,0},        //34   """
    746                            {6,3,7,15,31,63,31,15,7,3},        //35   "Strza³ka w prawo"
    747                            {6,48,56,60,62,63,62,60,56,48},        //36   "Strza³ka w lewo"
    748                            {8,228,164,232,8,16,16,23,37,39},        //37   "%"
    749                            {5,0,4,14,21,12,6,21,14,4},        //38   "$"
    750                            {5,0,0,0,0,0,0,17,10,4},        //39   "^"
    751                            {3,4,2,1,1,1,1,1,2,4},        //40   "("
    752                            {3,1,2,4,4,4,4,4,2,1},        //41   ")"
    753                            {3,0,0,0,5,2,5,0,0,0},        //42   "*"
    754                            {5,0,4,4,31,4,4,0,0,0},        //43   "+"//{5,0,36,4,63,4,4,0,0,0}, 
    755                            {1,1,1,0,0,0,0,0,0,0},        //44   ","
    756                            {2,0,0,0,3,0,0,0,0,0},        //45   "-"
    757                            {1,0,1,0,0,0,0,0,0,0},        //46   "."
    758                            {3,0,1,1,2,2,2,4,4,0},        //47   "/"
    759                            {4,0,6,9,9,9,9,9,6,0},    //0
    760                            {2,0,2,2,2,2,2,3,2,0},    //1
    761                            {4,0,15,2,4,4,8,9,6,0},   //2
    762                            {4,0,6,9,8,4,8,9,6,0},    //3
    763                            {4,0,8,8,31,9,10,12,8,0}, //4
    764                            {4,0,6,9,8,8,7,1,15,0},   //5
    765                            {4,0,6,9,9,9,7,9,6,0},    //6
    766                            {4,0,2,2,2,4,4,8,15,0},   //7
    767                            {4,0,6,9,9,6,9,9,6,0},    //8
    768                            {4,0,6,9,14,9,9,9,6,0},    //9  
    769                            {1,0,1,0,0,0,1,0,0,0},        //58   ":"
    770                            {1,1,1,0,0,0,1,0,0,0},        //59   ";"
    771                            {3,0,0,4,2,1,2,4,0,0},        //60   "<"
    772                            {4,0,0,0,15,0,15,0,0,0},        //61   "="
    773                            {3,0,0,1,2,4,2,1,0,0},        //62   ">"
    774                            {5,0,4,0,4,12,16,17,14,0},        //63   "?"
    775                            {8,194,61,85,149,181,169,66,60,0},        //64   "@"
    776                            {7,0,65,34,62,34,20,20,8,0},        //65   "A"
    777                            {4,0,7,9,9,15,9,9,7,0},        //66   "B"
    778                            {5,0,14,17,1,1,1,17,14,0},        //67   "C"
    779                            {5,0,15,17,17,17,17,17,15,0},        //68   "D"
    780                            {5,0,31,1,1,31,1,1,31,0},        //69   "E"
    781                            {4,0,1,1,1,7,1,1,15,0},        //70   "F"
    782                            {5,0,14,17,17,25,1,17,14,0},        //71   "G"
    783                            {5,0,17,17,17,31,17,17,17,0},        //72   "H"
    784                            {3,0,7,2,2,2,2,2,7,0},        //73   "I"
    785                            {4,0,7,9,8,8,8,8,8,0},        //74   "J"
    786                            {5,0,17,9,5,3,5,9,17,0},        //75   "K"
    787                            {4,0,15,1,1,1,1,1,1,0},        //76   "L"
    788                            {7,0,73,85,85,85,99,99,65,0},        //77   "M"
    789                            {5,0,17,25,25,21,19,19,17,0},        //78   "N"
    790                            {5,0,14,17,17,17,17,17,14,0},        //79   "O"
    791                            {4,0,1,1,1,15,9,9,15,0},        //80   "P"
    792                            {5,0,30,9,17,17,17,17,14,0},        //81   "Q"
    793                            {5,0,17,17,9,15,17,17,15,0},        //82   "R"
    794                            {4,0,6,9,8,6,1,9,6,0},        //83   "S"
    795                            {5,0,4,4,4,4,4,4,31,0},        //84   "T"
    796                            {5,0,14,17,17,17,17,17,17,0},        //85   "U"
    797                            {5,0,4,10,10,10,17,17,17,0},        //86   "V"
    798                            {7,0,34,34,85,73,73,65,65,0},        //87   "W"
    799                            {5,17,10,10,4,10,10,17,0},        //88   "X"
    800                            {5,0,4,4,4,4,10,10,17,0},        //89   "Y"
    801                            {6,0,63,1,2,4,8,16,63,0},        //90   "Z"
    802                            {2,1,1,1,1,1,1,1,3,0},        //91   "["
    803                            {3,0,4,4,2,2,2,1,1,0},        //92   "\"
    804                            {2,2,2,2,2,2,2,2,3,0},        //93   "]"
    805                            {3,0,0,0,0,0,5,5,2,0},        //94   "^"
    806                            {5,0,31,0,0,0,0,0,0,0},        //95   "_"
    807                            {2,0,0,0,0,0,0,2,1,0},        //96   "`"
    808                            {4,0,15,9,14,8,15,0,0,0},        //97   "a"
    809                            {4,0,7,9,9,9,7,1,1,0},        //98   "b"
    810                            {4,0,6,9,1,9,6,0,0,0},        //99   "c"
    811                            {4,0,14,9,9,9,14,8,8,0},        //100   "d"
    812                            {4,0,14,1,15,9,6,0,0,0},        //101   "e"
    813                            {3,0,2,2,2,2,7,2,4,0},        //102   "f"
    814                            {4,6,9,14,9,9,14,0,0,0},        //103   "g"
    815                            {4,0,9,9,9,9,7,1,1,0},        //104   "h"
    816                            {1,0,9,9,9,9,5,0,1,0},        //105   "i"
    817                            {1,1,9,9,9,9,5,0,1,0},        //106   "j"
    818                            {4,0,9,5,7,5,9,1,1,0},        //107   "k"
    819                            {1,0,1,1,1,1,1,1,1,0},        //108   "l"
    820                            {7,0,73,73,73,73,63,0,0,0},        //109   "m"
    821                            {4,0,9,9,9,9,7,0,0,0},        //110   "n"
    822                            {4,0,70,73,73,73,38,0,0,0},        //111   "o"
    823                            {4,1,71,73,73,73,39,0,0,0},        //112   "p"
    824                            {4,8,78,73,73,73,46,0,0,0},        //113   "q"
    825                            {3,0,1,1,1,1,7,0,0,0},             //114   "r"
    826                            {4,0,71,72,70,65,46,0,0,0},        //115   "s"
    827                            {2,0,67,73,65,65,43,1,0,0},        //116   "t"
    828                            {4,0,14,9,9,9,9,0,0,0},            //117   "u"
    829                            {5,0,68,74,74,74,17,0,0,0},        //118   "v"
    830                            {5,0,10,21,21,21,21,0,0,0},         //119   "w"
    831                            {4,0,73,70,70,70,9,0,0,0},         //120   "x"
    832                            {5,4,4,10,10,10,17,0,0,0},         //121   "y"
    833                            {3,0,71,65,66,68,23,0,0,0},        //122   "z"
    834                            {3,2,66,66,65,66,18,2,6,0},        //123   "{"
    835                            {1,1,1,1,1,1,1,1,1,0},        //124   "|"
    836                            {3,2,2,2,4,2,2,2,3,0},        //125   "}"
    837                            {4,0,0,0,13,11,0,0,0,0},        //126   "~"
    838                            {8,0,96,144,16,16,18,149,98,0},        //127   "*C"
    839                            {5,0,30,1,31,1,31,1,30,0},        //128   "€"
    840                            {5,0,17,10,10,4,10,10,17,0},        //129   X
    841                            {7,0,28,34,65,73,73,42,8,0}  //130 OnOff
    842                            };
    843          
    844          
    845          
    846          const unsigned short Arial_18[100][26] = {
    847           {16,0,0,0,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,0,0,0},        //30   ""
    848                            {16,0,0,0,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,0,0,0},        //31   ""
    849                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},        //32   " "
    850                            {16,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65534,65534,65534,65534,65534},        //33   "!"
    851                            {16,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65502,65502,65502,65502},        //34   """
    852                            {16,0,0,0,903,1927,1935,1807,1806,65535,65535,65535,3614,3612,7708,7740,7740,65535,65535,65535,15480,14456,14448,30832,30960,30960},        //35   "#"
    853                            {15,448,448,448,2032,8188,16382,32767,32223,31183,31183,31168,31168,32704,16320,8176,2044,510,479,463,463,32207,16383,16382,8188,2040},        //36   "$"
    854                            {16,0,0,0,480,448,33728,33664,34688,36608,36608,40448,39936,48128,14584,31742,62430,63375,59279,51087,51087,34703,34703,990,1022,248},        //37   "%"
    855                            {16,0,0,0,2032,57340,65534,65087,63519,63503,64527,65039,65311,57118,4094,2040,2032,4080,16376,15608,30840,30844,31992,16376,16368,4064},        //38   "&"
    856                            {16,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65279,65535,65535,65535,65535,65535,65535,63487,63487,65534,65534,65534,65534},        //39   "'"
    857                            {16,120,60,60,1084,56350,64542,64542,63519,63503,64527,64527,64527,56335,3087,1055,1054,3102,15390,15420,30780,30780,31864,15472,15600,3296},        //40   "("
    858                            {16,65535,65535,65535,65535,65535,65535,65535,65535,65519,65535,65535,65535,65535,65519,65519,65535,65535,65535,65527,65535,65535,65535,65535,65535,65534},        //41   ")"
    859                            {16,0,0,0,0,53248,61440,61440,61440,61440,61440,61440,61440,53248,0,0,0,460,13310,12796,28924,29182,30719,14335,12408,120},        //42   "*"
    860                            {16,0,0,0,0,0,0,960,960,960,960,960,960,65535,65535,65535,960,960,960,960,960,960,0,0,0,0},        //43   "+"
    861                            {5,14,28,28,31,31,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},        //44   ","
    862                            {9,0,0,0,0,0,0,0,0,0,0,511,511,511,0,0,0,0,0,0,0,0,0,0,0,0},        //45   "-"
    863                            {3,0,0,0,7,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},        //46   "."
    864                            {8,0,0,0,3,3,7,7,7,7,15,14,14,30,30,28,60,60,56,120,120,112,112,240,224,224},        //47   "/"
    865                            {15,0,0,0,2032,8188,8188,15934,31775,31775,30735,30735,30735,30735,30735,30735,30735,30735,30735,30735,31775,31775,15934,8188,8188,2032},        //48   "0"
    866                            {9,0,0,0,480,480,480,480,480,480,480,480,480,480,480,480,480,480,483,495,511,510,504,496,480,448},        //49   "1"
    867                            {15,0,0,0,32767,32767,32767,31,62,124,248,496,960,1920,3840,7680,15360,31744,30720,30735,30735,31775,32318,16382,8188,2032},        //50   "2"
    868                            {15,0,0,0,2032,8188,16382,15935,31775,30735,30720,30720,30720,31744,31744,16352,4064,4064,7936,15360,15375,15391,15934,8190,4092,2032},        //51   "3"
    869                            {15,0,0,0,3840,3840,3840,3840,3840,32767,32767,32767,3847,3855,3870,3870,3900,3960,3960,4080,4064,4032,4032,3968,3840,3840},        //52   "4"
    870                            {15,0,0,0,2032,8188,16382,15903,31759,30735,30720,30720,30720,30720,31744,32287,16383,8190,2046,30,30,62,60,16380,16380,16380},        //53   "5"
    871                            {15,0,0,0,2032,8188,16382,15934,31775,30735,30735,30735,30735,30751,32319,16383,8191,2031,15,15,30751,31774,15934,16380,8184,2032},        //54   "6"
    872                            //{16,65535,65535,65535,65527,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65471,65535,65407,65535,65279,65535,65535,65535,65534,65534,65534},        //55   "7"
    873                           // 0,0,0,0,120,120,120,120,120,240,240,240,224,224,224,192,192,128,128,   0,0,0,255,255,255,255},
    874                            {14,0,0,0,120,120,120,120,120,240,240,240,224,224,480,448,960,896,1920,1792,3840, 7680,16383,16383,16383,16383},
    875                           //{0,0,0,0,0,    0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  3,  3,  7,  7, 15,30,63 ,63 , 63, 63},
    876                            {16,0,0,0,2032,8188,16382,32319,31775,63503,63503,63503,30735,31775,32318,16380,4088,8188,15934,31774,31775,31775,15934,16382,8188,2032},        //56   "8"
    877                            {15,0,0,0,1016,4092,8190,16190,15903,31759,31744,30720,31736,32764,32766,32319,31775,30735,30735,30735,30735,31775,15935,8190,4092,2032},        //57   "9"
    878                            {5,0,0,0,31,31,31,0,0,0,0,0,0,0,0,0,0,31,31,31,0,0,0,0,0,0},        //58   ":"
    879                            {5,14,30,28,31,31,31,0,0,0,0,0,0,0,0,0,0,31,31,31,0,0,0,0,0,0},        //59   ";"
    880                            {16,0,0,0,0,0,0,57344,63488,65280,32704,4080,1022,127,31,127,1022,4080,32704,65280,63488,57344,0,0,0,0},        //60   "<"
    881                            {16,0,0,0,0,0,0,0,0,0,65535,65535,65535,0,0,0,65535,65535,65535,0,0,0,0,0,0,0},        //61   "="
    882                            {16,0,0,0,0,0,0,7,31,255,1022,4080,32704,65024,63488,65024,32704,4080,1022,255,31,7,0,0,0,0},        //62   ">"
    883                            {15,0,0,0,480,480,480,0,0,480,992,992,960,1984,3968,7936,15872,31744,30720,30720,30735,30751,32319,16382,8188,2032},        //63   "?"
    884                            {16,504,124,60,32286,65438,65423,59343,33743,975,975,975,975,975,1999,3998,40862,65310,65084,63612,248,1008,4064,65472,65280,64512},        //64   "@"
    885                            {16,0,0,0,7,32775,32783,49167,49183,49183,57374,65534,65532,65532,61564,63608,30968,31984,15600,15856,16352,8160,8128,4032,3968,1920},        //65   "A"
    886                            {16,65535,65535,65535,65534,65534,65534,61438,65534,65534,65534,65534,65534,61438,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //66   "B"
    887                            {16,0,0,0,32704,65520,65528,57852,49278,32830,31,31,15,15,15,15,15,15,31,31,32830,49278,57596,65528,65520,32640},        //67   "C"
    888                            {16,65535,65535,65535,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,32766,32766,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //68   "D"
    889                            {16,65535,65535,65535,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //69   "E"
    890                            {16,65535,65535,65535,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //70   "F"
    891                            {16,0,0,0,65408,65504,65528,33276,126,62,31,31,63503,63503,63503,15,15,15,31,30,62,126,49660,65528,65504,65408},        //71   "G"
    892                            {16,65535,65535,65535,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //72   "H"
    893                            {16,65535,65535,65535,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //73   "I"
    894                            {13,0,0,0,1016,2046,4095,8095,7951,7695,7695,7680,7680,7680,7680,7680,7680,7680,7680,7680,7680,7680,7680,7680,7680,7680},        //74   "J"
    895                            {16,65535,65535,65535,65534,65534,57342,65534,65534,65534,64510,65534,65534,65534,65534,65534,65518,65502,65534,65534,65534,65534,65534,65534,65534,65534},        //75   "K"
    896                            {16,65535,65535,65535,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //76   "L"
    897                            {16,65535,65535,65535,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //77   "M"
    898                            {16,65535,65535,65535,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //78   "N"
    899                            {16,0,0,0,32640,65504,65528,57852,32894,62,31,31,15,15,15,15,15,31,31,31,62,32894,57852,65528,65504,32640},        //79   "O"
    900                            {16,65535,65535,65535,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,61438,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //80   "P"
    901                            {16,0,0,0,32640,65504,65528,57852,63614,30782,6175,31,15,15,15,15,15,15,31,31,62,32894,57852,65528,65520,32640},        //81   "Q"
    902                            {16,65535,65535,65535,65534,65534,65534,65534,65534,61438,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //82   "R"
    903                            {16,0,0,0,16352,65528,65532,61566,49183,32783,32783,49152,57344,64512,65472,65528,8188,254,62,30,49182,57374,61566,65532,65528,16352},        //83   "S"
    904                            {16,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65534,65534,65534},        //84   "T"
    905                            {16,65535,65535,65535,65535,65535,65535,65533,57343,65535,49151,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //85   "U"
    906                            {16,65535,65535,65535,64767,63743,64255,62335,63359,63295,61375,61375,53151,57311,57295,40943,49135,16359,32759,32755,32755,65531,65529,65529,65532,65532},        //86   "V"
    907                            {16,65535,65535,65535,65087,65087,65087,65215,64991,64991,64991,63951,64495,64495,62447,63463,63479,59383,61427,61427,61435,53241,57337,8185,8189,16380},        //87   "W"
    908                            {16,65535,65535,65535,65535,65535,65535,57343,65531,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,61431,65535,65535,65535,32766},        //88   "X"
    909                            {16,65535,65535,65535,65023,65023,65023,65023,65023,65023,65023,65023,65023,64767,63743,63615,62271,59199,61343,53199,40911,16359,16371,32755,65529,65532},        //89   "Y"
    910                            {16,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65503,65535,65535,65535,65535,65535,64511,65535,65535,65534,65534,65534},        //90   "Z"
    911                            {16,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65528,65528,65528},        //91   "["
    912                            {16,65535,65535,65535,65471,65471,65535,65535,65503,65535,65535,65519,65519,65535,65527,65527,65535,65531,65531,65535,65535,65533,65535,65535,65534,65534},        //92   "\"
    913                            {16,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65534,65534,65534},        //93   "]"
    914                            {13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7687,3855,3855,3999,1950,1950,1020,1020,504,504,504},        //94   "^"
    915                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},        //95   "_"
    916                            {16,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65535,65534},        //96   "`"
    917                            {15,0,0,0,32252,16383,16383,16271,15887,15887,15375,15870,16380,16128,15360,15887,15903,8190,8190,2040,0,0,0,0,0,0},        //97   "a"
    918                            {16,65535,65535,65535,65502,65534,65534,65534,64510,65534,63486,63486,63486,63486,65534,65534,65022,65534,65534,65502,65534,65534,65534,65534,65534,65534},        //98   "b"
    919                            {14,0,0,0,2032,4092,8190,15935,15391,15375,15,15,15,15,15,15391,15935,8190,4092,2032,0,0,0,0,0,0},        //99   "c"
    920                            {15,0,0,0,32248,32764,32766,32575,32287,31759,31759,31751,31751,31759,31759,32271,32575,32766,32764,32248,31744,31744,31744,31744,31744,31744},        //100   "d"
    921                            {15,0,0,0,2040,8188,16382,15935,31759,15,7,32767,32767,31751,31759,15375,16191,8190,4092,1016,0,0,0,0,0,0},        //101   "e"
    922                            {15,0,0,0,1054,7198,15390,15390,31774,30,30,31774,31774,31774,31774,15390,15390,7423,3327,255,30,30,30,510,508,504},        //102   "f"
    923                            {15,15903,15375,15360,16376,32764,32766,32575,32271,31759,31759,31751,31751,31759,31759,32271,32575,32766,32764,32760,0,0,0,0,0,0},        //103   "g"
    924                            {16,65535,65535,65535,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //104   "h"
    925                            {16,65535,65535,65535,64510,64510,64510,64510,64510,64510,64510,64510,64510,64510,64510,65534,65534,65534,65534,65534,65535,65535,65535,65534,65534,65534},        //105   "i"
    926                            {16,65535,65535,65535,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65535,65535,65535,65534,65534,65534},        //106   "j"
    927                            {16,65535,65535,65535,65534,65534,65278,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534},        //107   "k"
    928                            {16,65535,65535,65535,65022,65534,65534,65406,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65534,65278,65534,65534,65534,65534,65534,65534},        //108   "l"
    929                            {16,0,0,0,31775,31775,31775,31775,31775,31775,31775,31775,31775,31775,31775,31775,65151,65535,57343,4047,0,0,0,0,0,0},        //109   "m"
    930                            {15,0,0,0,31775,31775,31775,31775,31775,31775,31775,31775,31775,31775,31775,31775,15999,16383,8191,4095,0,0,0,0,0,0},        //110   "n"
    931                            {15,0,0,0,1016,4092,8190,16191,15903,15375,31759,31759,31759,31759,15375,15903,16191,8190,4092,2032,0,0,0,0,0,0},        //111   "o"
    932                            {15,15,15,15,2031,8191,16383,15935,31775,30751,30735,30735,30735,30735,30751,31775,15999,16383,8191,2031,0,0,0,0,0,0},        //112   "p"
    933                            {15,31744,31744,31744,32752,32764,32766,32575,32271,31759,31759,31751,31751,31759,31759,32271,32575,32766,32764,32248,0,0,0,0,0,0},        //113   "q"
    934                            {15,30720,30720,30720,30751,30751,30751,30751,30751,30751,30751,30751,30751,30751,30751,30751,30783,31231,31743,31743,0,0,0,0,0,0},        //114   "r"
    935                            {14,0,0,0,1016,4094,8191,7967,15887,15872,8064,8184,4094,511,31,15,7951,3999,4094,1020,0,0,0,0,0,0},        //115   "s"
    936                            {14,0,0,0,764,3838,7934,7710,15902,15902,7710,7710,3614,30,30,30,7710,3839,3839,767,30,30,30,30,28,16},        //116   "t"
    937                            {15,0,0,0,32248,32764,32766,32574,31775,31775,31775,31775,31775,31775,31775,31775,31775,31775,31775,31775,0,0,0,0,0,0},        //117   "u"
    938                            {14,0,0,0,496,496,1008,1016,1016,2044,1980,1980,3870,3870,7967,7695,7695,15887,15367,15367,0,0,0,0,0,0},        //118   "v"
    939                            {16,0,0,0,57592,57592,61688,61948,61948,63996,63966,31710,31710,16335,16271,16271,16271,7943,7943,7943,0,0,0,0,0,0},        //119   "w"
    940                            {16,0,0,0,56839,57103,53007,51102,51198,50172,49656,16888,16624,504,1020,1020,2046,3999,3855,7951,0,0,0,0,0,0},        //120   "x"
    941                            {16,248,240,240,33248,33264,33264,33776,33784,34808,34748,1980,3900,3870,3870,7711,7695,15887,15375,15367,0,0,0,0,0,0},        //121   "y"
    942                            {16,0,0,0,49151,49151,49151,32783,32799,32830,32892,248,496,992,1984,3968,7936,8191,8191,8191,0,0,0,0,0,0},        //122   "z"
    943                            {16,124,60,60,48188,48188,48188,32828,32828,32830,32798,15,7,15,1054,3134,7228,7228,7228,7228,60,60,60,508,504,496},        //123   "{"
    944                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},        //124   "|"
    945                            {16,65511,65519,65519,65519,65519,65519,65519,65519,65519,65487,65311,65407,65311,65487,65519,65511,65511,65511,65511,65511,65511,65527,65520,65520,65528},        //125   "}"
    946                            {16,0,0,0,0,0,0,0,0,0,0,15873,32643,65511,59391,49662,32892,0,0,0,0,0,0,0,0,0},        //126   "~"
    947                            //{16,0,0,0,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,0,0,0},        //127   ""
    948                            {8,0,0,0,0,0,0,0,0,0,0,0,0,0,56,124,110,6,6,110,124,56,2,5,2},  //127   "*C"
    949                            {16,0,0,0,32704,65520,65528,57596,126,62,30,31,16383,16383,15,15,16383,32767,31,31,62,126,57596,65528,65520,32640},        //128   "€"
    950                            {16,0,0,0,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,32771,0,0,0},        //129   ""
    951                            };
    952          
    953          
    954          //*-----------------------------------------------------------------------------
    955          //* Nazwa funkcji :    Label
    956          //* Funkcja wrysowania napisu
    957          //*-----------------------------------------------------------------------------
    958          //*  Vstring    - wskaŸnik do tablicy znaków
    959          //*  alig       - wyrównanie -0=do lewej, 1=do prawej, 2=wyœrodkowany
    960          //*  X          - wspó³¿êdna X zale¿na od wyrównania 
    961          //*  Y          - wspó³¿êdna Y do³u napisu
    962          //*  maxChar    - maksymalna d³ugoœæ napisu w znakach 
    963          //*  clean      - d³ugoœæ (w pikselach) obszaru czyszczenia t³a 
    964          //*  minY, maxY - obszar roboczy
    965          //*  negatyw    - 0-brak, 1-negatyw
    966          //*  funkcja zwraca d³ugoœæ napisu w pikselach
    967          //*-----------------------------------------------------------------------------
    968          
    969          char Label (char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
    970          { 
    971            //char offset=43;
    972            char offset=30;
    973            
    974            
    975            int kol=0;
    976            char linia=0;
    977            char bit=0;
    978            char ill_znak=0;
    979            
    980            char pocz_X=X;
    981            
    982            kol=X/8;
    983            bit=X%8;
    984            linia=Y;
    985             
    986            char dlugosc=0;
    987            char clean_offset=0;
    988            
    989            
    990          
    991            
    992            
    993            
    994            if (alig==1)
    995            {
    996              do {       
    997                 
    998                 if (Vstring[ill_znak]>=offset)  
    999                  {
   1000                    dlugosc += Arial_7[Vstring[ill_znak]-offset][0];
   1001                  }
   1002                 else
   1003                 {
   1004                   dlugosc++;
   1005                   dlugosc++;
   1006                   dlugosc++;
   1007                 }
   1008                 dlugosc++;
   1009                 ill_znak++;
   1010                } while ((Vstring[ill_znak]) && (ill_znak<maxChar) && (X-dlugosc>=0) );
   1011           
   1012              clean_offset=clean;
   1013            }
   1014            else
   1015            {
   1016              do {   
   1017                 
   1018                 
   1019                 if (Vstring[ill_znak]>=offset)  
   1020                  {
   1021                    dlugosc += Arial_7[Vstring[ill_znak]-offset][0];
   1022                  }
   1023                 else
   1024                 {
   1025                   dlugosc++;
   1026                   dlugosc++;
   1027                   dlugosc++;
   1028                 }
   1029                 
   1030                 
   1031                 dlugosc++;
   1032                 ill_znak++;
   1033               } while ((Vstring[ill_znak]) && (ill_znak<maxChar) && (X+dlugosc<=64));
   1034              
   1035            }
   1036              
   1037            dlugosc--;
   1038            
   1039             //Czyszczenie obszaru ----------------------
   1040            linia=Y;
   1041            for (int i=1; i<=9; i++)
   1042             {
   1043              if ((linia>=minY) && (linia<=maxY))
   1044              {
   1045               kol=(X-clean_offset)/8;
   1046               bit=(X-clean_offset)%8;
   1047                 
   1048                for (int j=0; j<=clean; j++)
   1049                {
   1050                  LCD_Canvas[kol][linia] &=~(1<<bit);
   1051                  
   1052                  if (bit<7) { bit++;} else {bit=0;  kol++; }
   1053                }   
   1054          
   1055          
   1056             }
   1057              linia++;
   1058            }
   1059            //------------------------------------------------------
   1060              
   1061            if (alig==1)
   1062            {  
   1063              X-=dlugosc;
   1064            }  
   1065           
   1066            if (alig==2)
   1067            {  
   1068              X+=(clean-dlugosc)/2;
   1069              
   1070              if (((clean-dlugosc)%2)>0) X++;
   1071            }  
   1072          
   1073              
   1074            //wklejanie napisu do LCD_Canvas ----------------------
   1075            linia=Y;
   1076            for (int i=1; i<=9; i++)
   1077             {
   1078              if ((linia>=minY) && (linia<=maxY))
   1079              {
   1080               kol=X/8;
   1081               bit=X%8;
   1082              for (int k=0; k<=(ill_znak-1); k++)
   1083              {     
   1084                
   1085                if ((Vstring[k]>=offset) &&  (Vstring[k]!=32))
   1086                {
   1087                  for (int j=0; j<=Arial_7[Vstring[k]-offset][0]; j++)
   1088                  {
   1089                      LCD_Canvas[kol][linia] |= (((Arial_7[Vstring[k]-offset][i])>>j)&0x1)<<bit;
   1090                      if (bit<7) { bit++;} else {bit=0;  kol++; } 
   1091                  }
   1092                }
   1093                else 
   1094                {
   1095                     if (bit<7) { bit++;} else {bit=0;  kol++; } 
   1096                     if (bit<7) { bit++;} else {bit=0;  kol++; } 
   1097                     if (bit<7) { bit++;} else {bit=0;  kol++; } 
   1098          
   1099                }
   1100                
   1101                
   1102              }
   1103             }
   1104              linia++;
   1105            }
   1106            //------------------------------------------------------
   1107              
   1108          
   1109            //negatyw obszaru ----------------------
   1110           if (negatyw)
   1111           {
   1112            linia=Y;
   1113            for (int i=1; i<=9; i++)
   1114             {
   1115              if ((linia>=minY) && (linia<=maxY))
   1116              {
   1117               
   1118               kol=(pocz_X-clean_offset)/8;
   1119               bit=(pocz_X-clean_offset)%8;
   1120                 
   1121                for (int j=0; j<=clean; j++)
   1122                {
   1123                 
   1124                  if (((LCD_Canvas[kol][linia]>>bit)&0x1)>0)
   1125                  {
   1126                     LCD_Canvas[kol][linia] &=~(1<<bit);   
   1127                    
   1128                  }
   1129                  else
   1130                  {
   1131                    LCD_Canvas[kol][linia] |=(1<<bit); 
   1132                    
   1133                  }
   1134                  
   1135                  
   1136                  
   1137                  if (bit<7) { bit++;} else {bit=0;  kol++; }
   1138                }   
   1139          
   1140          
   1141             }
   1142              linia++;
   1143            }
   1144            }
   1145            //------------------------------------------------------
   1146             
   1147           return dlugosc;
   1148            
   1149          }//_______________________ Koniec funkcji Label __________________________
   1150          
   1151          
   1152          
   1153          
   1154          
   1155          
   1156          
   1157          
   1158          //*-----------------------------------------------------------------------------
   1159          //* Nazwa funkcji :    LabelLength
   1160          //* Funkcja wrysowania napisu
   1161          //*-----------------------------------------------------------------------------
   1162          //*  Vstring    - wskaŸnik do tablicy znaków
   1163          //*  maxChar    - maksymalna d³ugoœæ napisu w znakach 
   1164          //*  funkcja zwraca d³ugoœæ napisu w pikselach
   1165          //*-----------------------------------------------------------------------------
   1166          
   1167          char LabelLength (char *Vstring, char maxChar)
   1168          { 
   1169            //char offset=43;
   1170            char offset=30;
   1171            
   1172            
   1173            int kol=0;
   1174            char linia=0;
   1175            char bit=0;
   1176            char ill_znak=0;
   1177          
   1178             
   1179            char dlugosc=0;
   1180            char clean_offset=0;
   1181            
   1182           
   1183              do {   
   1184                 
   1185                 
   1186                 if (Vstring[ill_znak]>=offset)  
   1187                  {
   1188                    dlugosc += Arial_7[Vstring[ill_znak]-offset][0];
   1189                  }
   1190                 else
   1191                 {
   1192                   dlugosc++;
   1193                   dlugosc++;
   1194                   dlugosc++;
   1195                 }
   1196                 
   1197                 
   1198                 dlugosc++;
   1199                 ill_znak++;
   1200               } while ((Vstring[ill_znak]) && (ill_znak<maxChar) && (dlugosc<=64));
   1201              
   1202            
   1203              
   1204            dlugosc--;
   1205            
   1206             
   1207           return dlugosc;
   1208            
   1209          }//_______________________ Koniec funkcji LabelLength __________________________
   1210          
   1211          
   1212          
   1213          
   1214          
   1215          
   1216          
   1217          
   1218          //*-----------------------------------------------------------------------------
   1219          //* Nazwa funkcji :    Label
   1220          //* Funkcja wrysowania napisu
   1221          //*-----------------------------------------------------------------------------
   1222          //*  Vstring    - wskaŸnik do tablicy znaków
   1223          //*  alig       - wyrównanie -0=do lewej, 1=do prawej, 2=wyœrodkowany
   1224          //*  X          - wspó³¿êdna X zale¿na od wyrównania 
   1225          //*  Y          - wspó³¿êdna Y do³u napisu
   1226          //*  maxChar    - maksymalna d³ugoœæ napisu w znakach 
   1227          //*  clean      - d³ugoœæ (w pikselach) obszaru czyszczenia t³a 
   1228          //*  minY, maxY - obszar roboczy
   1229          //*  negatyw    - 0-brak, 1-negatyw
   1230          //*-----------------------------------------------------------------------------
   1231          
   1232          void Label20 (char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1233          { 
   1234            //char offset=43;
   1235            char offset=30;
   1236            
   1237            
   1238            int kol=0;
   1239            char linia=0;
   1240            char bit=0;
   1241            char ill_znak=0;
   1242            
   1243            char pocz_X=X;
   1244            
   1245            kol=X/8;
   1246            bit=X%8;
   1247            linia=Y;
   1248             
   1249            char dlugosc=0;
   1250            char clean_offset=0;
   1251            
   1252            
   1253          
   1254            
   1255            
   1256            
   1257            if (alig==1)
   1258            {
   1259              do {       
   1260                 
   1261                 if (Vstring[ill_znak]>=offset)  
   1262                  {
   1263                    dlugosc += Arial_18[Vstring[ill_znak]-offset][0];
   1264                  }
   1265                 else
   1266                 {
   1267                   dlugosc++;
   1268                   dlugosc++;
   1269                   dlugosc++;
   1270                 }
   1271                 dlugosc++;
   1272                 ill_znak++;
   1273                } while ((Vstring[ill_znak]) && (ill_znak<maxChar) && (X-dlugosc>=0) );
   1274           
   1275              clean_offset=clean;
   1276            }
   1277            else
   1278            {
   1279              do {   
   1280                 
   1281                 
   1282                 if (Vstring[ill_znak]>=offset)  
   1283                  {
   1284                    dlugosc += Arial_18[Vstring[ill_znak]-offset][0];
   1285                  }
   1286                 else
   1287                 {
   1288                   dlugosc++;
   1289                   dlugosc++;
   1290                   dlugosc++;
   1291                 }
   1292                 
   1293                 
   1294                 dlugosc++;
   1295                 ill_znak++;
   1296               } while ((Vstring[ill_znak]) && (ill_znak<maxChar) && (X+dlugosc<=64));
   1297              
   1298            }
   1299              
   1300            dlugosc--;
   1301            
   1302             //Czyszczenie obszaru ----------------------
   1303            linia=Y;
   1304            for (int i=1; i<=25; i++)
   1305             {
   1306              if ((linia>=minY) && (linia<=maxY))
   1307              {
   1308               kol=(X-clean_offset)/8;
   1309               bit=(X-clean_offset)%8;
   1310                 
   1311                for (int j=0; j<=clean; j++)
   1312                {
   1313                  LCD_Canvas[kol][linia] &=~(1<<bit);
   1314                  
   1315                  if (bit<7) { bit++;} else {bit=0;  kol++; }
   1316                }   
   1317          
   1318          
   1319             }
   1320              linia++;
   1321            }
   1322            //------------------------------------------------------
   1323              
   1324            if (alig==1)
   1325            {  
   1326              X-=dlugosc;
   1327            }  
   1328           
   1329            if (alig==2)
   1330            {  
   1331              X+=(clean-dlugosc)/2;
   1332              
   1333              if (((clean-dlugosc)%2)>0) X++;
   1334            }  
   1335          
   1336              
   1337            //wklejanie napisu do LCD_Canvas ----------------------
   1338            linia=Y;
   1339            for (int i=1; i<=25; i++)
   1340             {
   1341              if ((linia>=minY) && (linia<=maxY))
   1342              {
   1343               kol=X/8;
   1344               bit=X%8;
   1345              for (int k=0; k<=(ill_znak-1); k++)
   1346              {     
   1347                
   1348                if ((Vstring[k]>=offset) &&  (Vstring[k]!=32))
   1349                {
   1350                  for (int j=0; j<=Arial_18[Vstring[k]-offset][0]; j++)
   1351                  {
   1352                      LCD_Canvas[kol][linia] |= (((Arial_18[Vstring[k]-offset][i])>>j)&0x1)<<bit;
   1353                      if (bit<7) { bit++;} else {bit=0;  kol++; } 
   1354                  }
   1355                }
   1356                else 
   1357                {
   1358                     if (bit<7) { bit++;} else {bit=0;  kol++; } 
   1359                     if (bit<7) { bit++;} else {bit=0;  kol++; } 
   1360                     if (bit<7) { bit++;} else {bit=0;  kol++; } 
   1361          
   1362                }
   1363                
   1364                
   1365              }
   1366             }
   1367              linia++;
   1368            }
   1369            //------------------------------------------------------
   1370              
   1371          
   1372            //negatyw obszaru ----------------------
   1373           if (negatyw)
   1374           {
   1375            linia=Y;
   1376            for (int i=1; i<=9; i++)
   1377             {
   1378              if ((linia>=minY) && (linia<=maxY))
   1379              {
   1380               
   1381               kol=(pocz_X-clean_offset)/8;
   1382               bit=(pocz_X-clean_offset)%8;
   1383                 
   1384                for (int j=0; j<=clean; j++)
   1385                {
   1386                 
   1387                  if (((LCD_Canvas[kol][linia]>>bit)&0x1)>0)
   1388                  {
   1389                     LCD_Canvas[kol][linia] &=~(1<<bit);   
   1390                    
   1391                  }
   1392                  else
   1393                  {
   1394                    LCD_Canvas[kol][linia] |=(1<<bit); 
   1395                    
   1396                  }
   1397                  
   1398                  
   1399                  
   1400                  if (bit<7) { bit++;} else {bit=0;  kol++; }
   1401                }   
   1402          
   1403          
   1404             }
   1405              linia++;
   1406            }
   1407            }
   1408            //------------------------------------------------------
   1409             
   1410          
   1411            
   1412          }//_______________________ Koniec funkcji Label __________________________
   1413          
   1414          
   1415          
   1416          
   1417          
   1418          
   1419          
   1420          
   1421          
   1422          //*-----------------------------------------------------------------------------
   1423          //* Nazwa funkcji :    TimeToStr
   1424          //* Funkcja Czasu na string
   1425          //*-----------------------------------------------------------------------------
   1426          //*-----------------------------------------------------------------------------
   1427          void TimeToStr (char godz, char min, char sek, char Vstring[8]) 
   1428          { 
   1429                 if (godz<10) 
   1430                 {
   1431                   Vstring[0]=48;
   1432                   Vstring[1]=godz+48;
   1433                 }
   1434                 else
   1435                 {
   1436                   Vstring[0]=godz/10+48;
   1437                   Vstring[1]=godz%10+48;
   1438                 }
   1439                 Vstring[2]=58;
   1440                 
   1441                 if (min<10) 
   1442                 {
   1443                   Vstring[3]=48;
   1444                   Vstring[4]=min+48;
   1445                 }
   1446                 else
   1447                 {
   1448                   Vstring[3]=min/10+48;
   1449                   Vstring[4]=min%10+48;
   1450                 }
   1451                 Vstring[5]=58;
   1452                 
   1453                 
   1454                 if (sek<10) 
   1455                 {
   1456                   Vstring[6]=48;
   1457                   Vstring[7]=sek+48;
   1458                 }
   1459                 else
   1460                 {
   1461                   Vstring[6]=sek/10+48;
   1462                   Vstring[7]=sek%10+48;
   1463                 }
   1464          
   1465                 
   1466          }//_______________________ Koniec funkcji TimeToStr____________________________
   1467          
   1468          
   1469          
   1470          //*-----------------------------------------------------------------------------
   1471          //* Nazwa funkcji :    DateToStr
   1472          //* Funkcja Daty na string
   1473          //*-----------------------------------------------------------------------------
   1474          //*-----------------------------------------------------------------------------
   1475          void DateToStr (char dzin, char mies, char rok, char Vstring[8]) 
   1476          { 
   1477                 if (dzin<10) 
   1478                 {
   1479                   Vstring[0]=48;
   1480                   Vstring[1]=dzin+48;
   1481                 }
   1482                 else
   1483                 {
   1484                   Vstring[0]=dzin/10+48;
   1485                   Vstring[1]=dzin%10+48;
   1486                 }
   1487                 Vstring[2]=45; //"-"
   1488                 
   1489                 if (mies<10) 
   1490                 {
   1491                   Vstring[3]=48;
   1492                   Vstring[4]=mies+48;
   1493                 }
   1494                 else
   1495                 {
   1496                   Vstring[3]=mies/10+48;
   1497                   Vstring[4]=mies%10+48;
   1498                 }
   1499                 Vstring[5]=45; //"-"
   1500                 
   1501                 
   1502                 if (rok<10) 
   1503                 {
   1504                   Vstring[6]=48;
   1505                   Vstring[7]=rok+48;
   1506                 }
   1507                 else
   1508                 {
   1509                   Vstring[6]=rok/10+48;
   1510                   Vstring[7]=rok%10+48;
   1511                 }
   1512          
   1513                 
   1514          }//_______________________ Koniec funkcji DateToStr ____________________________
   1515          
   1516          
   1517          
   1518          
   1519          //*-----------------------------------------------------------------------------
   1520          //* Nazwa funkcji :    CharToStr
   1521          //* Funkcja konwersji zmiennej float na ³añcuch string   
   1522          //*-----------------------------------------------------------------------------
   1523          //*  Value   - zmienna typu float
   1524          //*  Vstring - tablica znaków
   1525          //*  ill     - liloœæ znaków (max=9) , ostatnia wartoœæ zapisanego ³añcucha to zawsze 0
   1526          //* return   - iloœæ cyfr w stringu
   1527          //*-----------------------------------------------------------------------------
   1528          char CharToStr (char Value, char *Vstring, char ill) 
   1529          { 
   1530                char set=0;
   1531                char dzies=0;
   1532                char jedn=0;
   1533                char ind;
   1534                
   1535                for (int i=0; i<ill; i++) Vstring[i]=0;
   1536                  
   1537                
   1538                set= Value/100;
   1539                dzies= (Value%100)/10;
   1540                jedn = Value- (set*100) - (dzies*10);
   1541                
   1542                if (ill==0) ill=1; 
   1543                ill--;
   1544                 
   1545                ind=0;
   1546                if (set>0) 
   1547                {
   1548                  Vstring[ind]=set+48;
   1549                  ind++;
   1550                }
   1551                if (set+dzies>0) 
   1552                {
   1553                  Vstring[ind]=dzies+48;
   1554                  ind++;
   1555                }
   1556                Vstring[ind]=jedn+48;
   1557          
   1558                ind++;
   1559                return ind;
   1560                
   1561                 
   1562          }//_______________________ Koniec funkcji konwersji float na string ____________________________
   1563          
   1564          
   1565          
   1566          
   1567          
   1568          
   1569          //*-----------------------------------------------------------------------------
   1570          //* Nazwa funkcji :    CharToStr2
   1571          //* Funkcja konwersji zmiennej float na ³añcuch string  w formacie 00 
   1572          //*-----------------------------------------------------------------------------
   1573          //*  Value   - zmienna typu float
   1574          //*  Vstring - tablica znaków
   1575          //*-----------------------------------------------------------------------------
   1576          void CharToStr2 (char Value, char *Vstring) 
   1577          { 
   1578                char set=0;
   1579                char dzies=0;
   1580                char jedn=0;
   1581          
   1582                set= Value/100;
   1583                dzies= (Value%100)/10;
   1584                jedn = Value- (set*100) - (dzies*10);      
   1585                
   1586                Vstring[1]=jedn+48;
   1587                Vstring[0]=dzies+48;        
   1588          }//_______________________ Koniec funkcji konwersji float na string ____________________________
   1589          
   1590          
   1591          
   1592          
   1593          
   1594          
   1595          
   1596          
   1597          //*-----------------------------------------------------------------------------
   1598          //* Nazwa funkcji :    CharToStr
   1599          //* Funkcja konwersji zmiennej char na ³añcuch znakowy string -2 elementowy   
   1600          //*-----------------------------------------------------------------------------
   1601          //*  Value   - zmienna typu float
   1602          //*  Vstring - tablica znaków
   1603          //*-----------------------------------------------------------------------------
   1604          void CharToStrData (char Value, char *Vstring) 
   1605          { 
   1606          
   1607                
   1608                for (int i=0; i<2; i++) Vstring[i]=0;
   1609                
   1610                Vstring[0]=(Value/10)+48;
   1611                Vstring[1]=(Value%10)+48;
   1612          
   1613          }//_______________________ Koniec funkcji konwersji char na string ____________________________
   1614          
   1615          
   1616          
   1617          
   1618          
   1619          //*-----------------------------------------------------------------------------
   1620          //* Nazwa funkcji :    sIntToStr
   1621          //* Funkcja konwersji zmiennej short int na ³añcuch string  wed³óg schematu dla zmiennej analogowej systemu (-3276.8 + 3276.7)
   1622          //*-----------------------------------------------------------------------------
   1623          //*  Value   - zmienna typu float
   1624          //*  Vstring - tablica znaków
   1625          //* return   - iloœæ cyfr w stringu
   1626          //*-----------------------------------------------------------------------------
   1627          char sIntToStr (signed short int Value, char *Vstring) 
   1628          { 
   1629                char znak=0;
   1630                char ind=0;
   1631                if (Value<0) znak='-';
   1632                
   1633                short int ValueTmp=abs(Value);
   1634                
   1635                char wartosc[6];
   1636                
   1637                for (int i=0; i<5; i++) 
   1638                {
   1639                  Vstring[i]=0;
   1640                  wartosc[i]=0;
   1641                }
   1642                  
   1643                
   1644                wartosc[0]   = ValueTmp/10000;
   1645                wartosc[1]   = (ValueTmp-(wartosc[0]*10000))/1000;
   1646                wartosc[2]   = (ValueTmp-(wartosc[0]*10000)-(wartosc[1]*1000))/100;
   1647                wartosc[3]   = (ValueTmp-(wartosc[0]*10000)-(wartosc[1]*1000)-(wartosc[2]*100))/10;
   1648                wartosc[4]   = '.';
   1649                wartosc[5]   = (ValueTmp-(wartosc[0]*10000)-(wartosc[1]*1000)-(wartosc[2]*100)-(wartosc[3]*10));
   1650                
   1651                char PP=0;
   1652                for (char i=0; i<5; i++) 
   1653                  if ((wartosc[i]>0) && (PP==0)) 
   1654                  {
   1655                    if (wartosc[i]=='.') PP=i; else PP=i+1;
   1656                  
   1657                  }
   1658                
   1659                if ((PP==0) && (wartosc[5]==0))
   1660                {
   1661                  ind=1;
   1662                  Vstring[0]='0';
   1663                }
   1664                else
   1665                {
   1666                  if (znak) 
   1667                  {
   1668                    Vstring[ind++]='-';
   1669                  }
   1670                  if (PP>0)
   1671                  for (char i=PP-1; i<4; i++)
   1672                  {
   1673                    Vstring[ind]=48+wartosc[i];
   1674                    ind++;
   1675                  }
   1676                  
   1677                    Vstring[ind]='.';
   1678                    Vstring[++ind]=48+wartosc[5];
   1679                    ind++;
   1680                }
   1681                
   1682                return ind;
   1683                
   1684                 
   1685          }//_______________________ Koniec funkcji konwersji float na string ____________________________
   1686          
   1687          
   1688          
   1689          
   1690          
   1691          
   1692          
   1693          //*-----------------------------------------------------------------------------
   1694          //* Nazwa funkcji :    FloToStr
   1695          //* Funkcja konwersji zmiennej float na ³añcuch string   
   1696          //*-----------------------------------------------------------------------------
   1697          //*  Value   - zmienna typu float
   1698          //*  Vstring - tablica znaków
   1699          //*  ill     - liloœæ znaków (max=9) , ostatnia wartoœæ zapisanego ³añcucha to zawsze 0
   1700          //*  Funkcja zwraca d³ugoœæ ³añcucha
   1701          //*-----------------------------------------------------------------------------
   1702          void HexToStr (int Value, char Vstring[8],char length) 
   1703          { 
   1704                length=length-1; 
   1705                for (int i=0; i<=length; i++) Vstring[i]=0;
   1706                 
   1707                 for (int i=0; i<=length; i++)
   1708                 {
   1709                    Vstring[length-i]=((Value>>(4*i))&0xf)+48;  
   1710                    
   1711                    if (Vstring[length-i]>57) {Vstring[length-i]+=7;}
   1712          
   1713                    
   1714                 }   
   1715             
   1716             
   1717             
   1718          }//_______________________ Koniec funkcji konwersji float na string ____________________________
   1719          
   1720          
   1721          
   1722          
   1723          
   1724          
   1725          
   1726          
   1727          
   1728          
   1729          //*-----------------------------------------------------------------------------
   1730          //* Nazwa funkcji :    List_Paint
   1731          //* Funkcja rysowania listy
   1732          //*-----------------------------------------------------------------------------
   1733          //* name[7]   -  Nazwa listy
   1734          //* Rows      -  ilosc wierszy
   1735          //* RowWith   -  szerokosc wiersza
   1736          //* Y         -  odsuniecie od górnej krawêdzi
   1737          //* FormStyle -  rodzaj formy 0-zwyk³a 1..-coraz mniejsze
   1738          //* Algin     - wyrównanie 0-pion œrodek, poziom lowo, 1-pion góra, poziom lowo, 2 pion dó³, poziom lowo, 3-pion œrodek, poziom wyœrodkowanie
   1739          //* p1...p8   - nazwy kolejnych pól
   1740          //*-----------------------------------------------------------------------------
   1741          
   1742          char RealRows;
   1743          char RowsPoz;
   1744          void List_Paint(char name[10], char Rows, char RowWith, char Y, char FormStyle, char Algin, __String p,...)
   1745          {
   1746            
   1747            
   1748           va_list parg; 
   1749           va_start( parg, p);// pocz¹tek pracy ze zmienn¹ list¹ parametrów 
   1750          char *par[20];
   1751          char idf=0;
   1752          par[0] =p;
   1753          while(idf<Rows) {par[++idf] = va_arg( parg, char*);} 
   1754          va_end(parg); 
   1755            
   1756          
   1757            RealRows=Rows;
   1758            if ((Rows>7) && (RowWith>13)) Rows=6;
   1759            if ((Rows>8) && (RowWith<=13)) Rows=7;
   1760            
   1761            if (FormStyle<4) 
   1762            {
   1763              CleanCanvas();
   1764            }
   1765            else
   1766            {
   1767              //  HalfCleanCanvas();
   1768              if (FormStyle)
   1769              {     
   1770                CleanCanvasArea(FormStyle-1, 127-(Y+18+(RowWith*Rows))-2, 62-2*FormStyle+4,(RowWith*Rows)+5,0);
   1771              
   1772              }
   1773              else
   1774              {
   1775                CleanCanvasArea(0, 127-(18+(RowWith*Rows))+Y, 62,(RowWith*Rows),0);
   1776          
   1777              }
   1778            }
   1779            
   1780             
   1781            
   1782           
   1783            if (FormStyle==0)
   1784            {
   1785            char ekran_tab[8][18] = {
   1786                            {255,1,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,252},
   1787                            {255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
   1788                            {255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
   1789                            {255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
   1790                            {255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
   1791                            {255,0,255,255,127,127,127,127,127,127,127,127,127,127,127,127,255,255},
   1792                            {255,0,255,0,254,255,251,247,111,159,159,111,247,251,255,254,0,255},
   1793                            {255,128,255,240,231,239,237,238,239,239,239,239,238,237,111,103,48,31}
   1794                            };
   1795              
   1796              CopyToCanvasPoint((char *)ekran_tab,0,109-Y,64,18); 
   1797              Label(name,0,2,114-Y,10,42,0,127,1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1798              
   1799             } 
   1800              
   1801           if (Rows>0)
   1802           {
   1803              
   1804              char napis1_Y=110-Y-(RowWith/2)-5;
   1805          
   1806              
   1807          
   1808              for (char i=0; i<=Rows-1; i++)
   1809              {
   1810                 if (par[i+RowsPoz]>0)
   1811                 switch (Algin)
   1812                 {
   1813                    case 0: Label(par[i+RowsPoz],0,2+FormStyle,napis1_Y-RowWith*i,15,58-2*FormStyle,0,127,0);     break; //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1814                    case 1: Label(par[i+RowsPoz],0,2+FormStyle,110-Y-10-RowWith*i,15,58-2*FormStyle,0,127,0);     break; //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1815                    case 2: Label(par[i+RowsPoz],0,2+FormStyle,110-Y+1-RowWith*(i+1),15,58-2*FormStyle,0,127,0);  break; //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw)   
   1816                    case 3: Label(par[i+RowsPoz],2,2+FormStyle,napis1_Y-RowWith*i,15,58-2*FormStyle,0,127,0);     break; //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1817                 }   
   1818              }
   1819              
   1820              
   1821              if (~FormStyle) H_line(2,127-(17)-Y,54,0); 
   1822              
   1823              V_line(62-FormStyle,127-(18+(Rows*RowWith))-Y,(Rows*RowWith),1);
   1824              if (FormStyle)
   1825              {
   1826                  V_line(63-FormStyle,127-(18+(Rows*RowWith))-Y,(Rows*RowWith)-2,1);
   1827              }
   1828              else
   1829              {
   1830                  V_line(63-FormStyle,127-(18+(Rows*RowWith))-Y,(Rows*RowWith),1); 
   1831              }
   1832              
   1833              V_line(FormStyle,127-(18+(Rows*RowWith))-Y,(Rows*RowWith),1);
   1834              
   1835              if (FormStyle) H_line(FormStyle,127-18-Y,63-2*FormStyle,1); 
   1836              
   1837              for (char i=18+RowWith; i<=18+(Rows*RowWith); i=i+RowWith)
   1838              {
   1839                H_line(1+FormStyle,127-i-Y,61-2*FormStyle,1); 
   1840              }
   1841              
   1842              H_line(4+FormStyle,127-(18+(Rows*RowWith))-1-Y,60-(2*FormStyle),1); 
   1843            
   1844           
   1845              if (RealRows!=Rows) //je¿eli wiêcej pozycji ni¿ na ekranie
   1846              {
   1847                 char LabelButt1[2], LabelButt2[2];
   1848                 LabelButt1[1]=0; LabelButt2[1]=0;  //LabelButt1 -góra, LabelButt2-dó³
   1849                 LabelButt1[0]=30; LabelButt2[0]=31;
   1850                 
   1851                 if (RowsPoz==0)
   1852                 {
   1853                    Button(LabelButt2,0,127-(18+(Rows*RowWith))-1-Y-15,64,16); //(etykieta char poz_X , char poz_Y ,char width, char height) 
   1854                 } 
   1855                 if ((RowsPoz>0) && (RowsPoz<RealRows-Rows))
   1856                 {
   1857                   Button(LabelButt1,0,127-(18+(Rows*RowWith))-1-Y-15,32,16); //(etykieta ,char poz_X , char poz_Y ,char width, char height)
   1858                   Button(LabelButt2,32,127-(18+(Rows*RowWith))-1-Y-15,32,16); //(etykieta char poz_X , char poz_Y ,char width, char height) 
   1859                 }
   1860                 if ((RowsPoz>0) && (RowsPoz>=RealRows-Rows))
   1861                 {
   1862                   Button(LabelButt1,0,127-(18+(Rows*RowWith))-1-Y-15,64,16); //(etykieta ,char poz_X , char poz_Y ,char width, char height)
   1863                 }
   1864                 
   1865                
   1866              }
   1867              
   1868              
   1869              
   1870              //bar poziomy
   1871              if (RealRows!=Rows)
   1872              {
   1873                 char MaxPoz = 127-19;
   1874                 char MinPoz = 127-(18+(Rows*RowWith))-1-Y+2;
   1875                 char Zakres =MaxPoz-MinPoz;
   1876                 char DlOdc=RealRows-Rows;
   1877                 DlOdc=RealRows-Rows+1;
   1878                 DlOdc=Zakres/DlOdc;
   1879                 char poz=RowsPoz*DlOdc;
   1880                 poz=MaxPoz-poz-DlOdc;
   1881                 V_line (61, MinPoz,Zakres+1, 1);  //V_line (char X, int Y, char lenght, char typ) 
   1882                 V_line (62, poz,DlOdc, 0);  //V_line (char X, int Y, char lenght, char typ) 
   1883              }
   1884              
   1885           }else{
   1886             V_line(0,1,115,1); 
   1887             V_line(63,0,115,1);
   1888             V_line(62,0,115,1);
   1889             H_line(0,1,63,1);
   1890             H_line(4,0,59,1);
   1891           }
   1892              
   1893          }//_______________________ Koniec funkcji List_Paint __________________________
   1894          
   1895          
   1896          
   1897              
   1898          
   1899          
   1900          
   1901          
   1902          
   1903          //*-----------------------------------------------------------------------------
   1904          //* Nazwa funkcji :    List_Event
   1905          //* Funkcja rysowania listy
   1906          //*-----------------------------------------------------------------------------
   1907          //* name[7]   -  Nazwa listy
   1908          //* Rows      -  ilosc wierszy
   1909          //* RowWith   -  szerokosc wiersza
   1910          //* Y         -  odsuniecie od górnej krawêdzi
   1911          //* p1...p8   - nazwy kolejnych pól
   1912          //*-----------------------------------------------------------------------------
   1913          
   1914          int List_Event(int X_up, int Y_up, int X_down, int Y_down, char Rows, char RowWith, char FormStyle, char Y)
   1915          {
   1916            static char SelectRow; 
   1917            char podswietl=0;
   1918            int ans = 0;
   1919            char AnsDown;
   1920             static char DownAction=0;
   1921          char Y_up_tmp=127-Y_up;
   1922          
   1923              static char Xdown=0;
   1924          
   1925            //zdarzenie typu down "X"
   1926              if ((FormStyle==0) && (X_down>46) && (X_down<63) && (Y_down>112-Y) && (Y_down<127-Y))    //"X"
   1927              {
   1928                MenuPaint();
   1929                H_line(49,114-Y,10,0);
   1930                H_line(49,123-Y,10,0); 
   1931                V_line(49,114-Y,10,0); 
   1932                V_line(58,114-Y,10,0); 
   1933                podswietl=1;
   1934          
   1935                DownAction=1;
   1936                AnsDown=0xFF;
   1937                
   1938                if ((!(AT91C_IFLASH_MEM->Config.SoundOff)) && (Xdown==0)) {
   1939                  ButtonBipCounter=g_counter+8;
   1940                    AT91C_BASE_PIOA->PIO_SODR =SpeakerPin;
   1941                  } 
   1942                Xdown=1;
   1943                
   1944              }
   1945            
   1946              
   1947              if ((FormStyle==0) && (X_up>46) && (X_up<63) && (Y_up>112-Y) && (Y_up<127-Y))                    //"X"
   1948              {
   1949                RowsPoz=0;
   1950                ans = -1;
   1951                      if ((!(AT91C_IFLASH_MEM->Config.SoundOff)) && (Xdown==1)) 
   1952                      {
   1953                        ButtonBipCounter=g_counter+8;
   1954                        AT91C_BASE_PIOA->PIO_SODR =SpeakerPin;
   1955                      } 
   1956                      Xdown=0;
   1957              }  
   1958          
   1959              
   1960              if (Rows>0)
   1961              {
   1962          
   1963          
   1964              if ((Rows>7) && (RowWith>13)) Rows=6;
   1965              if ((Rows>8) && (RowWith<=13)) Rows=7;
   1966          
   1967            //zdarzenie typu down
   1968              if ((X_down>FormStyle) && (X_down<63-FormStyle) && (Y_down>127-(17+(Rows*RowWith))-Y) && (Y_down<127-(17)-Y) && (RowWith))   
   1969              {
   1970                char Y_down_tmp=127-Y_down;
   1971                MenuPaint();
   1972                H_line(2+FormStyle,127-(  (((Y_down_tmp-18-Y) / RowWith)*RowWith)    +18+Y)-1,61-2*FormStyle,1);
   1973                H_line(2+FormStyle,127-(  (((Y_down_tmp-18-Y) / RowWith)*RowWith)    +18+Y)-(RowWith-1),61-2*FormStyle,1);
   1974                V_line(1+FormStyle,127-(  (((Y_down_tmp-18-Y) / RowWith)*RowWith)    +18+Y)-(RowWith-1),RowWith-1,1);
   1975                V_line(61-FormStyle,127-(  (((Y_down_tmp-18-Y) / RowWith)*RowWith)    +18+Y)-(RowWith-2),RowWith-3,1);
   1976                podswietl=1;
   1977                DownAction=1;
   1978                
   1979                DownAction=1;
   1980                AnsDown=((Y_down_tmp-18-Y) / RowWith)+1;
   1981                
   1982                //dzwiêk przyciœniêcia
   1983                    static char LastAnsD=-1;
   1984                    if ((AnsDown>=0) && (AnsDown!=LastAnsD))
   1985                    {
   1986                      if ((!(AT91C_IFLASH_MEM->Config.SoundOff))) {
   1987                          ButtonBipCounter=g_counter+8;
   1988                          AT91C_BASE_PIOA->PIO_SODR =SpeakerPin;
   1989                          
   1990                        } 
   1991                    }
   1992                    LastAnsD=AnsDown;
   1993                    Xdown=0;
   1994                
   1995           }
   1996              
   1997          
   1998          
   1999              
   2000              
   2001              
   2002              if ((RowWith) &(X_up>3) && (X_up<59) && (Y_up<127-(  (((Y_up_tmp-18-Y) / RowWith)*RowWith)    +18+Y)-1) && (Y_up>127-(  (((Y_up_tmp-18-Y) / RowWith)*RowWith)    +18+Y)-(RowWith-1)))                        //ustawienia
   2003              {
   2004                ans=RowsPoz+((Y_up_tmp-18-Y) / RowWith)+1;
   2005               // MenuPaint();
   2006              }
   2007              
   2008              if ((FormStyle==0) && (X_up>46) && (X_up<63) && (Y_up>112-Y) && (Y_up<127-Y))                    //"X"
   2009              {
   2010                ans = -1;
   2011             
   2012              }   
   2013              if ((podswietl==0)) MenuPaint();
   2014              
   2015              if (ans>RowsPoz+Rows) ans=0;  
   2016           
   2017          
   2018              if ((AnsDown>0) && (SelectRow!=AnsDown))
   2019              {
   2020                 SelectRow=AnsDown;
   2021                  
   2022              }else if (ans<0)
   2023              {
   2024                SelectRow=0;
   2025              }
   2026              
   2027              char Button1Action=0;
   2028              char Button2Action=0;
   2029              if (RealRows!=Rows) //je¿eli wiêcej pozycji ni¿ na ekranie
   2030              {
   2031                 char LabelButt1[2], LabelButt2[2];
   2032                 LabelButt1[1]=0; LabelButt2[1]=0;
   2033                 LabelButt1[0]=30; LabelButt2[0]=31;
   2034                 //LabelButt1 -góra, LabelButt2-dó³
   2035                 if (RowsPoz==0)
   2036                 {
   2037                    Button2Action=Button(LabelButt2,0,127-(18+(Rows*RowWith))-1-Y-15,64,16); //(etykieta char poz_X , char poz_Y ,char width, char height) 
   2038                 } 
   2039                 if ((RowsPoz>0) && (RowsPoz<RealRows-Rows))
   2040                 {
   2041                   Button1Action=Button(LabelButt1,0,127-(18+(Rows*RowWith))-1-Y-15,32,16); //(etykieta ,char poz_X , char poz_Y ,char width, char height)
   2042                   Button2Action=Button(LabelButt2,32,127-(18+(Rows*RowWith))-1-Y-15,32,16); //(etykieta char poz_X , char poz_Y ,char width, char height) 
   2043                 }
   2044                 if ((RowsPoz>0) && (RowsPoz>=RealRows-Rows))
   2045                 {
   2046                   Button1Action=Button(LabelButt1,0,127-(18+(Rows*RowWith))-1-Y-15,64,16); //(etykieta ,char poz_X , char poz_Y ,char width, char height)
   2047                 }
   2048              
   2049                 if (Button1Action==1) {RowsPoz--;  MenuPaint(); }
   2050                 if (Button2Action==1) {RowsPoz++;  MenuPaint(); }
   2051              }
   2052              
   2053              }
   2054              
   2055             // if (ans>0) RowsPoz=0;
   2056              static char LastAns=-1;
   2057              if ((ans>=0) && (ans!=LastAns))
   2058              {
   2059                Xdown=0;
   2060                if ((!(AT91C_IFLASH_MEM->Config.SoundOff))) {
   2061                  ButtonBipCounter=g_counter+8;
   2062                    AT91C_BASE_PIOA->PIO_SODR =SpeakerPin;
   2063                  } 
   2064              }
   2065              
   2066              if ((X_up>0)|| (Y_up>0)) Xdown=0;
   2067              LastAns=ans;
   2068              return ans;
   2069            
   2070              
   2071              
   2072          }//_______________________ Koniec funkcji List_Event __________________________
   2073          
   2074          
   2075          
   2076          
   2077          //*-----------------------------------------------------------------------------
   2078          //* Nazwa funkcji :    ScrollList_Paint
   2079          //* Funkcja rysowania listy
   2080          //*-----------------------------------------------------------------------------
   2081          //* name[7]   -  Nazwa listy
   2082          //* Size_scroll  -  wielkosc listy
   2083          //* poz   -1 -  poziome linie rozdzielaj¹ce
   2084          
   2085          //*-----------------------------------------------------------------------------
   2086          
   2087          void ScrollList_Paint(char name[15], int Size_scroll, int *_Suw_poz, char poz)
   2088              {
   2089          
   2090                 char ekran_tab[8][128] = {
   2091                            {254,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,255,3,253,245,237,221,61,61,221,237,245,253,3,254},
   2092                            {255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,240,239,235,237,238,239,239,238,237,235,239,240,255},
   2093                            {255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
   2094                            {255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
   2095                            {255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
   2096                            {255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
   2097                            {255,96,32,32,32,32,32,32,32,32,32,32,32,32,32,32,224,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,160,96,224,32,32,32,32,32,32,32,32,32,32,32,32,32,32,96,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
   2098                            {127,192,128,128,128,128,132,142,159,155,128,128,128,128,128,128,255,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,170,213,255,128,128,128,128,155,159,142,132,128,128,128,128,128,128,192,255,255,255,255,255,255,255,255,255,255,255,255,127,63},
   2099                            };
   2100               
   2101                 
   2102                  char suwak[14] = {128,255,255,255,255,224,238,238,224,255,255,255,255,128};
   2103                  
   2104                  int Suw_poz_tmp;
   2105                  //rysowanie wskaŸnika po³o¿enia
   2106                  if (Size_scroll>50)
   2107                  {
   2108                      Suw_poz_tmp=98-(((*_Suw_poz)*67)/Size_scroll)-14;
   2109              
   2110                      for (int i=(Suw_poz_tmp); i<=Suw_poz_tmp+13; i++)
   2111                      {
   2112                        ekran_tab[7][i]=suwak[i-Suw_poz_tmp];
   2113                      }
   2114                  }
   2115                  
   2116                  CopyToCanvas(ekran_tab);
   2117                  
   2118                  Label(name,0,15,116,15,46,0,127,1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2119                  if ((poz) && (Size_scroll>50))
   2120                  {
   2121                    H_line(54,Suw_poz_tmp,9,0);
   2122                    H_line(54,Suw_poz_tmp+13,9,0);
   2123                    V_line(54,Suw_poz_tmp+1,12,1); 
   2124                    V_line(55,Suw_poz_tmp+1,12,1); 
   2125                  }
   2126              
   2127              }//_________________________________________________________________________
   2128          
   2129          
   2130          
   2131          
   2132          
   2133          //*-----------------------------------------------------------------------------
   2134          //* Nazwa funkcji :    Ask_Paint
   2135          //* Funkcja rysowania listy
   2136          //*-----------------------------------------------------------------------------
   2137          //* name[7]   -  Nazwa listy
   2138          //* p1...p2   - nazwy kolejnych pól
   2139          //*-----------------------------------------------------------------------------
   2140          void Ask_Paint(char name[10], char p1[15], char p2[15])
   2141          {
   2142          
   2143          
   2144              List_Paint(name,1,47,25,0,3," "); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char back, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])
   2145                 
   2146              
   2147             if (p1!="") Label(p1,2,2,71,15,59,0,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2148             if (p2!="")  Label(p2,2,2,62,15,59,0,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2149              Label(" ",2,2,53,15,59,0,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2150          
   2151          
   2152              
   2153              char ekran_tab[8][15] = {
   2154                            {249,13,245,245,245,245,245,245,245,245,245,245,245,13,249},
   2155                            {255,0,255,255,119,55,55,87,103,103,119,255,255,0,255},
   2156                            {255,0,255,255,199,187,187,187,187,187,199,255,255,0,255},
   2157                            {63,96,95,95,95,95,95,95,95,95,95,95,95,96,63},
   2158                            {254,3,253,253,253,253,253,253,253,253,253,253,253,3,254},
   2159                            {255,0,255,255,227,221,221,221,221,221,227,255,255,0,255},
   2160                            {255,0,255,255,238,246,250,252,250,246,238,255,255,0,255},
   2161                            {207,216,215,215,215,215,215,215,215,215,215,215,215,216,207},
   2162                            };
   2163              
   2164              CopyToCanvasPoint((char *)ekran_tab,0,40,64,15); 
   2165              H_line(2,57,59,1); 
   2166              
   2167              
   2168          }//_______________________ Koniec funkcji Ask_Paint __________________________
   2169          
   2170          
   2171          
   2172          
   2173          //*-----------------------------------------------------------------------------
   2174          //* Nazwa funkcji :    List_Event
   2175          //* Funkcja rysowania listy
   2176          //*-----------------------------------------------------------------------------
   2177          //* name[7]   -  Nazwa listy
   2178          //* Rows      -  ilosc wierszy
   2179          //* RowWith   -  szerokosc wiersza
   2180          //* Y         -  odsuniecie od górnej krawêdzi
   2181          //* p1...p8   - nazwy kolejnych pól
   2182          //*-----------------------------------------------------------------------------
   2183          int Ask_Event(int X_up, int Y_up, int X_down, int Y_down)
   2184          {
   2185            char Y=25;
   2186            
   2187            char podswietl=0;
   2188            int ans = 0;
   2189            
   2190          
   2191          
   2192          
   2193            
   2194            //zdarzenie typu down 
   2195              for (char i=0; i<=30; i=i+30)
   2196              {
   2197            
   2198                  if ((X_down>2+i) && (X_down<51+i) &&  (Y_down>38) && (Y_down<55))   
   2199                  {  
   2200                    //MenuPaint();
   2201                    H_line(4+i,41,26,1);
   2202                    H_line(4+i,53,26,1);
   2203                    V_line(3+i,41,12,1);
   2204                    V_line(29+i,42,13,1);
   2205                    podswietl=1;
   2206                  }
   2207              }
   2208          
   2209           
   2210            //zdarzenie typu down "X"
   2211              if ((X_down>46) && (X_down<63) && (Y_down>112-Y) && (Y_down<127-Y))    //"X"
   2212              {
   2213                //MenuPaint();
   2214                H_line(49,114-Y,10,0);
   2215                H_line(49,123-Y,10,0); 
   2216                V_line(49,114-Y,10,0); 
   2217                V_line(58,114-Y,10,0); 
   2218                podswietl=1;
   2219              }
   2220            
   2221              
   2222              if ((X_up>46) && (X_up<63) && (Y_up>112-Y) && (Y_up<127-Y))                    //"X"
   2223              {
   2224                ans = -1;
   2225              }  
   2226          
   2227              
   2228                //zdarzenie typu down 
   2229              for (char i=0; i<=1; i++)
   2230              {
   2231                  if ((X_up>2+(i*30)) && (X_up<51+(i*30)) &&  (Y_up>38) && (Y_up<55))   
   2232                  {  
   2233                     ans=i+1;
   2234                  }
   2235              }
   2236          
   2237             // if ((X_down>=0) && (X_down<64) && (podswietl==0)) {MenuPaint();}
   2238          
   2239          
   2240              return ans;
   2241            
   2242          }//_______________________ Koniec funkcji List_Event __________________________
   2243          
   2244          
   2245          
   2246          
   2247          //*-----------------------------------------------------------------------------
   2248          //* Nazwa funkcji :    Info_Paint
   2249          //* Funkcja info
   2250          //*-----------------------------------------------------------------------------
   2251          //* p1...p2   - nazwy kolejnych pól
   2252          //*-----------------------------------------------------------------------------
   2253          void Message(char p1[15], char p2[15], int MenuLevelJump)
   2254          {
   2255          
   2256          
   2257              List_Paint("Info ",1,47,25,0,3,0,0,0,0,0,0,0,0); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char back, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])
   2258                 
   2259              
   2260             if (p1!="")  Label(p1,2,2,71,15,59,0,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2261             if (p2!="")  Label(p2,2,2,62,15,59,0,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2262              Label(" ",2,2,53,15,59,0,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2263              H_line(2,57,59,1); 
   2264             
   2265              if (Button("Ok ",12,40,40,15))
   2266              {
   2267                MenuLevel=MenuLevelJump;
   2268                MenuPaint();
   2269              }
   2270              
   2271              
   2272          }//_______________________ Koniec funkcji Info_Paint __________________________
   2273          
   2274          
   2275          
   2276          
   2277          //*-----------------------------------------------------------------------------
   2278          //* Nazwa funkcji :    List_Paint
   2279          //* Funkcja rysowania listy
   2280          //*-----------------------------------------------------------------------------
   2281          //* name[7]   -  Nazwa listy
   2282          //* Rows      -  ilosc wierszy
   2283          //* RowWith   -  szerokosc wiersza
   2284          //* Y         -  odsuniecie od górnej krawêdzi
   2285          //* FormStyle -  rodzaj formy 0-zwyk³a 1..-coraz mniejsze
   2286          //* Algin     - wyrównanie 0-pion œrodek, poziom lowo, 1-pion góra, poziom lowo, 2 pion dó³, poziom lowo, 3-pion œrodek, poziom wyœrodkowanie
   2287          //* p1...p8   - nazwy kolejnych pól
   2288          //*-----------------------------------------------------------------------------
   2289          void Number_Paint(char name[10], char p1[1], char p2[1])
   2290          {
   2291           
   2292            CleanCanvas();
   2293          
   2294            char ekran_tab[8][128] = {
   2295                            {254,255,3,249,5,245,245,245,245,245,245,245,245,245,245,245,245,245,245,5,249,1,1,249,5,245,245,245,245,245,245,245,245,245,245,245,245,245,245,5,249,1,1,249,5,245,245,245,245,245,245,245,245,245,245,245,245,245,245,5,249,1,1,249,5,245,245,245,245,245,245,245,245,245,245,245,245,245,245,5,249,3,255,255,255,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,255,3,255,255,255,255,255,255,255,255,255,255,255,254,252,248},
   2296                            {255,255,0,255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,255,0,0,255,0,255,255,249,249,249,243,243,243,231,231,207,192,255,255,0,255,0,0,255,0,255,255,231,231,192,230,229,229,227,227,231,231,255,255,0,255,0,0,255,0,255,255,231,231,231,231,231,231,229,225,227,231,255,255,0,255,0,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
   2297                            {255,255,0,7,136,139,139,139,139,139,139,139,139,139,139,139,139,139,139,136,7,0,0,7,136,139,139,139,139,139,139,139,139,139,139,139,139,139,139,136,7,0,0,7,136,139,139,139,139,139,139,139,139,139,139,139,139,139,139,136,7,0,0,7,136,139,139,139,139,139,139,139,139,139,139,139,139,139,139,136,7,0,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
   2298                            {255,255,0,255,0,254,254,62,158,158,158,158,158,158,158,158,62,254,254,0,255,0,0,255,0,254,254,62,158,158,158,158,62,158,158,158,62,254,254,0,255,0,0,255,0,254,254,62,158,254,254,254,158,30,158,62,62,254,254,0,255,0,0,255,0,254,254,30,158,62,126,126,254,254,254,158,62,254,254,0,255,0,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
   2299                            {255,255,0,255,0,127,127,124,121,121,121,121,121,121,121,121,124,127,127,0,255,0,0,255,0,127,127,124,121,121,121,121,124,121,121,121,124,127,127,0,255,0,0,255,0,127,127,124,121,121,121,121,121,124,127,127,120,127,127,0,255,0,0,255,0,127,127,120,127,127,126,124,124,121,121,121,124,127,127,0,255,0,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255},
   2300                            {255,255,0,224,17,209,209,209,209,209,209,209,209,209,209,209,209,209,209,17,224,0,0,224,17,209,209,209,209,209,209,209,209,209,209,209,209,209,209,17,224,0,0,224,17,209,209,209,209,209,209,209,209,209,209,209,209,209,209,17,224,0,0,224,17,209,209,209,209,209,209,209,209,209,209,209,209,209,209,17,224,0,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,192,127,127,127,127,127,127,127,127,127,127,127,127,255,255},
   2301                            {255,255,0,255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,255,0,0,255,0,255,255,199,179,63,63,7,51,51,51,51,135,255,255,0,255,0,0,255,0,255,255,135,51,51,49,49,129,241,243,55,143,255,255,0,255,0,0,255,0,255,255,135,51,63,63,63,143,63,63,51,135,255,255,0,255,0,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,254,255,251,247,111,159,159,111,247,251,255,254,0,255},
   2302                            {127,255,192,159,160,175,175,175,175,175,175,175,175,175,175,175,175,175,175,160,159,128,128,159,160,175,175,175,175,175,175,175,175,175,175,175,175,175,175,160,159,128,128,159,160,175,175,175,175,175,175,175,175,175,175,175,175,175,175,160,159,128,128,159,160,175,175,175,175,175,175,175,175,175,175,175,175,175,175,160,159,192,255,255,255,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,192,255,240,231,239,237,238,239,239,239,239,238,237,239,103,48,31},
   2303                            };
   2304              
   2305              CopyToCanvas(ekran_tab);
   2306              Label(name,0,2,116,10,42,0,127,1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2307              
   2308           
   2309              
   2310          
   2311          
   2312              Label(p1,0,9,7,2,7,0,127,1);      //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2313              Label(p2,0,51,7,2,7,0,127,1);    //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2314              
   2315          }//_______________________ Koniec funkcji List_Paint __________________________
   2316          
   2317          
   2318          
   2319          
   2320          
   2321          //*-----------------------------------------------------------------------------
   2322          //* Nazwa funkcji :    Number_Event
   2323          //* Funkcja rysowania listy
   2324          //*-----------------------------------------------------------------------------
   2325          //* name[7]   -  Nazwa listy
   2326          //* Rows      -  ilosc wierszy
   2327          //* RowWith   -  szerokosc wiersza
   2328          //* Y         -  odsuniecie od górnej krawêdzi
   2329          //* p1...p8   - nazwy kolejnych pól
   2330          //*-----------------------------------------------------------------------------
   2331          int Number_Event(int X_up, int Y_up, int X_down, int Y_down)
   2332          {
   2333          
   2334            char podswietl=0;
   2335            int ans = 0;
   2336            char kol = 0;
   2337            char row = 0;
   2338            
   2339          
   2340          
   2341            //zdarzenie typu down (najechanie na przycisk)
   2342            if ((X_down>1) && (X_down<62) && (Y_down>3) && (Y_down<81) && (X_down!=21) && (X_down!=42) && (Y_down!=61) && (Y_down!=41) && (Y_down!=21) )   
   2343              {
   2344                kol = (((X_down-1)/21))*21;
   2345                row = (((Y_down-3)/20))*20;
   2346                
   2347                MenuPaint();   
   2348                
   2349                H_line(kol+3, row+4, 16,1);
   2350                H_line(kol+3, row+19, 16,1);
   2351                V_line(kol+3, row+4, 16,1);
   2352                V_line(kol+18, row+4, 16,1);
   2353             
   2354                podswietl=1;
   2355              }
   2356           
   2357          
   2358              
   2359            //zdarzenie typu down "X"
   2360              if ((X_down>46) && (X_down<63) && (Y_down>112) && (Y_down<127))    //"X"
   2361              {
   2362                MenuPaint();
   2363                H_line(49,115,10,0);
   2364                H_line(49,124,10,0); 
   2365                V_line(49,115,10,0); 
   2366                V_line(58,115,10,0); 
   2367                podswietl=1;
   2368              }
   2369             
   2370            
   2371             //zdarzenie typu up (naciœniêcie na "X")
   2372              if ( (X_up>46) && (X_up<63) && (Y_up>112) && (Y_up<127))                    //"X"
   2373              {
   2374                ans = -1;
   2375              }  
   2376            
   2377            
   2378              if ((X_up>1) && (X_up<62) && (Y_up>3) && (Y_up<81) && (X_up!=21) && (X_up!=42) && (Y_up!=61) && (Y_up!=41) && (Y_up!=21) )   
   2379              {
   2380                kol = (((X_up-1)/21)+1);
   2381                row = 3-(((Y_up-3)/20));
   2382          
   2383                ans=(row*3)+kol;
   2384                
   2385                if ((!(AT91C_IFLASH_MEM->Config.SoundOff)) && (AlarmOn==0)) {
   2386                  ButtonBipCounter=g_counter+8;
   2387                    AT91C_BASE_PIOA->PIO_SODR =SpeakerPin;
   2388                  } 
   2389              }
   2390          
   2391            
   2392              if ((X_down>=0) && (X_down<64) && (podswietl==0)) MenuPaint();
   2393          
   2394           
   2395          
   2396              return ans;
   2397            
   2398              
   2399          }//_______________________ Koniec funkcji List_Event __________________________
   2400          
   2401          
   2402          
   2403          
   2404          
   2405          
   2406          
   2407          
   2408          
   2409          //*-----------------------------------------------------------------------------
   2410          //* Nazwa funkcji :    Message_Paint
   2411          //* Funkcja wiadomosci
   2412          //*-----------------------------------------------------------------------------
   2413          //* algin    - wyrównanie tekstu
   2414          //* p1..p3   -   napisy kolejnych lini
   2415          
   2416          //*-----------------------------------------------------------------------------
   2417          extern  char g_Message;
   2418          void Message_Paint(char algin, char p1[15], char p2[15], char p3[15],char p4[15],char p5[15])
   2419          {
   2420            g_Message=1;
   2421            g_info=1;
   2422            
   2423            char ekran_tab[8][128] = {
   2424                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,1,253,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,229,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,253,1,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
   2425                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,0,0,248,12,244,244,244,244,244,244,244,244,244,244,12,248,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
   2426                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,0,0,255,0,255,255,255,255,255,255,255,255,255,255,0,255,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
   2427                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,0,0,255,0,255,255,199,187,187,187,187,187,199,255,0,255,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
   2428                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,0,0,255,0,255,255,221,237,245,249,245,237,221,255,0,255,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
   2429                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,0,0,255,0,255,255,255,255,255,255,255,255,255,255,0,255,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
   2430                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,0,0,63,96,95,95,95,95,95,95,95,95,95,95,96,63,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
   2431                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,128,191,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,167,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,160,191,128,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
   2432                            };
   2433              
   2434              CopyToCanvas(ekran_tab);
   2435          
   2436          
   2437              if (p1!="") Label(p1,algin,4,90,15,56,0,127,0);      //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2438              if (p2!="") Label(p2,algin,4,90-9,15,56,0,127,0);    //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2439              if (p3!="") Label(p3,algin,4,90-18,15,56,0,127,0);    //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2440              if (p4!="") Label(p4,algin,4,90-27,15,56,0,127,0);    //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2441              if (p5!="") Label(p5,algin,4,90-36,15,56,0,127,0);    //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2442              
   2443              
   2444          }//_______________________ Koniec funkcji Mesage_Paint __________________________
   2445          
   2446          
   2447          
   2448          
   2449          
   2450          
   2451          
   2452          //*-----------------------------------------------------------------------------
   2453          //* Nazwa funkcji :    FloToStr
   2454          //* Funkcja konwersji zmiennej float na ³añcuch string   
   2455          //*-----------------------------------------------------------------------------
   2456          //*  Value   - zmienna typu float
   2457          //*  Vstring - tablica znaków
   2458          //*  ill     - liloœæ znaków (max=9) , ostatnia wartoœæ zapisanego ³añcucha to zawsze 0
   2459          //*  Funkcja zwraca d³ugoœæ ³añcucha
   2460          //*-----------------------------------------------------------------------------
   2461          char FloToStr (float Value, char Vstring[8],char ill) 
   2462          { 
   2463            float str_tmp[15]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};        
   2464             int min;
   2465             ill-=1;
   2466            
   2467             for (char i=0; i<=7; i++)  Vstring[i]=0;
   2468             for (char i=0; i<=14; i++)  str_tmp[i]=0;
   2469             
   2470             min=0;
   2471             if (Value<0)
   2472             {
   2473               Value=Value*(-1); 
   2474               min=1;
   2475               ill-=1;
   2476             }
   2477             
   2478           
   2479             int E_tmp=0;
   2480             int ill_tmp=0;
   2481             int ill_cor=0;
   2482             
   2483             
   2484             if (Value==0)
   2485             {
   2486               Vstring[0]=48;
   2487               ill_tmp=1;
   2488             }
   2489             else
   2490             {
   2491              if (Value>=1000000000000) 
   2492              {
   2493                 Vstring[0]=0x4C; //L
   2494                 Vstring[1]=0x4F; //O
   2495                 Vstring[2]=0x4E; //N
   2496                 Vstring[3]=0x47; //G
   2497                 Vstring[4]=0; Vstring[5]=0; Vstring[6]=0; Vstring[7]=0;
   2498              }  
   2499              else 
   2500              {  
   2501                long long int __Value=(long long int)(Value*1000000);
   2502                long long int __ValueRST=__Value;
   2503                long long int NastDiel=0;
   2504               
   2505                 if (Value>=100000000000 ) {if (E_tmp==0) E_tmp=12;     if (ill_tmp<ill)                   { ill_tmp++;  str_tmp[ill_tmp]=48+__Value    / 100000000000000000; __ValueRST=__Value    % 100000000000000000; }};
   2506                 if (Value>=10000000000  ) {if (E_tmp==0) E_tmp=11;     if (ill_tmp<ill)                   { ill_tmp++;  str_tmp[ill_tmp]=48+__ValueRST / 10000000000000000 ; __ValueRST=__ValueRST % 10000000000000000 ; }};
   2507                 if (Value>=1000000000   ) {if (E_tmp==0) E_tmp=10;     if (ill_tmp<ill)                   { ill_tmp++;  str_tmp[ill_tmp]=48+__ValueRST / 1000000000000000  ; __ValueRST=__ValueRST % 1000000000000000  ; }};
   2508                 if (Value>=100000000    ) {if (E_tmp==0) E_tmp=9;      if (ill_tmp<ill)                   { ill_tmp++;  str_tmp[ill_tmp]=48+__ValueRST / 100000000000000   ; __ValueRST=__ValueRST % 100000000000000   ; }};
   2509                 if (Value>=10000000     ) {if (E_tmp==0) E_tmp=8;      if (ill_tmp<ill)                   { ill_tmp++;  str_tmp[ill_tmp]=48+__ValueRST / 10000000000000    ; __ValueRST=__ValueRST % 10000000000000    ; }};
   2510                 if (Value>=1000000      ) {if (E_tmp==0) E_tmp=7;      if (ill_tmp<ill)                   { ill_tmp++;  str_tmp[ill_tmp]=48+__ValueRST / 1000000000000     ; __ValueRST=__ValueRST % 1000000000000     ; NastDiel=100000000000; }};
   2511                 if (Value>=100000       ) {if (E_tmp==0) E_tmp=6;      if (ill_tmp<ill)                   { ill_tmp++;  str_tmp[ill_tmp]=48+__ValueRST / 100000000000      ; __ValueRST=__ValueRST % 100000000000      ; NastDiel=10000000000 ; }};
   2512                 if (Value>=10000        ) {if (E_tmp==0) E_tmp=5;      if (ill_tmp<ill) { ill_tmp++;  str_tmp[ill_tmp]=48+__ValueRST / 10000000000       ; __ValueRST=__ValueRST % 10000000000       ; NastDiel=1000000000  ; }};
   2513                 if (Value>=1000         ) {if (E_tmp==0) E_tmp=4;      if (ill_tmp<ill) { ill_tmp++;  str_tmp[ill_tmp]=48+__ValueRST / 1000000000        ; __ValueRST=__ValueRST % 1000000000        ; NastDiel=100000000   ; }};
   2514                 if (Value>=100          ) {if (E_tmp==0) E_tmp=3;      if (ill_tmp<ill) { ill_tmp++;  str_tmp[ill_tmp]=48+__ValueRST / 100000000         ; __ValueRST=__ValueRST % 100000000         ; NastDiel=10000000    ; }};
   2515                 if (Value>=10           ) {if (E_tmp==0) E_tmp=2;      if (ill_tmp<ill) { ill_tmp++;  str_tmp[ill_tmp]=48+__ValueRST / 10000000          ; __ValueRST=__ValueRST % 10000000          ; NastDiel=1000000     ; }};
   2516                 if (Value>=1            ) {if (E_tmp==0) E_tmp=1;      if (ill_tmp<ill) { ill_tmp++;  str_tmp[ill_tmp]=48+__ValueRST / 1000000           ; __ValueRST=__ValueRST % 1000000           ; NastDiel=100000      ; }};
   2517                 if (Value>=0.09999      ) {if (E_tmp==0) E_tmp=100;    if ((ill_tmp<ill)&&(__ValueRST>0)) { ill_tmp++;  str_tmp[ill_tmp]=0x2E; ill_tmp++;  str_tmp[ill_tmp]=48+__ValueRST / 100000            ; __ValueRST=__ValueRST % 100000            ; NastDiel=10000; }};
   2518                 if (Value>=0.009999     ) {if (E_tmp==0) E_tmp=101;    if ((ill_tmp<ill)&&(__ValueRST>0)) { ill_tmp++;  str_tmp[ill_tmp]=48+(__ValueRST / 10000)           ; __ValueRST=__ValueRST % 10000             ; NastDiel=1000        ; }};
   2519                 if (Value>=0.0009999    ) {if (E_tmp==0) E_tmp=102;    if ((ill_tmp<ill)&&(__ValueRST>0)) { ill_tmp++;  str_tmp[ill_tmp]=48+(__ValueRST / 1000)            ; __ValueRST=__ValueRST % 1000              ; NastDiel=100         ; }};
   2520                 if (Value>=0.00009999   ) {if (E_tmp==0) E_tmp=103;    if ((ill_tmp<ill)&&(__ValueRST>0)) { ill_tmp++;  str_tmp[ill_tmp]=48+(__ValueRST / 100)             ; __ValueRST=__ValueRST % 100               ; NastDiel=10          ; }};
   2521                 if (Value>=0.000009999  ) {if (E_tmp==0) E_tmp=104;    if ((ill_tmp<ill)&&(__ValueRST>0)) { ill_tmp++;  str_tmp[ill_tmp]=48+(__ValueRST / 10)              ; __ValueRST=__ValueRST % 10                ; NastDiel=1           ; }};
   2522                 if (Value>=0.0000009999 ) {if (E_tmp==0) E_tmp=105;    if ((ill_tmp<ill)&&(__ValueRST>0)) { ill_tmp++;  str_tmp[ill_tmp]=48+(__ValueRST / 1)               ; __ValueRST=__ValueRST % 1                 ; NastDiel=0           ; }};
   2523             
   2524                 if ((__ValueRST) && (NastDiel))
   2525                 {
   2526                   if (((__ValueRST/NastDiel)>5) && (str_tmp[ill_tmp]<57)) { str_tmp[ill_tmp]++; }
   2527                   if (((__ValueRST/NastDiel)>5) && (str_tmp[ill_tmp]==57)) 
   2528                      { 
   2529                        str_tmp[ill_tmp]=0;
   2530                        ill_cor++;
   2531                        if ((str_tmp[ill_tmp-1]>53) && (str_tmp[ill_tmp-1]<57) && ((ill_tmp-1)<1)  )
   2532                          { 
   2533                            str_tmp[ill_tmp-1]++; 
   2534                          }
   2535                          if ((str_tmp[ill_tmp-1]==57) && ((ill_tmp-1)>0)  )
   2536                          {
   2537                            ill_cor++;
   2538                            str_tmp[ill_tmp-1]=0;
   2539                            
   2540                              if ((str_tmp[ill_tmp-2]>53) && (str_tmp[ill_tmp-2]<57) && ((ill_tmp-2)<1)  )
   2541                              { 
   2542                                str_tmp[ill_tmp-2]++; 
   2543                              }
   2544                            
   2545                              if ((str_tmp[ill_tmp-2]==57) && ((ill_tmp-2)>0)  )
   2546                              {
   2547                                  str_tmp[ill_tmp-2]=0;
   2548                                  if ((str_tmp[ill_tmp-3]>53) && (str_tmp[ill_tmp-3]<57) && ((ill_tmp-3)<1)  )
   2549                                  { 
   2550                                    ill_cor++;
   2551                                    str_tmp[ill_tmp-3]++; 
   2552                                  }
   2553                                  if ((str_tmp[ill_tmp-3]==57) && ((ill_tmp-3)>0)  )
   2554                                  {
   2555                                      str_tmp[ill_tmp-3]=0;
   2556                                      if ((str_tmp[ill_tmp-4]>53) && (str_tmp[ill_tmp-4]<57) && ((ill_tmp-4)<1)  )
   2557                                      { 
   2558                                        ill_cor++;
   2559                            
   2560                                        str_tmp[ill_tmp-4]++; 
   2561                                      }
   2562                                      if ((str_tmp[ill_tmp-4]==57) && ((ill_tmp-4)>0)  )
   2563                                      {
   2564                                
   2565                                        if ((str_tmp[ill_tmp-5]>53) && (str_tmp[ill_tmp-5]<57) && ((ill_tmp-5)<1)  )
   2566                                        { 
   2567                                          ill_cor++;
   2568                                          str_tmp[ill_tmp-4]=0;
   2569                                          str_tmp[ill_tmp-5]++; 
   2570                                        }
   2571                      
   2572                                      }
   2573                                  }
   2574                                     
   2575                              }
   2576                            
   2577                            
   2578                          }
   2579                      }
   2580                 }
   2581                 
   2582          
   2583                
   2584                if (ill_tmp-ill_cor) {ill_tmp-=ill_cor;} else {ill_tmp=0;}
   2585          
   2586                
   2587                if (E_tmp<100) 
   2588                {
   2589                  for (int i=0; i<=ill-1; i++) Vstring[min+i]=str_tmp[i+1];  
   2590                }
   2591          
   2592                if ( E_tmp == 100 )
   2593                  {
   2594                    Vstring[min+0]=48;
   2595                    for (int i=1; i<=(E_tmp-100); i++) Vstring[min+i]=48; 
   2596                    for (int i=1+(E_tmp-100); i<=ill-1; i++) Vstring[min+i]=str_tmp[1+i-(1+(E_tmp-100))];  
   2597                  }
   2598                if ( E_tmp > 100 )
   2599                  {
   2600                    Vstring[min+0]=48;
   2601                    Vstring[min+1]=46;
   2602                    for (int i=2; i<=(1+E_tmp-100); i++) Vstring[min+i]=48; 
   2603                    for (int i=2+(E_tmp-100); i<=ill-1; i++) {Vstring[min+i]=str_tmp[1+i-(2+(E_tmp-100))];  }
   2604          
   2605                  }  
   2606           
   2607              
   2608            
   2609                if (NastDiel<=10000)
   2610                {
   2611                  if ((Vstring[ill-1]==46)) 
   2612                    {
   2613                      Vstring[ill-1]=0;
   2614                    }
   2615                  if ((Vstring[ill-1]==48)) 
   2616                    {
   2617                      Vstring[ill-1]=0;
   2618                      ill_tmp--;
   2619                      if (Vstring[ill-2]==46)
   2620                      {
   2621                         Vstring[ill-2]=0;
   2622                         ill_tmp--; 
   2623                      }
   2624                      else
   2625                      {
   2626                           if ((Vstring[ill-2]==48)) 
   2627                           {
   2628                              Vstring[ill-2]=0;
   2629                              ill_tmp--;
   2630                              if (Vstring[ill-3]==46)
   2631                              {
   2632                                Vstring[ill-3]=0;
   2633                                ill_tmp--; 
   2634                              }
   2635                              else
   2636                              {
   2637                                    if ((Vstring[ill-3]==48)) 
   2638                                    {
   2639                                      Vstring[ill-3]=0;
   2640                                      ill_tmp--;
   2641                                      if (Vstring[ill-4]==46)
   2642                                      {
   2643                                        Vstring[ill-4]=0;
   2644                                        ill_tmp--; 
   2645                                      }
   2646                                      else
   2647                                      {
   2648                                          if ((Vstring[ill-4]==48)) 
   2649                                          {
   2650                                            Vstring[ill-4]=0;
   2651                                            ill_tmp--;
   2652                                            if (Vstring[ill-5]==46)
   2653                                            {
   2654                                              Vstring[ill-5]=0;
   2655                                              ill_tmp--; 
   2656                                            }
   2657                                            else
   2658                                            {
   2659                                                if ((Vstring[ill-5]==48)) 
   2660                                                {
   2661                                                  Vstring[ill-5]=0;
   2662                                                  ill_tmp--;
   2663                                                  if (Vstring[ill-6]==46)
   2664                                                  {
   2665                                                    Vstring[ill-6]=0;
   2666                                                    ill_tmp--; 
   2667                                                  }
   2668                                                  else
   2669                                                  {  
   2670                                                    if ((Vstring[ill-6]==48)) 
   2671                                                    {
   2672                                                      Vstring[ill-6]=0;
   2673                                                      ill_tmp--;
   2674                                                      if (Vstring[ill-7]==46)
   2675                                                      {
   2676                                                        Vstring[ill-7]=0;
   2677                                                        ill_tmp--; 
   2678                                                      }
   2679          
   2680                                                    }
   2681                                                  }
   2682                                                 }
   2683                                          
   2684                                          
   2685                         
   2686                                            }
   2687                                          }
   2688                                    
   2689                         
   2690                                      }
   2691                                    }  
   2692                         
   2693                              }
   2694                           }  
   2695                        
   2696                         
   2697                      }
   2698                  
   2699                    }
   2700                  
   2701                }
   2702                
   2703              
   2704                if ((E_tmp>ill) && (E_tmp<100))
   2705                {
   2706                  if ((Vstring[ill-2]>53)&&(Vstring[ill-3]<57)) Vstring[ill-3]++;
   2707                  Vstring[ill-2]=0x45;
   2708                  Vstring[ill-1]=48+E_tmp-ill+2;
   2709                }    
   2710              
   2711                if (min)
   2712                {
   2713                  Vstring[0]=45; 
   2714                }
   2715                
   2716                ill++;
   2717                Vstring[ill+1]=0;
   2718              
   2719               }
   2720             }
   2721          
   2722               
   2723             return ill_tmp;
   2724          
   2725          
   2726             
   2727          }//_______________________ Koniec funkcji konwersji float na string ____________________________
   2728          
   2729          
   2730          
   2731          
   2732          
   2733          
   2734          //*-----------------------------------------------------------------------------
   2735          //* Nazwa funkcji :    H_line
   2736          //* Funkcja rysowania lini poziomej
   2737          //*-----------------------------------------------------------------------------
   2738          
   2739          //*  X          - wspó³¿êdna X zale¿na 
   2740          //*  Y          - wspó³¿êdna Y do³u napisu
   2741          //*  length     -d³ugoœæ
   2742          //*  typ        -0-bia³a 1=ci¹gla, 2=kropkowana, 3=kreskowana 
   2743          //*-----------------------------------------------------------------------------
   2744          void H_line (char X, int Y, char lenght, char typ) 
   2745          { 
   2746              int kol=0;
   2747              char bit=0;
   2748            
   2749                kol=X/8;
   2750                bit=X%8;
   2751                
   2752                for (int j=1; j<=lenght; j++)
   2753                {
   2754                    
   2755                    if (typ>0) 
   2756                    {
   2757                      LCD_Canvas[kol][Y] |= (0x1)<<bit;
   2758                      if (bit<7) { bit++;} else {bit=0;  kol++; }
   2759                    }
   2760                    else
   2761                    {
   2762                        
   2763                        LCD_Canvas[kol][Y] &= ~((0x1)<<bit);
   2764                      if (bit<7) { bit++;} else {bit=0;  kol++; }
   2765                      
   2766                    }
   2767                   
   2768                    if ((typ==3) && ((j+1)<=lenght))
   2769                    {
   2770                      LCD_Canvas[kol][Y] |= (0x1)<<bit;
   2771                      if (bit<7) { bit++;} else {bit=0;  kol++;}
   2772                      j++;
   2773                    }
   2774                     if ((typ>=2) && ((j+1)<=lenght))
   2775                    {
   2776                      LCD_Canvas[kol][Y] &=~((0x1)<<bit);
   2777                      if (bit<7) { bit++;} else {bit=0;  kol++;}
   2778                      j++;
   2779                    }
   2780                    
   2781                }   
   2782          
   2783          }//_______________________ Koniec funkcji H_line ____________________________ 
   2784          
   2785          
   2786          
   2787          
   2788          
   2789          
   2790          
   2791          //*-----------------------------------------------------------------------------
   2792          //* Nazwa funkcji :    V_line
   2793          //* Funkcja rysowania lini pionowej
   2794          //*-----------------------------------------------------------------------------
   2795          
   2796          //*  X          - wspó³¿êdna X zale¿na 
   2797          //*  Y          - wspó³¿êdna Y do³u napisu
   2798          //*  length     -d³ugoœæ
   2799          //*  typ        -0-bia³a 1=ci¹gla, 2=kropkowana, 3=kreskowana 
   2800          //*-----------------------------------------------------------------------------
   2801          void V_line (char X, int Y, char lenght, char typ) 
   2802          { 
   2803              int kol=0;
   2804              char bit=0;
   2805            
   2806                kol=X/8;
   2807                bit=X%8;
   2808                
   2809                if (typ==1) 
   2810                {
   2811                  for (int j=0; j<=lenght-1; j++)
   2812                  {
   2813                    LCD_Canvas[kol][Y+j] |= (0x1)<<bit;
   2814                  }
   2815                }
   2816                
   2817                if (typ==2) 
   2818                {
   2819                  char zmiana=0;
   2820                  for (int j=0; j<=lenght-1; j++)
   2821                  {
   2822                    if (zmiana==0)
   2823                    {
   2824                      LCD_Canvas[kol][Y+j] |= (0x1)<<bit;
   2825                      zmiana=1;
   2826                    }
   2827                    else
   2828                    {
   2829                      LCD_Canvas[kol][Y+j] &= ~((0x1)<<bit);
   2830                      zmiana=0;
   2831                    }
   2832                  }
   2833                }
   2834                
   2835                if (typ==3) 
   2836                {
   2837                  char zmiana=0;
   2838                  for (int j=0; j<=lenght-1; j++)
   2839                  {
   2840                    if (zmiana<2)
   2841                    {
   2842                      LCD_Canvas[kol][Y+j] |= (0x1)<<bit;
   2843                      zmiana++;
   2844                    }
   2845                    else
   2846                    {
   2847                      LCD_Canvas[kol][Y+j] &= ~((0x1)<<bit);
   2848                      zmiana=0;
   2849                    }
   2850                  }
   2851                }
   2852                
   2853                
   2854                if (typ==0) 
   2855                {
   2856                   for (int j=0; j<=lenght-1; j++)
   2857                    {
   2858                    LCD_Canvas[kol][Y+j] &= ~((0x1)<<bit);
   2859                    }
   2860                  
   2861                }
   2862          
   2863          
   2864          }//_______________________ Koniec funkcji H_line ____________________________ 
   2865          
   2866          
   2867          
   2868          long long int ButtonEventTime=0;
   2869          //*-----------------------------------------------------------------------------
   2870          //* Nazwa funkcji :    Button
   2871          //* Uniwersalna funkcja przycisku
   2872          //*-----------------------------------------------------------------------------
   2873          //*  Label        - etykieta
   2874          //*  poz_X   - pozycja lewy róg
   2875          //*  poz_Y   - pozycja dolny róg
   2876          //*  width -   szerokoœæ
   2877          //*  height -  wysokoœæ
   2878          //*-----------------------------------------------------------------------------
   2879          long long ButtonBipCounter=0;
   2880          
   2881          char Button (char _Label[15], char poz_X , char poz_Y ,char width, char height) 
   2882          { 
   2883              char odp =0;
   2884              char tmpI=0;
   2885              char tmpF=0;
   2886              while ((tmpI<=15) && (tmpF==0))
   2887              {
   2888                if (_Label[tmpI]==0)
   2889                {
   2890                  tmpF=1;
   2891                }else{
   2892                  tmpI++;
   2893                }
   2894              }
   2895              static char ButtonDown=0;
   2896              CleanCanvasArea(poz_X+2, poz_Y+2, width-4, height-4,1);  //(char X, char Y, char X_Lenght, char Y_Lenght, char Type);   
   2897              Label(_Label,2,poz_X+3,poz_Y+(height/2)-4,tmpI,width-7,1,127,1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   2898           
   2899          
   2900          
   2901              if ( (X_down>poz_X) && (X_down<poz_X+width) && (Y_down>poz_Y+2) && (Y_down<poz_Y+height))
   2902              {    
   2903                  H_line(poz_X+2,poz_Y+1,width-4,1); // (char X, int Y, char lenght, char typ) 
   2904                  H_line(poz_X+2,poz_Y+height-2,width-4,1); // (char X, int Y, char lenght, char typ) 
   2905                  V_line(poz_X+1,poz_Y+2,height-4,1); // (char X, int Y, char lenght, char typ) 
   2906                  V_line(poz_X+width-2,poz_Y+2,height-4,1); // (char X, int Y, char lenght, char typ) 
   2907                  odp=2;
   2908                  
   2909                  if ((ButtonDown==0) && (!(AT91C_IFLASH_MEM->Config.SoundOff))) {
   2910                    AT91C_BASE_PIOA->PIO_SODR =SpeakerPin;
   2911                    ButtonBipCounter=g_counter+8;
   2912                  } 
   2913                  ButtonDown=1;
   2914              }
   2915              else 
   2916              {
   2917                  
   2918                
   2919                 
   2920                  H_line(poz_X+2,poz_Y+1,width-4,0); // (char X, int Y, char lenght, char typ) 
   2921                  H_line(poz_X+2,poz_Y+height-2,width-4,0); // (char X, int Y, char lenght, char typ) 
   2922                  V_line(poz_X+1,poz_Y+2,height-4,0); // (char X, int Y, char lenght, char typ) 
   2923                  V_line(poz_X+width-2,poz_Y+2,height-4,0); // (char X, int Y, char lenght, char typ)   
   2924                 
   2925                  H_line(poz_X+1,poz_Y,width-2,1); // (char X, int Y, char lenght, char typ) 
   2926                  H_line(poz_X+1,poz_Y+height-1,width-2,1); // (char X, int Y, char lenght, char typ) 
   2927                  V_line(poz_X,poz_Y+1,height-2,1); // (char X, int Y, char lenght, char typ) 
   2928                  V_line(poz_X+width-1,poz_Y+1,height-2,1); // (char X, int Y, char lenght, char typ) 
   2929              
   2930                  CanvasPixel(poz_X+1, poz_Y+1,1);   //(char X, char Y, char Colour)
   2931                  CanvasPixel(poz_X+width-2, poz_Y+1,1);   //(char X, char Y, char Colour)
   2932                  CanvasPixel(poz_X+1, poz_Y+height-2,1);   //(char X, char Y, char Colour)
   2933                  CanvasPixel(poz_X+width-2, poz_Y+height-2 ,1);   //(char X, char Y, char Colour)
   2934                  
   2935                  
   2936                  if ( (X_up>poz_X) && (X_up<poz_X+width) && (Y_up>poz_Y+2) && (Y_up<poz_Y+height))
   2937                  {    
   2938                    odp =1;
   2939                    ButtonDown=0;
   2940                  } 
   2941                    
   2942                    
   2943              }
   2944              
   2945          
   2946                 
   2947                ButtonEventTime=g_counter;
   2948              
   2949              return odp;
   2950              
   2951          }
   2952          
   2953          
   2954          
   2955          
   2956          
   2957          
   2958          //*-----------------------------------------------------------------------------
   2959          //* Nazwa funkcji :    Zone
   2960          //* Uniwersalna funkcja przycisku strefy (przycisk bia³y)
   2961          //*-----------------------------------------------------------------------------
   2962          //*  Label        - etykieta
   2963          //*  poz_X   - pozycja lewy róg
   2964          //*  poz_Y   - pozycja dolny róg
   2965          //*  width -   szerokoœæ
   2966          //*  height -  wysokoœæ
   2967          //*  LineType- typ lini 0-bia³a 1=ci¹gla, 2=kropkowana, 3=kreskowana
   2968          //*-----------------------------------------------------------------------------
   2969          char Zone (char _Label[15], char poz_X , char poz_Y ,char width, char height, char LineType) 
   2970          { 
   2971              char odp =0;
   2972              char tmpI=0;
   2973              char tmpF=0;
   2974              while ((tmpI<=15) && (tmpF==0))
   2975              {
   2976                if (_Label[tmpI]==0)
   2977                {
   2978                  tmpF=1;
   2979                }else{
   2980                  tmpI++;
   2981                }
   2982              }
   2983              
   2984              //CleanCanvasArea(poz_X+2, poz_Y+2, width-4, height-4,0);  //(char X, char Y, char X_Lenght, char Y_Lenght, char Type);   
   2985              if (_Label!=0) Label(_Label,2,poz_X+3,poz_Y+(height/2)-4,tmpI,width-7,1,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   2986           
   2987          
   2988          
   2989              if ( (X_down>poz_X) && (X_down<poz_X+width) && (Y_down>poz_Y+2) && (Y_down<poz_Y+height))
   2990              {    
   2991                  H_line(poz_X+2,poz_Y+1,width-4,1); // (char X, int Y, char lenght, char typ) 
   2992                  H_line(poz_X+2,poz_Y+height-2,width-4,1); // (char X, int Y, char lenght, char typ) 
   2993                  V_line(poz_X+1,poz_Y+2,height-4,1); // (char X, int Y, char lenght, char typ) 
   2994                  V_line(poz_X+width-2,poz_Y+2,height-4,1); // (char X, int Y, char lenght, char typ) 
   2995                  odp=2;
   2996              }
   2997              else 
   2998              {
   2999                  
   3000              
   3001                  H_line(poz_X+1,poz_Y,width-2,LineType); // (char X, int Y, char lenght, char typ) 
   3002                  H_line(poz_X+1,poz_Y+height-1,width-2,LineType); // (char X, int Y, char lenght, char typ) 
   3003                  V_line(poz_X,poz_Y+1,height-2,LineType); // (char X, int Y, char lenght, char typ) 
   3004                  V_line(poz_X+width-1,poz_Y+1,height-2,LineType); // (char X, int Y, char lenght, char typ) 
   3005              
   3006          
   3007                  
   3008                  if ( (X_up>poz_X) && (X_up<poz_X+width) && (Y_up>poz_Y+2) && (Y_up<poz_Y+height))
   3009                  {    
   3010                    odp =1;
   3011                  }
   3012              }
   3013              
   3014          
   3015                 
   3016                ButtonEventTime=g_counter;
   3017              
   3018              return odp;
   3019              
   3020          }
   3021          
   3022          
   3023           
   3024          
   3025          
   3026          //*-----------------------------------------------------------------------------
   3027          //* Nazwa funkcji :    List_Paint
   3028          //* Funkcja rysowania listy
   3029          //*-----------------------------------------------------------------------------
   3030          //* X1
   3031          //* Y1
   3032          //* X2
   3033          //* Y2
   3034          //* p - solid
   3035          //*-----------------------------------------------------------------------------
   3036          
   3037          
   3038          void Rectangle(char X1,char Y1,char Width,char Height,...)
   3039          {
   3040            
   3041           va_list parg; 
   3042           va_start( parg, Height);// pocz¹tek pracy ze zmienn¹ list¹ parametrów 
   3043           char SO;
   3044           SO = va_arg( parg, char);
   3045           va_end(parg); 
   3046            
   3047          
   3048          
   3049             H_line(X1,Y1,Width,1);
   3050             H_line(X1,Y1+Height-1,Width,1);
   3051             V_line(X1,Y1,Height,1);
   3052             V_line(X1+Width-1,Y1,Height,1);
   3053                        
   3054             //if (SO==1) CleanCanvasArea(X1,Y1,Width,Height,1);
   3055             
   3056          }
   3057           
   3058           
   3059          //*-----------------------------------------------------------------------------
   3060          //* Nazwa funkcji :    CheckLCD
   3061          //* Funkcja sprawdza kolejne porty LCD
   3062          //*-----------------------------------------------------------------------------
   3063          //*-----------------------------------------------------------------------------
   3064          
   3065          void CheckLCD(void)
   3066           {
   3067             m_pPio->PIO_SODR =  LCD_BUS_MASK;                         // zeruje piny
   3068           
   3069             
   3070             AT91C_BASE_PIOA->PIO_CODR = DI; AT91C_BASE_PIOA->PIO_SODR = DI; 
   3071             AT91C_BASE_PIOA->PIO_CODR = ENABLE; AT91C_BASE_PIOA->PIO_SODR = ENABLE; 
   3072             AT91C_BASE_PIOA->PIO_CODR = DB0; AT91C_BASE_PIOA->PIO_SODR = DB0; 
   3073             AT91C_BASE_PIOA->PIO_CODR = DB1; AT91C_BASE_PIOA->PIO_SODR = DB1; 
   3074             AT91C_BASE_PIOA->PIO_CODR = DB2; AT91C_BASE_PIOA->PIO_SODR = DB2; 
   3075             AT91C_BASE_PIOA->PIO_CODR = DB3; AT91C_BASE_PIOA->PIO_SODR = DB3; 
   3076             AT91C_BASE_PIOA->PIO_CODR = DB4; AT91C_BASE_PIOA->PIO_SODR = DB4; 
   3077             AT91C_BASE_PIOA->PIO_CODR = DB5; AT91C_BASE_PIOA->PIO_SODR = DB5; 
   3078             AT91C_BASE_PIOA->PIO_CODR = DB6; AT91C_BASE_PIOA->PIO_SODR = DB6; 
   3079             AT91C_BASE_PIOA->PIO_CODR = DB7; AT91C_BASE_PIOA->PIO_SODR = DB7; 
   3080             AT91C_BASE_PIOA->PIO_CODR = CS1; AT91C_BASE_PIOA->PIO_SODR = CS1; 
   3081             AT91C_BASE_PIOA->PIO_CODR = CS2; AT91C_BASE_PIOA->PIO_SODR = CS2; 
   3082             AT91C_BASE_PIOA->PIO_CODR = (unsigned long)LightLCD; AT91C_BASE_PIOA->PIO_SODR = (unsigned long)LightLCD; 
   3083          
   3084            
   3085          
   3086          }//_______________________ Koniec funkcji CheckLCD __________________________
   3087          
   3088           
   3089            _TPoint Up, Down;   
   3090          
   3091          #define TouchAmount 4       //iloœæ pamiêtanych punktów dotyku   
   3092          void GetTouchPoint(signed short *Xd,signed short  *Yd, signed short *Xu, signed short  *Yu)
   3093          {
   3094          
   3095            static _TPoint TouchList[TouchAmount];                                        //lista FIFO wspó³¿êdnych
   3096          
   3097          
   3098            for (char i=1; i<TouchAmount; i++)
   3099            {
   3100               TouchList[TouchAmount-i].x=TouchList[TouchAmount-i-1].x;
   3101               TouchList[TouchAmount-i].y=TouchList[TouchAmount-i-1].y;
   3102            }
   3103          
   3104            Down.x=-1;
   3105            Down.y=-1;
   3106            Up.x=-1;
   3107            Up.y=-1;
   3108              
   3109            ReadTP(TouchList); 
   3110            
   3111            //je¿eli pomiar ci¹g³y dotkniêtego ekranu 
   3112            if ((TouchList[0].x>0) && (TouchList[1].x>0) && (TouchList[2].x>0) &&(TouchList[3].x>0))  
   3113            {
   3114              Down.x=((TouchList[1].x) + (TouchList[2].x))/2;
   3115          
   3116              Down.y=((TouchList[1].y) + (TouchList[2].y))/2;
   3117            }
   3118            
   3119            //je¿eli dotkniêto ekran
   3120            if ((TouchList[0].x>0) && (TouchList[1].x>0) && (TouchList[2].x>0) &&(TouchList[3].x<=0))  
   3121            {
   3122              Down.x=((TouchList[0].x) + (TouchList[1].x))/2;
   3123          
   3124              Down.y=((TouchList[0].y) + (TouchList[1].y))/2;
   3125              TouchList[2].x=Down.x;
   3126              TouchList[2].x=Down.x;
   3127            }
   3128          
   3129            //je¿eli puszczono ekran
   3130            if ((TouchList[0].x<=0) && (TouchList[1].x>0) && (TouchList[2].x>0) &&(TouchList[3].x>0))  
   3131            {
   3132              Up.x=((TouchList[2].x) + (TouchList[3].x))/2;
   3133          
   3134              Up.y=((TouchList[2].y) + (TouchList[3].y))/2;
   3135            }  
   3136            
   3137            if ((Down.x>0) && (Down.y>0))
   3138            {
   3139              Down.x=korekta_X.A*Down.x+korekta_X.B;
   3140              Down.y=korekta_Y.A*Down.y+korekta_Y.B;
   3141            }
   3142            
   3143            if ((Up.x>0) && (Up.y>0))
   3144            { 
   3145              Up.x=korekta_X.A*Up.x+korekta_X.B;
   3146              Up.y=korekta_Y.A*Up.y+korekta_Y.B;
   3147              /*
   3148              for (char i=0; i<TouchAmount; i++)
   3149                {
   3150                   TouchList[TouchAmount-i].x=0;
   3151                   TouchList[TouchAmount-i].y=0;
   3152                   
   3153                }
   3154                   Down.x=0;
   3155                   Down.y=0;
   3156                   */
   3157                   
   3158            }
   3159            if ((korekta_X.B!=0) && (korekta_Y.B!=0))
   3160            {
   3161              if ((Down.x>64) || (Down.y>128)) {Down.x=-1; Down.y=-1;} 
   3162              if ((Up.x>64) || (Up.y>128)) {Up.x=-1; Up.y=-1;} 
   3163            }
   3164            *Xd=Down.x;
   3165            *Yd=Down.y;
   3166            *Xu=Up.x;
   3167            *Yu=Up.y;
   3168          
   3169          }
   3170          
   3171          #endif
                       ^
Warning[Pe001]: last line of file ends without a newline


 
 
 0 bytes of memory

Errors: none
Warnings: 1
