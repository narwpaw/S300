###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           23/Oct/2012  20:58:14 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v0.9 -              #
#                    23.10.2012\Framework\Application_prog.c                  #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v0.9 -             #
#                    23.10.2012\Framework\Application_prog.c" -D              #
#                    AT91SAM7S256 -D AT91SAM7SEK -D iH -D __ALARM -D S300     #
#                    -lC "D:\Zeuron\Projekty\S300\S300-program v0.9 -         #
#                    23.10.2012\S300\List\" --diag_suppress Pa082 -o          #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.9 -             #
#                    23.10.2012\S300\Obj\" --no_unroll --no_inline --no_tbaa  #
#                    --no_scheduling --debug --endian little --cpu ARM7TDMI   #
#                    -e --fpu None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 5.0\ARM\INC\DLib_Config_Norma #
#                    l.h" -I "D:\Zeuron\Projekty\S300\S300-program v0.9 -     #
#                    23.10.2012\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.9 -             #
#                    23.10.2012\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.9 -             #
#                    23.10.2012\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v0.9 - 23.10.2012\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v0.9 - 23.10.2012\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.9 -             #
#                    23.10.2012\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v0.9 - 23.10.2012\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v0.9 -             #
#                    23.10.2012\Framework\Configuration\" -I "C:\Program      #
#                    Files\IAR Systems\Embedded Workbench 5.0\ARM\INC\"       #
#                    --section .text=Debug.txt --interwork --cpu_mode thumb   #
#                    -Om                                                      #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v0.9 -              #
#                    23.10.2012\S300\List\Application_prog.lst                #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v0.9 -              #
#                    23.10.2012\S300\Obj\Application_prog.o                   #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v0.9 - 23.10.2012\Framework\Application_prog.c
      1          //****************************************************************************//
      2          //*--------------------------------------------------------------------------*//
      3          //*                                 CEURON                                   *//                       
      4          //*--------------------------------------------------------------------------*//
      5          //*--------------------------------------------------------------------------*//
      6          //*  Nazwa pliku                  : Application_prog.c                       *//
      7          //*  Opis                         : Plik obs³ugi programu u¿ytkowego         *//
      8          //*  Autor                        : Pawe³ Narwojsz                           *//
      9          //*  Data utrzorzenia             : 10.09.2007                               *//
     10          //*  Data ostatniej modyfikacji   : --.--.----                               *//
     11          //*--------------------------------------------------------------------------*//
     12          //*                                                                          *//
     13          //*--------------------------------------------------------------------------*//
     14          //* Rejestr zmian  (data - opis):                                            *//
     15          //*                                                                          *//
     16          //*                               Brak zmian                                 *//
     17          //*                                                                          *//
     18          //*__________________________________________________________________________*// 
     19          //****************************************************************************//
     20          //****************************************************************************//
     21          
     22          
     23          
     24          
     25          #include "Application_prog.h" 
     26          
     27          #include "Framework.h"
     28          #include "core/device.h"                                                        //aduje bibliotreki dla odpowiedniego procesora
     29          #include "modbus.h"

                                          
                                          ^
"D:\Zeuron\Projekty\S300\S300-program v0.9 - 23.10.2012\Framework\Configuration\InterruptPriority.h",59  Warning[Pe001]: 
          last line of file ends without a newline
     30          #include "usart.h"
     31          #include "RF_Exe.h"
     32          #include "ScreenMENU2.h"
     33          
     34          
     35          //Zmienne globalne -------------------------------------------------------------
     36            char NumberScene=NumberSceneMax;  //iloœæ u¿ywanych scen. Wartoœæ pierwotnie NumberSceneMax nastêpnie wyliczana
     37            short ScreenUse;

   \                                 In section .bss, align 1
     38            char SceneBefOff=0; //Je¿eli >0 to oznacza ¿e sceny zosta³y wy³¹czone przyskiem/zdarzeniem off.  SceneBefOff= nr sceny przed wy³¹czeniem
   \                     SceneBefOff:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     39            _TransQuality TransQuality; //tablica informacyjna jakoœci po³¹czenia pola odpowiadaj¹ polom _ProgramTab.NeuronsIdTab
   \                     TransQuality:
   \   00000000                      DS8 216
     40          
     41            //___________________________Koniec zmiennych globalnych________________________
     42          
     43          
     44          
     45          
     46          #ifdef _LIVE_RJESTR   
     47            extern unsigned short LIVE_TAB[LIVE_TAB_SIZE];
     48            extern char LIVE_TAB_IDX;
     49          #endif
     50            
     51          
     52          extern RAM ram;
     53          extern int g_US0_BAUDRATE;
     54          //extern FlashPagesOffset;

   \                                 In section .bss, align 4
     55          Convers_DW_F ProgConvers_DW_F;
   \                     ProgConvers_DW_F:
   \   00000000                      DS8 4
     56          
     57          extern  _ScreenPaternDesign ScreenSetTab_0[];
     58          extern  _ScreenPaternDesign ScreenSetTab_1[];
     59          extern int int1;
     60          extern int FlashProgramOfset;
     61          extern int g_counter;
     62          extern char AdressModbus;
     63          extern char q_US0_Comm_Mode;
     64          extern char US0_MasterMODBUS_ENABLE;
     65          extern void Delay (unsigned long a);
     66          extern char g_Stop_Program;                                                     //1- zatrzymuje program
     67          extern char g_Restart_Program;                                                  //1- restartuje program
     68          extern unsigned int CyklPerSek;
     69          extern _DateTime DateTime;
     70          extern _RF_TaskTab  RF_TaskTab;

   \                                 In section .bss, align 4
     71          _ButtonGraph  ButtonExe[ScreenNr][ScrenButtonNr];                                         //do tej zmiennej przepisywane sa stany 1 z Button
   \                     ButtonExe:
   \   00000000                      DS8 576
     72          
     73          

   \                                 In section .bss, align 8
     74          volatile _ProgramTab gProg;
   \                     gProg:
   \   00000000                      DS8 50800
     75          char        *pProg=(char*)&gProg;

   \                                 In section .bss, align 4
     76          _NeuronsListUnit NeuronsList[NumberNeurons];
   \                     NeuronsList:
   \   00000000                      DS8 420
     77          
     78          
     79          
     80          

   \                                 In section .bss, align 4
     81          char Variables[13];    //zmienne
   \                     Variables:
   \   00000000                      DS8 16
     82          //char VariablesNetTmp[13];    //zmienne tyczmasowe dla komunikacji WiFi stosowana jako separacja  Variables[] ¿eby nie nadpisywaæ zmiennych

   \                                 In section .bss, align 4
     83          short int VariablesAnal[AnalogVarAmount];    //zmienne
   \                     VariablesAnal:
   \   00000000                      DS8 40
     84          
     85          
     86          

   \                                 In section .bss, align 4
     87          _MainStage  MainStage; 
   \                     MainStage:
   \   00000000                      DS8 1596
     88          _Trap      Trap;
     89          
     90          extern _ZD_MODBUS ZD_MODBUS_0[ZD_MODBUS_Tab_Max];

   \                                 In section Debug.txt, align 4, keep-with-next
     91          void SetModbusTask(void)
     92          {
     93          
     94                ptr_ZD_MODBUS ZD_MODBUS;
     95          
     96          
     97                ZD_MODBUS         =   ZD_MODBUS_0;
     98            
     99          
    100             
    101                
    102                char i=0; 
    103            
    104           
    105                   
    106                ZD_MODBUS[i].Adress=1;
   \                     SetModbusTask:
   \   00000000   ....               LDR      R0,??DataTable0  ;; ZD_MODBUS_0
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0170               STRB     R1,[R0, #+0]
    107                ZD_MODBUS[i].Function=0xF;
   \   00000006   0F21               MOVS     R1,#+15
   \   00000008   0A00               MOVS     R2,R1
   \   0000000A   4270               STRB     R2,[R0, #+1]
    108                ZD_MODBUS[i].Target=0x0;
   \   0000000C   0022               MOVS     R2,#+0
   \   0000000E   8270               STRB     R2,[R0, #+2]
   \   00000010   C270               STRB     R2,[R0, #+3]
    109                ZD_MODBUS[i].StartAdr=0;
   \   00000012   0271               STRB     R2,[R0, #+4]
   \   00000014   4271               STRB     R2,[R0, #+5]
    110                ZD_MODBUS[i].Coil=8;
   \   00000016   0822               MOVS     R2,#+8
   \   00000018   8271               STRB     R2,[R0, #+6]
   \   0000001A   120A               LSRS     R2,R2,#+8
   \   0000001C   C271               STRB     R2,[R0, #+7]
    111                ZD_MODBUS[i].Error=0x0;
   \   0000001E   C272               STRB     R2,[R0, #+11]
   \   00000020   0273               STRB     R2,[R0, #+12]
    112                
    113                i=1; 
    114                ZD_MODBUS[i].Adress=2;
   \   00000022   0222               MOVS     R2,#+2
   \   00000024   4273               STRB     R2,[R0, #+13]
    115                ZD_MODBUS[i].Function=0xF;
   \   00000026   0A00               MOVS     R2,R1
   \   00000028   8273               STRB     R2,[R0, #+14]
    116                ZD_MODBUS[i].Target=0x0;
   \   0000002A   0022               MOVS     R2,#+0
   \   0000002C   C273               STRB     R2,[R0, #+15]
   \   0000002E   0274               STRB     R2,[R0, #+16]
    117                ZD_MODBUS[i].StartAdr=1;
   \   00000030   0122               MOVS     R2,#+1
   \   00000032   4274               STRB     R2,[R0, #+17]
   \   00000034   120A               LSRS     R2,R2,#+8
   \   00000036   8274               STRB     R2,[R0, #+18]
    118                ZD_MODBUS[i].Coil=8;
   \   00000038   0822               MOVS     R2,#+8
   \   0000003A   C274               STRB     R2,[R0, #+19]
   \   0000003C   120A               LSRS     R2,R2,#+8
   \   0000003E   0275               STRB     R2,[R0, #+20]
    119                ZD_MODBUS[i].Error=0x0;
   \   00000040   0276               STRB     R2,[R0, #+24]
   \   00000042   4276               STRB     R2,[R0, #+25]
    120           
    121                i=2; 
    122                ZD_MODBUS[i].Adress=3;
   \   00000044   0322               MOVS     R2,#+3
   \   00000046   8276               STRB     R2,[R0, #+26]
    123                ZD_MODBUS[i].Function=0xF;
   \   00000048   C176               STRB     R1,[R0, #+27]
    124                ZD_MODBUS[i].Target=0x0;
   \   0000004A   0021               MOVS     R1,#+0
   \   0000004C   0177               STRB     R1,[R0, #+28]
   \   0000004E   4177               STRB     R1,[R0, #+29]
    125                ZD_MODBUS[i].StartAdr=2;
   \   00000050   0221               MOVS     R1,#+2
   \   00000052   8177               STRB     R1,[R0, #+30]
   \   00000054   090A               LSRS     R1,R1,#+8
   \   00000056   C177               STRB     R1,[R0, #+31]
    126                ZD_MODBUS[i].Coil=8;
   \   00000058   0100               MOVS     R1,R0
   \   0000005A   2031               ADDS     R1,R1,#+32
   \   0000005C   0822               MOVS     R2,#+8
   \   0000005E   0A70               STRB     R2,[R1, #+0]
   \   00000060   120A               LSRS     R2,R2,#+8
   \   00000062   4A70               STRB     R2,[R1, #+1]
    127                ZD_MODBUS[i].Error=0x0;      
   \   00000064   2530               ADDS     R0,R0,#+37
   \   00000066   1100               MOVS     R1,R2
   \   00000068   0170               STRB     R1,[R0, #+0]
   \   0000006A   4170               STRB     R1,[R0, #+1]
    128          
    129               
    130                
    131          }
   \   0000006C   7047               BX       LR               ;; return
    132          
    133          
    134          //*-----------------------------------------------------------------------------
    135          //* Nazwa funkcji :    PortStageRead
    136          //* Funkcja wydobywa wartoœæ bitu o numerze PortNr ze zmiennej pod adresem *Stage 
    137          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    138          char PortStageRead(short int Stage, char PortNr)
    139          {
   \                     PortStageRead:
   \   00000000   0200               MOVS     R2,R0
    140              char odp=0;
    141              odp=(Stage>>PortNr)&0x1;
    142              return odp;
   \   00000002   0A41               ASRS     R2,R2,R1
   \   00000004   0120               MOVS     R0,#+1
   \   00000006   1040               ANDS     R0,R0,R2
   \   00000008   7047               BX       LR               ;; return
    143          }
    144          
    145          //*-----------------------------------------------------------------------------
    146          //* Nazwa funkcji :    PortStageSet
    147          //* Funkcja ustawia stan portu (bit PortNr dla zmiennej pod adresem *Stage) na Value 
    148          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    149          void PortStageSet(short int *Stage, char PortNr, char Value)
    150          {
   \                     PortStageSet:
   \   00000000   11B4               PUSH     {R0,R4}
    151              Value&=0x1;
    152              *Stage=(*Stage&(~(0x1<<PortNr))) | (Value<<PortNr);
   \   00000002   0388               LDRH     R3,[R0, #+0]
   \   00000004   0124               MOVS     R4,#+1
   \   00000006   8C40               LSLS     R4,R4,R1
   \   00000008   A343               BICS     R3,R3,R4
   \   0000000A   0124               MOVS     R4,#+1
   \   0000000C   1440               ANDS     R4,R4,R2
   \   0000000E   8C40               LSLS     R4,R4,R1
   \   00000010   1C43               ORRS     R4,R4,R3
   \   00000012   0480               STRH     R4,[R0, #+0]
    153          }
   \   00000014   18BC               POP      {R3,R4}
   \   00000016   7047               BX       LR               ;; return
    154          
    155          
    156          
    157          //*-----------------------------------------------------------------------------
    158          //* Nazwa funkcji :    ProcStI_Action
    159          //* Funkcja procedury "Stan wejœcia"
    160          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    161          void ProcStI_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    162          {  
   \                     ProcStI_Action:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0C00               MOVS     R4,R1
    163            //je¿eli port w wêŸle == 1 i wiarygodny pomiar
    164            if (Proc->Nr>=0)
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   6156               LDRSB    R1,[R4, R1]
   \   00000008   0029               CMP      R1,#+0
   \   0000000A   1DD4               BMI      ??ProcStI_Action_0
    165            {
    166              if ((MainStg->StageI[Proc->Nr].Port !=0x8AAA))
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   6156               LDRSB    R1,[R4, R1]
   \   00000010   1423               MOVS     R3,#+20
   \   00000012   5943               MULS     R1,R3,R1
   \   00000014   5118               ADDS     R1,R2,R1
   \   00000016   A031               ADDS     R1,R1,#+160
   \   00000018   0988               LDRH     R1,[R1, #+0]
   \   0000001A   ....               LDR      R3,??DataTable3  ;; 0x8aaa
   \   0000001C   9942               CMP      R1,R3
   \   0000001E   20D0               BEQ      ??ProcStI_Action_1
    167              {
    168                 if (*PrvOut)
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   405E               LDRSH    R0,[R0, R1]
   \   00000024   0028               CMP      R0,#+0
   \   00000026   0DD0               BEQ      ??ProcStI_Action_2
    169                 {
    170                    Proc->Out=PortStageRead(MainStg->StageI[Proc->Nr].Port, Proc->Tag.Port);  
   \   00000028   217A               LDRB     R1,[R4, #+8]
   \   0000002A   0120               MOVS     R0,#+1
   \   0000002C   2056               LDRSB    R0,[R4, R0]
   \   0000002E   1423               MOVS     R3,#+20
   \   00000030   5843               MULS     R0,R3,R0
   \   00000032   1018               ADDS     R0,R2,R0
   \   00000034   A030               ADDS     R0,R0,#+160
   \   00000036   0088               LDRH     R0,[R0, #+0]
   \   00000038   0004               LSLS     R0,R0,#+16
   \   0000003A   0014               ASRS     R0,R0,#+16
   \   0000003C   ........           BL       PortStageRead
   \   00000040   6082               STRH     R0,[R4, #+18]
   \   00000042   0EE0               B        ??ProcStI_Action_1
    171                 }else{
    172                   Proc->Out=0;
   \                     ??ProcStI_Action_2:
   \   00000044   6082               STRH     R0,[R4, #+18]
   \   00000046   0CE0               B        ??ProcStI_Action_1
    173                 }
    174              }
    175              
    176            //je¿eli zmienna dwustanowa  
    177            }else{
    178                Proc->Out= (Variables[Proc->Tag.Port/8]>> (Proc->Tag.Port%8))&0x1;
   \                     ??ProcStI_Action_0:
   \   00000048   207A               LDRB     R0,[R4, #+8]
   \   0000004A   C010               ASRS     R0,R0,#+3
   \   0000004C   ....               LDR      R1,??DataTable12  ;; Variables
   \   0000004E   085C               LDRB     R0,[R1, R0]
   \   00000050   217A               LDRB     R1,[R4, #+8]
   \   00000052   0A00               MOVS     R2,R1
   \   00000054   D208               LSRS     R2,R2,#+3
   \   00000056   D200               LSLS     R2,R2,#+3
   \   00000058   891A               SUBS     R1,R1,R2
   \   0000005A   0841               ASRS     R0,R0,R1
   \   0000005C   0121               MOVS     R1,#+1
   \   0000005E   0140               ANDS     R1,R1,R0
   \   00000060   6182               STRH     R1,[R4, #+18]
    179            }
    180          
    181          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStI_Action_1:
   \   00000062   10BC               POP      {R4}
   \   00000064   01BC               POP      {R0}
   \   00000066   0047               BX       R0               ;; return
    182          
    183          
    184          
    185          //*-----------------------------------------------------------------------------
    186          //* Nazwa funkcji :    ProcStI_Action
    187          //* Funkcja procedury "Stan wejœcia"
    188          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    189          void ProcStNI_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    190          {  
   \                     ProcStNI_Action:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0C00               MOVS     R4,R1
    191                   //je¿eli port w wêŸle == 1 i wiarygodny pomiar
    192            if ((MainStg->StageI[Proc->Nr].Port !=0x8AAA))
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   6156               LDRSB    R1,[R4, R1]
   \   00000008   1423               MOVS     R3,#+20
   \   0000000A   5943               MULS     R1,R3,R1
   \   0000000C   5118               ADDS     R1,R2,R1
   \   0000000E   A031               ADDS     R1,R1,#+160
   \   00000010   0988               LDRH     R1,[R1, #+0]
   \   00000012   ....               LDR      R3,??DataTable3  ;; 0x8aaa
   \   00000014   9942               CMP      R1,R3
   \   00000016   2DD0               BEQ      ??ProcStNI_Action_0
    193            {
    194            
    195             if (*PrvOut)
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   405E               LDRSH    R0,[R0, R1]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   28D0               BEQ      ??ProcStNI_Action_1
    196             {
    197          
    198                   if (Proc->Nr>=0)
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   2056               LDRSB    R0,[R4, R0]
   \   00000024   0028               CMP      R0,#+0
   \   00000026   13D4               BMI      ??ProcStNI_Action_2
    199                   {
    200                     if (PortStageRead(MainStg->StageI[Proc->Nr].Port, Proc->Tag.Port)==1)
   \   00000028   217A               LDRB     R1,[R4, #+8]
   \   0000002A   0120               MOVS     R0,#+1
   \   0000002C   2056               LDRSB    R0,[R4, R0]
   \   0000002E   1423               MOVS     R3,#+20
   \   00000030   5843               MULS     R0,R3,R0
   \   00000032   1018               ADDS     R0,R2,R0
   \   00000034   A030               ADDS     R0,R0,#+160
   \   00000036   0088               LDRH     R0,[R0, #+0]
   \   00000038   0004               LSLS     R0,R0,#+16
   \   0000003A   0014               ASRS     R0,R0,#+16
   \   0000003C   ........           BL       PortStageRead
   \   00000040   0128               CMP      R0,#+1
   \   00000042   02D1               BNE      ??ProcStNI_Action_3
    201                     {
    202                      Proc->Out=0; 
   \   00000044   0020               MOVS     R0,#+0
   \   00000046   6082               STRH     R0,[R4, #+18]
   \   00000048   14E0               B        ??ProcStNI_Action_0
    203                     }else{
    204                      Proc->Out=1;
   \                     ??ProcStNI_Action_3:
   \   0000004A   0120               MOVS     R0,#+1
   \   0000004C   6082               STRH     R0,[R4, #+18]
   \   0000004E   11E0               B        ??ProcStNI_Action_0
    205                     }
    206                   }else{
    207                     if (((Variables[Proc->Tag.Port/8]>> (Proc->Tag.Port%8))&0x1)==1)
   \                     ??ProcStNI_Action_2:
   \   00000050   207A               LDRB     R0,[R4, #+8]
   \   00000052   C010               ASRS     R0,R0,#+3
   \   00000054   ....               LDR      R1,??DataTable12  ;; Variables
   \   00000056   085C               LDRB     R0,[R1, R0]
   \   00000058   217A               LDRB     R1,[R4, #+8]
   \   0000005A   0A00               MOVS     R2,R1
   \   0000005C   D208               LSRS     R2,R2,#+3
   \   0000005E   D200               LSLS     R2,R2,#+3
   \   00000060   891A               SUBS     R1,R1,R2
   \   00000062   0841               ASRS     R0,R0,R1
   \   00000064   0121               MOVS     R1,#+1
   \   00000066   0140               ANDS     R1,R1,R0
   \   00000068   481E               SUBS     R0,R1,#+1
   \   0000006A   8041               SBCS     R0,R0,R0
   \   0000006C   C00F               LSRS     R0,R0,#+31
   \   0000006E   6082               STRH     R0,[R4, #+18]
   \   00000070   00E0               B        ??ProcStNI_Action_0
    208                     {
    209                      Proc->Out=0; 
    210                     }else{
    211                      Proc->Out=1;
    212                     }
    213                   }
    214                 }else{
    215                   Proc->Out=0;
   \                     ??ProcStNI_Action_1:
   \   00000072   6082               STRH     R0,[R4, #+18]
    216                 }
    217             }
    218          
    219          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStNI_Action_0:
   \   00000074   10BC               POP      {R4}
   \   00000076   01BC               POP      {R0}
   \   00000078   0047               BX       R0               ;; return
    220          
    221          
    222          
    223          
    224          //*-----------------------------------------------------------------------------
    225          //* Nazwa funkcji :    ProcGetAnal_Action
    226          //* Funkcja procedury "Stan wejœcia analogowego"
    227          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    228          void ProcGetReg_Action(_Procedure *Proc, _MainStage *MainStg) 
    229          {  
   \                     ProcGetReg_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    230            if (Proc->Nr>=0)
   \   00000002   0122               MOVS     R2,#+1
   \   00000004   8256               LDRSB    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   18D4               BMI      ??ProcGetReg_Action_0
    231            {
    232                if ((MainStg->StageI[Proc->Nr].Value[Proc->Tag.RegNr])!=(signed short int )0x8AAA)
   \   0000000A   A022               MOVS     R2,#+160
   \   0000000C   037A               LDRB     R3,[R0, #+8]
   \   0000000E   5B00               LSLS     R3,R3,#+1
   \   00000010   0124               MOVS     R4,#+1
   \   00000012   0457               LDRSB    R4,[R0, R4]
   \   00000014   1425               MOVS     R5,#+20
   \   00000016   6C43               MULS     R4,R5,R4
   \   00000018   0C19               ADDS     R4,R1,R4
   \   0000001A   E318               ADDS     R3,R4,R3
   \   0000001C   9A5E               LDRSH    R2,[R3, R2]
   \   0000001E   0B4B               LDR      R3,??ProcGetReg_Action_1  ;; 0xffff8aaa
   \   00000020   9A42               CMP      R2,R3
   \   00000022   10D0               BEQ      ??ProcGetReg_Action_2
    233                {
    234                  Proc->Out=MainStg->StageI[Proc->Nr].Value[Proc->Tag.RegNr];  
   \   00000024   027A               LDRB     R2,[R0, #+8]
   \   00000026   5200               LSLS     R2,R2,#+1
   \   00000028   0123               MOVS     R3,#+1
   \   0000002A   C356               LDRSB    R3,[R0, R3]
   \   0000002C   2C00               MOVS     R4,R5
   \   0000002E   6343               MULS     R3,R4,R3
   \   00000030   C918               ADDS     R1,R1,R3
   \   00000032   8918               ADDS     R1,R1,R2
   \   00000034   A031               ADDS     R1,R1,#+160
   \   00000036   0988               LDRH     R1,[R1, #+0]
   \   00000038   4182               STRH     R1,[R0, #+18]
   \   0000003A   04E0               B        ??ProcGetReg_Action_2
    235                }
    236            }else{
    237                Proc->Out=VariablesAnal[Proc->Tag.RegNr];
   \                     ??ProcGetReg_Action_0:
   \   0000003C   017A               LDRB     R1,[R0, #+8]
   \   0000003E   4900               LSLS     R1,R1,#+1
   \   00000040   ....               LDR      R2,??DataTable6  ;; VariablesAnal
   \   00000042   515A               LDRH     R1,[R2, R1]
   \   00000044   4182               STRH     R1,[R0, #+18]
    238            }
    239               
    240          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcGetReg_Action_2:
   \   00000046   38BC               POP      {R3-R5}
   \   00000048   01BC               POP      {R0}
   \   0000004A   0047               BX       R0               ;; return
   \                     ??ProcGetReg_Action_1:
   \   0000004C   AA8AFFFF           DC32     0xffff8aaa
    241          
    242          
    243          
    244          //*-----------------------------------------------------------------------------
    245          //* Nazwa funkcji :    ProcSetAnal_Action
    246          //* Funkcja procedury "Ustawienie wyjœcia analogowego"
    247          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    248          void ProcSetAnal_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    249          {  
   \                     ProcSetAnal_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    250            if (Proc->Nr>=0)
   \   00000002   0123               MOVS     R3,#+1
   \   00000004   CB56               LDRSB    R3,[R1, R3]
   \   00000006   002B               CMP      R3,#+0
   \   00000008   0CD4               BMI      ??ProcSetAnal_Action_0
    251            {
    252                MainStg->StageQ[Proc->Nr].Value[Proc->Tag.RegNr]=*PrvOut;
   \   0000000A   D723               MOVS     R3,#+215
   \   0000000C   9B00               LSLS     R3,R3,#+2        ;; #+860
   \   0000000E   0C7A               LDRB     R4,[R1, #+8]
   \   00000010   6400               LSLS     R4,R4,#+1
   \   00000012   0125               MOVS     R5,#+1
   \   00000014   4957               LDRSB    R1,[R1, R5]
   \   00000016   1425               MOVS     R5,#+20
   \   00000018   6943               MULS     R1,R5,R1
   \   0000001A   5118               ADDS     R1,R2,R1
   \   0000001C   0919               ADDS     R1,R1,R4
   \   0000001E   0088               LDRH     R0,[R0, #+0]
   \   00000020   C852               STRH     R0,[R1, R3]
   \   00000022   04E0               B        ??ProcSetAnal_Action_1
    253            }else{
    254                VariablesAnal[Proc->Tag.RegNr]=*PrvOut;
   \                     ??ProcSetAnal_Action_0:
   \   00000024   097A               LDRB     R1,[R1, #+8]
   \   00000026   4900               LSLS     R1,R1,#+1
   \   00000028   ....               LDR      R2,??DataTable6  ;; VariablesAnal
   \   0000002A   0088               LDRH     R0,[R0, #+0]
   \   0000002C   5052               STRH     R0,[R2, R1]
    255            }   
    256           
    257          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcSetAnal_Action_1:
   \   0000002E   38BC               POP      {R3-R5}
   \   00000030   01BC               POP      {R0}
   \   00000032   0047               BX       R0               ;; return
    258          
    259          
    260          
    261          
    262          //*-----------------------------------------------------------------------------
    263          //* Nazwa funkcji :    ProcConstAnal_Action
    264          //* Funkcja procedury "staa analogowa"
    265          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    266          void ProcConstAnal_Action(_Procedure *Proc) 
    267          {  
    268            Proc->Out=Proc->Tag.ConstAnValue;  
   \                     ProcConstAnal_Action:
   \   00000000   0189               LDRH     R1,[R0, #+8]
   \   00000002   4182               STRH     R1,[R0, #+18]
    269          }//_______________________ Koniec funkcji  ____________________________
   \   00000004   7047               BX       LR               ;; return
    270          
    271          
    272          
    273          
    274          
    275          //*-----------------------------------------------------------------------------
    276          
    277          
    278          
    279          
    280          
    281          //*-----------------------------------------------------------------------------
    282          //* Nazwa funkcji :    ProcStB_Action
    283          //* Funkcja procedury "Akcja przycisków przycisków"
    284          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    285          void ProcStB_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    286          {  
   \                     ProcStB_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    287             if (*PrvOut)
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C05E               LDRSH    R0,[R0, R3]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   06D0               BEQ      ??ProcStB_Action_0
    288             {
    289                Proc->Out=MainStg->StageButtonExe[Proc->Nr];  
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   0856               LDRSB    R0,[R1, R0]
   \   0000000E   1018               ADDS     R0,R2,R0
   \   00000010   5030               ADDS     R0,R0,#+80
   \   00000012   0078               LDRB     R0,[R0, #+0]
   \   00000014   4882               STRH     R0,[R1, #+18]
   \   00000016   00E0               B        ??ProcStB_Action_1
    290          
    291             }else{
    292               Proc->Out=0;
   \                     ??ProcStB_Action_0:
   \   00000018   4882               STRH     R0,[R1, #+18]
    293             }
    294          
    295          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStB_Action_1:
   \   0000001A   08BC               POP      {R3}
   \   0000001C   01BC               POP      {R0}
   \   0000001E   0047               BX       R0               ;; return
    296          
    297          
    298          
    299          //*-----------------------------------------------------------------------------
    300          //* Nazwa funkcji :    ProcStQ_Action
    301          //* Funkcja procedury "Stan wyjœcia"
    302          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    303          void ProcStQ_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    304          {  
   \                     ProcStQ_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0C00               MOVS     R4,R1
    305             if (*PrvOut)
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   405E               LDRSH    R0,[R0, R1]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   0ED0               BEQ      ??ProcStQ_Action_0
    306             {
    307                Proc->Out=PortStageRead(MainStg->StageQ[Proc->Nr].Port,Proc->Tag.Port);  
   \   0000000C   217A               LDRB     R1,[R4, #+8]
   \   0000000E   D720               MOVS     R0,#+215
   \   00000010   8000               LSLS     R0,R0,#+2        ;; #+860
   \   00000012   0123               MOVS     R3,#+1
   \   00000014   E356               LDRSB    R3,[R4, R3]
   \   00000016   1425               MOVS     R5,#+20
   \   00000018   6B43               MULS     R3,R5,R3
   \   0000001A   D218               ADDS     R2,R2,R3
   \   0000001C   105A               LDRH     R0,[R2, R0]
   \   0000001E   0004               LSLS     R0,R0,#+16
   \   00000020   0014               ASRS     R0,R0,#+16
   \   00000022   ........           BL       PortStageRead
   \   00000026   6082               STRH     R0,[R4, #+18]
   \   00000028   00E0               B        ??ProcStQ_Action_1
    308             }else{
    309                Proc->Out=0;
   \                     ??ProcStQ_Action_0:
   \   0000002A   6082               STRH     R0,[R4, #+18]
    310             }
    311          
    312          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStQ_Action_1:
   \   0000002C   38BC               POP      {R3-R5}
   \   0000002E   01BC               POP      {R0}
   \   00000030   0047               BX       R0               ;; return
    313          
    314          
    315          
    316          
    317          
    318          //*-----------------------------------------------------------------------------
    319          //* Nazwa funkcji :    ProcStS_Action
    320          //* Funkcja procedury "Stan sceny"
    321          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    322          void ProcStS_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    323          {  
   \                     ProcStS_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    324            Proc->Out=0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   4B82               STRH     R3,[R1, #+18]
    325             if (*PrvOut)
   \   00000006   C05E               LDRSH    R0,[R0, R3]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   08D0               BEQ      ??ProcStS_Action_0
    326             {
    327                if (Proc->Nr==MainStg->SceneNr) Proc->Out=1;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   0856               LDRSB    R0,[R1, R0]
   \   00000010   C323               MOVS     R3,#+195
   \   00000012   DB00               LSLS     R3,R3,#+3        ;; #+1560
   \   00000014   D25C               LDRB     R2,[R2, R3]
   \   00000016   9042               CMP      R0,R2
   \   00000018   01D1               BNE      ??ProcStS_Action_0
   \   0000001A   0120               MOVS     R0,#+1
   \   0000001C   4882               STRH     R0,[R1, #+18]
    328             }
    329          
    330          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStS_Action_0:
   \   0000001E   08BC               POP      {R3}
   \   00000020   01BC               POP      {R0}
   \   00000022   0047               BX       R0               ;; return
    331          
    332          
    333          
    334          /*
    335          
    336          //-----------------------------------------------------------------------------
    337          // Nazwa funkcji :    ProcStT_Action
    338          // Funkcja procedury "Stan timera"
    339          //-----------------------------------------------------------------------------
    340          void ProcStT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    341          {  
    342             if (*PrvOut)
    343             {
    344                Proc->Out=PortStageRead(MainStg->StageTimer[Proc->Nr].Port,Proc->Tag.Port);  
    345             }else{
    346                Proc->Out=0;
    347             }
    348          
    349          }//_______________________ Koniec funkcji  ____________________________
    350          
    351          
    352          
    353          
    354          //-----------------------------------------------------------------------------
    355          // Nazwa funkcji :    ProcStT_Action
    356          // Funkcja procedury "Stan timera"
    357          //-----------------------------------------------------------------------------
    358          void ProcStNT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    359          {  
    360             if (*PrvOut) 
    361             {
    362                if (PortStageRead(MainStg->StageTimer[Proc->Nr].Port,Proc->Tag.Port))
    363                {
    364                  Proc->Out=0;
    365                }else{
    366                  Proc->Out=1;  
    367                }
    368             }else{
    369                Proc->Out=0;
    370             }
    371          
    372          }//_______________________ Koniec funkcji  ____________________________
    373          */
    374          
    375          
    376          
    377           extern unsigned long long g_NextTimeProgram;
    378          
    379          
    380          //*-----------------------------------------------------------------------------
    381          //* Nazwa funkcji :    ProcWOUT_Action
    382          //* Funkcja procedury "Ustaw stan wyjœcia"
    383          //*-----------------------------------------------------------------------------
    384          

   \                                 In section Debug.txt, align 4, keep-with-next
    385          void ProcWOUT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    386          {  
   \                     ProcWOUT_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    387          
    388               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   205E               LDRSH    R0,[R4, R0]
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   33D1               BNE      ??ProcWOUT_Action_0
   \   00000010   1220               MOVS     R0,#+18
   \   00000012   285E               LDRSH    R0,[R5, R0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   2FD1               BNE      ??ProcWOUT_Action_0
    389               {
    390                if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   2856               LDRSB    R0,[R5, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   1AD4               BMI      ??ProcWOUT_Action_1
    391                {
    392                  
    393                  
    394                 PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,1); 
                                     ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000020   0122               MOVS     R2,#+1
   \   00000022   297A               LDRB     R1,[R5, #+8]
   \   00000024   D720               MOVS     R0,#+215
   \   00000026   8000               LSLS     R0,R0,#+2        ;; #+860
   \   00000028   1300               MOVS     R3,R2
   \   0000002A   EB56               LDRSB    R3,[R5, R3]
   \   0000002C   1427               MOVS     R7,#+20
   \   0000002E   7B43               MULS     R3,R7,R3
   \   00000030   F318               ADDS     R3,R6,R3
   \   00000032   1818               ADDS     R0,R3,R0
   \   00000034   ........           BL       PortStageSet
    395                 
    396                 if (TransQuality.Mensur[Proc->Nr-1]>0)    
   \   00000038   0120               MOVS     R0,#+1
   \   0000003A   2856               LDRSB    R0,[R5, R0]
   \   0000003C   8000               LSLS     R0,R0,#+2
   \   0000003E   ....               LDR      R1,??DataTable10  ;; TransQuality
   \   00000040   0818               ADDS     R0,R1,R0
   \   00000042   806C               LDR      R0,[R0, #+72]
   \   00000044   0028               CMP      R0,#+0
   \   00000046   17D0               BEQ      ??ProcWOUT_Action_0
    397                   MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   00000048   ....               LDR      R0,??DataTable11  ;; 0x619
   \   0000004A   0121               MOVS     R1,#+1
   \   0000004C   6956               LDRSB    R1,[R5, R1]
   \   0000004E   7118               ADDS     R1,R6,R1
   \   00000050   3A00               MOVS     R2,R7
   \   00000052   0A54               STRB     R2,[R1, R0]
   \   00000054   10E0               B        ??ProcWOUT_Action_0
    398                 
    399                 
    400                                                       
    401                 
    402                 #ifdef _LIVE_RJESTR 
    403                 LIVE_TAB[LIVE_TAB_IDX]=0xF000 | ((Proc->Nr&0xF)<<8) | ((MainStg->StageQ[Proc->Nr].Port)&0xFF);
    404                 if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    405                 #endif
    406          
    407                 
    408                 //je¿eli zmienna dwustanowa  
    409                }else{
    410                    Variables[Proc->Tag.Port/8] |= 1<<(Proc->Tag.Port%8);
   \                     ??ProcWOUT_Action_1:
   \   00000056   ....               LDR      R1,??DataTable12  ;; Variables
   \   00000058   287A               LDRB     R0,[R5, #+8]
   \   0000005A   C010               ASRS     R0,R0,#+3
   \   0000005C   8446               MOV      R12,R0
   \   0000005E   287A               LDRB     R0,[R5, #+8]
   \   00000060   C010               ASRS     R0,R0,#+3
   \   00000062   0B5C               LDRB     R3,[R1, R0]
   \   00000064   0127               MOVS     R7,#+1
   \   00000066   287A               LDRB     R0,[R5, #+8]
   \   00000068   0200               MOVS     R2,R0
   \   0000006A   D208               LSRS     R2,R2,#+3
   \   0000006C   D200               LSLS     R2,R2,#+3
   \   0000006E   801A               SUBS     R0,R0,R2
   \   00000070   8740               LSLS     R7,R7,R0
   \   00000072   1F43               ORRS     R7,R7,R3
   \   00000074   6046               MOV      R0,R12
   \   00000076   0F54               STRB     R7,[R1, R0]
    411                    
    412                  #ifdef _LIVE_RJESTR   
    413                    LIVE_TAB[LIVE_TAB_IDX]=0xF000 | ((Proc->Nr&0xF)<<8) | ((MainStg->StageQ[Proc->Nr].Port)&0xFF);
    414                    if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    415                  #endif
    416                }
    417               }
    418          
    419               if ((*PrvOut==0) && (Proc->Out==1))
   \                     ??ProcWOUT_Action_0:
   \   00000078   0020               MOVS     R0,#+0
   \   0000007A   205E               LDRSH    R0,[R4, R0]
   \   0000007C   0028               CMP      R0,#+0
   \   0000007E   30D1               BNE      ??ProcWOUT_Action_2
   \   00000080   1220               MOVS     R0,#+18
   \   00000082   285E               LDRSH    R0,[R5, R0]
   \   00000084   0128               CMP      R0,#+1
   \   00000086   2CD1               BNE      ??ProcWOUT_Action_2
    420               {
    421                 if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000088   2856               LDRSB    R0,[R5, R0]
   \   0000008A   0028               CMP      R0,#+0
   \   0000008C   1AD4               BMI      ??ProcWOUT_Action_3
    422                 {
    423                   PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,0); 
                                       ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   0000008E   0022               MOVS     R2,#+0
   \   00000090   297A               LDRB     R1,[R5, #+8]
   \   00000092   D720               MOVS     R0,#+215
   \   00000094   8000               LSLS     R0,R0,#+2        ;; #+860
   \   00000096   0123               MOVS     R3,#+1
   \   00000098   EB56               LDRSB    R3,[R5, R3]
   \   0000009A   1427               MOVS     R7,#+20
   \   0000009C   7B43               MULS     R3,R7,R3
   \   0000009E   F318               ADDS     R3,R6,R3
   \   000000A0   1818               ADDS     R0,R3,R0
   \   000000A2   ........           BL       PortStageSet
    424                   
    425                   if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \   000000A6   0120               MOVS     R0,#+1
   \   000000A8   2856               LDRSB    R0,[R5, R0]
   \   000000AA   8000               LSLS     R0,R0,#+2
   \   000000AC   ....               LDR      R1,??DataTable10  ;; TransQuality
   \   000000AE   0818               ADDS     R0,R1,R0
   \   000000B0   806C               LDR      R0,[R0, #+72]
   \   000000B2   0028               CMP      R0,#+0
   \   000000B4   15D0               BEQ      ??ProcWOUT_Action_2
    426                     MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   000000B6   ....               LDR      R0,??DataTable11  ;; 0x619
   \   000000B8   0121               MOVS     R1,#+1
   \   000000BA   6956               LDRSB    R1,[R5, R1]
   \   000000BC   7118               ADDS     R1,R6,R1
   \   000000BE   3A00               MOVS     R2,R7
   \   000000C0   0A54               STRB     R2,[R1, R0]
   \   000000C2   0EE0               B        ??ProcWOUT_Action_2
    427                  //je¿eli zmienna dwustanowa  
    428                }else{
    429                    Variables[Proc->Tag.Port/8]&= ~(1<<(Proc->Tag.Port%8));
   \                     ??ProcWOUT_Action_3:
   \   000000C4   ....               LDR      R1,??DataTable12  ;; Variables
   \   000000C6   287A               LDRB     R0,[R5, #+8]
   \   000000C8   C010               ASRS     R0,R0,#+3
   \   000000CA   2A7A               LDRB     R2,[R5, #+8]
   \   000000CC   D210               ASRS     R2,R2,#+3
   \   000000CE   8A5C               LDRB     R2,[R1, R2]
   \   000000D0   0123               MOVS     R3,#+1
   \   000000D2   2E7A               LDRB     R6,[R5, #+8]
   \   000000D4   3700               MOVS     R7,R6
   \   000000D6   FF08               LSRS     R7,R7,#+3
   \   000000D8   FF00               LSLS     R7,R7,#+3
   \   000000DA   F61B               SUBS     R6,R6,R7
   \   000000DC   B340               LSLS     R3,R3,R6
   \   000000DE   9A43               BICS     R2,R2,R3
   \   000000E0   0A54               STRB     R2,[R1, R0]
    430                    #ifdef _LIVE_RJESTR 
    431                      LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    432                      if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    433                    #endif
    434                }  
    435               }
    436               Proc->Out=*PrvOut;
   \                     ??ProcWOUT_Action_2:
   \   000000E2   2088               LDRH     R0,[R4, #+0]
   \   000000E4   6882               STRH     R0,[R5, #+18]
    437            
    438          }//_______________________ Koniec funkcji  ____________________________
   \   000000E6   F8BC               POP      {R3-R7}
   \   000000E8   01BC               POP      {R0}
   \   000000EA   0047               BX       R0               ;; return
    439          
    440          
    441                
    442          
    443          //*-----------------------------------------------------------------------------
    444          //* Nazwa funkcji :    ProcWOUTS_Action
    445          //* Funkcja procedury "Ustaw stan wyjœcia na 1"
    446          //*-----------------------------------------------------------------------------
    447          

   \                                 In section Debug.txt, align 4, keep-with-next
    448          void ProcWOUTS_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    449          {  
   \                     ProcWOUTS_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    450          
    451               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   205E               LDRSH    R0,[R4, R0]
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   31D1               BNE      ??ProcWOUTS_Action_0
   \   00000010   1220               MOVS     R0,#+18
   \   00000012   285E               LDRSH    R0,[R5, R0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   2DD1               BNE      ??ProcWOUTS_Action_0
    452               {
    453                if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   2856               LDRSB    R0,[R5, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   1AD4               BMI      ??ProcWOUTS_Action_1
    454                {
    455                 PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,1); 
                                     ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000020   0122               MOVS     R2,#+1
   \   00000022   297A               LDRB     R1,[R5, #+8]
   \   00000024   D720               MOVS     R0,#+215
   \   00000026   8000               LSLS     R0,R0,#+2        ;; #+860
   \   00000028   1300               MOVS     R3,R2
   \   0000002A   EB56               LDRSB    R3,[R5, R3]
   \   0000002C   1427               MOVS     R7,#+20
   \   0000002E   7B43               MULS     R3,R7,R3
   \   00000030   F318               ADDS     R3,R6,R3
   \   00000032   1818               ADDS     R0,R3,R0
   \   00000034   ........           BL       PortStageSet
    456                 
    457                 if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \   00000038   0120               MOVS     R0,#+1
   \   0000003A   2856               LDRSB    R0,[R5, R0]
   \   0000003C   8000               LSLS     R0,R0,#+2
   \   0000003E   1049               LDR      R1,??ProcWOUTS_Action_2  ;; TransQuality
   \   00000040   0818               ADDS     R0,R1,R0
   \   00000042   806C               LDR      R0,[R0, #+72]
   \   00000044   0028               CMP      R0,#+0
   \   00000046   15D0               BEQ      ??ProcWOUTS_Action_0
    458                   MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   00000048   0E48               LDR      R0,??ProcWOUTS_Action_2+0x4  ;; 0x619
   \   0000004A   0121               MOVS     R1,#+1
   \   0000004C   6956               LDRSB    R1,[R5, R1]
   \   0000004E   7118               ADDS     R1,R6,R1
   \   00000050   3A00               MOVS     R2,R7
   \   00000052   0A54               STRB     R2,[R1, R0]
   \   00000054   0EE0               B        ??ProcWOUTS_Action_0
    459                
    460                 #ifdef _LIVE_RJESTR 
    461                 LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    462                 if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    463                 #endif
    464                 
    465                 //je¿eli zmienna dwustanowa  
    466                }else{
    467                    Variables[Proc->Tag.Port/8]|= 1<<(Proc->Tag.Port%8);
   \                     ??ProcWOUTS_Action_1:
   \   00000056   0C4A               LDR      R2,??ProcWOUTS_Action_2+0x8  ;; Variables
   \   00000058   287A               LDRB     R0,[R5, #+8]
   \   0000005A   0100               MOVS     R1,R0
   \   0000005C   C910               ASRS     R1,R1,#+3
   \   0000005E   C010               ASRS     R0,R0,#+3
   \   00000060   105C               LDRB     R0,[R2, R0]
   \   00000062   0123               MOVS     R3,#+1
   \   00000064   2E7A               LDRB     R6,[R5, #+8]
   \   00000066   3700               MOVS     R7,R6
   \   00000068   FF08               LSRS     R7,R7,#+3
   \   0000006A   FF00               LSLS     R7,R7,#+3
   \   0000006C   F61B               SUBS     R6,R6,R7
   \   0000006E   B340               LSLS     R3,R3,R6
   \   00000070   0343               ORRS     R3,R3,R0
   \   00000072   5354               STRB     R3,[R2, R1]
    468                }
    469               }
    470               Proc->Out=*PrvOut;
   \                     ??ProcWOUTS_Action_0:
   \   00000074   2088               LDRH     R0,[R4, #+0]
   \   00000076   6882               STRH     R0,[R5, #+18]
    471            
    472          }//_______________________ Koniec funkcji  ____________________________
   \   00000078   F8BC               POP      {R3-R7}
   \   0000007A   01BC               POP      {R0}
   \   0000007C   0047               BX       R0               ;; return
   \   0000007E   C046               Nop      
   \                     ??ProcWOUTS_Action_2:
   \   00000080   ........           DC32     TransQuality
   \   00000084   19060000           DC32     0x619
   \   00000088   ........           DC32     Variables
    473          
    474          
    475          //*-----------------------------------------------------------------------------
    476          //* Nazwa funkcji :    ProcWOUTR_Action
    477          //* Funkcja procedury "Ustaw stan wyjœcia  na 0"
    478          //*-----------------------------------------------------------------------------
    479          

   \                                 In section Debug.txt, align 4, keep-with-next
    480          void ProcWOUTR_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    481          {  
   \                     ProcWOUTR_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    482          
    483               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   205E               LDRSH    R0,[R4, R0]
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   31D1               BNE      ??ProcWOUTR_Action_0
   \   00000010   1220               MOVS     R0,#+18
   \   00000012   285E               LDRSH    R0,[R5, R0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   2DD1               BNE      ??ProcWOUTR_Action_0
    484               {
    485                if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   2856               LDRSB    R0,[R5, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   1AD4               BMI      ??ProcWOUTR_Action_1
    486                { 
    487                 PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,0); 
                                     ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000020   0022               MOVS     R2,#+0
   \   00000022   297A               LDRB     R1,[R5, #+8]
   \   00000024   D720               MOVS     R0,#+215
   \   00000026   8000               LSLS     R0,R0,#+2        ;; #+860
   \   00000028   0123               MOVS     R3,#+1
   \   0000002A   EB56               LDRSB    R3,[R5, R3]
   \   0000002C   1427               MOVS     R7,#+20
   \   0000002E   7B43               MULS     R3,R7,R3
   \   00000030   F318               ADDS     R3,R6,R3
   \   00000032   1818               ADDS     R0,R3,R0
   \   00000034   ........           BL       PortStageSet
    488                 
    489                 if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \   00000038   0120               MOVS     R0,#+1
   \   0000003A   2856               LDRSB    R0,[R5, R0]
   \   0000003C   8000               LSLS     R0,R0,#+2
   \   0000003E   1049               LDR      R1,??ProcWOUTR_Action_2  ;; TransQuality
   \   00000040   0818               ADDS     R0,R1,R0
   \   00000042   806C               LDR      R0,[R0, #+72]
   \   00000044   0028               CMP      R0,#+0
   \   00000046   15D0               BEQ      ??ProcWOUTR_Action_0
    490                   MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   00000048   0E48               LDR      R0,??ProcWOUTR_Action_2+0x4  ;; 0x619
   \   0000004A   0121               MOVS     R1,#+1
   \   0000004C   6956               LDRSB    R1,[R5, R1]
   \   0000004E   7118               ADDS     R1,R6,R1
   \   00000050   3A00               MOVS     R2,R7
   \   00000052   0A54               STRB     R2,[R1, R0]
   \   00000054   0EE0               B        ??ProcWOUTR_Action_0
    491                 
    492                 #ifdef _LIVE_RJESTR 
    493                  LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    494                  if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    495                 #endif
    496                  
    497                  //je¿eli zmienna dwustanowa  
    498                }else{
    499                    Variables[Proc->Tag.Port/8]&= ~(1<<(Proc->Tag.Port%8));
   \                     ??ProcWOUTR_Action_1:
   \   00000056   0C48               LDR      R0,??ProcWOUTR_Action_2+0x8  ;; Variables
   \   00000058   297A               LDRB     R1,[R5, #+8]
   \   0000005A   C910               ASRS     R1,R1,#+3
   \   0000005C   2A7A               LDRB     R2,[R5, #+8]
   \   0000005E   D210               ASRS     R2,R2,#+3
   \   00000060   825C               LDRB     R2,[R0, R2]
   \   00000062   0123               MOVS     R3,#+1
   \   00000064   2E7A               LDRB     R6,[R5, #+8]
   \   00000066   3700               MOVS     R7,R6
   \   00000068   FF08               LSRS     R7,R7,#+3
   \   0000006A   FF00               LSLS     R7,R7,#+3
   \   0000006C   F61B               SUBS     R6,R6,R7
   \   0000006E   B340               LSLS     R3,R3,R6
   \   00000070   9A43               BICS     R2,R2,R3
   \   00000072   4254               STRB     R2,[R0, R1]
    500                }
    501               }
    502               Proc->Out=*PrvOut;
   \                     ??ProcWOUTR_Action_0:
   \   00000074   2088               LDRH     R0,[R4, #+0]
   \   00000076   6882               STRH     R0,[R5, #+18]
    503            
    504          }//_______________________ Koniec funkcji  ____________________________
   \   00000078   F8BC               POP      {R3-R7}
   \   0000007A   01BC               POP      {R0}
   \   0000007C   0047               BX       R0               ;; return
   \   0000007E   C046               Nop      
   \                     ??ProcWOUTR_Action_2:
   \   00000080   ........           DC32     TransQuality
   \   00000084   19060000           DC32     0x619
   \   00000088   ........           DC32     Variables
    505          
    506          
    507          
    508          
    509          //*-----------------------------------------------------------------------------
    510          //* Nazwa funkcji :    ProcWOUTC_Action
    511          //* Funkcja procedury "zmaina stanu wyjœcia/zmiennej na przeciwny "
    512          //*-----------------------------------------------------------------------------
    513          

   \                                 In section Debug.txt, align 4, keep-with-next
    514          void ProcWOUTC_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    515          {  
   \                     ProcWOUTC_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    516          
    517               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   205E               LDRSH    R0,[R4, R0]
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   4DD1               BNE      ??ProcWOUTC_Action_0
   \   00000010   1220               MOVS     R0,#+18
   \   00000012   285E               LDRSH    R0,[R5, R0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   49D1               BNE      ??ProcWOUTC_Action_0
    518               {
    519                if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   2856               LDRSB    R0,[R5, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   36D4               BMI      ??ProcWOUTC_Action_1
    520                {
    521                   if (PortStageRead(MainStg->StageQ[Proc->Nr].Port,Proc->Tag.Port)==1) //je¿eli wyjœcie w stanie wysokim to zeruj je¿eli nie to ustaw 1
   \   00000020   297A               LDRB     R1,[R5, #+8]
   \   00000022   D720               MOVS     R0,#+215
   \   00000024   8000               LSLS     R0,R0,#+2        ;; #+860
   \   00000026   0122               MOVS     R2,#+1
   \   00000028   AA56               LDRSB    R2,[R5, R2]
   \   0000002A   1423               MOVS     R3,#+20
   \   0000002C   5A43               MULS     R2,R3,R2
   \   0000002E   B218               ADDS     R2,R6,R2
   \   00000030   105A               LDRH     R0,[R2, R0]
   \   00000032   0004               LSLS     R0,R0,#+16
   \   00000034   0014               ASRS     R0,R0,#+16
   \   00000036   ........           BL       PortStageRead
   \   0000003A   0128               CMP      R0,#+1
   \   0000003C   0CD1               BNE      ??ProcWOUTC_Action_2
    522                   { 
    523                      PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,0); 
                                          ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   0000003E   0022               MOVS     R2,#+0
   \   00000040   297A               LDRB     R1,[R5, #+8]
   \   00000042   D720               MOVS     R0,#+215
   \   00000044   8000               LSLS     R0,R0,#+2        ;; #+860
   \   00000046   0123               MOVS     R3,#+1
   \   00000048   EB56               LDRSB    R3,[R5, R3]
   \   0000004A   1427               MOVS     R7,#+20
   \   0000004C   7B43               MULS     R3,R7,R3
   \   0000004E   F318               ADDS     R3,R6,R3
   \   00000050   1818               ADDS     R0,R3,R0
   \   00000052   ........           BL       PortStageSet
   \   00000056   0BE0               B        ??ProcWOUTC_Action_3
    524                   }else{
    525                      PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,1);
                                          ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \                     ??ProcWOUTC_Action_2:
   \   00000058   0122               MOVS     R2,#+1
   \   0000005A   297A               LDRB     R1,[R5, #+8]
   \   0000005C   D720               MOVS     R0,#+215
   \   0000005E   8000               LSLS     R0,R0,#+2        ;; #+860
   \   00000060   1300               MOVS     R3,R2
   \   00000062   EB56               LDRSB    R3,[R5, R3]
   \   00000064   1427               MOVS     R7,#+20
   \   00000066   7B43               MULS     R3,R7,R3
   \   00000068   F318               ADDS     R3,R6,R3
   \   0000006A   1818               ADDS     R0,R3,R0
   \   0000006C   ........           BL       PortStageSet
    526                   }
    527                   
    528                   
    529                   if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \                     ??ProcWOUTC_Action_3:
   \   00000070   0120               MOVS     R0,#+1
   \   00000072   2856               LDRSB    R0,[R5, R0]
   \   00000074   8000               LSLS     R0,R0,#+2
   \   00000076   1049               LDR      R1,??ProcWOUTC_Action_4  ;; TransQuality
   \   00000078   0818               ADDS     R0,R1,R0
   \   0000007A   806C               LDR      R0,[R0, #+72]
   \   0000007C   0028               CMP      R0,#+0
   \   0000007E   15D0               BEQ      ??ProcWOUTC_Action_0
    530                     MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   00000080   0E48               LDR      R0,??ProcWOUTC_Action_4+0x4  ;; 0x619
   \   00000082   0121               MOVS     R1,#+1
   \   00000084   6956               LDRSB    R1,[R5, R1]
   \   00000086   7118               ADDS     R1,R6,R1
   \   00000088   3A00               MOVS     R2,R7
   \   0000008A   0A54               STRB     R2,[R1, R0]
   \   0000008C   0EE0               B        ??ProcWOUTC_Action_0
    531                  
    532                   
    533                   
    534                  #ifdef _LIVE_RJESTR 
    535                    LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    536                    if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    537                  #endif
    538                   
    539                 
    540                 //je¿eli zmienna dwustanowa  
    541                }else{
    542                    Variables[Proc->Tag.Port/8]|= 1<<(Proc->Tag.Port%8);
   \                     ??ProcWOUTC_Action_1:
   \   0000008E   0C4A               LDR      R2,??ProcWOUTC_Action_4+0x8  ;; Variables
   \   00000090   287A               LDRB     R0,[R5, #+8]
   \   00000092   0100               MOVS     R1,R0
   \   00000094   C910               ASRS     R1,R1,#+3
   \   00000096   C010               ASRS     R0,R0,#+3
   \   00000098   105C               LDRB     R0,[R2, R0]
   \   0000009A   0123               MOVS     R3,#+1
   \   0000009C   2E7A               LDRB     R6,[R5, #+8]
   \   0000009E   3700               MOVS     R7,R6
   \   000000A0   FF08               LSRS     R7,R7,#+3
   \   000000A2   FF00               LSLS     R7,R7,#+3
   \   000000A4   F61B               SUBS     R6,R6,R7
   \   000000A6   B340               LSLS     R3,R3,R6
   \   000000A8   0343               ORRS     R3,R3,R0
   \   000000AA   5354               STRB     R3,[R2, R1]
    543                }
    544               }
    545               Proc->Out=*PrvOut;
   \                     ??ProcWOUTC_Action_0:
   \   000000AC   2088               LDRH     R0,[R4, #+0]
   \   000000AE   6882               STRH     R0,[R5, #+18]
    546            
    547          }//_______________________ Koniec funkcji  ____________________________
   \   000000B0   F8BC               POP      {R3-R7}
   \   000000B2   01BC               POP      {R0}
   \   000000B4   0047               BX       R0               ;; return
   \   000000B6   C046               Nop      
   \                     ??ProcWOUTC_Action_4:
   \   000000B8   ........           DC32     TransQuality
   \   000000BC   19060000           DC32     0x619
   \   000000C0   ........           DC32     Variables
    548          
    549          
    550          
    551          
    552          
    553          /*
    554          //-----------------------------------------------------------------------------
    555          // Nazwa funkcji :    ProcSetT_Action
    556          // Funkcja procedury "Forsuj stan timera"
    557          //-----------------------------------------------------------------------------
    558          
    559          void ProcRstT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    560          {  
    561               if ((*PrvOut==1) && (Proc->Out==0))
    562               {
    563                  MainStg->StageTimer[Proc->Nr].Curent=0;
    564                  MainObiect.Timer[Proc->Nr]=0;
    565               }
    566               Proc->Out=*PrvOut;
    567            
    568          }//_______________________ Koniec funkcji  ____________________________
    569          */
    570          
    571          
    572          
    573          //*-----------------------------------------------------------------------------
    574          //* Nazwa funkcji :    ProcNOT_Action
    575          //* Funkcja procedury "Negacja
    576          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    577          void ProcNOT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    578          {  
    579             if (*PrvOut)
   \                     ProcNOT_Action:
   \   00000000   0022               MOVS     R2,#+0
   \   00000002   805E               LDRSH    R0,[R0, R2]
   \   00000004   421E               SUBS     R2,R0,#+1
   \   00000006   9241               SBCS     R2,R2,R2
   \   00000008   D20F               LSRS     R2,R2,#+31
   \   0000000A   4A82               STRH     R2,[R1, #+18]
    580             {
    581                Proc->Out=0;  
    582             }else{
    583                Proc->Out=1;
    584             }
    585          }//_______________________ Koniec funkcji__ ____________________________
   \   0000000C   7047               BX       LR               ;; return
    586          
    587          
    588          
    589          
    590          //*-----------------------------------------------------------------------------
    591          //* Nazwa funkcji :    ProcToggleT_Action
    592          //* Funkcja procedury "Przerzutnik typu T"
    593          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    594          void ProcToggleRS_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    595          {  
   \                     ProcToggleRS_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    596             if ((*PrvOut))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C05E               LDRSH    R0,[R0, R3]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   02D0               BEQ      ??ProcToggleRS_Action_0
    597             {
    598               Proc->Out=1;
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   5082               STRH     R0,[R2, #+18]
   \   0000000E   04E0               B        ??ProcToggleRS_Action_1
    599             }
    600             else if (*UpOut)
   \                     ??ProcToggleRS_Action_0:
   \   00000010   085E               LDRSH    R0,[R1, R0]
   \   00000012   0028               CMP      R0,#+0
   \   00000014   01D0               BEQ      ??ProcToggleRS_Action_1
    601             {
    602               Proc->Out=0;
   \   00000016   1800               MOVS     R0,R3
   \   00000018   5082               STRH     R0,[R2, #+18]
    603             }
    604             
    605          
    606               
    607          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcToggleRS_Action_1:
   \   0000001A   08BC               POP      {R3}
   \   0000001C   01BC               POP      {R0}
   \   0000001E   0047               BX       R0               ;; return
    608          
    609          
    610          
    611          
    612          //*-----------------------------------------------------------------------------
    613          //* Nazwa funkcji :    ProcToggleT_Action
    614          //* Funkcja procedury "Przerzutnik typu T"
    615          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    616          void ProcToggleT_Action(short int *PrvOut, _Procedure *Proc) 
    617          {  
   \                     ProcToggleT_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    618             if ((*PrvOut) && (Proc->LastIn==0) && (Proc->Out==0))
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   825E               LDRSH    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   09D0               BEQ      ??ProcToggleT_Action_0
   \   0000000A   0A7C               LDRB     R2,[R1, #+16]
   \   0000000C   002A               CMP      R2,#+0
   \   0000000E   06D1               BNE      ??ProcToggleT_Action_0
   \   00000010   1222               MOVS     R2,#+18
   \   00000012   8A5E               LDRSH    R2,[R1, R2]
   \   00000014   002A               CMP      R2,#+0
   \   00000016   02D1               BNE      ??ProcToggleT_Action_0
    619             {
    620               Proc->Out=1;
   \   00000018   0122               MOVS     R2,#+1
   \   0000001A   4A82               STRH     R2,[R1, #+18]
   \   0000001C   0CE0               B        ??ProcToggleT_Action_1
    621             }
    622             else if ((*PrvOut) && (Proc->LastIn==0) && (Proc->Out==1))
   \                     ??ProcToggleT_Action_0:
   \   0000001E   0022               MOVS     R2,#+0
   \   00000020   825E               LDRSH    R2,[R0, R2]
   \   00000022   002A               CMP      R2,#+0
   \   00000024   08D0               BEQ      ??ProcToggleT_Action_1
   \   00000026   0A7C               LDRB     R2,[R1, #+16]
   \   00000028   002A               CMP      R2,#+0
   \   0000002A   05D1               BNE      ??ProcToggleT_Action_1
   \   0000002C   1222               MOVS     R2,#+18
   \   0000002E   8A5E               LDRSH    R2,[R1, R2]
   \   00000030   012A               CMP      R2,#+1
   \   00000032   01D1               BNE      ??ProcToggleT_Action_1
    623             {
    624               Proc->Out=0;
   \   00000034   0022               MOVS     R2,#+0
   \   00000036   4A82               STRH     R2,[R1, #+18]
    625             }
    626             
    627             Proc->LastIn=*PrvOut;
   \                     ??ProcToggleT_Action_1:
   \   00000038   0088               LDRH     R0,[R0, #+0]
   \   0000003A   0874               STRB     R0,[R1, #+16]
    628                 
    629          
    630          
    631          }//_______________________ Koniec funkcji__ ____________________________
   \   0000003C   08BC               POP      {R3}
   \   0000003E   01BC               POP      {R0}
   \   00000040   0047               BX       R0               ;; return
    632          
    633          
    634          //*-----------------------------------------------------------------------------
    635          //* Nazwa funkcji :    ProcTLI1_Action
    636          //* Funkcja procedury "Procedura impulsu jednocyklowego
    637          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    638          void ProcTLI1_Action(short int *PrvOut, _Procedure *Proc) 
    639          {  
   \                     ProcTLI1_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    640             if ((*PrvOut) && (Proc->LastIn==0))
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   825E               LDRSH    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   05D0               BEQ      ??ProcTLI1_Action_0
   \   0000000A   0A7C               LDRB     R2,[R1, #+16]
   \   0000000C   531E               SUBS     R3,R2,#+1
   \   0000000E   9B41               SBCS     R3,R3,R3
   \   00000010   DB0F               LSRS     R3,R3,#+31
   \   00000012   4B82               STRH     R3,[R1, #+18]
   \   00000014   00E0               B        ??ProcTLI1_Action_1
    641             {
    642               Proc->Out=1;
    643             }
    644             else
    645             {
    646               Proc->Out=0;
   \                     ??ProcTLI1_Action_0:
   \   00000016   4A82               STRH     R2,[R1, #+18]
    647             }
    648             
    649             Proc->LastIn=*PrvOut;
   \                     ??ProcTLI1_Action_1:
   \   00000018   0088               LDRH     R0,[R0, #+0]
   \   0000001A   0874               STRB     R0,[R1, #+16]
    650                 
    651          
    652          
    653          }//_______________________ Koniec funkcji__ ____________________________
   \   0000001C   08BC               POP      {R3}
   \   0000001E   01BC               POP      {R0}
   \   00000020   0047               BX       R0               ;; return
    654          
    655          
    656          
    657          
    658          //*-----------------------------------------------------------------------------
    659          //* Nazwa funkcji :    ProcLim_Action
    660          //* Funkcja procedury "Porównanie wartoœci. Je¿eli 1>2 q=1"
    661          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    662          void ProcLim_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    663          {  
   \                     ProcLim_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    664             if ((*PrvOut)>(*UpOut))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C95E               LDRSH    R1,[R1, R3]
   \   00000006   C05E               LDRSH    R0,[R0, R3]
   \   00000008   8142               CMP      R1,R0
   \   0000000A   02DA               BGE      ??ProcLim_Action_0
    665             {
    666               Proc->Out=1;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   5082               STRH     R0,[R2, #+18]
   \   00000010   01E0               B        ??ProcLim_Action_1
    667             }
    668             else
    669             {
    670               Proc->Out=0;
   \                     ??ProcLim_Action_0:
   \   00000012   1800               MOVS     R0,R3
   \   00000014   5082               STRH     R0,[R2, #+18]
    671             }
    672               
    673          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcLim_Action_1:
   \   00000016   08BC               POP      {R3}
   \   00000018   01BC               POP      {R0}
   \   0000001A   0047               BX       R0               ;; return
    674          
    675          
    676          
    677          
    678          //*-----------------------------------------------------------------------------
    679          //* Nazwa funkcji :    ProcEven_Action
    680          //* Funkcja procedury "Porównanie wartoœci. Je¿eli 1=2 q=1"
    681          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    682          void ProcEven_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    683          {  
   \                     ProcEven_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    684             if ((*PrvOut)==(*UpOut))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C05E               LDRSH    R0,[R0, R3]
   \   00000006   C95E               LDRSH    R1,[R1, R3]
   \   00000008   8842               CMP      R0,R1
   \   0000000A   02D1               BNE      ??ProcEven_Action_0
    685             {
    686               Proc->Out=1;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   5082               STRH     R0,[R2, #+18]
   \   00000010   01E0               B        ??ProcEven_Action_1
    687             }
    688             else
    689             {
    690               Proc->Out=0;
   \                     ??ProcEven_Action_0:
   \   00000012   1800               MOVS     R0,R3
   \   00000014   5082               STRH     R0,[R2, #+18]
    691             }
    692             
    693          
    694               
    695          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcEven_Action_1:
   \   00000016   08BC               POP      {R3}
   \   00000018   01BC               POP      {R0}
   \   0000001A   0047               BX       R0               ;; return
    696          
    697          
    698          
    699          
    700          //*-----------------------------------------------------------------------------
    701          //* Nazwa funkcji :    ProcPlus_Action
    702          //* Funkcja procedury "Plus"
    703          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    704          void ProcPlus_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    705          {  
    706               Proc->Out=(*PrvOut)+(*UpOut);  
   \                     ProcPlus_Action:
   \   00000000   0023               MOVS     R3,#+0
   \   00000002   C05E               LDRSH    R0,[R0, R3]
   \   00000004   C95E               LDRSH    R1,[R1, R3]
   \   00000006   4018               ADDS     R0,R0,R1
   \   00000008   5082               STRH     R0,[R2, #+18]
    707          }//_______________________ Koniec funkcji__ ____________________________
   \   0000000A   7047               BX       LR               ;; return
    708          
    709          
    710          
    711          //*-----------------------------------------------------------------------------
    712          //* Nazwa funkcji :    ProcPlus_Action
    713          //* Funkcja procedury "Plus"
    714          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    715          void ProcMinus_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    716          {  
    717               Proc->Out=(*PrvOut)-(*UpOut);  
   \                     ProcMinus_Action:
   \   00000000   0023               MOVS     R3,#+0
   \   00000002   C05E               LDRSH    R0,[R0, R3]
   \   00000004   C95E               LDRSH    R1,[R1, R3]
   \   00000006   401A               SUBS     R0,R0,R1
   \   00000008   5082               STRH     R0,[R2, #+18]
    718          }//_______________________ Koniec funkcji__ ____________________________
   \   0000000A   7047               BX       LR               ;; return
    719          
    720          
    721          //*-----------------------------------------------------------------------------
    722          //* Nazwa funkcji :    ProcPlus_Action
    723          //* Funkcja procedury "Plus"
    724          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    725          void ProcMul_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    726          {    
   \                     ProcMul_Action:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   1400               MOVS     R4,R2
    727               int odp;
    728               odp=(*PrvOut)*(*UpOut)/10; 
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   805E               LDRSH    R0,[R0, R2]
   \   00000008   895E               LDRSH    R1,[R1, R2]
   \   0000000A   4843               MULS     R0,R1,R0
   \   0000000C   0A21               MOVS     R1,#+10
   \   0000000E   ........           BL       __aeabi_idivmod
    729               if (odp>30000)
   \   00000012   0749               LDR      R1,??ProcMul_Action_0  ;; 0x7531
   \   00000014   8842               CMP      R0,R1
   \   00000016   07DB               BLT      ??ProcMul_Action_1
    730               {
    731                  if (odp>0) Proc->Out=30000; else Proc->Out=-30000;
   \   00000018   0128               CMP      R0,#+1
   \   0000001A   02DB               BLT      ??ProcMul_Action_2
   \   0000001C   481E               SUBS     R0,R1,#+1
   \   0000001E   6082               STRH     R0,[R4, #+18]
   \   00000020   03E0               B        ??ProcMul_Action_3
   \                     ??ProcMul_Action_2:
   \   00000022   0448               LDR      R0,??ProcMul_Action_0+0x4  ;; 0xffff8ad0
   \   00000024   6082               STRH     R0,[R4, #+18]
   \   00000026   00E0               B        ??ProcMul_Action_3
    732               }else{
    733                  Proc->Out=odp; 
   \                     ??ProcMul_Action_1:
   \   00000028   6082               STRH     R0,[R4, #+18]
    734               }
    735          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcMul_Action_3:
   \   0000002A   10BC               POP      {R4}
   \   0000002C   01BC               POP      {R0}
   \   0000002E   0047               BX       R0               ;; return
   \                     ??ProcMul_Action_0:
   \   00000030   31750000           DC32     0x7531
   \   00000034   D08AFFFF           DC32     0xffff8ad0
    736          
    737          
    738          //*-----------------------------------------------------------------------------
    739          //* Nazwa funkcji :    ProcPlus_Action
    740          //* Funkcja procedury "Plus"
    741          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    742          void ProcDiv_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    743          {  
   \                     ProcDiv_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0E00               MOVS     R6,R1
   \   00000006   1700               MOVS     R7,R2
    744               if ((*UpOut)==0)
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   305E               LDRSH    R0,[R6, R0]
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   08D1               BNE      ??ProcDiv_Action_0
    745               {
    746                 if ((*PrvOut)>0) Proc->Out=30000; else Proc->Out=-30000;
   \   00000010   285E               LDRSH    R0,[R5, R0]
   \   00000012   0128               CMP      R0,#+1
   \   00000014   02DB               BLT      ??ProcDiv_Action_1
   \   00000016   1748               LDR      R0,??ProcDiv_Action_2  ;; 0x7530
   \   00000018   7882               STRH     R0,[R7, #+18]
   \   0000001A   27E0               B        ??ProcDiv_Action_3
   \                     ??ProcDiv_Action_1:
   \   0000001C   1648               LDR      R0,??ProcDiv_Action_2+0x4  ;; 0xffff8ad0
   \   0000001E   7882               STRH     R0,[R7, #+18]
   \   00000020   24E0               B        ??ProcDiv_Action_3
    747               }else{
    748                
    749                Proc->Out=((*PrvOut)*10)/(*UpOut); 
   \                     ??ProcDiv_Action_0:
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   285E               LDRSH    R0,[R5, R0]
   \   00000026   0A21               MOVS     R1,#+10
   \   00000028   4843               MULS     R0,R1,R0
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   715E               LDRSH    R1,[R6, R1]
   \   0000002E   ........           BL       __aeabi_idivmod
   \   00000032   7882               STRH     R0,[R7, #+18]
    750                if ( (((*PrvOut)*100)/(*UpOut))>((((*PrvOut)*10)/(*UpOut))*10)+5) Proc->Out++;
   \   00000034   0020               MOVS     R0,#+0
   \   00000036   285E               LDRSH    R0,[R5, R0]
   \   00000038   6421               MOVS     R1,#+100
   \   0000003A   4843               MULS     R0,R1,R0
   \   0000003C   0021               MOVS     R1,#+0
   \   0000003E   715E               LDRSH    R1,[R6, R1]
   \   00000040   ........           BL       __aeabi_idivmod
   \   00000044   0400               MOVS     R4,R0
   \   00000046   0020               MOVS     R0,#+0
   \   00000048   285E               LDRSH    R0,[R5, R0]
   \   0000004A   0A21               MOVS     R1,#+10
   \   0000004C   4843               MULS     R0,R1,R0
   \   0000004E   0021               MOVS     R1,#+0
   \   00000050   715E               LDRSH    R1,[R6, R1]
   \   00000052   ........           BL       __aeabi_idivmod
   \   00000056   0100               MOVS     R1,R0
   \   00000058   0A20               MOVS     R0,#+10
   \   0000005A   4143               MULS     R1,R0,R1
   \   0000005C   491D               ADDS     R1,R1,#+5
   \   0000005E   2000               MOVS     R0,R4
   \   00000060   8142               CMP      R1,R0
   \   00000062   03DA               BGE      ??ProcDiv_Action_3
   \   00000064   1220               MOVS     R0,#+18
   \   00000066   385E               LDRSH    R0,[R7, R0]
   \   00000068   401C               ADDS     R0,R0,#+1
   \   0000006A   7882               STRH     R0,[R7, #+18]
    751               }
    752          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcDiv_Action_3:
   \   0000006C   F8BC               POP      {R3-R7}
   \   0000006E   01BC               POP      {R0}
   \   00000070   0047               BX       R0               ;; return
   \   00000072   C046               Nop      
   \                     ??ProcDiv_Action_2:
   \   00000074   30750000           DC32     0x7530
   \   00000078   D08AFFFF           DC32     0xffff8ad0
    753          
    754          
    755          
    756          
    757          
    758          //*-----------------------------------------------------------------------------
    759          //* Nazwa funkcji :    ProcConect_Action
    760          //* Funkcja procedury "Przeniesienie stanu w prawo"
    761          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    762          void ProcConect_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    763          {  
    764                Proc->Out=*PrvOut;  
   \                     ProcConect_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    765            
    766          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    767          
    768          
    769          
    770          //*-----------------------------------------------------------------------------
    771          //* Nazwa funkcji :    ProcDown_Action
    772          //* Funkcja procedury "Przeniesienie stanu w dó³"
    773          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    774          void ProcDown_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    775          {  
    776                Proc->Out=*PrvOut;  
   \                     ProcDown_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    777          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    778          
    779          
    780          
    781          //*-----------------------------------------------------------------------------
    782          //* Nazwa funkcji :    ProcDownRight_Action
    783          //* Funkcja procedury "Przeniesienie stanu w dó³ i prawo"
    784          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    785          void ProcDownRight_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    786          {  
    787                Proc->Out=*PrvOut;
   \                     ProcDownRight_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    788          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    789          
    790          
    791          
    792          
    793          
    794          //*-----------------------------------------------------------------------------
    795          //* Nazwa funkcji :    ProcUpToRight_Action
    796          //* Funkcja procedury "Przeniesienie stanu z góry w prawo"
    797          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    798          void ProcUpToRight_Action(short int *PrvUpOut, _Procedure *Proc) 
    799          {  
    800                Proc->Out=*PrvUpOut;
   \                     ProcUpToRight_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    801          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    802          
    803          
    804          
    805          //*-----------------------------------------------------------------------------
    806          //* Nazwa funkcji :    ProcUpToRightDown_Action
    807          //* Funkcja procedury "Przeniesienie stanu z góry w prawo i dó³"
    808          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    809          void ProcUpToRightDown_Action(short int *PrvUpOut, _Procedure *Proc) 
    810          {  
    811                Proc->Out=*PrvUpOut;
   \                     ProcUpToRightDown_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    812          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    813          
    814          
    815          //*-----------------------------------------------------------------------------
    816          //* Nazwa funkcji :    ProcSetScn
    817          //* Funkcja procedury "Ustaw scenê"
    818          //*-----------------------------------------------------------------------------
    819          char LastScene=0;

   \                                 In section Debug.txt, align 4, keep-with-next
    820          void ProcSetScn_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    821          {  
   \                     ProcSetScn_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    822               
    823            
    824               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   012B               CMP      R3,#+1
   \   00000008   1DD1               BNE      ??ProcSetScn_Action_0
   \   0000000A   1223               MOVS     R3,#+18
   \   0000000C   CB5E               LDRSH    R3,[R1, R3]
   \   0000000E   002B               CMP      R3,#+0
   \   00000010   19D1               BNE      ??ProcSetScn_Action_0
    825               {  
    826                  //if (Proc->Tag.NrScene>NumberScene) Proc->Tag.NrScene=NumberScene;
    827                 if (Proc->Nr==0)  //je¿eli on/off scen
   \   00000012   0123               MOVS     R3,#+1
   \   00000014   CB56               LDRSB    R3,[R1, R3]
   \   00000016   002B               CMP      R3,#+0
   \   00000018   11D1               BNE      ??ProcSetScn_Action_1
    828                 {
    829                   if (LastScene)
   \   0000001A   0D4B               LDR      R3,??ProcSetScn_Action_2  ;; Trap
   \   0000001C   5C7A               LDRB     R4,[R3, #+9]
   \   0000001E   002C               CMP      R4,#+0
   \   00000020   05D0               BEQ      ??ProcSetScn_Action_3
    830                   {
    831                      MainStg->SceneNr=LastScene;
   \   00000022   C325               MOVS     R5,#+195
   \   00000024   ED00               LSLS     R5,R5,#+3        ;; #+1560
   \   00000026   5455               STRB     R4,[R2, R5]
    832                      LastScene=0;
   \   00000028   0022               MOVS     R2,#+0
   \   0000002A   5A72               STRB     R2,[R3, #+9]
   \   0000002C   0BE0               B        ??ProcSetScn_Action_0
    833                   }else{ 
    834                      LastScene=MainStg->SceneNr;
   \                     ??ProcSetScn_Action_3:
   \   0000002E   C324               MOVS     R4,#+195
   \   00000030   E400               LSLS     R4,R4,#+3        ;; #+1560
   \   00000032   1219               ADDS     R2,R2,R4
   \   00000034   1478               LDRB     R4,[R2, #+0]
   \   00000036   5C72               STRB     R4,[R3, #+9]
    835                      MainStg->SceneNr=0;
   \   00000038   0023               MOVS     R3,#+0
   \   0000003A   1370               STRB     R3,[R2, #+0]
   \   0000003C   03E0               B        ??ProcSetScn_Action_0
    836                   }
    837                   
    838                 }else{
    839                  MainStg->SceneNr=Proc->Nr;
   \                     ??ProcSetScn_Action_1:
   \   0000003E   C323               MOVS     R3,#+195
   \   00000040   DB00               LSLS     R3,R3,#+3        ;; #+1560
   \   00000042   4C78               LDRB     R4,[R1, #+1]
   \   00000044   D454               STRB     R4,[R2, R3]
    840                 }
    841               }
    842          
    843               
    844               Proc->Out=*PrvOut;
   \                     ??ProcSetScn_Action_0:
   \   00000046   0088               LDRH     R0,[R0, #+0]
   \   00000048   4882               STRH     R0,[R1, #+18]
    845          
    846          }//_______________________ Koniec funkcji__ ____________________________
   \   0000004A   38BC               POP      {R3-R5}
   \   0000004C   01BC               POP      {R0}
   \   0000004E   0047               BX       R0               ;; return
   \                     ??ProcSetScn_Action_2:
   \   00000050   ........           DC32     Trap
    847          
    848          
    849          
    850          
    851          //*-----------------------------------------------------------------------------
    852          //* Nazwa funkcji :    ProcInc_Action
    853          //* Funkcja procedury "Inkrementuj scenê"
    854          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    855          void ProcInc_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    856          {  
   \                     ProcInc_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    857               if ((*PrvOut) && (Proc->LastIn==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   002B               CMP      R3,#+0
   \   00000008   0ED0               BEQ      ??ProcInc_Action_0
   \   0000000A   0B7C               LDRB     R3,[R1, #+16]
   \   0000000C   002B               CMP      R3,#+0
   \   0000000E   0BD1               BNE      ??ProcInc_Action_0
    858               {  
    859                  
    860                    if (MainStg->SceneNr<NumberScene) MainStg->SceneNr++;
   \   00000010   C323               MOVS     R3,#+195
   \   00000012   DB00               LSLS     R3,R3,#+3        ;; #+1560
   \   00000014   D218               ADDS     R2,R2,R3
   \   00000016   084B               LDR      R3,??ProcInc_Action_1  ;; Trap
   \   00000018   1478               LDRB     R4,[R2, #+0]
   \   0000001A   1D7A               LDRB     R5,[R3, #+8]
   \   0000001C   AC42               CMP      R4,R5
   \   0000001E   01D2               BCS      ??ProcInc_Action_2
   \   00000020   641C               ADDS     R4,R4,#+1
   \   00000022   1470               STRB     R4,[R2, #+0]
    861                    LastScene=0;
   \                     ??ProcInc_Action_2:
   \   00000024   0022               MOVS     R2,#+0
   \   00000026   5A72               STRB     R2,[R3, #+9]
    862               }
    863               
    864          
    865               Proc->LastIn=*PrvOut;
   \                     ??ProcInc_Action_0:
   \   00000028   0288               LDRH     R2,[R0, #+0]
   \   0000002A   0A74               STRB     R2,[R1, #+16]
    866               Proc->Out=*PrvOut;
   \   0000002C   0088               LDRH     R0,[R0, #+0]
   \   0000002E   4882               STRH     R0,[R1, #+18]
    867           
    868          }//_______________________ Koniec funkcji__ ____________________________
   \   00000030   38BC               POP      {R3-R5}
   \   00000032   01BC               POP      {R0}
   \   00000034   0047               BX       R0               ;; return
   \   00000036   C046               Nop      
   \                     ??ProcInc_Action_1:
   \   00000038   ........           DC32     Trap
    869          
    870          
    871          //*-----------------------------------------------------------------------------
    872          //* Nazwa funkcji :    ProcIncDec_Action
    873          //* Funkcja procedury "Dekrementuj scenê"
    874          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    875          void ProcDec_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    876          {  
   \                     ProcDec_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    877               if ((*PrvOut) && (Proc->LastIn==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   002B               CMP      R3,#+0
   \   00000008   0DD0               BEQ      ??ProcDec_Action_0
   \   0000000A   0B7C               LDRB     R3,[R1, #+16]
   \   0000000C   002B               CMP      R3,#+0
   \   0000000E   0AD1               BNE      ??ProcDec_Action_0
    878               {  
    879                  
    880                  if (MainStg->SceneNr>0) MainStg->SceneNr--;
   \   00000010   C323               MOVS     R3,#+195
   \   00000012   DB00               LSLS     R3,R3,#+3        ;; #+1560
   \   00000014   D218               ADDS     R2,R2,R3
   \   00000016   1378               LDRB     R3,[R2, #+0]
   \   00000018   002B               CMP      R3,#+0
   \   0000001A   01D0               BEQ      ??ProcDec_Action_1
   \   0000001C   5B1E               SUBS     R3,R3,#+1
   \   0000001E   1370               STRB     R3,[R2, #+0]
    881                  LastScene=0;
   \                     ??ProcDec_Action_1:
   \   00000020   044A               LDR      R2,??ProcDec_Action_2  ;; Trap + 9
   \   00000022   0023               MOVS     R3,#+0
   \   00000024   1370               STRB     R3,[R2, #+0]
    882               }
    883               
    884          
    885               Proc->LastIn=*PrvOut;
   \                     ??ProcDec_Action_0:
   \   00000026   0288               LDRH     R2,[R0, #+0]
   \   00000028   0A74               STRB     R2,[R1, #+16]
    886               Proc->Out=*PrvOut;
   \   0000002A   0088               LDRH     R0,[R0, #+0]
   \   0000002C   4882               STRH     R0,[R1, #+18]
    887          
    888          }//_______________________ Koniec funkcji__ ____________________________
   \   0000002E   08BC               POP      {R3}
   \   00000030   01BC               POP      {R0}
   \   00000032   0047               BX       R0               ;; return
   \                     ??ProcDec_Action_2:
   \   00000034   ........           DC32     Trap + 9
    889          
    890          
    891          
    892          //*-----------------------------------------------------------------------------
    893          //* Nazwa funkcji :    ProcSPK_Action
    894          //* Funkcja procedury "Dekrementuj scenê"
    895          //*-----------------------------------------------------------------------------
    896          extern     char Speaker[SPK_Amount];                                                   //sygna³ dŸwiêkowy

   \                                 In section Debug.txt, align 4, keep-with-next
    897          void ProcSPK_Action(short int *PrvOut, _Procedure *Proc) 
    898          {  
   \                     ProcSPK_Action:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0200               MOVS     R2,R0
   \   00000004   0B00               MOVS     R3,R1
    899               if ((*PrvOut) && (Proc->Out==0))
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   105E               LDRSH    R0,[R2, R0]
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   21D0               BEQ      ??ProcSPK_Action_0
   \   0000000E   1220               MOVS     R0,#+18
   \   00000010   185E               LDRSH    R0,[R3, R0]
   \   00000012   0028               CMP      R0,#+0
   \   00000014   1DD1               BNE      ??ProcSPK_Action_0
    900               {  
    901                  for (char i=0; i<SPK_Amount; i++) Speaker[i]=0;
   \   00000016   0100               MOVS     R1,R0
   \   00000018   1E4D               LDR      R5,??ProcSPK_Action_1  ;; Speaker
   \   0000001A   0600               MOVS     R6,R0
   \   0000001C   03E0               B        ??ProcSPK_Action_2
   \                     ??ProcSPK_Action_3:
   \   0000001E   2E55               STRB     R6,[R5, R4]
   \   00000020   491C               ADDS     R1,R1,#+1
   \   00000022   0906               LSLS     R1,R1,#+24
   \   00000024   090E               LSRS     R1,R1,#+24
   \                     ??ProcSPK_Action_2:
   \   00000026   0C00               MOVS     R4,R1
   \   00000028   042C               CMP      R4,#+4
   \   0000002A   F8D3               BCC      ??ProcSPK_Action_3
    902                  Speaker[Proc->Tag.SpeakerType]=1;
   \   0000002C   187A               LDRB     R0,[R3, #+8]
   \   0000002E   1949               LDR      R1,??ProcSPK_Action_1  ;; Speaker
   \   00000030   0124               MOVS     R4,#+1
   \   00000032   0C54               STRB     R4,[R1, R0]
    903                  if (Proc->Tag.SpeakerType==0) 
   \   00000034   187A               LDRB     R0,[R3, #+8]
   \   00000036   0028               CMP      R0,#+0
   \   00000038   1AD1               BNE      ??ProcSPK_Action_4
    904                  {
    905                         ButtonBipCounter=g_counter+300000;
   \   0000003A   174C               LDR      R4,??ProcSPK_Action_1+0x4  ;; ButtonBipCounter
   \   0000003C   1748               LDR      R0,??ProcSPK_Action_1+0x8  ;; g_counter
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   1749               LDR      R1,??ProcSPK_Action_1+0xC  ;; 0x493e0
   \   00000042   4018               ADDS     R0,R0,R1
   \   00000044   C117               ASRS     R1,R0,#+31
   \   00000046   03C4               STM      R4!,{R0,R1}
    906                         AT91C_BASE_PIOA->PIO_SODR =SpeakerPin;  
                                                           ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   00000048   1648               LDR      R0,??ProcSPK_Action_1+0x10  ;; 0xfffff430
   \   0000004A   8021               MOVS     R1,#+128
   \   0000004C   0906               LSLS     R1,R1,#+24       ;; #-2147483648
   \   0000004E   0160               STR      R1,[R0, #+0]
   \   00000050   0EE0               B        ??ProcSPK_Action_4
    907                  }
    908               }else if (*PrvOut==0) {
   \                     ??ProcSPK_Action_0:
   \   00000052   0020               MOVS     R0,#+0
   \   00000054   105E               LDRSH    R0,[R2, R0]
   \   00000056   0028               CMP      R0,#+0
   \   00000058   0AD1               BNE      ??ProcSPK_Action_4
    909                 for (char i=0; i<SPK_Amount; i++) Speaker[i]=0;
   \   0000005A   0100               MOVS     R1,R0
   \   0000005C   0D4D               LDR      R5,??ProcSPK_Action_1  ;; Speaker
   \   0000005E   0600               MOVS     R6,R0
   \   00000060   03E0               B        ??ProcSPK_Action_5
   \                     ??ProcSPK_Action_6:
   \   00000062   2E55               STRB     R6,[R5, R4]
   \   00000064   491C               ADDS     R1,R1,#+1
   \   00000066   0906               LSLS     R1,R1,#+24
   \   00000068   090E               LSRS     R1,R1,#+24
   \                     ??ProcSPK_Action_5:
   \   0000006A   0C00               MOVS     R4,R1
   \   0000006C   042C               CMP      R4,#+4
   \   0000006E   F8D3               BCC      ??ProcSPK_Action_6
    910               }
    911               if ((*PrvOut==0) && (Proc->Out==1))
   \                     ??ProcSPK_Action_4:
   \   00000070   0020               MOVS     R0,#+0
   \   00000072   105E               LDRSH    R0,[R2, R0]
   \   00000074   0028               CMP      R0,#+0
   \   00000076   07D1               BNE      ??ProcSPK_Action_7
   \   00000078   1220               MOVS     R0,#+18
   \   0000007A   185E               LDRSH    R0,[R3, R0]
   \   0000007C   0128               CMP      R0,#+1
   \   0000007E   03D1               BNE      ??ProcSPK_Action_7
    912               {  
    913                  AT91C_BASE_PIOA->PIO_CODR =SpeakerPin;  
                                                    ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   00000080   0948               LDR      R0,??ProcSPK_Action_1+0x14  ;; 0xfffff434
   \   00000082   8021               MOVS     R1,#+128
   \   00000084   0906               LSLS     R1,R1,#+24       ;; #-2147483648
   \   00000086   0160               STR      R1,[R0, #+0]
    914               }
    915               Proc->Out=*PrvOut;
   \                     ??ProcSPK_Action_7:
   \   00000088   1088               LDRH     R0,[R2, #+0]
   \   0000008A   5882               STRH     R0,[R3, #+18]
    916          }//_______________________ Koniec funkcji__ ____________________________
   \   0000008C   70BC               POP      {R4-R6}
   \   0000008E   01BC               POP      {R0}
   \   00000090   0047               BX       R0               ;; return
   \   00000092   C046               Nop      
   \                     ??ProcSPK_Action_1:
   \   00000094   ........           DC32     Speaker
   \   00000098   ........           DC32     ButtonBipCounter
   \   0000009C   ........           DC32     g_counter
   \   000000A0   E0930400           DC32     0x493e0
   \   000000A4   30F4FFFF           DC32     0xfffff430
   \   000000A8   34F4FFFF           DC32     0xfffff434
    917          
    918          
    919          
    920          
    921          
    922          //*-----------------------------------------------------------------------------
    923          //* Nazwa funkcji :    ProcSumL_Action
    924          //* Funkcja procedury "Sumy logicznej"
    925          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    926          void ProcSumL_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    927          {  
    928            Proc->Out=*PrvOut | *UpOut;   
   \                     ProcSumL_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   0988               LDRH     R1,[R1, #+0]
   \   00000004   0143               ORRS     R1,R1,R0
   \   00000006   5182               STRH     R1,[R2, #+18]
    929          }//_______________________ Koniec funkcji__ ____________________________
   \   00000008   7047               BX       LR               ;; return
    930          
    931          
    932          
    933          //*-----------------------------------------------------------------------------
    934          //* Nazwa funkcji :    ProcIncDec_Action
    935          //* Funkcja procedury "Inkrementuj scenê"
    936          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    937          void ProcTimerSet_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    938          {  
   \                     ProcTimerSet_Action:
   \   00000000   10B5               PUSH     {R4,LR}
    939             if ((*PrvOut)==0)
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   825E               LDRSH    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   01D1               BNE      ??ProcTimerSet_Action_0
    940             {
    941               Proc->Out=0;
   \   0000000A   4A82               STRH     R2,[R1, #+18]
   \   0000000C   13E0               B        ??ProcTimerSet_Action_1
    942             }else{
    943               if ((Proc->Tag.CounterStartTime+Proc->Tag.SetCounter)<g_seconds_counter)
   \                     ??ProcTimerSet_Action_0:
   \   0000000E   0C4A               LDR      R2,??ProcTimerSet_Action_2  ;; g_seconds_counter
   \   00000010   CB68               LDR      R3,[R1, #+12]
   \   00000012   8C68               LDR      R4,[R1, #+8]
   \   00000014   1B19               ADDS     R3,R3,R4
   \   00000016   1468               LDR      R4,[R2, #+0]
   \   00000018   A342               CMP      R3,R4
   \   0000001A   9B41               SBCS     R3,R3,R3
   \   0000001C   DB0F               LSRS     R3,R3,#+31
   \   0000001E   4B82               STRH     R3,[R1, #+18]
    944               {
    945                 Proc->Out=1;
    946               }else{
    947                 Proc->Out=0;
    948               }
    949               if ((*PrvOut) && (Proc->LastIn==0))
   \   00000020   0023               MOVS     R3,#+0
   \   00000022   C35E               LDRSH    R3,[R0, R3]
   \   00000024   002B               CMP      R3,#+0
   \   00000026   06D0               BEQ      ??ProcTimerSet_Action_1
   \   00000028   0B7C               LDRB     R3,[R1, #+16]
   \   0000002A   002B               CMP      R3,#+0
   \   0000002C   03D1               BNE      ??ProcTimerSet_Action_1
    950               {  
    951                 Proc->Tag.CounterStartTime=g_seconds_counter; 
   \   0000002E   1268               LDR      R2,[R2, #+0]
   \   00000030   CA60               STR      R2,[R1, #+12]
    952                 Proc->Out=0;
   \   00000032   0022               MOVS     R2,#+0
   \   00000034   4A82               STRH     R2,[R1, #+18]
    953               }
    954             }   
    955             
    956             Proc->LastIn=*PrvOut;
   \                     ??ProcTimerSet_Action_1:
   \   00000036   0088               LDRH     R0,[R0, #+0]
   \   00000038   0874               STRB     R0,[R1, #+16]
    957          }//_______________________ Koniec funkcji__ ____________________________
   \   0000003A   10BC               POP      {R4}
   \   0000003C   01BC               POP      {R0}
   \   0000003E   0047               BX       R0               ;; return
   \                     ??ProcTimerSet_Action_2:
   \   00000040   ........           DC32     g_seconds_counter
    958          
    959          
    960          
    961          
    962          
    963          
    964          //*-----------------------------------------------------------------------------
    965          //* Nazwa funkcji :    ProcClock_Action
    966          //* Funkcja procedury "Zegar"
    967          //*-----------------------------------------------------------------------------
    968          

   \                                 In section Debug.txt, align 4, keep-with-next
    969          void ProcClock_Action(short int *PrvOut, _Procedure *Proc) 
    970          {  
   \                     ProcClock_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    971             Proc->Out=0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   4A82               STRH     R2,[R1, #+18]
    972             if (*PrvOut)
   \   00000006   805E               LDRSH    R0,[R0, R2]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   31D0               BEQ      ??ProcClock_Action_0
    973             {
    974                if ((Proc->Tag.ClkPrcType==PrcMounth) && (Proc->Tag.ClkPrcVal==DateTime.Mounth))  Proc->Out=1; 
   \   0000000C   087A               LDRB     R0,[R1, #+8]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   06D1               BNE      ??ProcClock_Action_1
   \   00000012   487A               LDRB     R0,[R1, #+9]
   \   00000014   184A               LDR      R2,??ProcClock_Action_2  ;; DateTime + 1
   \   00000016   1278               LDRB     R2,[R2, #+0]
   \   00000018   9042               CMP      R0,R2
   \   0000001A   01D1               BNE      ??ProcClock_Action_1
   \   0000001C   0120               MOVS     R0,#+1
   \   0000001E   4882               STRH     R0,[R1, #+18]
    975                if ((Proc->Tag.ClkPrcType==PrcDay)    && (Proc->Tag.ClkPrcVal==DateTime.Day))     Proc->Out=1; 
   \                     ??ProcClock_Action_1:
   \   00000020   087A               LDRB     R0,[R1, #+8]
   \   00000022   0128               CMP      R0,#+1
   \   00000024   06D1               BNE      ??ProcClock_Action_3
   \   00000026   487A               LDRB     R0,[R1, #+9]
   \   00000028   144A               LDR      R2,??ProcClock_Action_2+0x4  ;; DateTime + 2
   \   0000002A   1278               LDRB     R2,[R2, #+0]
   \   0000002C   9042               CMP      R0,R2
   \   0000002E   01D1               BNE      ??ProcClock_Action_3
   \   00000030   0120               MOVS     R0,#+1
   \   00000032   4882               STRH     R0,[R1, #+18]
    976                if ((Proc->Tag.ClkPrcType==PrcHour)   && (Proc->Tag.ClkPrcVal==DateTime.Hour))    Proc->Out=1; 
   \                     ??ProcClock_Action_3:
   \   00000034   087A               LDRB     R0,[R1, #+8]
   \   00000036   0228               CMP      R0,#+2
   \   00000038   06D1               BNE      ??ProcClock_Action_4
   \   0000003A   487A               LDRB     R0,[R1, #+9]
   \   0000003C   104A               LDR      R2,??ProcClock_Action_2+0x8  ;; DateTime + 3
   \   0000003E   1278               LDRB     R2,[R2, #+0]
   \   00000040   9042               CMP      R0,R2
   \   00000042   01D1               BNE      ??ProcClock_Action_4
   \   00000044   0120               MOVS     R0,#+1
   \   00000046   4882               STRH     R0,[R1, #+18]
    977                if ((Proc->Tag.ClkPrcType==PrcMinute) && (Proc->Tag.ClkPrcVal==DateTime.Minute))  Proc->Out=1;  
   \                     ??ProcClock_Action_4:
   \   00000048   087A               LDRB     R0,[R1, #+8]
   \   0000004A   0328               CMP      R0,#+3
   \   0000004C   06D1               BNE      ??ProcClock_Action_5
   \   0000004E   487A               LDRB     R0,[R1, #+9]
   \   00000050   0C4A               LDR      R2,??ProcClock_Action_2+0xC  ;; DateTime + 4
   \   00000052   1278               LDRB     R2,[R2, #+0]
   \   00000054   9042               CMP      R0,R2
   \   00000056   01D1               BNE      ??ProcClock_Action_5
   \   00000058   0120               MOVS     R0,#+1
   \   0000005A   4882               STRH     R0,[R1, #+18]
    978                if ((Proc->Tag.ClkPrcType==PrcSecond) && (Proc->Tag.ClkPrcVal==DateTime.Second))  Proc->Out=1; 
   \                     ??ProcClock_Action_5:
   \   0000005C   087A               LDRB     R0,[R1, #+8]
   \   0000005E   0428               CMP      R0,#+4
   \   00000060   06D1               BNE      ??ProcClock_Action_0
   \   00000062   487A               LDRB     R0,[R1, #+9]
   \   00000064   084A               LDR      R2,??ProcClock_Action_2+0x10  ;; DateTime + 5
   \   00000066   1278               LDRB     R2,[R2, #+0]
   \   00000068   9042               CMP      R0,R2
   \   0000006A   01D1               BNE      ??ProcClock_Action_0
   \   0000006C   0120               MOVS     R0,#+1
   \   0000006E   4882               STRH     R0,[R1, #+18]
    979                        
    980          
    981             }
    982          
    983          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcClock_Action_0:
   \   00000070   08BC               POP      {R3}
   \   00000072   01BC               POP      {R0}
   \   00000074   0047               BX       R0               ;; return
   \   00000076   C046               Nop      
   \                     ??ProcClock_Action_2:
   \   00000078   ........           DC32     DateTime + 1
   \   0000007C   ........           DC32     DateTime + 2
   \   00000080   ........           DC32     DateTime + 3
   \   00000084   ........           DC32     DateTime + 4
   \   00000088   ........           DC32     DateTime + 5
    984          
    985          
    986          
    987          //*-----------------------------------------------------------------------------
    988          //* Nazwa funkcji :    ProcDay_Action
    989          //* Funkcja procedury "Dnia tygodnia"
    990          //*-----------------------------------------------------------------------------
    991          

   \                                 In section Debug.txt, align 4, keep-with-next
    992          void ProcDay_Action(short int *PrvOut, _Procedure *Proc) 
    993          {  
   \                     ProcDay_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    994             Proc->Out=0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   4A82               STRH     R2,[R1, #+18]
    995             if (*PrvOut)
   \   00000006   805E               LDRSH    R0,[R0, R2]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   06D0               BEQ      ??ProcDay_Action_0
    996             {
    997                if (Proc->Tag.DayOfWeek==DateTime.DayOfWeek)  Proc->Out=1; 
   \   0000000C   087A               LDRB     R0,[R1, #+8]
   \   0000000E   044A               LDR      R2,??ProcDay_Action_1  ;; DateTime + 6
   \   00000010   1278               LDRB     R2,[R2, #+0]
   \   00000012   9042               CMP      R0,R2
   \   00000014   01D1               BNE      ??ProcDay_Action_0
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   4882               STRH     R0,[R1, #+18]
    998          
    999             }
   1000          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcDay_Action_0:
   \   0000001A   08BC               POP      {R3}
   \   0000001C   01BC               POP      {R0}
   \   0000001E   0047               BX       R0               ;; return
   \                     ??ProcDay_Action_1:
   \   00000020   ........           DC32     DateTime + 6
   1001          
   1002          
   1003          
   1004          
   1005          
   1006          
   1007          
   1008          //*-----------------------------------------------------------------------------
   1009          //* Nazwa funkcji :    Program
   1010          //* Funkcja opóŸnienia
   1011          //*-----------------------------------------------------------------------------
   1012          volatile char Busy_program=0;
   1013          
   1014          char SceneNrLast=0;
   1015          char RealPrcLines=MaxPrcLines;
   1016          
   1017          int PtogTime=0;
   1018          unsigned long last_time;
   1019          

   \                                 In section Debug.txt, align 4, keep-with-next
   1020          void Program (_ProgramTab *ProgTab) 
   1021          { 
   \                     Program:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   1022              static int MemCol=0;
   1023              static int MemRow=0;
   1024              int StartLineNr=0;
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   2600               MOVS     R6,R4
   1025              int StartPrcInLine=0;
   \   00000008   0194               STR      R4,[SP, #+4]
   \   0000000A   CE4D               LDR      R5,??Program_1   ;; Trap
   \   0000000C   A87A               LDRB     R0,[R5, #+10]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   00D0               BEQ      .+4
   \   00000012   0CE2               B        ??Program_2
   \   00000014   0120               MOVS     R0,#+1
   \   00000016   A872               STRB     R0,[R5, #+10]
   1026              
   1027              if (Busy_program==0)
   1028              {
   1029                Busy_program=1;
   1030              
   1031          
   1032             last_time=g_counter;
   \   00000018   CB48               LDR      R0,??Program_1+0x4  ;; g_counter
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   6861               STR      R0,[R5, #+20]
   1033            
   1034          
   1035            
   1036            short int StPrvPrc; //stan poprzedniej procedury
   1037            short int StUpPrc; //stan procedury z linii wy¿ej, z tej samej kolumny dla sumy logicznej
   1038            
   1039            if ((Trap.Enable) && (Trap.Change))
   \   0000001E   2878               LDRB     R0,[R5, #+0]
   \   00000020   0028               CMP      R0,#+0
   \   00000022   07D0               BEQ      ??Program_3
   \   00000024   2879               LDRB     R0,[R5, #+4]
   \   00000026   0028               CMP      R0,#+0
   \   00000028   04D0               BEQ      ??Program_3
   1040                  {
   1041                    StartPrcInLine=MemCol;
   \   0000002A   A869               LDR      R0,[R5, #+24]
   \   0000002C   0190               STR      R0,[SP, #+4]
   1042                    StartLineNr=MemRow;
   \   0000002E   EE69               LDR      R6,[R5, #+28]
   1043                    Trap.Change=0;
   \   00000030   2000               MOVS     R0,R4
   \   00000032   2871               STRB     R0,[R5, #+4]
   1044                  }
   1045            
   1046            
   1047                 for (char NB=0; NB<NumberButton; NB++)
   \                     ??Program_3:
   \   00000034   2100               MOVS     R1,R4
   \   00000036   08E0               B        ??Program_4
   1048                 {
   1049                      MainStage.StageButtonExe[NB]=MainStage.StageButton[NB];  
   \                     ??Program_5:
   \   00000038   0A00               MOVS     R2,R1
   \   0000003A   C448               LDR      R0,??Program_1+0x8  ;; MainStage
   \   0000003C   8318               ADDS     R3,R0,R2
   \   0000003E   5033               ADDS     R3,R3,#+80
   \   00000040   805C               LDRB     R0,[R0, R2]
   \   00000042   1870               STRB     R0,[R3, #+0]
   1050                      //MainStage.StageButton[NB]=0;
   1051                 }
   \   00000044   491C               ADDS     R1,R1,#+1
   \   00000046   0906               LSLS     R1,R1,#+24
   \   00000048   090E               LSRS     R1,R1,#+24
   \                     ??Program_4:
   \   0000004A   0800               MOVS     R0,R1
   \   0000004C   5028               CMP      R0,#+80
   \   0000004E   F3D3               BCC      ??Program_5
   1052            
   1053            
   1054            
   1055                for (int LineNr=StartLineNr; LineNr<RealPrcLines; LineNr++)
   \   00000050   00E0               B        ??Program_6
   \                     ??Program_7:
   \   00000052   761C               ADDS     R6,R6,#+1
   \                     ??Program_6:
   \   00000054   287B               LDRB     R0,[R5, #+12]
   \   00000056   8642               CMP      R6,R0
   \   00000058   00DB               BLT      .+4
   \   0000005A   E7E1               B        ??Program_8
   1056                {
   1057                  for (int PrcInLine=StartPrcInLine; PrcInLine<MaxPrcInLine; PrcInLine++)
   \   0000005C   019F               LDR      R7,[SP, #+4]
   \   0000005E   18E0               B        ??Program_9
   1058                  {
   1059                   
   1060                    
   1061          
   1062                    
   1063                    
   1064                    
   1065                   if ((Trap.Enable) &&  (Trap.Row==LineNr) && (Trap.Col==PrcInLine)) 
   1066                   {
   1067                     Trap.Activ=1; 
   1068                     MemCol=PrcInLine;
   1069                     MemRow=LineNr;
   1070                      
   1071                   }
   1072                   if ((Trap.Enable==0) || (Trap.Activ==0) )
   1073                   {
   1074          
   1075                     
   1076                   if (Trap.Enable==0)
   1077                   {
   1078                    MemCol=PrcInLine;
   1079                    MemRow=LineNr;
   1080                   }  
   1081                     
   1082                     
   1083                     if (ProgTab->Line[LineNr].Proc[PrcInLine].Type!=None)
   1084                     {
   1085                        if (PrcInLine==0)
   1086                        {
   1087                          StPrvPrc= 1;
   1088                        }else{
   1089                          StPrvPrc= (ProgTab->Line[LineNr].Proc[PrcInLine-1].Out);
   1090                        }
   1091                        
   1092                        
   1093          
   1094                        switch (ProgTab->Line[LineNr].Proc[PrcInLine].Type)
   1095                        {    
   1096                            case ProcConect     : ProcConect_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1097                            case ProcDown       : ProcDown_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1098                            case ProcDownRight  : ProcDownRight_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1099                            case ProcSumLogRight     : 
   1100                                                StUpPrc= 0;
   1101                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1102                                                ProcSumL_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1103                                                break;
   1104                            case ProcSumLogDown     : 
   1105                                                StUpPrc= 0;
   1106                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1107                                                ProcSumL_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1108                                                break;
   1109                            case ProcUpToRight     : 
   1110                                                StUpPrc= 0;
   1111                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1112                                                ProcUpToRight_Action(&StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1113                                                break;
   1114                                                
   1115                            case ProcUpToRightDown    : 
   1116                                                StUpPrc= 0;
   1117                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1118                                                ProcUpToRightDown_Action(&StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1119                                                break;                    
   1120                                             
   1121                           
   1122                            
   1123                            case ProcNOT        : ProcNOT_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;         
   1124                            case ProcToggleRS   : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1125                                                  ProcToggleRS_Action(&StPrvPrc, &StUpPrc,  &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;    
   1126                            case ProcToggleT    : ProcToggleT_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;         
   1127                            case ProcTLI1       : ProcTLI1_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;         
   1128                            case ProcStI        : ProcStI_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1129                            case ProcStNI       : ProcStNI_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1130                            case ProcStQ        : ProcStQ_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1131                            case ProcStB        : ProcStB_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1132                            case ProcStS        : ProcStS_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1133                            case ProcWOUT       : ProcWOUT_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1134                            case ProcWOUTS      : ProcWOUTS_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]),&MainStage); break;
   1135                            case ProcWOUTR      : ProcWOUTR_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]),&MainStage); break;
   1136                            case ProcWOUTC      : ProcWOUTC_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]),&MainStage); break;
   1137                            case ProcSetScn     : ProcSetScn_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1138                            case ProcInc        : ProcInc_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;             
   1139                            case ProcDec        : ProcDec_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;             
   1140                            case ProcSPK        : ProcSPK_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break; 
   1141                            case ProcTimerSet   : ProcTimerSet_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1142                            case ProcClock      : ProcClock_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1143                            case ProcDay        : ProcDay_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1144                            case ProcGetReg     : ProcGetReg_Action(&(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1145                            case ProcSetReg     : ProcSetAnal_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1146                            case ProcConstAnal  : ProcConstAnal_Action(&(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1147                            case ProcLim        : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1148                                                  ProcLim_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1149                            case ProcEven       : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1150                                                  ProcEven_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1151                            case ProcPlus       : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1152                                                  ProcPlus_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1153                            case ProcMinus      : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1154                                                  ProcMinus_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1155                            case ProcMul        : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1156                                                  ProcMul_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1157                            case ProcDiv        : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1158                                                  ProcDiv_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1159          
   1160                            
   1161                        }
   1162                        
   1163                     }  
   1164                    
   1165                   
   1166                   
   1167                   
   1168                   
   1169                   
   1170                   if ((LineNr==RealPrcLines-1) && (PrcInLine==MaxPrcInLine-1))
   1171                    { 
   1172                    
   1173                        //ThermostatsExecute();
   1174          
   1175                          /* 
   1176                          for (char iNrQ=0; iNrQ<NumberNeurons; iNrQ++)
   1177                          {  
   1178                            for (char iNrReg=0; iNrReg<NumberReg; iNrReg++)
   1179                          {
   1180                            MainStage.StageQ[iNrQ].Value[iNrReg]=MainStage.StageQ_TMP[iNrQ].Value[iNrReg]; 
   1181                          }
   1182                          
   1183                          }
   1184                          */
   1185          
   1186                      for (char iNrReg=0; iNrReg<NumberReg; iNrReg++)
   1187                      {
   1188                        MainStage.StageI[0].Value[iNrReg]=MainStage.StageQ[0].Value[iNrReg]; 
   \                     ??Program_10:
   \   00000060   0A00               MOVS     R2,R1
   \   00000062   5200               LSLS     R2,R2,#+1
   \   00000064   8018               ADDS     R0,R0,R2
   \   00000066   A022               MOVS     R2,#+160
   \   00000068   D723               MOVS     R3,#+215
   \   0000006A   9B00               LSLS     R3,R3,#+2        ;; #+860
   \   0000006C   C35A               LDRH     R3,[R0, R3]
   \   0000006E   8352               STRH     R3,[R0, R2]
   1189                      }
   \   00000070   491C               ADDS     R1,R1,#+1
   \   00000072   0906               LSLS     R1,R1,#+24
   \   00000074   090E               LSRS     R1,R1,#+24
   \                     ??Program_11:
   \   00000076   0800               MOVS     R0,R1
   \   00000078   0A28               CMP      R0,#+10
   \   0000007A   B448               LDR      R0,??Program_1+0x8  ;; MainStage
   \   0000007C   F0D3               BCC      ??Program_10
   1190            
   1191           
   1192            
   1193                      if (MainStage.SceneNr!=SceneNrLast)
   \   0000007E   C321               MOVS     R1,#+195
   \   00000080   C900               LSLS     R1,R1,#+3        ;; #+1560
   \   00000082   405C               LDRB     R0,[R0, R1]
   \   00000084   E97A               LDRB     R1,[R5, #+11]
   \   00000086   8842               CMP      R0,R1
   \   00000088   02D0               BEQ      ??Program_12
   1194                      {
   1195                        SceneNrLast=MainStage.SceneNr;
   \   0000008A   E872               STRB     R0,[R5, #+11]
   1196                        MenuPaint();
   \   0000008C   ........           BL       MenuPaint
   1197                      }
   \                     ??Program_12:
   \   00000090   7F1C               ADDS     R7,R7,#+1
   \                     ??Program_9:
   \   00000092   0A2F               CMP      R7,#+10
   \   00000094   DDDA               BGE      ??Program_7
   \   00000096   2878               LDRB     R0,[R5, #+0]
   \   00000098   0028               CMP      R0,#+0
   \   0000009A   09D0               BEQ      ??Program_13
   \   0000009C   6878               LDRB     R0,[R5, #+1]
   \   0000009E   B042               CMP      R0,R6
   \   000000A0   06D1               BNE      ??Program_13
   \   000000A2   A878               LDRB     R0,[R5, #+2]
   \   000000A4   B842               CMP      R0,R7
   \   000000A6   03D1               BNE      ??Program_13
   \   000000A8   0120               MOVS     R0,#+1
   \   000000AA   E870               STRB     R0,[R5, #+3]
   \   000000AC   AF61               STR      R7,[R5, #+24]
   \   000000AE   EE61               STR      R6,[R5, #+28]
   \                     ??Program_13:
   \   000000B0   2878               LDRB     R0,[R5, #+0]
   \   000000B2   0028               CMP      R0,#+0
   \   000000B4   02D0               BEQ      ??Program_14
   \   000000B6   E978               LDRB     R1,[R5, #+3]
   \   000000B8   0029               CMP      R1,#+0
   \   000000BA   E9D1               BNE      ??Program_12
   \                     ??Program_14:
   \   000000BC   0028               CMP      R0,#+0
   \   000000BE   01D1               BNE      ??Program_15
   \   000000C0   AF61               STR      R7,[R5, #+24]
   \   000000C2   EE61               STR      R6,[R5, #+28]
   \                     ??Program_15:
   \   000000C4   1820               MOVS     R0,#+24
   \   000000C6   7843               MULS     R0,R7,R0
   \   000000C8   F021               MOVS     R1,#+240
   \   000000CA   7143               MULS     R1,R6,R1
   \   000000CC   029A               LDR      R2,[SP, #+8]
   \   000000CE   5118               ADDS     R1,R2,R1
   \   000000D0   0818               ADDS     R0,R1,R0
   \   000000D2   0100               MOVS     R1,R0
   \   000000D4   1231               ADDS     R1,R1,#+18
   \   000000D6   8A79               LDRB     R2,[R1, #+6]
   \   000000D8   002A               CMP      R2,#+0
   \   000000DA   00D1               BNE      .+4
   \   000000DC   9CE1               B        ??Program_16
   \   000000DE   002F               CMP      R7,#+0
   \   000000E0   6A46               MOV      R2,SP
   \   000000E2   02D1               BNE      ??Program_17
   \   000000E4   0123               MOVS     R3,#+1
   \   000000E6   1380               STRH     R3,[R2, #+0]
   \   000000E8   01E0               B        ??Program_18
   \                     ??Program_17:
   \   000000EA   0B88               LDRH     R3,[R1, #+0]
   \   000000EC   1380               STRH     R3,[R2, #+0]
   \                     ??Program_18:
   \   000000EE   8979               LDRB     R1,[R1, #+6]
   \   000000F0   891E               SUBS     R1,R1,#+2
   \   000000F2   3D29               CMP      R1,#+61
   \   000000F4   00D9               BLS      .+4
   \   000000F6   8FE1               B        ??Program_16
   \   000000F8   01A2               ADR      R2,??Program_0
   \   000000FA   4900               LSLS     R1,R1,#+1
   \   000000FC   525A               LDRH     R2,[R2, R1]
   \   000000FE   9744               ADD      PC,PC,R2
   \                     ??Program_0:
   \   00000100   7A0088009600       DC16     +122,+136,+150,+196
   \              C400        
   \   00000108   A400D800F800       DC16     +164,+216,+248,+280
   \              1801        
   \   00000110   260144015001       DC16     +294,+324,+336,+790
   \              1603        
   \   00000118   160316031603       DC16     +790,+790,+790,+790
   \              1603        
   \   00000120   160316035C01       DC16     +790,+790,+348,+362
   \              6A01        
   \   00000128   780186019401       DC16     +376,+390,+404,+790
   \              1603        
   \   00000130   160316031603       DC16     +790,+790,+790,+790
   \              1603        
   \   00000138   16031603A201       DC16     +790,+790,+418,+432
   \              B001        
   \   00000140   BE01CC01DA01       DC16     +446,+460,+474,+488
   \              E801        
   \   00000148   F60104021603       DC16     +502,+516,+790,+790
   \              1603        
   \   00000150   160316031603       DC16     +790,+790,+790,+528
   \              1002        
   \   00000158   1E022A021603       DC16     +542,+554,+790,+790
   \              1603        
   \   00000160   160316031603       DC16     +790,+790,+790,+790
   \              1603        
   \   00000168   16035C023602       DC16     +790,+604,+566,+590
   \              4E02        
   \   00000170   64028202A002       DC16     +612,+642,+672,+702
   \              BE02        
   \   00000178   DC02FA02           DC16     +732,+762
   \                     ??Program_19:
   \   0000017C   734A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   0000017E   1830               ADDS     R0,R0,#+24
   \   00000180   0100               MOVS     R1,R0
   \   00000182   6846               MOV      R0,SP
   \   00000184   ........           BL       ProcConect_Action
   \   00000188   46E1               B        ??Program_16
   \                     ??Program_20:
   \   0000018A   704A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   0000018C   1830               ADDS     R0,R0,#+24
   \   0000018E   0100               MOVS     R1,R0
   \   00000190   6846               MOV      R0,SP
   \   00000192   ........           BL       ProcDown_Action
   \   00000196   3FE1               B        ??Program_16
   \                     ??Program_21:
   \   00000198   6C4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   0000019A   1830               ADDS     R0,R0,#+24
   \   0000019C   0100               MOVS     R1,R0
   \   0000019E   6846               MOV      R0,SP
   \   000001A0   ........           BL       ProcDownRight_Action
   \   000001A4   38E1               B        ??Program_16
   \                     ??Program_22:
   \   000001A6   6946               MOV      R1,SP
   \   000001A8   2200               MOVS     R2,R4
   \   000001AA   4A80               STRH     R2,[R1, #+2]
   \   000001AC   002E               CMP      R6,#+0
   \   000001AE   03D0               BEQ      ??Program_23
   \   000001B0   0200               MOVS     R2,R0
   \   000001B2   C63A               SUBS     R2,R2,#+198
   \   000001B4   1288               LDRH     R2,[R2, #+0]
   \   000001B6   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_23:
   \   000001B8   1830               ADDS     R0,R0,#+24
   \   000001BA   0200               MOVS     R2,R0
   \   000001BC   891C               ADDS     R1,R1,#+2
   \   000001BE   6846               MOV      R0,SP
   \   000001C0   ........           BL       ProcSumL_Action
   \   000001C4   28E1               B        ??Program_16
   \                     ??Program_24:
   \   000001C6   6946               MOV      R1,SP
   \   000001C8   2200               MOVS     R2,R4
   \   000001CA   4A80               STRH     R2,[R1, #+2]
   \   000001CC   002E               CMP      R6,#+0
   \   000001CE   F3D0               BEQ      ??Program_23
   \   000001D0   0200               MOVS     R2,R0
   \   000001D2   C63A               SUBS     R2,R2,#+198
   \   000001D4   1288               LDRH     R2,[R2, #+0]
   \   000001D6   4A80               STRH     R2,[R1, #+2]
   \   000001D8   EEE7               B        ??Program_23
   \                     ??Program_25:
   \   000001DA   6946               MOV      R1,SP
   \   000001DC   2200               MOVS     R2,R4
   \   000001DE   4A80               STRH     R2,[R1, #+2]
   \   000001E0   002E               CMP      R6,#+0
   \   000001E2   03D0               BEQ      ??Program_26
   \   000001E4   0200               MOVS     R2,R0
   \   000001E6   C63A               SUBS     R2,R2,#+198
   \   000001E8   1288               LDRH     R2,[R2, #+0]
   \   000001EA   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_26:
   \   000001EC   1830               ADDS     R0,R0,#+24
   \   000001EE   0100               MOVS     R1,R0
   \   000001F0   00A8               ADD      R0,SP,#+0
   \   000001F2   801C               ADDS     R0,R0,#+2
   \   000001F4   ........           BL       ProcUpToRight_Action
   \   000001F8   0EE1               B        ??Program_16
   \                     ??Program_27:
   \   000001FA   6946               MOV      R1,SP
   \   000001FC   2200               MOVS     R2,R4
   \   000001FE   4A80               STRH     R2,[R1, #+2]
   \   00000200   002E               CMP      R6,#+0
   \   00000202   03D0               BEQ      ??Program_28
   \   00000204   0200               MOVS     R2,R0
   \   00000206   C63A               SUBS     R2,R2,#+198
   \   00000208   1288               LDRH     R2,[R2, #+0]
   \   0000020A   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_28:
   \   0000020C   1830               ADDS     R0,R0,#+24
   \   0000020E   0100               MOVS     R1,R0
   \   00000210   00A8               ADD      R0,SP,#+0
   \   00000212   801C               ADDS     R0,R0,#+2
   \   00000214   ........           BL       ProcUpToRightDown_Action
   \   00000218   FEE0               B        ??Program_16
   \                     ??Program_29:
   \   0000021A   4C4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   0000021C   1830               ADDS     R0,R0,#+24
   \   0000021E   0100               MOVS     R1,R0
   \   00000220   6846               MOV      R0,SP
   \   00000222   ........           BL       ProcNOT_Action
   \   00000226   F7E0               B        ??Program_16
   \                     ??Program_30:
   \   00000228   002E               CMP      R6,#+0
   \   0000022A   04D0               BEQ      ??Program_31
   \   0000022C   6946               MOV      R1,SP
   \   0000022E   0200               MOVS     R2,R0
   \   00000230   C63A               SUBS     R2,R2,#+198
   \   00000232   1288               LDRH     R2,[R2, #+0]
   \   00000234   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_31:
   \   00000236   1830               ADDS     R0,R0,#+24
   \   00000238   0200               MOVS     R2,R0
   \   0000023A   00A9               ADD      R1,SP,#+0
   \   0000023C   891C               ADDS     R1,R1,#+2
   \   0000023E   6846               MOV      R0,SP
   \   00000240   ........           BL       ProcToggleRS_Action
   \   00000244   E8E0               B        ??Program_16
   \                     ??Program_32:
   \   00000246   1830               ADDS     R0,R0,#+24
   \   00000248   0100               MOVS     R1,R0
   \   0000024A   6846               MOV      R0,SP
   \   0000024C   ........           BL       ProcToggleT_Action
   \   00000250   E2E0               B        ??Program_16
   \                     ??Program_33:
   \   00000252   1830               ADDS     R0,R0,#+24
   \   00000254   0100               MOVS     R1,R0
   \   00000256   6846               MOV      R0,SP
   \   00000258   ........           BL       ProcTLI1_Action
   \   0000025C   DCE0               B        ??Program_16
   \                     ??Program_34:
   \   0000025E   3B4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000260   1830               ADDS     R0,R0,#+24
   \   00000262   0100               MOVS     R1,R0
   \   00000264   6846               MOV      R0,SP
   \   00000266   ........           BL       ProcStI_Action
   \   0000026A   D5E0               B        ??Program_16
   \                     ??Program_35:
   \   0000026C   374A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   0000026E   1830               ADDS     R0,R0,#+24
   \   00000270   0100               MOVS     R1,R0
   \   00000272   6846               MOV      R0,SP
   \   00000274   ........           BL       ProcStNI_Action
   \   00000278   CEE0               B        ??Program_16
   \                     ??Program_36:
   \   0000027A   344A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   0000027C   1830               ADDS     R0,R0,#+24
   \   0000027E   0100               MOVS     R1,R0
   \   00000280   6846               MOV      R0,SP
   \   00000282   ........           BL       ProcStQ_Action
   \   00000286   C7E0               B        ??Program_16
   \                     ??Program_37:
   \   00000288   304A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   0000028A   1830               ADDS     R0,R0,#+24
   \   0000028C   0100               MOVS     R1,R0
   \   0000028E   6846               MOV      R0,SP
   \   00000290   ........           BL       ProcStB_Action
   \   00000294   C0E0               B        ??Program_16
   \                     ??Program_38:
   \   00000296   2D4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000298   1830               ADDS     R0,R0,#+24
   \   0000029A   0100               MOVS     R1,R0
   \   0000029C   6846               MOV      R0,SP
   \   0000029E   ........           BL       ProcStS_Action
   \   000002A2   B9E0               B        ??Program_16
   \                     ??Program_39:
   \   000002A4   294A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002A6   1830               ADDS     R0,R0,#+24
   \   000002A8   0100               MOVS     R1,R0
   \   000002AA   6846               MOV      R0,SP
   \   000002AC   ........           BL       ProcWOUT_Action
   \   000002B0   B2E0               B        ??Program_16
   \                     ??Program_40:
   \   000002B2   264A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002B4   1830               ADDS     R0,R0,#+24
   \   000002B6   0100               MOVS     R1,R0
   \   000002B8   6846               MOV      R0,SP
   \   000002BA   ........           BL       ProcWOUTS_Action
   \   000002BE   ABE0               B        ??Program_16
   \                     ??Program_41:
   \   000002C0   224A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002C2   1830               ADDS     R0,R0,#+24
   \   000002C4   0100               MOVS     R1,R0
   \   000002C6   6846               MOV      R0,SP
   \   000002C8   ........           BL       ProcWOUTR_Action
   \   000002CC   A4E0               B        ??Program_16
   \                     ??Program_42:
   \   000002CE   1F4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002D0   1830               ADDS     R0,R0,#+24
   \   000002D2   0100               MOVS     R1,R0
   \   000002D4   6846               MOV      R0,SP
   \   000002D6   ........           BL       ProcWOUTC_Action
   \   000002DA   9DE0               B        ??Program_16
   \                     ??Program_43:
   \   000002DC   1B4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002DE   1830               ADDS     R0,R0,#+24
   \   000002E0   0100               MOVS     R1,R0
   \   000002E2   6846               MOV      R0,SP
   \   000002E4   ........           BL       ProcSetScn_Action
   \   000002E8   96E0               B        ??Program_16
   \                     ??Program_44:
   \   000002EA   184A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002EC   1830               ADDS     R0,R0,#+24
   \   000002EE   0100               MOVS     R1,R0
   \   000002F0   6846               MOV      R0,SP
   \   000002F2   ........           BL       ProcInc_Action
   \   000002F6   8FE0               B        ??Program_16
   \                     ??Program_45:
   \   000002F8   144A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002FA   1830               ADDS     R0,R0,#+24
   \   000002FC   0100               MOVS     R1,R0
   \   000002FE   6846               MOV      R0,SP
   \   00000300   ........           BL       ProcDec_Action
   \   00000304   88E0               B        ??Program_16
   \                     ??Program_46:
   \   00000306   1830               ADDS     R0,R0,#+24
   \   00000308   0100               MOVS     R1,R0
   \   0000030A   6846               MOV      R0,SP
   \   0000030C   ........           BL       ProcSPK_Action
   \   00000310   82E0               B        ??Program_16
   \                     ??Program_47:
   \   00000312   0E4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000314   1830               ADDS     R0,R0,#+24
   \   00000316   0100               MOVS     R1,R0
   \   00000318   6846               MOV      R0,SP
   \   0000031A   ........           BL       ProcTimerSet_Action
   \   0000031E   7BE0               B        ??Program_16
   \                     ??Program_48:
   \   00000320   1830               ADDS     R0,R0,#+24
   \   00000322   0100               MOVS     R1,R0
   \   00000324   6846               MOV      R0,SP
   \   00000326   ........           BL       ProcClock_Action
   \   0000032A   75E0               B        ??Program_16
   \                     ??Program_49:
   \   0000032C   1830               ADDS     R0,R0,#+24
   \   0000032E   0100               MOVS     R1,R0
   \   00000330   6846               MOV      R0,SP
   \   00000332   ........           BL       ProcDay_Action
   \   00000336   6FE0               B        ??Program_16
   \                     ??Program_50:
   \   00000338   0449               LDR      R1,??Program_1+0x8  ;; MainStage
   \   0000033A   1830               ADDS     R0,R0,#+24
   \   0000033C   ........           BL       ProcGetReg_Action
   \   00000340   6AE0               B        ??Program_16
   \   00000342   C046               Nop      
   \                     ??Program_1:
   \   00000344   ........           DC32     Trap
   \   00000348   ........           DC32     g_counter
   \   0000034C   ........           DC32     MainStage
   \                     ??Program_51:
   \   00000350   3B4A               LDR      R2,??Program_52  ;; MainStage
   \   00000352   1830               ADDS     R0,R0,#+24
   \   00000354   0100               MOVS     R1,R0
   \   00000356   6846               MOV      R0,SP
   \   00000358   ........           BL       ProcSetAnal_Action
   \   0000035C   5CE0               B        ??Program_16
   \                     ??Program_53:
   \   0000035E   1830               ADDS     R0,R0,#+24
   \   00000360   ........           BL       ProcConstAnal_Action
   \   00000364   58E0               B        ??Program_16
   \                     ??Program_54:
   \   00000366   002E               CMP      R6,#+0
   \   00000368   04D0               BEQ      ??Program_55
   \   0000036A   6946               MOV      R1,SP
   \   0000036C   0200               MOVS     R2,R0
   \   0000036E   C63A               SUBS     R2,R2,#+198
   \   00000370   1288               LDRH     R2,[R2, #+0]
   \   00000372   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_55:
   \   00000374   1830               ADDS     R0,R0,#+24
   \   00000376   0200               MOVS     R2,R0
   \   00000378   00A9               ADD      R1,SP,#+0
   \   0000037A   891C               ADDS     R1,R1,#+2
   \   0000037C   6846               MOV      R0,SP
   \   0000037E   ........           BL       ProcLim_Action
   \   00000382   49E0               B        ??Program_16
   \                     ??Program_56:
   \   00000384   002E               CMP      R6,#+0
   \   00000386   04D0               BEQ      ??Program_57
   \   00000388   6946               MOV      R1,SP
   \   0000038A   0200               MOVS     R2,R0
   \   0000038C   C63A               SUBS     R2,R2,#+198
   \   0000038E   1288               LDRH     R2,[R2, #+0]
   \   00000390   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_57:
   \   00000392   1830               ADDS     R0,R0,#+24
   \   00000394   0200               MOVS     R2,R0
   \   00000396   00A9               ADD      R1,SP,#+0
   \   00000398   891C               ADDS     R1,R1,#+2
   \   0000039A   6846               MOV      R0,SP
   \   0000039C   ........           BL       ProcEven_Action
   \   000003A0   3AE0               B        ??Program_16
   \                     ??Program_58:
   \   000003A2   002E               CMP      R6,#+0
   \   000003A4   04D0               BEQ      ??Program_59
   \   000003A6   6946               MOV      R1,SP
   \   000003A8   0200               MOVS     R2,R0
   \   000003AA   C63A               SUBS     R2,R2,#+198
   \   000003AC   1288               LDRH     R2,[R2, #+0]
   \   000003AE   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_59:
   \   000003B0   1830               ADDS     R0,R0,#+24
   \   000003B2   0200               MOVS     R2,R0
   \   000003B4   00A9               ADD      R1,SP,#+0
   \   000003B6   891C               ADDS     R1,R1,#+2
   \   000003B8   6846               MOV      R0,SP
   \   000003BA   ........           BL       ProcPlus_Action
   \   000003BE   2BE0               B        ??Program_16
   \                     ??Program_60:
   \   000003C0   002E               CMP      R6,#+0
   \   000003C2   04D0               BEQ      ??Program_61
   \   000003C4   6946               MOV      R1,SP
   \   000003C6   0200               MOVS     R2,R0
   \   000003C8   C63A               SUBS     R2,R2,#+198
   \   000003CA   1288               LDRH     R2,[R2, #+0]
   \   000003CC   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_61:
   \   000003CE   1830               ADDS     R0,R0,#+24
   \   000003D0   0200               MOVS     R2,R0
   \   000003D2   00A9               ADD      R1,SP,#+0
   \   000003D4   891C               ADDS     R1,R1,#+2
   \   000003D6   6846               MOV      R0,SP
   \   000003D8   ........           BL       ProcMinus_Action
   \   000003DC   1CE0               B        ??Program_16
   \                     ??Program_62:
   \   000003DE   002E               CMP      R6,#+0
   \   000003E0   04D0               BEQ      ??Program_63
   \   000003E2   6946               MOV      R1,SP
   \   000003E4   0200               MOVS     R2,R0
   \   000003E6   C63A               SUBS     R2,R2,#+198
   \   000003E8   1288               LDRH     R2,[R2, #+0]
   \   000003EA   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_63:
   \   000003EC   1830               ADDS     R0,R0,#+24
   \   000003EE   0200               MOVS     R2,R0
   \   000003F0   00A9               ADD      R1,SP,#+0
   \   000003F2   891C               ADDS     R1,R1,#+2
   \   000003F4   6846               MOV      R0,SP
   \   000003F6   ........           BL       ProcMul_Action
   \   000003FA   0DE0               B        ??Program_16
   \                     ??Program_64:
   \   000003FC   002E               CMP      R6,#+0
   \   000003FE   04D0               BEQ      ??Program_65
   \   00000400   6946               MOV      R1,SP
   \   00000402   0200               MOVS     R2,R0
   \   00000404   C63A               SUBS     R2,R2,#+198
   \   00000406   1288               LDRH     R2,[R2, #+0]
   \   00000408   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_65:
   \   0000040A   1830               ADDS     R0,R0,#+24
   \   0000040C   0200               MOVS     R2,R0
   \   0000040E   00A9               ADD      R1,SP,#+0
   \   00000410   891C               ADDS     R1,R1,#+2
   \   00000412   6846               MOV      R0,SP
   \   00000414   ........           BL       ProcDiv_Action
   \                     ??Program_16:
   \   00000418   287B               LDRB     R0,[R5, #+12]
   \   0000041A   401E               SUBS     R0,R0,#+1
   \   0000041C   8642               CMP      R6,R0
   \   0000041E   00D0               BEQ      .+4
   \   00000420   36E6               B        ??Program_12
   \   00000422   092F               CMP      R7,#+9
   \   00000424   00D0               BEQ      .+4
   \   00000426   33E6               B        ??Program_12
   \   00000428   2100               MOVS     R1,R4
   \   0000042A   24E6               B        ??Program_11
   1198           
   1199                   
   1200          
   1201                   }
   1202                   
   1203                   
   1204                  }
   1205                  
   1206                  
   1207                }
   1208              }
   1209            Busy_program=0;
   \                     ??Program_8:
   \   0000042C   AC72               STRB     R4,[R5, #+10]
   1210            
   1211              }
   1212             
   1213              
   1214              PtogTime=g_counter-last_time;
   \                     ??Program_2:
   \   0000042E   0548               LDR      R0,??Program_52+0x4  ;; g_counter
   \   00000430   0068               LDR      R0,[R0, #+0]
   \   00000432   6969               LDR      R1,[R5, #+20]
   \   00000434   401A               SUBS     R0,R0,R1
   \   00000436   2861               STR      R0,[R5, #+16]
   1215          
   1216          }//_______________________ Koniec funkcji program__ ____________________________
   \   00000438   FEBC               POP      {R1-R7}
   \   0000043A   01BC               POP      {R0}
   \   0000043C   0047               BX       R0               ;; return
   \   0000043E   C046               Nop      
   \                     ??Program_52:
   \   00000440   ........           DC32     MainStage
   \   00000444   ........           DC32     g_counter

   \                                 In section .data, align 4
   \                     Trap:
   \   00000000   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \                     NumberScene:
   \   00000008   0A                 DC8 10
   \                     LastScene:
   \   00000009   00                 DC8 0
   \                     Busy_program:
   \   0000000A   00                 DC8 0
   \                     SceneNrLast:
   \   0000000B   00                 DC8 0
   \                     RealPrcLines:
   \   0000000C   C8                 DC8 200
   \   0000000D   00                 DC8 0
   \                     ScreenUse:
   \   0000000E   0000               DC8 0, 0
   \                     PtogTime:
   \   00000010   00000000           DC32 0
   \                     last_time:
   \   00000014   00000000           DC8 0, 0, 0, 0
   \   00000018   00000000           DC32 0
   \   0000001C   00000000           DC32 0

   \                                 In section .data, align 4
   \                     pProg:
   \   00000000   ........           DC32 gProg
   1217          
   1218          
   1219          
   1220          //-----------------------------------------------------------------------------
   1221          // Nazwa funkcji :    SceneNrCount
   1222          // Funkcja zlicza u¿ywane w programie u¿ytkowym sceny. Odpowiedzi¹ jest iloœæ scen
   1223          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1224          char SceneNrCount(_ProgramTab *ProgTab)
   1225          {
   \                     SceneNrCount:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0100               MOVS     R1,R0
   1226                char MaxScnNr=0;
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   1000               MOVS     R0,R2
   1227                for (int LineNr=0; LineNr<MaxPrcLines; LineNr++)
   \   00000008   1300               MOVS     R3,R2
   \   0000000A   14E0               B        ??SceneNrCount_0
   1228                {
   1229                  for (int PrcInLine=0; PrcInLine<MaxPrcInLine; PrcInLine++)
   1230                  {
   1231                     if ((ProgTab->Line[LineNr].Proc[PrcInLine].Type==ProcStS) && (ProgTab->Line[LineNr].Proc[PrcInLine].Nr>MaxScnNr))
   \                     ??SceneNrCount_1:
   \   0000000C   1825               MOVS     R5,#+24
   \   0000000E   6543               MULS     R5,R4,R5
   \   00000010   F026               MOVS     R6,#+240
   \   00000012   5E43               MULS     R6,R3,R6
   \   00000014   8E19               ADDS     R6,R1,R6
   \   00000016   7519               ADDS     R5,R6,R5
   \   00000018   2E7E               LDRB     R6,[R5, #+24]
   \   0000001A   182E               CMP      R6,#+24
   \   0000001C   07D1               BNE      ??SceneNrCount_2
   \   0000001E   0600               MOVS     R6,R0
   \   00000020   1927               MOVS     R7,#+25
   \   00000022   EF57               LDRSB    R7,[R5, R7]
   \   00000024   BE42               CMP      R6,R7
   \   00000026   02DA               BGE      ??SceneNrCount_2
   1232                     {
   1233                       MaxScnNr=ProgTab->Line[LineNr].Proc[PrcInLine].Nr;
   \   00000028   3800               MOVS     R0,R7
   \   0000002A   0006               LSLS     R0,R0,#+24
   \   0000002C   000E               LSRS     R0,R0,#+24
   1234                     }
   1235                  }
   \                     ??SceneNrCount_2:
   \   0000002E   641C               ADDS     R4,R4,#+1
   \                     ??SceneNrCount_3:
   \   00000030   0A2C               CMP      R4,#+10
   \   00000032   EBDB               BLT      ??SceneNrCount_1
   \   00000034   5B1C               ADDS     R3,R3,#+1
   \                     ??SceneNrCount_0:
   \   00000036   C82B               CMP      R3,#+200
   \   00000038   01DA               BGE      ??SceneNrCount_4
   \   0000003A   1400               MOVS     R4,R2
   \   0000003C   F8E7               B        ??SceneNrCount_3
   1236                  
   1237                }
   1238            
   1239                return MaxScnNr;
   \                     ??SceneNrCount_4:
   \   0000003E   F8BC               POP      {R3-R7}
   \   00000040   02BC               POP      {R1}
   \   00000042   0847               BX       R1               ;; return
   1240          }//_______________________ Koniec funkcji_______________________________________
   1241          
   1242          
   1243          
   1244          
   1245             
   1246          //-----------------------------------------------------------------------------
   1247          // Nazwa funkcji :    ScreenNrCount
   1248          // Funkcja zlicza u¿ywane ekrany. Odpowiedzi¹ jest suma logiczna u¿ywanych ekranów
   1249          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1250          short CheckScreenUse(_ProgramTab *ProgTab)
   1251          {
   \                     CheckScreenUse:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0120               MOVS     R0,#+1
   1252            
   1253                short ScreenUse=1; 
   1254               
   1255                char f=1;  
   \   00000004   0100               MOVS     R1,R0
   \   00000006   0022               MOVS     R2,#+0
   \   00000008   28E0               B        ??CheckScreenUse_0
   1256            
   1257                char sc=0;
   1258                _ScreenPaternDesign *ScreenPaternDesign; 
   1259                while ((f)&&(sc<ScreenNr))
   1260                {
   1261                  f=0;
   1262                  
   1263                       if (sc==0) 
   1264                      {
   1265                        ScreenPaternDesign=ScreenSetTab_0;
   1266                      }else{
   1267                        ScreenPaternDesign=ScreenSetTab_1; 
   1268                      }  
   1269          
   1270                  for (int bt=0; bt<ScrenButtonNr; bt++)
   1271                  {
   1272                    if ((ScreenPaternDesign[ProgTab->Screen[sc].PaternDesign].Button[bt].Width>0) && (ProgTab->Screen[sc].Button[bt].OpenPage>0) )
   \                     ??CheckScreenUse_1:
   \   0000000A   1500               MOVS     R5,R2
   \   0000000C   A026               MOVS     R6,#+160
   \   0000000E   7543               MULS     R5,R6,R5
   \   00000010   009E               LDR      R6,[SP, #+0]
   \   00000012   7519               ADDS     R5,R6,R5
   \   00000014   A700               LSLS     R7,R4,#+2
   \   00000016   BC46               MOV      R12,R7
   \   00000018   184E               LDR      R6,??CheckScreenUse_2  ;; 0xbb98
   \   0000001A   AF5D               LDRB     R7,[R5, R6]
   \   0000001C   5826               MOVS     R6,#+88
   \   0000001E   7743               MULS     R7,R6,R7
   \   00000020   DE19               ADDS     R6,R3,R7
   \   00000022   6746               MOV      R7,R12
   \   00000024   F619               ADDS     R6,R6,R7
   \   00000026   B678               LDRB     R6,[R6, #+2]
   \   00000028   002E               CMP      R6,#+0
   \   0000002A   11D0               BEQ      ??CheckScreenUse_3
   \   0000002C   144E               LDR      R6,??CheckScreenUse_2+0x4  ;; 0xbbaa
   \   0000002E   E700               LSLS     R7,R4,#+3
   \   00000030   ED19               ADDS     R5,R5,R7
   \   00000032   AD19               ADDS     R5,R5,R6
   \   00000034   0F26               MOVS     R6,#+15
   \   00000036   2F78               LDRB     R7,[R5, #+0]
   \   00000038   3742               TST      R7,R6
   \   0000003A   09D0               BEQ      ??CheckScreenUse_3
   1273                    {
   1274                      ScreenUse |=1<<(ProgTab->Screen[sc].Button[bt].OpenPage-1);
   \   0000003C   0121               MOVS     R1,#+1
   \   0000003E   3D00               MOVS     R5,R7
   \   00000040   2E40               ANDS     R6,R6,R5
   \   00000042   751E               SUBS     R5,R6,#+1
   \   00000044   A940               LSLS     R1,R1,R5
   \   00000046   0143               ORRS     R1,R1,R0
   \   00000048   0904               LSLS     R1,R1,#+16
   \   0000004A   0914               ASRS     R1,R1,#+16
   \   0000004C   0800               MOVS     R0,R1
   1275                      f=1;
   \   0000004E   0121               MOVS     R1,#+1
   1276                    }
   1277                  }
   \                     ??CheckScreenUse_3:
   \   00000050   641C               ADDS     R4,R4,#+1
   \                     ??CheckScreenUse_4:
   \   00000052   092C               CMP      R4,#+9
   \   00000054   D9DB               BLT      ??CheckScreenUse_1
   1278                  sc++;
   \   00000056   521C               ADDS     R2,R2,#+1
   \   00000058   1206               LSLS     R2,R2,#+24
   \   0000005A   120E               LSRS     R2,R2,#+24
   \                     ??CheckScreenUse_0:
   \   0000005C   0029               CMP      R1,#+0
   \   0000005E   0AD0               BEQ      ??CheckScreenUse_5
   \   00000060   1100               MOVS     R1,R2
   \   00000062   0829               CMP      R1,#+8
   \   00000064   07D2               BCS      ??CheckScreenUse_5
   \   00000066   0021               MOVS     R1,#+0
   \   00000068   1300               MOVS     R3,R2
   \   0000006A   01D1               BNE      ??CheckScreenUse_6
   \   0000006C   054B               LDR      R3,??CheckScreenUse_2+0x8  ;; ScreenSetTab_0
   \   0000006E   00E0               B        ??CheckScreenUse_7
   \                     ??CheckScreenUse_6:
   \   00000070   054B               LDR      R3,??CheckScreenUse_2+0xC  ;; ScreenSetTab_1
   \                     ??CheckScreenUse_7:
   \   00000072   0C00               MOVS     R4,R1
   \   00000074   EDE7               B        ??CheckScreenUse_4
   1279                  
   1280                }
   1281                
   1282           
   1283            
   1284                return ScreenUse;
   \                     ??CheckScreenUse_5:
   \   00000076   F8BC               POP      {R3-R7}
   \   00000078   02BC               POP      {R1}
   \   0000007A   0847               BX       R1               ;; return
   \                     ??CheckScreenUse_2:
   \   0000007C   98BB0000           DC32     0xbb98
   \   00000080   AABB0000           DC32     0xbbaa
   \   00000084   ........           DC32     ScreenSetTab_0
   \   00000088   ........           DC32     ScreenSetTab_1
   1285            
   1286          }//_______________________ Koniec funkcji_______________________________________
   1287          
   1288          
   1289               
   1290               
   1291               

   \                                 In section Debug.txt, align 4, keep-with-next
   1292          void CountLines(_ProgramTab *ProgTab)
   1293          {
   \                     CountLines:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   1294               char UseLine=0;
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0A00               MOVS     R2,R1
   1295                  for (char j=0; j<MaxPrcLines; j++)
   \   00000006   0B00               MOVS     R3,R1
   \   00000008   13E0               B        ??CountLines_0
   1296                    for (char i=0; i<MaxPrcInLine; i++) 
   1297                      if (ProgTab->Line[j].Proc[i].Type>0) UseLine=j;
   \                     ??CountLines_1:
   \   0000000A   1826               MOVS     R6,#+24
   \   0000000C   7543               MULS     R5,R6,R5
   \   0000000E   1E00               MOVS     R6,R3
   \   00000010   F027               MOVS     R7,#+240
   \   00000012   7E43               MULS     R6,R7,R6
   \   00000014   8619               ADDS     R6,R0,R6
   \   00000016   7519               ADDS     R5,R6,R5
   \   00000018   2D7E               LDRB     R5,[R5, #+24]
   \   0000001A   002D               CMP      R5,#+0
   \   0000001C   00D0               BEQ      ??CountLines_2
   \   0000001E   1A00               MOVS     R2,R3
   \                     ??CountLines_2:
   \   00000020   641C               ADDS     R4,R4,#+1
   \   00000022   2406               LSLS     R4,R4,#+24
   \   00000024   240E               LSRS     R4,R4,#+24
   \                     ??CountLines_3:
   \   00000026   2500               MOVS     R5,R4
   \   00000028   0A2D               CMP      R5,#+10
   \   0000002A   EED3               BCC      ??CountLines_1
   \   0000002C   5B1C               ADDS     R3,R3,#+1
   \   0000002E   1B06               LSLS     R3,R3,#+24
   \   00000030   1B0E               LSRS     R3,R3,#+24
   \                     ??CountLines_0:
   \   00000032   1C00               MOVS     R4,R3
   \   00000034   C82C               CMP      R4,#+200
   \   00000036   01D2               BCS      ??CountLines_4
   \   00000038   0C00               MOVS     R4,R1
   \   0000003A   F4E7               B        ??CountLines_3
   1298              RealPrcLines=UseLine+1; 
   \                     ??CountLines_4:
   \   0000003C   0248               LDR      R0,??CountLines_5  ;; Trap + 12
   \   0000003E   521C               ADDS     R2,R2,#+1
   \   00000040   0270               STRB     R2,[R0, #+0]
   1299          }
   \   00000042   F8BC               POP      {R3-R7}
   \   00000044   01BC               POP      {R0}
   \   00000046   0047               BX       R0               ;; return
   \                     ??CountLines_5:
   \   00000048   ........           DC32     Trap + 12
   1300          
   1301          
   1302          

   \                                 In section Debug.txt, align 4, keep-with-next
   1303          void RefreshNeuronsList(_ProgramTab *ProgTab)
   1304          {
   \                     RefreshNeuronsList:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0024               MOVS     R4,#+0
   \   00000004   09E0               B        ??RefreshNeuronsList_0
   1305            for (char i=0; i<NumberNeurons; i++)
   1306            {
   1307             if (ProgTab->NeuronsIdTab[i]>0)
   1308             {
   1309                 NeuronsList[i].NeuronType=(_NeuronType)((ProgTab->NeuronsIdTab[i])/1000000);
   1310                 NeuronsList[i].NeuronID=(ProgTab->NeuronsIdTab[i])-(NeuronsList[i].NeuronType*1000000);
   1311             }else{
   1312                 NeuronsList[i].NeuronType=(_NeuronType)0;
   \                     ??RefreshNeuronsList_1:
   \   00000006   0C21               MOVS     R1,#+12
   \   00000008   4843               MULS     R0,R1,R0
   \   0000000A   1349               LDR      R1,??RefreshNeuronsList_2  ;; NeuronsList
   \   0000000C   0E18               ADDS     R6,R1,R0
   \   0000000E   0020               MOVS     R0,#+0
   \   00000010   3070               STRB     R0,[R6, #+0]
   1313                 NeuronsList[i].NeuronID=0;
   \   00000012   7060               STR      R0,[R6, #+4]
   1314             }
   \                     ??RefreshNeuronsList_3:
   \   00000014   641C               ADDS     R4,R4,#+1
   \   00000016   2406               LSLS     R4,R4,#+24
   \   00000018   240E               LSRS     R4,R4,#+24
   \                     ??RefreshNeuronsList_0:
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   2328               CMP      R0,#+35
   \   0000001E   17D2               BCS      ??RefreshNeuronsList_4
   \   00000020   0E49               LDR      R1,??RefreshNeuronsList_2+0x4  ;; 0xc098
   \   00000022   8200               LSLS     R2,R0,#+2
   \   00000024   009B               LDR      R3,[SP, #+0]
   \   00000026   9A18               ADDS     R2,R3,R2
   \   00000028   5518               ADDS     R5,R2,R1
   \   0000002A   2968               LDR      R1,[R5, #+0]
   \   0000002C   0129               CMP      R1,#+1
   \   0000002E   EADB               BLT      ??RefreshNeuronsList_1
   \   00000030   0C21               MOVS     R1,#+12
   \   00000032   4843               MULS     R0,R1,R0
   \   00000034   0849               LDR      R1,??RefreshNeuronsList_2  ;; NeuronsList
   \   00000036   0E18               ADDS     R6,R1,R0
   \   00000038   094F               LDR      R7,??RefreshNeuronsList_2+0x8  ;; 0xf4240
   \   0000003A   2868               LDR      R0,[R5, #+0]
   \   0000003C   3900               MOVS     R1,R7
   \   0000003E   ........           BL       __aeabi_idivmod
   \   00000042   3070               STRB     R0,[R6, #+0]
   \   00000044   2868               LDR      R0,[R5, #+0]
   \   00000046   3178               LDRB     R1,[R6, #+0]
   \   00000048   7943               MULS     R1,R7,R1
   \   0000004A   401A               SUBS     R0,R0,R1
   \   0000004C   7060               STR      R0,[R6, #+4]
   \   0000004E   E1E7               B        ??RefreshNeuronsList_3
   1315            }
   1316          }
   \                     ??RefreshNeuronsList_4:
   \   00000050   F8BC               POP      {R3-R7}
   \   00000052   01BC               POP      {R0}
   \   00000054   0047               BX       R0               ;; return
   \   00000056   C046               Nop      
   \                     ??RefreshNeuronsList_2:
   \   00000058   ........           DC32     NeuronsList
   \   0000005C   98C00000           DC32     0xc098
   \   00000060   40420F00           DC32     0xf4240
   1317          
   1318          
   1319          
   1320          //-----------------------------------------------------------------------------
   1321          // Nazwa funkcji :    AddRsTask
   1322          // Funkcja ustawia dodanie zadania dla transmisji Rs
   1323          // Ord - typ rozkazu : odczyt wejœæ, zapis
   1324          // Node - nr wêz³a/urz¹dzenia
   1325          // Reg  - nr rejestru w wêŸle 
   1326          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1327          void AddRsTask(_OrderType Ord, char Node, char Reg)
   1328          { 
   \                     AddRsTask:
   \   00000000   F4B5               PUSH     {R2,R4-R7,LR}
   1329               ptr_ZD_MODBUS ZD_MODBUS;
   1330               ZD_MODBUS         =   ZD_MODBUS_0;
   1331               
   1332              char OrdExist=0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   1400               MOVS     R4,R2
   1333              char RfOrd=0;
   \   00000006   1300               MOVS     R3,R2
   1334              char FreePlace=0;
   1335              
   1336              
   1337              //przepisanie rozkazu na zrozumia³y dla tablicy zadañ Rs
   1338              if (Ord==SI) RfOrd=0x4; 
   \   00000008   0128               CMP      R0,#+1
   \   0000000A   00D1               BNE      ??AddRsTask_0
   \   0000000C   0423               MOVS     R3,#+4
   1339              if (Ord==SQ) RfOrd=0xF; 
   \                     ??AddRsTask_0:
   \   0000000E   0228               CMP      R0,#+2
   \   00000010   00D1               BNE      ??AddRsTask_1
   \   00000012   0F23               MOVS     R3,#+15
   1340          
   1341                
   1342          
   1343                    
   1344              //Sprawdzenie czy taki rozkaz nie istnieje w tablicy
   1345              char i=0;
   \                     ??AddRsTask_1:
   \   00000014   1000               MOVS     R0,R2
   \   00000016   1FE0               B        ??AddRsTask_2
   1346              while ((i<ZD_MODBUS_Tab_Max) && (OrdExist==0))
   1347              {
   1348                 if ((ZD_MODBUS[i].Adress==Node) && 
   1349                     (ZD_MODBUS[i].Function==RfOrd) &&
   1350                     (ZD_MODBUS[i].Target==Reg) &&
   1351                     (ZD_MODBUS[i].StartAdr==Node-0))
   \                     ??AddRsTask_3:
   \   00000018   264D               LDR      R5,??AddRsTask_4  ;; ZD_MODBUS_0
   \   0000001A   0600               MOVS     R6,R0
   \   0000001C   0D27               MOVS     R7,#+13
   \   0000001E   7E43               MULS     R6,R7,R6
   \   00000020   AD19               ADDS     R5,R5,R6
   \   00000022   2E78               LDRB     R6,[R5, #+0]
   \   00000024   8E42               CMP      R6,R1
   \   00000026   14D1               BNE      ??AddRsTask_5
   \   00000028   6E78               LDRB     R6,[R5, #+1]
   \   0000002A   9E42               CMP      R6,R3
   \   0000002C   11D1               BNE      ??AddRsTask_5
   \   0000002E   AE78               LDRB     R6,[R5, #+2]
   \   00000030   EF78               LDRB     R7,[R5, #+3]
   \   00000032   3F06               LSLS     R7,R7,#+24
   \   00000034   3F0C               LSRS     R7,R7,#+16
   \   00000036   3E43               ORRS     R6,R6,R7
   \   00000038   6F46               MOV      R7,SP
   \   0000003A   3F78               LDRB     R7,[R7, #+0]
   \   0000003C   BE42               CMP      R6,R7
   \   0000003E   08D1               BNE      ??AddRsTask_5
   \   00000040   2E79               LDRB     R6,[R5, #+4]
   \   00000042   6F79               LDRB     R7,[R5, #+5]
   \   00000044   3F06               LSLS     R7,R7,#+24
   \   00000046   3F0C               LSRS     R7,R7,#+16
   \   00000048   3E43               ORRS     R6,R6,R7
   \   0000004A   0D00               MOVS     R5,R1
   \   0000004C   AE42               CMP      R6,R5
   \   0000004E   00D1               BNE      ??AddRsTask_5
   1352                    {
   1353                      OrdExist=1;
   \   00000050   0124               MOVS     R4,#+1
   1354                    }
   1355                 i++;
   \                     ??AddRsTask_5:
   \   00000052   401C               ADDS     R0,R0,#+1
   \   00000054   0006               LSLS     R0,R0,#+24
   \   00000056   000E               LSRS     R0,R0,#+24
   1356              }
   \                     ??AddRsTask_2:
   \   00000058   0500               MOVS     R5,R0
   \   0000005A   1E2D               CMP      R5,#+30
   \   0000005C   01D2               BCS      ??AddRsTask_6
   \   0000005E   2500               MOVS     R5,R4
   \   00000060   DAD0               BEQ      ??AddRsTask_3
   1357              
   1358              //je¿eli rozkaz nie istnieje to dodaj
   1359              if (OrdExist==0)
   \                     ??AddRsTask_6:
   \   00000062   002C               CMP      R4,#+0
   \   00000064   23D1               BNE      ??AddRsTask_7
   1360              {
   1361                //znajdŸ wolne miejsce w tablicy zadañ 
   1362                FreePlace=0;
   \   00000066   02E0               B        ??AddRsTask_8
   1363                while ((FreePlace<ZD_MODBUS_Tab_Max) && (ZD_MODBUS[FreePlace].Adress!=0)) FreePlace++;
   \                     ??AddRsTask_9:
   \   00000068   521C               ADDS     R2,R2,#+1
   \   0000006A   1206               LSLS     R2,R2,#+24
   \   0000006C   120E               LSRS     R2,R2,#+24
   \                     ??AddRsTask_8:
   \   0000006E   1000               MOVS     R0,R2
   \   00000070   1E28               CMP      R0,#+30
   \   00000072   05D2               BCS      ??AddRsTask_10
   \   00000074   0D24               MOVS     R4,#+13
   \   00000076   6043               MULS     R0,R4,R0
   \   00000078   0E4C               LDR      R4,??AddRsTask_4  ;; ZD_MODBUS_0
   \   0000007A   205C               LDRB     R0,[R4, R0]
   \   0000007C   0028               CMP      R0,#+0
   \   0000007E   F3D1               BNE      ??AddRsTask_9
   1364                
   1365                
   1366                if (FreePlace<ZD_MODBUS_Tab_Max)     //jezeli jest miejsce w tablicy to dodaj
   \                     ??AddRsTask_10:
   \   00000080   1000               MOVS     R0,R2
   \   00000082   1E28               CMP      R0,#+30
   \   00000084   13D2               BCS      ??AddRsTask_7
   1367                { 
   1368                  ZD_MODBUS[FreePlace].Adress=Node;
   \   00000086   0B4D               LDR      R5,??AddRsTask_4  ;; ZD_MODBUS_0
   \   00000088   0D20               MOVS     R0,#+13
   \   0000008A   4243               MULS     R2,R0,R2
   \   0000008C   A818               ADDS     R0,R5,R2
   \   0000008E   0170               STRB     R1,[R0, #+0]
   1369                  ZD_MODBUS[FreePlace].Function=RfOrd;
   \   00000090   4370               STRB     R3,[R0, #+1]
   1370                  ZD_MODBUS[FreePlace].Target=Reg;
   \   00000092   6A46               MOV      R2,SP
   \   00000094   1278               LDRB     R2,[R2, #+0]
   \   00000096   8270               STRB     R2,[R0, #+2]
   \   00000098   120A               LSRS     R2,R2,#+8
   \   0000009A   C270               STRB     R2,[R0, #+3]
   1371                  ZD_MODBUS[FreePlace].StartAdr=Node-0;   //miejsce w pamiêci do pobrania danych (odpowiada nodowi)
   \   0000009C   0171               STRB     R1,[R0, #+4]
   \   0000009E   090A               LSRS     R1,R1,#+8
   \   000000A0   4171               STRB     R1,[R0, #+5]
   1372                  ZD_MODBUS[FreePlace].Coil=16;
   \   000000A2   1021               MOVS     R1,#+16
   \   000000A4   8171               STRB     R1,[R0, #+6]
   \   000000A6   090A               LSRS     R1,R1,#+8
   \   000000A8   C171               STRB     R1,[R0, #+7]
   1373                  ZD_MODBUS[FreePlace].Error=0x0; 
   \   000000AA   C172               STRB     R1,[R0, #+11]
   \   000000AC   0173               STRB     R1,[R0, #+12]
   1374                }
   1375                
   1376                
   1377              }
   1378              
   1379                
   1380          
   1381                
   1382                          
   1383          }//_______________________ Koniec funkcji  AddRsTask _________________
   \                     ??AddRsTask_7:
   \   000000AE   F8BC               POP      {R3-R7}
   \   000000B0   01BC               POP      {R0}
   \   000000B2   0047               BX       R0               ;; return
   \                     ??AddRsTask_4:
   \   000000B4   ........           DC32     ZD_MODBUS_0
   1384          
   1385          
   1386          
   1387          
   1388          //-----------------------------------------------------------------------------
   1389          // Nazwa funkcji :    AddRfTask
   1390          // Funkcja ustawia dodanie zadania dla transmisji Rs
   1391          // Ord - typ rozkazu : odczyt wejœæ, zapis
   1392          // Node - nr wêz³a/urz¹dzeia
   1393          // Reg  - nr rejestru w wêŸle 
   1394          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1395          void AddRfTask(_OrderType Ord, char Node, char Reg)
   1396          { 
   \                     AddRfTask:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0020               MOVS     R0,#+0
   1397              char OrdExist=0;
   1398              char RfOrd;
   1399              char FreePlace=0;
   1400              
   1401             
   1402              //przepisanie rozkazu na zrozumia³y dla tablicy zadañ RF
   1403              switch (Ord)
   \   00000006   012C               CMP      R4,#+1
   \   00000008   02D0               BEQ      ??AddRfTask_0
   \   0000000A   022C               CMP      R4,#+2
   \   0000000C   02D0               BEQ      ??AddRfTask_1
   \   0000000E   02E0               B        ??AddRfTask_2
   1404              {
   1405                  case SI:  RfOrd=R_RegOrd; break; 
   \                     ??AddRfTask_0:
   \   00000010   0123               MOVS     R3,#+1
   \   00000012   00E0               B        ??AddRfTask_2
   1406                  case SQ:  RfOrd=W_RegOrd; break; 
   \                     ??AddRfTask_1:
   \   00000014   0223               MOVS     R3,#+2
   1407              }  
   1408           
   1409                
   1410              //Sprawdzenie czy taki rozkaz nie istnieje w tablicy
   1411              char i=0;
   \                     ??AddRfTask_2:
   \   00000016   0400               MOVS     R4,R0
   \   00000018   20E0               B        ??AddRfTask_3
   1412              while ((i<RF_Tasks) && (OrdExist==0))
   1413              {
   1414                 if ((RF_TaskTab[i].Node==Node) && 
   1415                     (RF_TaskTab[i].Command.ID==NeuronsList[Node-1].NeuronID) &&
   1416                     (RF_TaskTab[i].Command.Order==RfOrd) &&
   1417                     (RF_TaskTab[i].Command.Auxi==Reg))
   \                     ??AddRfTask_4:
   \   0000001A   264D               LDR      R5,??AddRfTask_5  ;; RF_TaskTab
   \   0000001C   2600               MOVS     R6,R4
   \   0000001E   F600               LSLS     R6,R6,#+3
   \   00000020   AD19               ADDS     R5,R5,R6
   \   00000022   2E78               LDRB     R6,[R5, #+0]
   \   00000024   8E42               CMP      R6,R1
   \   00000026   16D1               BNE      ??AddRfTask_6
   \   00000028   6D68               LDR      R5,[R5, #+4]
   \   0000002A   2F03               LSLS     R7,R5,#+12
   \   0000002C   3F0B               LSRS     R7,R7,#+12
   \   0000002E   BC46               MOV      R12,R7
   \   00000030   0C27               MOVS     R7,#+12
   \   00000032   4F43               MULS     R7,R1,R7
   \   00000034   204E               LDR      R6,??AddRfTask_5+0x4  ;; NeuronsList
   \   00000036   F619               ADDS     R6,R6,R7
   \   00000038   083E               SUBS     R6,R6,#+8
   \   0000003A   3668               LDR      R6,[R6, #+0]
   \   0000003C   6746               MOV      R7,R12
   \   0000003E   B742               CMP      R7,R6
   \   00000040   09D1               BNE      ??AddRfTask_6
   \   00000042   F026               MOVS     R6,#+240
   \   00000044   3604               LSLS     R6,R6,#+16       ;; #+15728640
   \   00000046   2E40               ANDS     R6,R6,R5
   \   00000048   360D               LSRS     R6,R6,#+20
   \   0000004A   9E42               CMP      R6,R3
   \   0000004C   03D1               BNE      ??AddRfTask_6
   \   0000004E   2D0E               LSRS     R5,R5,#+24
   \   00000050   9542               CMP      R5,R2
   \   00000052   00D1               BNE      ??AddRfTask_6
   1418                    {
   1419                      OrdExist=1;
   \   00000054   0120               MOVS     R0,#+1
   1420                    }
   1421                 i++;
   \                     ??AddRfTask_6:
   \   00000056   641C               ADDS     R4,R4,#+1
   \   00000058   2406               LSLS     R4,R4,#+24
   \   0000005A   240E               LSRS     R4,R4,#+24
   1422              }
   \                     ??AddRfTask_3:
   \   0000005C   2500               MOVS     R5,R4
   \   0000005E   322D               CMP      R5,#+50
   \   00000060   01D2               BCS      ??AddRfTask_7
   \   00000062   0500               MOVS     R5,R0
   \   00000064   D9D0               BEQ      ??AddRfTask_4
   1423              
   1424              //je¿eli rozkaz nie istnieje to dodaj
   1425              if (OrdExist==0)
   \                     ??AddRfTask_7:
   \   00000066   0028               CMP      R0,#+0
   \   00000068   21D1               BNE      ??AddRfTask_8
   1426              {
   1427                //znajdŸ wolne miejsce w tablicy zadañ 
   1428                FreePlace=0;
   \   0000006A   02E0               B        ??AddRfTask_9
   1429                while ((FreePlace<RF_Tasks) && (RF_TaskTab[FreePlace].Node!=0)) FreePlace++;
   \                     ??AddRfTask_10:
   \   0000006C   401C               ADDS     R0,R0,#+1
   \   0000006E   0006               LSLS     R0,R0,#+24
   \   00000070   000E               LSRS     R0,R0,#+24
   \                     ??AddRfTask_9:
   \   00000072   0400               MOVS     R4,R0
   \   00000074   322C               CMP      R4,#+50
   \   00000076   04D2               BCS      ??AddRfTask_11
   \   00000078   E400               LSLS     R4,R4,#+3
   \   0000007A   0E4D               LDR      R5,??AddRfTask_5  ;; RF_TaskTab
   \   0000007C   2C5D               LDRB     R4,[R5, R4]
   \   0000007E   002C               CMP      R4,#+0
   \   00000080   F4D1               BNE      ??AddRfTask_10
   1430                
   1431                
   1432                if (FreePlace<RF_Tasks)     //jezeli jest miejsce w tablicy to dodaj
   \                     ??AddRfTask_11:
   \   00000082   0400               MOVS     R4,R0
   \   00000084   322C               CMP      R4,#+50
   \   00000086   12D2               BCS      ??AddRfTask_8
   1433                {
   1434                  RF_TaskTab[FreePlace].Node=Node;
   \   00000088   0A4D               LDR      R5,??AddRfTask_5  ;; RF_TaskTab
   \   0000008A   C000               LSLS     R0,R0,#+3
   \   0000008C   2818               ADDS     R0,R5,R0
   \   0000008E   0170               STRB     R1,[R0, #+0]
   1435                  RF_TaskTab[FreePlace].Command.ID=NeuronsList[Node-1].NeuronID;
   1436                  RF_TaskTab[FreePlace].Command.Order=RfOrd;
   1437                  RF_TaskTab[FreePlace].Command.Auxi=Reg;
   \   00000090   0C24               MOVS     R4,#+12
   \   00000092   6143               MULS     R1,R4,R1
   \   00000094   084C               LDR      R4,??AddRfTask_5+0x4  ;; NeuronsList
   \   00000096   6118               ADDS     R1,R4,R1
   \   00000098   0839               SUBS     R1,R1,#+8
   \   0000009A   0968               LDR      R1,[R1, #+0]
   \   0000009C   074C               LDR      R4,??AddRfTask_5+0x8  ;; 0xff0fffff
   \   0000009E   0C40               ANDS     R4,R4,R1
   \   000000A0   1905               LSLS     R1,R3,#+20
   \   000000A2   2143               ORRS     R1,R1,R4
   \   000000A4   0902               LSLS     R1,R1,#+8
   \   000000A6   090A               LSRS     R1,R1,#+8
   \   000000A8   1206               LSLS     R2,R2,#+24
   \   000000AA   0A43               ORRS     R2,R2,R1
   \   000000AC   4260               STR      R2,[R0, #+4]
   1438                  
   1439                }
   1440                
   1441                
   1442              }
   1443              
   1444              
   1445          
   1446          }//_______________________ Koniec funkcji  AddRfTask _________________
   \                     ??AddRfTask_8:
   \   000000AE   F8BC               POP      {R3-R7}
   \   000000B0   01BC               POP      {R0}
   \   000000B2   0047               BX       R0               ;; return
   \                     ??AddRfTask_5:
   \   000000B4   ........           DC32     RF_TaskTab
   \   000000B8   ........           DC32     NeuronsList
   \   000000BC   FFFF0FFF           DC32     0xff0fffff
   1447          
   1448          
   1449          
   1450          
   1451          
   1452          
   1453          //-----------------------------------------------------------------------------
   1454          // Nazwa funkcji :    SetTask
   1455          // Funkcja ustawia zadania transmisji RS oraz RF
   1456          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1457          void SetTask(_ProgramTab *ProgTab)
   1458          { 
   \                     SetTask:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   8AB0               SUB      SP,SP,#+40
   1459                _Procedure Proc; 
   1460                _OrderType SetOrd=NonOrd;
   1461                char       RegOrd=0;
   1462            
   1463                
   1464                //wyczyszczenie tablicy zadañ
   1465                for (char i=0; i<RF_Tasks; i++) 
   \   00000004   0025               MOVS     R5,#+0
   \   00000006   2800               MOVS     R0,R5
   \   00000008   08E0               B        ??SetTask_0
   1466                {
   1467                  RF_TaskTab[i].Node=0;
   \                     ??SetTask_1:
   \   0000000A   C900               LSLS     R1,R1,#+3
   \   0000000C   8D4A               LDR      R2,??SetTask_2   ;; RF_TaskTab
   \   0000000E   5118               ADDS     R1,R2,R1
   \   00000010   2A00               MOVS     R2,R5
   \   00000012   0A70               STRB     R2,[R1, #+0]
   1468                  RF_TaskTab[i].Command.ID=0;
   1469                  RF_TaskTab[i].Command.Order=0;
   1470                  RF_TaskTab[i].Command.Auxi=0;
   \   00000014   4D60               STR      R5,[R1, #+4]
   1471                }
   \   00000016   401C               ADDS     R0,R0,#+1
   \   00000018   0006               LSLS     R0,R0,#+24
   \   0000001A   000E               LSRS     R0,R0,#+24
   \                     ??SetTask_0:
   \   0000001C   0100               MOVS     R1,R0
   \   0000001E   3229               CMP      R1,#+50
   \   00000020   F3D3               BCC      ??SetTask_1
   1472                
   1473                for (char node=0; node<NumberNeurons; node++)
   \   00000022   2C00               MOVS     R4,R5
   \   00000024   15E0               B        ??SetTask_3
   1474                {
   1475                   if((NeuronsList[node].NeuronType!=NoneNodeType) && (NeuronsList[node].NeuronType>=BeginRF) && (NeuronsList[node].NeuronType<=EndRF))  AddRfTask(SI, node+1, 0);
   \                     ??SetTask_4:
   \   00000026   8848               LDR      R0,??SetTask_2+0x4  ;; NeuronsList
   \   00000028   2100               MOVS     R1,R4
   \   0000002A   0C22               MOVS     R2,#+12
   \   0000002C   5143               MULS     R1,R2,R1
   \   0000002E   405C               LDRB     R0,[R0, R1]
   \   00000030   0028               CMP      R0,#+0
   \   00000032   0BD0               BEQ      ??SetTask_5
   \   00000034   0228               CMP      R0,#+2
   \   00000036   09D3               BCC      ??SetTask_5
   \   00000038   0628               CMP      R0,#+6
   \   0000003A   07D2               BCS      ??SetTask_5
   \   0000003C   2A00               MOVS     R2,R5
   \   0000003E   2100               MOVS     R1,R4
   \   00000040   491C               ADDS     R1,R1,#+1
   \   00000042   0906               LSLS     R1,R1,#+24
   \   00000044   090E               LSRS     R1,R1,#+24
   \   00000046   0120               MOVS     R0,#+1
   \   00000048   ........           BL       AddRfTask
   1476                }
   \                     ??SetTask_5:
   \   0000004C   641C               ADDS     R4,R4,#+1
   \   0000004E   2406               LSLS     R4,R4,#+24
   \   00000050   240E               LSRS     R4,R4,#+24
   \                     ??SetTask_3:
   \   00000052   2000               MOVS     R0,R4
   \   00000054   2328               CMP      R0,#+35
   \   00000056   E6D3               BCC      ??SetTask_4
   1477                
   1478                
   1479                for (int LineNr=0; LineNr<RealPrcLines; LineNr++)
   \   00000058   0095               STR      R5,[SP, #+0]
   \   0000005A   02E0               B        ??SetTask_6
   \                     ??SetTask_7:
   \   0000005C   0098               LDR      R0,[SP, #+0]
   \   0000005E   401C               ADDS     R0,R0,#+1
   \   00000060   0090               STR      R0,[SP, #+0]
   \                     ??SetTask_6:
   \   00000062   0098               LDR      R0,[SP, #+0]
   \   00000064   7949               LDR      R1,??SetTask_2+0x8  ;; Trap + 12
   \   00000066   0978               LDRB     R1,[R1, #+0]
   \   00000068   8842               CMP      R0,R1
   \   0000006A   58DA               BGE      ??SetTask_8
   1480                {
   1481                  for (int PrcInLine=0; PrcInLine<MaxPrcInLine; PrcInLine++)
   \   0000006C   2C00               MOVS     R4,R5
   \   0000006E   2FE0               B        ??SetTask_9
   1482                  {
   1483          
   1484                        Proc=ProgTab->Line[LineNr].Proc[PrcInLine];
   1485                        
   1486                        RegOrd=Proc.Tag.RegNr;
   1487                        SetOrd=NonOrd;
   1488                        //wybór typu rozkazu
   1489                        switch (Proc.Type)
   1490                        {
   1491                           case ProcWOUT:       SetOrd=SQ;  RegOrd=0; break;
   1492                           case ProcWOUTS:      SetOrd=SQ;  RegOrd=0; break;
   1493                           case ProcWOUTR:      SetOrd=SQ;  RegOrd=0; break;
   1494                           case ProcWOUTC:      SetOrd=SQ;  RegOrd=0; break;
   1495                           case ProcStI:        SetOrd=SI;  RegOrd=0; break;
   1496                           case ProcStNI:       SetOrd=SI;  RegOrd=0; break;
   1497                           case ProcSetReg:     SetOrd=SQ;  RegOrd=Proc.Tag.RegNr; break;
   1498                           case ProcGetReg:     SetOrd=SI;  RegOrd=Proc.Tag.RegNr; break;
   \                     ??SetTask_10:
   \   00000070   0127               MOVS     R7,#+1
   1499                        }     
   1500                         
   1501                        
   1502                        //je¿eli rozkaz
   1503                        if (SetOrd!=NonOrd)
   \                     ??SetTask_11:
   \   00000072   002F               CMP      R7,#+0
   \   00000074   2BD0               BEQ      ??SetTask_12
   1504                        {
   1505                              
   1506                                //Je¿eli nody z transmisj¹ RS
   1507                                if (((NeuronsList[Proc.Nr-1].NeuronType>=BeginRS) && (NeuronsList[Proc.Nr-1].NeuronType<=EndRS)) || (NeuronsList[Proc.Nr-1].NeuronType==0))
   \   00000076   6846               MOV      R0,SP
   \   00000078   04A9               ADD      R1,SP,#+16
   \   0000007A   4978               LDRB     R1,[R1, #+1]
   \   0000007C   0172               STRB     R1,[R0, #+8]
   \   0000007E   7248               LDR      R0,??SetTask_2+0x4  ;; NeuronsList
   \   00000080   6A46               MOV      R2,SP
   \   00000082   0821               MOVS     R1,#+8
   \   00000084   5156               LDRSB    R1,[R2, R1]
   \   00000086   0C22               MOVS     R2,#+12
   \   00000088   5143               MULS     R1,R2,R1
   \   0000008A   4018               ADDS     R0,R0,R1
   \   0000008C   0C38               SUBS     R0,R0,#+12
   \   0000008E   0190               STR      R0,[SP, #+4]
   \   00000090   0078               LDRB     R0,[R0, #+0]
   \   00000092   0028               CMP      R0,#+0
   \   00000094   01D0               BEQ      ??SetTask_13
   \   00000096   0328               CMP      R0,#+3
   \   00000098   01D3               BCC      ??SetTask_14
   \                     ??SetTask_13:
   \   0000009A   0028               CMP      R0,#+0
   \   0000009C   08D1               BNE      ??SetTask_15
   1508                                {
   1509                                  AddRsTask(SetOrd, Proc.Nr, RegOrd);                //Dodaj rozkaz do tablicy zadañ Modbus
   \                     ??SetTask_14:
   \   0000009E   3200               MOVS     R2,R6
   \   000000A0   6946               MOV      R1,SP
   \   000000A2   0820               MOVS     R0,#+8
   \   000000A4   0956               LDRSB    R1,[R1, R0]
   \   000000A6   0906               LSLS     R1,R1,#+24
   \   000000A8   090E               LSRS     R1,R1,#+24
   \   000000AA   3800               MOVS     R0,R7
   \   000000AC   ........           BL       AddRsTask
   1510                                }
   1511                                //Je¿eli nody z transmisj¹ RF
   1512                                if ((NeuronsList[Proc.Nr-1].NeuronType>=BeginRF) && (NeuronsList[Proc.Nr-1].NeuronType<=EndRF))
   \                     ??SetTask_15:
   \   000000B0   0198               LDR      R0,[SP, #+4]
   \   000000B2   0078               LDRB     R0,[R0, #+0]
   \   000000B4   0228               CMP      R0,#+2
   \   000000B6   0AD3               BCC      ??SetTask_12
   \   000000B8   0628               CMP      R0,#+6
   \   000000BA   08D2               BCS      ??SetTask_12
   1513                                {
   1514                                   AddRfTask(SetOrd, Proc.Nr, RegOrd);                //Dodaj rozkaz do tablicy zadañ RF
   \   000000BC   3200               MOVS     R2,R6
   \   000000BE   6946               MOV      R1,SP
   \   000000C0   0820               MOVS     R0,#+8
   \   000000C2   0956               LDRSB    R1,[R1, R0]
   \   000000C4   0906               LSLS     R1,R1,#+24
   \   000000C6   090E               LSRS     R1,R1,#+24
   \   000000C8   3800               MOVS     R0,R7
   \   000000CA   ........           BL       AddRfTask
   1515                                }
   1516                        }  
   \                     ??SetTask_12:
   \   000000CE   641C               ADDS     R4,R4,#+1
   \                     ??SetTask_9:
   \   000000D0   0A2C               CMP      R4,#+10
   \   000000D2   C3DA               BGE      ??SetTask_7
   \   000000D4   04A8               ADD      R0,SP,#+16
   \   000000D6   1821               MOVS     R1,#+24
   \   000000D8   6143               MULS     R1,R4,R1
   \   000000DA   009A               LDR      R2,[SP, #+0]
   \   000000DC   F023               MOVS     R3,#+240
   \   000000DE   5A43               MULS     R2,R3,R2
   \   000000E0   0A9B               LDR      R3,[SP, #+40]
   \   000000E2   9A18               ADDS     R2,R3,R2
   \   000000E4   5118               ADDS     R1,R2,R1
   \   000000E6   1831               ADDS     R1,R1,#+24
   \   000000E8   1822               MOVS     R2,#+24
   \   000000EA   ........           BL       __aeabi_memcpy4
   \   000000EE   04A8               ADD      R0,SP,#+16
   \   000000F0   067A               LDRB     R6,[R0, #+8]
   \   000000F2   2F00               MOVS     R7,R5
   \   000000F4   6846               MOV      R0,SP
   \   000000F6   007C               LDRB     R0,[R0, #+16]
   \   000000F8   1438               SUBS     R0,R0,#+20
   \   000000FA   0128               CMP      R0,#+1
   \   000000FC   0AD9               BLS      ??SetTask_16
   \   000000FE   0C38               SUBS     R0,R0,#+12
   \   00000100   0328               CMP      R0,#+3
   \   00000102   04D9               BLS      ??SetTask_17
   \   00000104   1838               SUBS     R0,R0,#+24
   \   00000106   B3D0               BEQ      ??SetTask_10
   \   00000108   401E               SUBS     R0,R0,#+1
   \   0000010A   06D0               BEQ      ??SetTask_18
   \   0000010C   B1E7               B        ??SetTask_11
   \                     ??SetTask_17:
   \   0000010E   0227               MOVS     R7,#+2
   \   00000110   2E00               MOVS     R6,R5
   \   00000112   AEE7               B        ??SetTask_11
   \                     ??SetTask_16:
   \   00000114   0127               MOVS     R7,#+1
   \   00000116   2E00               MOVS     R6,R5
   \   00000118   ABE7               B        ??SetTask_11
   \                     ??SetTask_18:
   \   0000011A   0227               MOVS     R7,#+2
   \   0000011C   A9E7               B        ??SetTask_11
   1517                        
   1518                  }
   1519                  
   1520                }
   1521                
   1522                
   1523                
   1524                
   1525                
   1526                //Bezpoœrednie zmienne ekranowe
   1527                volatile _Screen* ScreenLokal;
   1528                 _ScreenPaternDesign *ScreenPaternDesign;
   1529          
   1530                
   1531                 for (char Sheet=0; Sheet<ScreenNr; Sheet++)
   \                     ??SetTask_8:
   \   0000011E   2E00               MOVS     R6,R5
   \   00000120   4AE0               B        ??SetTask_19
   1532                 {
   1533                     if (ScreenUse&1<<Sheet)
   1534                     {
   1535                        if (Sheet==0) 
   1536                        {
   1537                          ScreenPaternDesign=ScreenSetTab_0;
   1538                        }else{
   1539                          ScreenPaternDesign=ScreenSetTab_1; 
   1540                        } 
   1541                       
   1542                       ScreenLokal=&gProg.Screen[Sheet];
   1543                       for (char i=0; i<ScrenAnalogNr; i++)
   1544                          {
   1545          
   1546                                if ( (ScreenPaternDesign[ScreenLokal->PaternDesign].Value[i].Width>0) && ((ScreenLokal->Analog[i].Nr>0) || ((ScreenLokal->Analog[i].Nr==0)&&(ScreenLokal->Analog[i].Reg>0))))
   1547                                 {
   1548                                    AddRfTask(SI, ScreenLokal->Analog[i].Nr, ScreenLokal->Analog[i].Reg);
   1549                                 }
   1550                          }
   1551                       for (char i=0; i<ScrenGraphNr; i++)
   1552                          {
   1553                                if ((ScreenPaternDesign[ScreenLokal->PaternDesign].Graph[i].Width>0) && ((ScreenLokal->Graph[i].Type==GraphOnOff) || (ScreenLokal->Graph[i].PlusOnOff==1) || (ScreenLokal->Graph[i].Type==GraphWartosc)))
   \                     ??SetTask_20:
   \   00000122   8100               LSLS     R1,R0,#+2
   \   00000124   2278               LDRB     R2,[R4, #+0]
   \   00000126   5823               MOVS     R3,#+88
   \   00000128   5A43               MULS     R2,R3,R2
   \   0000012A   009B               LDR      R3,[SP, #+0]
   \   0000012C   9A18               ADDS     R2,R3,R2
   \   0000012E   5118               ADDS     R1,R2,R1
   \   00000130   2631               ADDS     R1,R1,#+38
   \   00000132   0978               LDRB     R1,[R1, #+0]
   \   00000134   0029               CMP      R1,#+0
   \   00000136   11D0               BEQ      ??SetTask_21
   \   00000138   0721               MOVS     R1,#+7
   \   0000013A   4843               MULS     R0,R1,R0
   \   0000013C   2018               ADDS     R0,R4,R0
   \   0000013E   5330               ADDS     R0,R0,#+83
   \   00000140   0178               LDRB     R1,[R0, #+0]
   \   00000142   0B29               CMP      R1,#+11
   \   00000144   05D0               BEQ      ??SetTask_22
   \   00000146   8179               LDRB     R1,[R0, #+6]
   \   00000148   C907               LSLS     R1,R1,#+31
   \   0000014A   02D4               BMI      ??SetTask_22
   \   0000014C   0178               LDRB     R1,[R0, #+0]
   \   0000014E   0A29               CMP      R1,#+10
   \   00000150   04D1               BNE      ??SetTask_21
   1554                                 {
   1555                                    AddRfTask(SI, ScreenLokal->Graph[i].Nr, ScreenLokal->Graph[i].Reg);
   \                     ??SetTask_22:
   \   00000152   4279               LDRB     R2,[R0, #+5]
   \   00000154   0179               LDRB     R1,[R0, #+4]
   \   00000156   0120               MOVS     R0,#+1
   \   00000158   ........           BL       AddRfTask
   1556                                 }
   1557                          }
   \                     ??SetTask_21:
   \   0000015C   7F1C               ADDS     R7,R7,#+1
   \   0000015E   3F06               LSLS     R7,R7,#+24
   \   00000160   3F0E               LSRS     R7,R7,#+24
   \                     ??SetTask_23:
   \   00000162   3800               MOVS     R0,R7
   \   00000164   0428               CMP      R0,#+4
   \   00000166   DCD3               BCC      ??SetTask_20
   1558                       
   1559                       //je¿eli na stronie jest termostat
   1560                       if (((Sheet==0) && (gProg.Screen[Sheet].PaternDesign==MainScreenTermo)) || 
   1561                              ((Sheet) && (gProg.Screen[Sheet].PaternDesign==SubScreenTermo)))
   \   00000168   3000               MOVS     R0,R6
   \   0000016A   03D1               BNE      ??SetTask_24
   \   0000016C   0198               LDR      R0,[SP, #+4]
   \   0000016E   0078               LDRB     R0,[R0, #+0]
   \   00000170   0828               CMP      R0,#+8
   \   00000172   05D0               BEQ      ??SetTask_25
   \                     ??SetTask_24:
   \   00000174   3000               MOVS     R0,R6
   \   00000176   1CD0               BEQ      ??SetTask_26
   \   00000178   0198               LDR      R0,[SP, #+4]
   \   0000017A   0078               LDRB     R0,[R0, #+0]
   \   0000017C   0528               CMP      R0,#+5
   \   0000017E   18D1               BNE      ??SetTask_26
   1562                        {
   1563                        
   1564                       if (ScreenLokal->Thermo.ActorNode>0)
   \                     ??SetTask_25:
   \   00000180   8C34               ADDS     R4,R4,#+140
   \   00000182   0020               MOVS     R0,#+0
   \   00000184   2056               LDRSB    R0,[R4, R0]
   \   00000186   0128               CMP      R0,#+1
   \   00000188   07DB               BLT      ??SetTask_27
   1565                                 {
   1566                                    AddRfTask(SQ, ScreenLokal->Thermo.ActorNode, ScreenLokal->Thermo.ActorPort);
   \   0000018A   6278               LDRB     R2,[R4, #+1]
   \   0000018C   0020               MOVS     R0,#+0
   \   0000018E   2156               LDRSB    R1,[R4, R0]
   \   00000190   0906               LSLS     R1,R1,#+24
   \   00000192   090E               LSRS     R1,R1,#+24
   \   00000194   0220               MOVS     R0,#+2
   \   00000196   ........           BL       AddRfTask
   1567                                 }   
   1568                       if (ScreenLokal->Thermo.SensorNode>0)
   \                     ??SetTask_27:
   \   0000019A   0320               MOVS     R0,#+3
   \   0000019C   2056               LDRSB    R0,[R4, R0]
   \   0000019E   0128               CMP      R0,#+1
   \   000001A0   07DB               BLT      ??SetTask_26
   1569                                 {
   1570                                    AddRfTask(SI, ScreenLokal->Thermo.SensorNode, ScreenLokal->Thermo.SensorReg);
   \   000001A2   2279               LDRB     R2,[R4, #+4]
   \   000001A4   0320               MOVS     R0,#+3
   \   000001A6   2156               LDRSB    R1,[R4, R0]
   \   000001A8   0906               LSLS     R1,R1,#+24
   \   000001AA   090E               LSRS     R1,R1,#+24
   \   000001AC   0120               MOVS     R0,#+1
   \   000001AE   ........           BL       AddRfTask
   1571                                 }  
   1572                       
   1573                        }
   \                     ??SetTask_26:
   \   000001B2   761C               ADDS     R6,R6,#+1
   \   000001B4   3606               LSLS     R6,R6,#+24
   \   000001B6   360E               LSRS     R6,R6,#+24
   \                     ??SetTask_19:
   \   000001B8   3000               MOVS     R0,R6
   \   000001BA   0828               CMP      R0,#+8
   \   000001BC   3DD2               BCS      ??SetTask_28
   \   000001BE   0E20               MOVS     R0,#+14
   \   000001C0   2349               LDR      R1,??SetTask_2+0xC  ;; Trap
   \   000001C2   085E               LDRSH    R0,[R1, R0]
   \   000001C4   0121               MOVS     R1,#+1
   \   000001C6   B140               LSLS     R1,R1,R6
   \   000001C8   0140               ANDS     R1,R1,R0
   \   000001CA   F2D0               BEQ      ??SetTask_26
   \   000001CC   3000               MOVS     R0,R6
   \   000001CE   02D1               BNE      ??SetTask_29
   \   000001D0   2048               LDR      R0,??SetTask_2+0x10  ;; ScreenSetTab_0
   \   000001D2   0090               STR      R0,[SP, #+0]
   \   000001D4   01E0               B        ??SetTask_30
   \                     ??SetTask_29:
   \   000001D6   2048               LDR      R0,??SetTask_2+0x14  ;; ScreenSetTab_1
   \   000001D8   0090               STR      R0,[SP, #+0]
   \                     ??SetTask_30:
   \   000001DA   2048               LDR      R0,??SetTask_2+0x18  ;; 0xbb98
   \   000001DC   3100               MOVS     R1,R6
   \   000001DE   A022               MOVS     R2,#+160
   \   000001E0   5143               MULS     R1,R2,R1
   \   000001E2   1F4A               LDR      R2,??SetTask_2+0x1C  ;; gProg
   \   000001E4   5118               ADDS     R1,R2,R1
   \   000001E6   0818               ADDS     R0,R1,R0
   \   000001E8   0190               STR      R0,[SP, #+4]
   \   000001EA   0400               MOVS     R4,R0
   \   000001EC   2F00               MOVS     R7,R5
   \   000001EE   1FE0               B        ??SetTask_31
   \                     ??SetTask_32:
   \   000001F0   8100               LSLS     R1,R0,#+2
   \   000001F2   2278               LDRB     R2,[R4, #+0]
   \   000001F4   5823               MOVS     R3,#+88
   \   000001F6   5A43               MULS     R2,R3,R2
   \   000001F8   009B               LDR      R3,[SP, #+0]
   \   000001FA   9A18               ADDS     R2,R3,R2
   \   000001FC   5118               ADDS     R1,R2,R1
   \   000001FE   3631               ADDS     R1,R1,#+54
   \   00000200   0978               LDRB     R1,[R1, #+0]
   \   00000202   0029               CMP      R1,#+0
   \   00000204   11D0               BEQ      ??SetTask_33
   \   00000206   0721               MOVS     R1,#+7
   \   00000208   4843               MULS     R0,R1,R0
   \   0000020A   2018               ADDS     R0,R4,R0
   \   0000020C   7330               ADDS     R0,R0,#+115
   \   0000020E   0178               LDRB     R1,[R0, #+0]
   \   00000210   0029               CMP      R1,#+0
   \   00000212   05D1               BNE      ??SetTask_34
   \   00000214   0178               LDRB     R1,[R0, #+0]
   \   00000216   0029               CMP      R1,#+0
   \   00000218   07D1               BNE      ??SetTask_33
   \   0000021A   4178               LDRB     R1,[R0, #+1]
   \   0000021C   0029               CMP      R1,#+0
   \   0000021E   04D0               BEQ      ??SetTask_33
   \                     ??SetTask_34:
   \   00000220   4278               LDRB     R2,[R0, #+1]
   \   00000222   0178               LDRB     R1,[R0, #+0]
   \   00000224   0120               MOVS     R0,#+1
   \   00000226   ........           BL       AddRfTask
   \                     ??SetTask_33:
   \   0000022A   7F1C               ADDS     R7,R7,#+1
   \   0000022C   3F06               LSLS     R7,R7,#+24
   \   0000022E   3F0E               LSRS     R7,R7,#+24
   \                     ??SetTask_31:
   \   00000230   3800               MOVS     R0,R7
   \   00000232   0428               CMP      R0,#+4
   \   00000234   DCD3               BCC      ??SetTask_32
   \   00000236   2F00               MOVS     R7,R5
   \   00000238   93E7               B        ??SetTask_23
   1574                     
   1575                     }
   1576          
   1577                 }
   1578                //-------------------------------
   1579                
   1580                
   1581                //Dodanie standardowego odpytywania wez³ów nie u¿ywanych w programie
   1582                 /*
   1583                 char ExstF=0;
   1584                
   1585                for (char i=0; i<NumberNeurons; i++)
   1586                {
   1587                  ExstF=0;
   1588                  if (NeuronsList[i].NeuronID!=0)
   1589                  {
   1590                     for (char j=0; j<RF_Tasks; j++)
   1591                     {
   1592                       if (RF_TaskTab[j].Command.ID==0)  //je¿eli brak zadañ to wyjdŸ
   1593                       { 
   1594                         j=RF_Tasks;
   1595                       }else if (RF_TaskTab[j].Command.ID==NeuronsList[i].NeuronID)    //je¿eli zadanie dla tego noda istnieje
   1596                       {
   1597                         ExstF=1;   //ustaw flagê
   1598                       }
   1599                     }
   1600                     
   1601                     //je¿eli nie znaleziono zadania dla wez³a przypisz pytanie standardowe
   1602                     if (ExstF==0)
   1603                     {
   1604                         AddRfTask(SI, i+1, 0);                //Dodaj pytanie standardowe do tablicy zadañ RF
   1605                     }
   1606                  }
   1607                  
   1608                }
   1609                 */
   1610               
   1611                
   1612                
   1613                          
   1614          }//_______________________ Koniec funkcji  SetTask_________________
   \                     ??SetTask_28:
   \   0000023A   0BB0               ADD      SP,SP,#+44
   \   0000023C   F0BC               POP      {R4-R7}
   \   0000023E   01BC               POP      {R0}
   \   00000240   0047               BX       R0               ;; return
   \   00000242   C046               Nop      
   \                     ??SetTask_2:
   \   00000244   ........           DC32     RF_TaskTab
   \   00000248   ........           DC32     NeuronsList
   \   0000024C   ........           DC32     Trap + 12
   \   00000250   ........           DC32     Trap
   \   00000254   ........           DC32     ScreenSetTab_0
   \   00000258   ........           DC32     ScreenSetTab_1
   \   0000025C   98BB0000           DC32     0xbb98
   \   00000260   ........           DC32     gProg
   1615          
   1616          
   1617          
   1618          
   1619          
   1620          
   1621          
   1622          
   1623          //-----------------------------------------------------------------------------
   1624          // Nazwa funkcji :    ProgramChangeSave
   1625          // Funkcja zapisu zmian w programie u¿ytkowym
   1626          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1627          void ProgramChangeExecute(_ProgramTab *ProgTab)
   1628          {
   \                     ProgramChangeExecute:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1629             //obliczenie iloœci u¿ywanych scen
   1630             NumberScene=SceneNrCount(ProgTab);
   \   00000004   094D               LDR      R5,??ProgramChangeExecute_0  ;; Trap
   \   00000006   ........           BL       SceneNrCount
   \   0000000A   2872               STRB     R0,[R5, #+8]
   1631             
   1632             //obliczenie iloœci u¿ywanych linii
   1633             CountLines(ProgTab);
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       CountLines
   1634             
   1635             //obliczenie iloœci u¿ywanych stron ekranowych
   1636             ScreenUse=CheckScreenUse(ProgTab);
   \   00000012   2000               MOVS     R0,R4
   \   00000014   ........           BL       CheckScreenUse
   \   00000018   E881               STRH     R0,[R5, #+14]
   1637             
   1638          
   1639             
   1640             //odœwierzenie/przepisanie listy neuronów
   1641             RefreshNeuronsList(ProgTab);
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       RefreshNeuronsList
   1642             
   1643             
   1644             //ustawienie zadañ Rs i RF
   1645             SetTask(ProgTab);
   \   00000020   2000               MOVS     R0,R4
   \   00000022   ........           BL       SetTask
   1646            
   1647          }//_______________________ Koniec funkcji zapisu zmian programu_________________
   \   00000026   38BC               POP      {R3-R5}
   \   00000028   01BC               POP      {R0}
   \   0000002A   0047               BX       R0               ;; return
   \                     ??ProgramChangeExecute_0:
   \   0000002C   ........           DC32     Trap
   1648          
   1649          
   1650          
   1651          
   1652          
   1653          
   1654          //*-----------------------------------------------------------------------------
   1655          //* Nazwa funkcji :    GetBinVarPack
   1656          //* Funkcja zwraca paczkê w tablicy wartoœci zmienncyh dwustanowych z zakresu B000 - B700
   1657          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1658          void GetBinVarPack(WORD adr, WORD Length,unsigned char *Tab )
   1659          {
   1660            /*
   1661                  WORD  RamByte=(adr/8);
   1662                  WORD  RamBit= (adr) % 8;
   1663                  char  CurentByte;
   1664                  char  CurentBit;  
   1665            
   1666              
   1667                for (WORD i=0; i<Length; i++)
   1668                      {
   1669                         Tab[CurentByte] &= ~(1<<CurentBit);
   1670                         Tab[CurentByte] |=  (((ram.BinVarRAM[RamByte]>>RamBit) & 0x1)<< CurentBit);
   1671                                   
   1672                         if (CurentBit<7) {CurentBit++;} else {CurentBit=0; CurentByte++;}
   1673                         if (RamBit<7) {RamBit++;} else {RamBit=0; RamByte++;}
   1674                      }  
   1675            
   1676           */
   1677          }//_______________________ Koniec funkcji GetBinVar ____________________________
   \                     GetBinVarPack:
   \   00000000   7047               BX       LR               ;; return
   1678          
   1679          
   1680          
   1681          
   1682          
   1683          
   1684          
   1685          
   1686          
   1687          //*-----------------------------------------------------------------------------
   1688          //* Nazwa funkcji :    GetBinVar
   1689          //* Funkcja przepisuje paczkê wartoœci zmiennych dwustanowej komunikacyjnej DA00 - DDFF do Tab
   1690          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1691          void GetBinVarPackComm(WORD adr, WORD Length, unsigned char* Tab )
   1692          {
   \                     GetBinVarPackComm:
   \   00000000   F7B5               PUSH     {R0-R2,R4-R7,LR}
   1693                  WORD  RamByte=adr;
   \   00000002   0021               MOVS     R1,#+0
   1694                  WORD  RamBit= 0;
   1695                  char  CurentByte = 0;
   \   00000004   0A00               MOVS     R2,R1
   1696                  char  CurentBit = 0;  
   \   00000006   0B00               MOVS     R3,R1
   1697          
   1698                  for (char i=0; i<16; i++)  {Tab[i]=0;}
   \   00000008   0C00               MOVS     R4,R1
   \   0000000A   0E00               MOVS     R6,R1
   \   0000000C   05E0               B        ??GetBinVarPackComm_0
   \                     ??GetBinVarPackComm_1:
   \   0000000E   2700               MOVS     R7,R4
   \   00000010   029D               LDR      R5,[SP, #+8]
   \   00000012   EE55               STRB     R6,[R5, R7]
   \   00000014   641C               ADDS     R4,R4,#+1
   \   00000016   2406               LSLS     R4,R4,#+24
   \   00000018   240E               LSRS     R4,R4,#+24
   \                     ??GetBinVarPackComm_0:
   \   0000001A   2500               MOVS     R5,R4
   \   0000001C   102D               CMP      R5,#+16
   \   0000001E   F6D3               BCC      ??GetBinVarPackComm_1
   1699               
   1700              
   1701                for (WORD i=0; i<Length; i++)
   \   00000020   0C00               MOVS     R4,R1
   \   00000022   06E0               B        ??GetBinVarPackComm_2
   1702                      {
   1703                         if ((ram.VarCom_Word[RamByte]>>RamBit) & 0x1) { Tab[CurentByte] |= 0x1<<CurentBit;} else {Tab[CurentByte] &= ~(0x1<<CurentBit);}
   1704                        
   1705                         
   1706                         if (CurentBit<7) {CurentBit++;} else {CurentBit=0; CurentByte++; Tab[CurentByte]=0;}
   1707                         if (RamBit<7) {RamBit++;} else {RamBit=0; RamByte++;}
   \                     ??GetBinVarPackComm_3:
   \   00000024   0021               MOVS     R1,#+0
   \   00000026   401C               ADDS     R0,R0,#+1
   \   00000028   0004               LSLS     R0,R0,#+16
   \   0000002A   000C               LSRS     R0,R0,#+16
   \                     ??GetBinVarPackComm_4:
   \   0000002C   641C               ADDS     R4,R4,#+1
   \   0000002E   2404               LSLS     R4,R4,#+16
   \   00000030   240C               LSRS     R4,R4,#+16
   \                     ??GetBinVarPackComm_2:
   \   00000032   2500               MOVS     R5,R4
   \   00000034   6E46               MOV      R6,SP
   \   00000036   B688               LDRH     R6,[R6, #+4]
   \   00000038   B542               CMP      R5,R6
   \   0000003A   2DD2               BCS      ??GetBinVarPackComm_5
   \   0000003C   0500               MOVS     R5,R0
   \   0000003E   6D00               LSLS     R5,R5,#+1
   \   00000040   174E               LDR      R6,??GetBinVarPackComm_6  ;; ram
   \   00000042   755B               LDRH     R5,[R6, R5]
   \   00000044   0D41               ASRS     R5,R5,R1
   \   00000046   ED07               LSLS     R5,R5,#+31
   \   00000048   08D5               BPL      ??GetBinVarPackComm_7
   \   0000004A   1500               MOVS     R5,R2
   \   0000004C   029E               LDR      R6,[SP, #+8]
   \   0000004E   7519               ADDS     R5,R6,R5
   \   00000050   2E78               LDRB     R6,[R5, #+0]
   \   00000052   0127               MOVS     R7,#+1
   \   00000054   9F40               LSLS     R7,R7,R3
   \   00000056   3743               ORRS     R7,R7,R6
   \   00000058   2F70               STRB     R7,[R5, #+0]
   \   0000005A   07E0               B        ??GetBinVarPackComm_8
   \                     ??GetBinVarPackComm_7:
   \   0000005C   1500               MOVS     R5,R2
   \   0000005E   029E               LDR      R6,[SP, #+8]
   \   00000060   7519               ADDS     R5,R6,R5
   \   00000062   2E78               LDRB     R6,[R5, #+0]
   \   00000064   0127               MOVS     R7,#+1
   \   00000066   9F40               LSLS     R7,R7,R3
   \   00000068   BE43               BICS     R6,R6,R7
   \   0000006A   2E70               STRB     R6,[R5, #+0]
   \                     ??GetBinVarPackComm_8:
   \   0000006C   1D00               MOVS     R5,R3
   \   0000006E   072D               CMP      R5,#+7
   \   00000070   03D2               BCS      ??GetBinVarPackComm_9
   \   00000072   5B1C               ADDS     R3,R3,#+1
   \   00000074   1B06               LSLS     R3,R3,#+24
   \   00000076   1B0E               LSRS     R3,R3,#+24
   \   00000078   07E0               B        ??GetBinVarPackComm_10
   \                     ??GetBinVarPackComm_9:
   \   0000007A   0023               MOVS     R3,#+0
   \   0000007C   521C               ADDS     R2,R2,#+1
   \   0000007E   1206               LSLS     R2,R2,#+24
   \   00000080   120E               LSRS     R2,R2,#+24
   \   00000082   1700               MOVS     R7,R2
   \   00000084   029D               LDR      R5,[SP, #+8]
   \   00000086   1E00               MOVS     R6,R3
   \   00000088   EE55               STRB     R6,[R5, R7]
   \                     ??GetBinVarPackComm_10:
   \   0000008A   0D00               MOVS     R5,R1
   \   0000008C   072D               CMP      R5,#+7
   \   0000008E   C9D2               BCS      ??GetBinVarPackComm_3
   \   00000090   491C               ADDS     R1,R1,#+1
   \   00000092   0904               LSLS     R1,R1,#+16
   \   00000094   090C               LSRS     R1,R1,#+16
   \   00000096   C9E7               B        ??GetBinVarPackComm_4
   1708                      }  
   1709          }//_______________________ Koniec funkcji GetBinVarComm ________________________
   \                     ??GetBinVarPackComm_5:
   \   00000098   FEBC               POP      {R1-R7}
   \   0000009A   01BC               POP      {R0}
   \   0000009C   0047               BX       R0               ;; return
   \   0000009E   C046               Nop      
   \                     ??GetBinVarPackComm_6:
   \   000000A0   ........           DC32     ram
   1710          
   1711          
   1712          //*-----------------------------------------------------------------------------
   1713          //* Nazwa funkcji :    GetRegPackComm
   1714          //* Funkcja przepisuje StageQ
   1715          //*   Adr - nr StageQ
   1716          //*   Reg - nr rejestru
   1717          //*   LengthBit - ile bitów do kopiowania je¿eli wiêcej ni¿ 16 to kopiuje z nastêpnego rejestru
   1718          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1719          void GetRegPackComm(short int  Adr, char Reg, char LengthBit, unsigned char* Tab )
   1720          {
   \                     GetRegPackComm:
   \   00000000   FDB5               PUSH     {R0,R2-R7,LR}
   1721                  WORD  RamWord=Reg;
   \   00000002   0C00               MOVS     R4,R1
   \   00000004   0023               MOVS     R3,#+0
   1722                  WORD  RamBitInWord= 0;
   1723                  char  CurentByte = 0;
   \   00000006   1900               MOVS     R1,R3
   1724                  char  CurentBit = 0;  
   \   00000008   0A00               MOVS     R2,R1
   1725           
   1726                  Adr+=1;
   \   0000000A   6D46               MOV      R5,SP
   \   0000000C   401C               ADDS     R0,R0,#+1
   \   0000000E   2880               STRH     R0,[R5, #+0]
   1727                  
   1728                  for (char i=0; i<16; i++)  {Tab[i]=0;}
   \   00000010   0800               MOVS     R0,R1
   \   00000012   0600               MOVS     R6,R0
   \   00000014   05E0               B        ??GetRegPackComm_0
   \                     ??GetRegPackComm_1:
   \   00000016   0700               MOVS     R7,R0
   \   00000018   029D               LDR      R5,[SP, #+8]
   \   0000001A   EE55               STRB     R6,[R5, R7]
   \   0000001C   401C               ADDS     R0,R0,#+1
   \   0000001E   0006               LSLS     R0,R0,#+24
   \   00000020   000E               LSRS     R0,R0,#+24
   \                     ??GetRegPackComm_0:
   \   00000022   0500               MOVS     R5,R0
   \   00000024   102D               CMP      R5,#+16
   \   00000026   F6D3               BCC      ??GetRegPackComm_1
   1729               
   1730              
   1731                for (WORD i=0; i<LengthBit; i++)
   \   00000028   0D00               MOVS     R5,R1
   \   0000002A   06E0               B        ??GetRegPackComm_2
   1732                      {
   1733                         if ((MainStage.StageQ[Adr].Value[RamWord]>>RamBitInWord) & 0x1) { Tab[CurentByte] |= 0x1<<CurentBit;} else {Tab[CurentByte] &= ~(0x1<<CurentBit);}
   1734                        
   1735                         
   1736                         if (CurentBit<7) {CurentBit++;} else {CurentBit=0; CurentByte++; Tab[CurentByte]=0;}
   1737                         if (RamBitInWord<15) {RamBitInWord++;} else {RamBitInWord=0; RamWord++;}
   \                     ??GetRegPackComm_3:
   \   0000002C   0023               MOVS     R3,#+0
   \   0000002E   641C               ADDS     R4,R4,#+1
   \   00000030   2404               LSLS     R4,R4,#+16
   \   00000032   240C               LSRS     R4,R4,#+16
   \                     ??GetRegPackComm_4:
   \   00000034   6D1C               ADDS     R5,R5,#+1
   \   00000036   2D04               LSLS     R5,R5,#+16
   \   00000038   2D0C               LSRS     R5,R5,#+16
   \                     ??GetRegPackComm_2:
   \   0000003A   2800               MOVS     R0,R5
   \   0000003C   6E46               MOV      R6,SP
   \   0000003E   3679               LDRB     R6,[R6, #+4]
   \   00000040   B042               CMP      R0,R6
   \   00000042   38D2               BCS      ??GetRegPackComm_5
   \   00000044   D720               MOVS     R0,#+215
   \   00000046   8000               LSLS     R0,R0,#+2        ;; #+860
   \   00000048   8446               MOV      R12,R0
   \   0000004A   2000               MOVS     R0,R4
   \   0000004C   4600               LSLS     R6,R0,#+1
   \   0000004E   6F46               MOV      R7,SP
   \   00000050   0020               MOVS     R0,#+0
   \   00000052   385E               LDRSH    R0,[R7, R0]
   \   00000054   1427               MOVS     R7,#+20
   \   00000056   7843               MULS     R0,R7,R0
   \   00000058   184F               LDR      R7,??GetRegPackComm_6  ;; MainStage
   \   0000005A   3818               ADDS     R0,R7,R0
   \   0000005C   8619               ADDS     R6,R0,R6
   \   0000005E   6046               MOV      R0,R12
   \   00000060   305E               LDRSH    R0,[R6, R0]
   \   00000062   1841               ASRS     R0,R0,R3
   \   00000064   C007               LSLS     R0,R0,#+31
   \   00000066   08D5               BPL      ??GetRegPackComm_7
   \   00000068   0800               MOVS     R0,R1
   \   0000006A   029E               LDR      R6,[SP, #+8]
   \   0000006C   3018               ADDS     R0,R6,R0
   \   0000006E   0678               LDRB     R6,[R0, #+0]
   \   00000070   0127               MOVS     R7,#+1
   \   00000072   9740               LSLS     R7,R7,R2
   \   00000074   3743               ORRS     R7,R7,R6
   \   00000076   0770               STRB     R7,[R0, #+0]
   \   00000078   07E0               B        ??GetRegPackComm_8
   \                     ??GetRegPackComm_7:
   \   0000007A   0800               MOVS     R0,R1
   \   0000007C   029E               LDR      R6,[SP, #+8]
   \   0000007E   3018               ADDS     R0,R6,R0
   \   00000080   0678               LDRB     R6,[R0, #+0]
   \   00000082   0127               MOVS     R7,#+1
   \   00000084   9740               LSLS     R7,R7,R2
   \   00000086   BE43               BICS     R6,R6,R7
   \   00000088   0670               STRB     R6,[R0, #+0]
   \                     ??GetRegPackComm_8:
   \   0000008A   1000               MOVS     R0,R2
   \   0000008C   0728               CMP      R0,#+7
   \   0000008E   03D2               BCS      ??GetRegPackComm_9
   \   00000090   521C               ADDS     R2,R2,#+1
   \   00000092   1206               LSLS     R2,R2,#+24
   \   00000094   120E               LSRS     R2,R2,#+24
   \   00000096   07E0               B        ??GetRegPackComm_10
   \                     ??GetRegPackComm_9:
   \   00000098   0022               MOVS     R2,#+0
   \   0000009A   491C               ADDS     R1,R1,#+1
   \   0000009C   0906               LSLS     R1,R1,#+24
   \   0000009E   090E               LSRS     R1,R1,#+24
   \   000000A0   0F00               MOVS     R7,R1
   \   000000A2   0298               LDR      R0,[SP, #+8]
   \   000000A4   1600               MOVS     R6,R2
   \   000000A6   C655               STRB     R6,[R0, R7]
   \                     ??GetRegPackComm_10:
   \   000000A8   1800               MOVS     R0,R3
   \   000000AA   0F28               CMP      R0,#+15
   \   000000AC   BED2               BCS      ??GetRegPackComm_3
   \   000000AE   5B1C               ADDS     R3,R3,#+1
   \   000000B0   1B04               LSLS     R3,R3,#+16
   \   000000B2   1B0C               LSRS     R3,R3,#+16
   \   000000B4   BEE7               B        ??GetRegPackComm_4
   1738                      }  
   1739          }//_______________________ Koniec funkcji GetRegPackComm ________________________
   \                     ??GetRegPackComm_5:
   \   000000B6   FEBC               POP      {R1-R7}
   \   000000B8   01BC               POP      {R0}
   \   000000BA   0047               BX       R0               ;; return
   \                     ??GetRegPackComm_6:
   \   000000BC   ........           DC32     MainStage

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   ........           DC32     ZD_MODBUS_0

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   AA8A0000           DC32     0x8aaa

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   ........           DC32     VariablesAnal

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   ........           DC32     TransQuality

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   19060000           DC32     0x619

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable12:
   \   00000000   ........           DC32     Variables
   1740          
   1741          
   1742          
   1743          
   1744          
   1745          
   1746          //****************************************************************************//
   1747          //****************************************************************************//
   1748          //*************************** P R O C E D U R Y ******************************//
   1749          //****************************************************************************//
   1750          //****************************************************************************//
   1751          
   1752          
   1753          
   1754          
   1755          
   1756          
   1757          
   1758          
   1759          
   1760          
   1761          

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     AddRfTask                    24
     AddRsTask                    24
     CheckScreenUse               24
     CountLines                   24
     GetBinVarPack                 0
     GetBinVarPackComm            32
     GetRegPackComm               32
     PortStageRead                 0
     PortStageSet                  8
     ProcClock_Action              8
     ProcConect_Action             0
     ProcConstAnal_Action          0
     ProcDay_Action                8
     ProcDec_Action                8
     ProcDiv_Action               24
     ProcDownRight_Action          0
     ProcDown_Action               0
     ProcEven_Action               8
     ProcGetReg_Action            16
     ProcInc_Action               16
     ProcLim_Action                8
     ProcMinus_Action              0
     ProcMul_Action                8
     ProcNOT_Action                0
     ProcPlus_Action               0
     ProcSPK_Action               16
     ProcSetAnal_Action           16
     ProcSetScn_Action            16
     ProcStB_Action                8
     ProcStI_Action                8
     ProcStNI_Action               8
     ProcStQ_Action               16
     ProcStS_Action                8
     ProcSumL_Action               0
     ProcTLI1_Action               8
     ProcTimerSet_Action           8
     ProcToggleRS_Action           8
     ProcToggleT_Action            8
     ProcUpToRightDown_Action      0
     ProcUpToRight_Action          0
     ProcWOUTC_Action             24
     ProcWOUTR_Action             24
     ProcWOUTS_Action             24
     ProcWOUT_Action              24
     Program                      32
     ProgramChangeExecute         16
     RefreshNeuronsList           24
     SceneNrCount                 24
     SetModbusTask                 0
     SetTask                      64


   Section sizes:

     Function/Label           Bytes
     --------------           -----
     SceneBefOff                  1
     TransQuality               216
     ProgConvers_DW_F             4
     ButtonExe                  576
     gProg                    50800
     NeuronsList                420
     Variables                   16
     VariablesAnal               40
     MainStage                 1596
     SetModbusTask              110
     PortStageRead               10
     PortStageSet                24
     ProcStI_Action             104
     ProcStNI_Action            122
     ProcGetReg_Action           80
     ProcSetAnal_Action          52
     ProcConstAnal_Action         6
     ProcStB_Action              32
     ProcStQ_Action              50
     ProcStS_Action              36
     ProcWOUT_Action            236
     ProcWOUTS_Action           140
     ProcWOUTR_Action           140
     ProcWOUTC_Action           196
     ProcNOT_Action              14
     ProcToggleRS_Action         32
     ProcToggleT_Action          66
     ProcTLI1_Action             34
     ProcLim_Action              28
     ProcEven_Action             28
     ProcPlus_Action             12
     ProcMinus_Action            12
     ProcMul_Action              56
     ProcDiv_Action             124
     ProcConect_Action            6
     ProcDown_Action              6
     ProcDownRight_Action         6
     ProcUpToRight_Action         6
     ProcUpToRightDown_Action     6
     ProcSetScn_Action           84
     ProcInc_Action              60
     ProcDec_Action              56
     ProcSPK_Action             172
     ProcSumL_Action             10
     ProcTimerSet_Action         68
     ProcClock_Action           140
     ProcDay_Action              36
     Program                   1096
     Trap                        32
     pProg                        4
     SceneNrCount                68
     CheckScreenUse             140
     CountLines                  76
     RefreshNeuronsList         100
     AddRsTask                  184
     AddRfTask                  192
     SetTask                    612
     ProgramChangeExecute        48
     GetBinVarPack                2
     GetBinVarPackComm          164
     GetRegPackComm             192
     ??DataTable0                 4
     ??DataTable3                 4
     ??DataTable6                 4
     ??DataTable10                4
     ??DataTable11                4
     ??DataTable12                4

 
 53 669 bytes in section .bss
     36 bytes in section .data
  5 298 bytes in section Debug.txt
 
  5 298 bytes of CODE memory
 53 705 bytes of DATA memory

Errors: none
Warnings: 9
