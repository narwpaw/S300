###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           04/Jun/2013  20:16:41 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\Framework\Application_prog.c                  #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\Framework\Application_prog.c" -D              #
#                    AT91SAM7S256 -D AT91SAM7SEK -D iH -D __ALARM -D          #
#                    __WIFI_MODULE -D __MaxRf -D S300iMax -lC                 #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\S300iMax\List\" --diag_suppress Pa082 -o      #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\S300iMax\Obj\" --no_unroll --no_inline        #
#                    --no_tbaa --no_scheduling --debug --endian little --cpu  #
#                    ARM7TDMI -e --fpu None --dlib_config "C:\Program Files   #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    5.0\ARM\INC\DLib_Config_Normal.h" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v1.3 - 04.06.2013\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v1.3 - 04.06.2013\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v1.3 - 04.06.2013\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\Framework\Configuration\" -I "C:\Program      #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\INC\" --section .text=Debug.txt --interwork      #
#                    --cpu_mode thumb -Om                                     #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300iMax\List\Application_prog.lst            #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300iMax\Obj\Application_prog.o               #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\Application_prog.c
      1          //****************************************************************************//
      2          //*--------------------------------------------------------------------------*//
      3          //*                                 CEURON                                   *//                       
      4          //*--------------------------------------------------------------------------*//
      5          //*--------------------------------------------------------------------------*//
      6          //*  Nazwa pliku                  : Application_prog.c                       *//
      7          //*  Opis                         : Plik obs³ugi programu u¿ytkowego         *//
      8          //*  Autor                        : Pawe³ Narwojsz                           *//
      9          //*  Data utrzorzenia             : 10.09.2007                               *//
     10          //*  Data ostatniej modyfikacji   : --.--.----                               *//
     11          //*--------------------------------------------------------------------------*//
     12          //*                                                                          *//
     13          //*--------------------------------------------------------------------------*//
     14          //* Rejestr zmian  (data - opis):                                            *//
     15          //*                                                                          *//
     16          //*                               Brak zmian                                 *//
     17          //*                                                                          *//
     18          //*__________________________________________________________________________*// 
     19          //****************************************************************************//
     20          //****************************************************************************//
     21          
     22          
     23          
     24          
     25          #include "Application_prog.h" 
     26          
     27          #include "Framework.h"
     28          #include "core/device.h"                                                        //aduje bibliotreki dla odpowiedniego procesora
     29          #include "modbus.h"

                                          
                                          ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\Configuration\InterruptPriority.h",59  Warning[Pe001]: 
          last line of file ends without a newline
     30          #include "usart.h"
     31          #include "RF_Exe.h"
     32          #include "ScreenMENU2.h"
     33          
     34          
     35          //Zmienne globalne -------------------------------------------------------------
     36            char NumberScene=NumberSceneMax;  //iloœæ u¿ywanych scen. Wartoœæ pierwotnie NumberSceneMax nastêpnie wyliczana
     37            short ScreenUse;

   \                                 In section .bss, align 1
     38            char SceneBefOff=0; //Je¿eli >0 to oznacza ¿e sceny zosta³y wy³¹czone przyskiem/zdarzeniem off.  SceneBefOff= nr sceny przed wy³¹czeniem
   \                     SceneBefOff:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     39            _TransQuality TransQuality; //tablica informacyjna jakoœci po³¹czenia pola odpowiadaj¹ polom _ProgramTab.NeuronsIdTab
   \                     TransQuality:
   \   00000000                      DS8 216
     40          
     41            //___________________________Koniec zmiennych globalnych________________________
     42          
     43          
     44          
     45          
     46          #ifdef _LIVE_RJESTR   
     47            extern unsigned short LIVE_TAB[LIVE_TAB_SIZE];
     48            extern char LIVE_TAB_IDX;
     49          #endif
     50            
     51          
     52          extern RAM ram;
     53          extern int g_US0_BAUDRATE;
     54          //extern FlashPagesOffset;

   \                                 In section .bss, align 4
     55          Convers_DW_F ProgConvers_DW_F;
   \                     ProgConvers_DW_F:
   \   00000000                      DS8 4
     56          
     57          extern  _ScreenPaternDesign ScreenSetTab_0[];
     58          extern  _ScreenPaternDesign ScreenSetTab_1[];
     59          extern int int1;
     60          extern int FlashProgramOfset;
     61          extern int g_counter;
     62          extern char AdressModbus;
     63          extern char q_US0_Comm_Mode;
     64          extern char US0_MasterMODBUS_ENABLE;
     65          extern void Delay (unsigned long a);
     66          extern char g_Stop_Program;                                                     //1- zatrzymuje program
     67          extern char g_Restart_Program;                                                  //1- restartuje program
     68          extern unsigned int CyklPerSek;
     69          extern _DateTime DateTime;
     70          extern _RF_TaskTab  RF_TaskTab;

   \                                 In section .bss, align 4
     71          _ButtonGraph  ButtonExe[ScreenNr][ScrenButtonNr];                                         //do tej zmiennej przepisywane sa stany 1 z Button
   \                     ButtonExe:
   \   00000000                      DS8 576
     72          
     73          

   \                                 In section .bss, align 8
     74          volatile _ProgramTab gProg;
   \                     gProg:
   \   00000000                      DS8 50800
     75          char        *pProg=(char*)&gProg;

   \                                 In section .bss, align 4
     76          _NeuronsListUnit NeuronsList[NumberNeurons];
   \                     NeuronsList:
   \   00000000                      DS8 420
     77          
     78          
     79          
     80          
     81          char Variables[13];    //zmienne
     82          char VariablesImpulse[13];    //zmienne - flaga impulsu
     83          //char VariablesNetTmp[13];    //zmienne tyczmasowe dla komunikacji WiFi stosowana jako separacja  Variables[] ¿eby nie nadpisywaæ zmiennych

   \                                 In section .bss, align 4
     84          short int VariablesAnal[AnalogVarAmount];    //zmienne
   \                     VariablesAnal:
   \   00000000                      DS8 40
     85          
     86          extern unsigned char ChangeStageFlag;
     87          
     88          

   \                                 In section .bss, align 4
     89          _MainStage  MainStage; 
   \                     MainStage:
   \   00000000                      DS8 1808
     90          _Trap      Trap;
     91          
     92          extern _ZD_MODBUS ZD_MODBUS_0[ZD_MODBUS_Tab_Max];

   \                                 In section Debug.txt, align 4, keep-with-next
     93          void SetModbusTask(void)
     94          {
     95          
     96                ptr_ZD_MODBUS ZD_MODBUS;
     97          
     98          
     99                ZD_MODBUS         =   ZD_MODBUS_0;
    100            
    101          
    102             
    103                
    104                char i=0; 
    105            
    106           
    107                   
    108                ZD_MODBUS[i].Adress=1;
   \                     SetModbusTask:
   \   00000000   ....               LDR      R0,??DataTable0  ;; ZD_MODBUS_0
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0170               STRB     R1,[R0, #+0]
    109                ZD_MODBUS[i].Function=0xF;
   \   00000006   0F21               MOVS     R1,#+15
   \   00000008   0A00               MOVS     R2,R1
   \   0000000A   4270               STRB     R2,[R0, #+1]
    110                ZD_MODBUS[i].Target=0x0;
   \   0000000C   0022               MOVS     R2,#+0
   \   0000000E   8270               STRB     R2,[R0, #+2]
   \   00000010   C270               STRB     R2,[R0, #+3]
    111                ZD_MODBUS[i].StartAdr=0;
   \   00000012   0271               STRB     R2,[R0, #+4]
   \   00000014   4271               STRB     R2,[R0, #+5]
    112                ZD_MODBUS[i].Coil=8;
   \   00000016   0822               MOVS     R2,#+8
   \   00000018   8271               STRB     R2,[R0, #+6]
   \   0000001A   120A               LSRS     R2,R2,#+8
   \   0000001C   C271               STRB     R2,[R0, #+7]
    113                ZD_MODBUS[i].Error=0x0;
   \   0000001E   C272               STRB     R2,[R0, #+11]
   \   00000020   0273               STRB     R2,[R0, #+12]
    114                
    115                i=1; 
    116                ZD_MODBUS[i].Adress=2;
   \   00000022   0222               MOVS     R2,#+2
   \   00000024   4273               STRB     R2,[R0, #+13]
    117                ZD_MODBUS[i].Function=0xF;
   \   00000026   0A00               MOVS     R2,R1
   \   00000028   8273               STRB     R2,[R0, #+14]
    118                ZD_MODBUS[i].Target=0x0;
   \   0000002A   0022               MOVS     R2,#+0
   \   0000002C   C273               STRB     R2,[R0, #+15]
   \   0000002E   0274               STRB     R2,[R0, #+16]
    119                ZD_MODBUS[i].StartAdr=1;
   \   00000030   0122               MOVS     R2,#+1
   \   00000032   4274               STRB     R2,[R0, #+17]
   \   00000034   120A               LSRS     R2,R2,#+8
   \   00000036   8274               STRB     R2,[R0, #+18]
    120                ZD_MODBUS[i].Coil=8;
   \   00000038   0822               MOVS     R2,#+8
   \   0000003A   C274               STRB     R2,[R0, #+19]
   \   0000003C   120A               LSRS     R2,R2,#+8
   \   0000003E   0275               STRB     R2,[R0, #+20]
    121                ZD_MODBUS[i].Error=0x0;
   \   00000040   0276               STRB     R2,[R0, #+24]
   \   00000042   4276               STRB     R2,[R0, #+25]
    122           
    123                i=2; 
    124                ZD_MODBUS[i].Adress=3;
   \   00000044   0322               MOVS     R2,#+3
   \   00000046   8276               STRB     R2,[R0, #+26]
    125                ZD_MODBUS[i].Function=0xF;
   \   00000048   C176               STRB     R1,[R0, #+27]
    126                ZD_MODBUS[i].Target=0x0;
   \   0000004A   0021               MOVS     R1,#+0
   \   0000004C   0177               STRB     R1,[R0, #+28]
   \   0000004E   4177               STRB     R1,[R0, #+29]
    127                ZD_MODBUS[i].StartAdr=2;
   \   00000050   0221               MOVS     R1,#+2
   \   00000052   8177               STRB     R1,[R0, #+30]
   \   00000054   090A               LSRS     R1,R1,#+8
   \   00000056   C177               STRB     R1,[R0, #+31]
    128                ZD_MODBUS[i].Coil=8;
   \   00000058   0100               MOVS     R1,R0
   \   0000005A   2031               ADDS     R1,R1,#+32
   \   0000005C   0822               MOVS     R2,#+8
   \   0000005E   0A70               STRB     R2,[R1, #+0]
   \   00000060   120A               LSRS     R2,R2,#+8
   \   00000062   4A70               STRB     R2,[R1, #+1]
    129                ZD_MODBUS[i].Error=0x0;      
   \   00000064   2530               ADDS     R0,R0,#+37
   \   00000066   1100               MOVS     R1,R2
   \   00000068   0170               STRB     R1,[R0, #+0]
   \   0000006A   4170               STRB     R1,[R0, #+1]
    130          
    131               
    132                
    133          }
   \   0000006C   7047               BX       LR               ;; return
    134          
    135          
    136          //*-----------------------------------------------------------------------------
    137          //* Nazwa funkcji :    PortStageRead
    138          //* Funkcja wydobywa wartoœæ bitu o numerze PortNr ze zmiennej pod adresem *Stage 
    139          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    140          char PortStageRead(short int Stage, char PortNr)
    141          {
   \                     PortStageRead:
   \   00000000   0200               MOVS     R2,R0
    142              char odp=0;
    143              odp=(Stage>>PortNr)&0x1;
    144              return odp;
   \   00000002   0A41               ASRS     R2,R2,R1
   \   00000004   0120               MOVS     R0,#+1
   \   00000006   1040               ANDS     R0,R0,R2
   \   00000008   7047               BX       LR               ;; return
    145          }
    146          
    147          //*-----------------------------------------------------------------------------
    148          //* Nazwa funkcji :    PortStageSet
    149          //* Funkcja ustawia stan portu (bit PortNr dla zmiennej pod adresem *Stage) na Value 
    150          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    151          void PortStageSet(short int *Stage, char PortNr, char Value)
    152          {
   \                     PortStageSet:
   \   00000000   11B4               PUSH     {R0,R4}
    153              Value&=0x1;
    154              *Stage=(*Stage&(~(0x1<<PortNr))) | (Value<<PortNr);
   \   00000002   0388               LDRH     R3,[R0, #+0]
   \   00000004   0124               MOVS     R4,#+1
   \   00000006   8C40               LSLS     R4,R4,R1
   \   00000008   A343               BICS     R3,R3,R4
   \   0000000A   0124               MOVS     R4,#+1
   \   0000000C   1440               ANDS     R4,R4,R2
   \   0000000E   8C40               LSLS     R4,R4,R1
   \   00000010   1C43               ORRS     R4,R4,R3
   \   00000012   0480               STRH     R4,[R0, #+0]
    155          }
   \   00000014   18BC               POP      {R3,R4}
   \   00000016   7047               BX       LR               ;; return
    156          
    157          
    158          
    159          //*-----------------------------------------------------------------------------
    160          //* Nazwa funkcji :    ProcStI_Action
    161          //* Funkcja procedury "Stan wejœcia"
    162          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    163          void ProcStI_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    164          {  
   \                     ProcStI_Action:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0C00               MOVS     R4,R1
    165            //je¿eli port w wêŸle == 1 i wiarygodny pomiar
    166            if (Proc->Nr>=0)
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   6156               LDRSB    R1,[R4, R1]
   \   00000008   0029               CMP      R1,#+0
   \   0000000A   1DD4               BMI      ??ProcStI_Action_0
    167            {
    168              if ((MainStg->StageI[Proc->Nr].Port !=0x8AAA))
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   6156               LDRSB    R1,[R4, R1]
   \   00000010   1623               MOVS     R3,#+22
   \   00000012   5943               MULS     R1,R3,R1
   \   00000014   5118               ADDS     R1,R2,R1
   \   00000016   A031               ADDS     R1,R1,#+160
   \   00000018   0988               LDRH     R1,[R1, #+0]
   \   0000001A   ....               LDR      R3,??DataTable3  ;; 0x8aaa
   \   0000001C   9942               CMP      R1,R3
   \   0000001E   21D0               BEQ      ??ProcStI_Action_1
    169              {
    170                 if (*PrvOut)
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   405E               LDRSH    R0,[R0, R1]
   \   00000024   0028               CMP      R0,#+0
   \   00000026   0DD0               BEQ      ??ProcStI_Action_2
    171                 {
    172                    Proc->Out=PortStageRead(MainStg->StageI[Proc->Nr].Port, Proc->Tag.Port);  
   \   00000028   217A               LDRB     R1,[R4, #+8]
   \   0000002A   0120               MOVS     R0,#+1
   \   0000002C   2056               LDRSB    R0,[R4, R0]
   \   0000002E   1623               MOVS     R3,#+22
   \   00000030   5843               MULS     R0,R3,R0
   \   00000032   1018               ADDS     R0,R2,R0
   \   00000034   A030               ADDS     R0,R0,#+160
   \   00000036   0088               LDRH     R0,[R0, #+0]
   \   00000038   0004               LSLS     R0,R0,#+16
   \   0000003A   0014               ASRS     R0,R0,#+16
   \   0000003C   ........           BL       PortStageRead
   \   00000040   6082               STRH     R0,[R4, #+18]
   \   00000042   0FE0               B        ??ProcStI_Action_1
    173                 }else{
    174                   Proc->Out=0;
   \                     ??ProcStI_Action_2:
   \   00000044   6082               STRH     R0,[R4, #+18]
   \   00000046   0DE0               B        ??ProcStI_Action_1
    175                 }
    176              }
    177              
    178            //je¿eli zmienna dwustanowa  
    179            }else{
    180                Proc->Out= (Variables[Proc->Tag.Port/8]>> (Proc->Tag.Port%8))&0x1;
   \                     ??ProcStI_Action_0:
   \   00000048   207A               LDRB     R0,[R4, #+8]
   \   0000004A   C010               ASRS     R0,R0,#+3
   \   0000004C   ....               LDR      R1,??DataTable4  ;; Trap
   \   0000004E   0818               ADDS     R0,R1,R0
   \   00000050   007C               LDRB     R0,[R0, #+16]
   \   00000052   217A               LDRB     R1,[R4, #+8]
   \   00000054   0A00               MOVS     R2,R1
   \   00000056   D208               LSRS     R2,R2,#+3
   \   00000058   D200               LSLS     R2,R2,#+3
   \   0000005A   891A               SUBS     R1,R1,R2
   \   0000005C   0841               ASRS     R0,R0,R1
   \   0000005E   0121               MOVS     R1,#+1
   \   00000060   0140               ANDS     R1,R1,R0
   \   00000062   6182               STRH     R1,[R4, #+18]
    181            }
    182          
    183          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStI_Action_1:
   \   00000064   10BC               POP      {R4}
   \   00000066   01BC               POP      {R0}
   \   00000068   0047               BX       R0               ;; return
    184          
    185          
    186          
    187          //*-----------------------------------------------------------------------------
    188          //* Nazwa funkcji :    ProcStI_Action
    189          //* Funkcja procedury "Stan wejœcia"
    190          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    191          void ProcStNI_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    192          {  
   \                     ProcStNI_Action:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0C00               MOVS     R4,R1
    193                   //je¿eli port w wêŸle == 1 i wiarygodny pomiar
    194            if ((MainStg->StageI[Proc->Nr].Port !=0x8AAA))
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   6156               LDRSB    R1,[R4, R1]
   \   00000008   1623               MOVS     R3,#+22
   \   0000000A   5943               MULS     R1,R3,R1
   \   0000000C   5118               ADDS     R1,R2,R1
   \   0000000E   A031               ADDS     R1,R1,#+160
   \   00000010   0988               LDRH     R1,[R1, #+0]
   \   00000012   ....               LDR      R3,??DataTable3  ;; 0x8aaa
   \   00000014   9942               CMP      R1,R3
   \   00000016   2ED0               BEQ      ??ProcStNI_Action_0
    195            {
    196            
    197             if (*PrvOut)
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   405E               LDRSH    R0,[R0, R1]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   29D0               BEQ      ??ProcStNI_Action_1
    198             {
    199          
    200                   if (Proc->Nr>=0)
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   2056               LDRSB    R0,[R4, R0]
   \   00000024   0028               CMP      R0,#+0
   \   00000026   13D4               BMI      ??ProcStNI_Action_2
    201                   {
    202                     if (PortStageRead(MainStg->StageI[Proc->Nr].Port, Proc->Tag.Port)==1)
   \   00000028   217A               LDRB     R1,[R4, #+8]
   \   0000002A   0120               MOVS     R0,#+1
   \   0000002C   2056               LDRSB    R0,[R4, R0]
   \   0000002E   1623               MOVS     R3,#+22
   \   00000030   5843               MULS     R0,R3,R0
   \   00000032   1018               ADDS     R0,R2,R0
   \   00000034   A030               ADDS     R0,R0,#+160
   \   00000036   0088               LDRH     R0,[R0, #+0]
   \   00000038   0004               LSLS     R0,R0,#+16
   \   0000003A   0014               ASRS     R0,R0,#+16
   \   0000003C   ........           BL       PortStageRead
   \   00000040   0128               CMP      R0,#+1
   \   00000042   02D1               BNE      ??ProcStNI_Action_3
    203                     {
    204                      Proc->Out=0; 
   \   00000044   0020               MOVS     R0,#+0
   \   00000046   6082               STRH     R0,[R4, #+18]
   \   00000048   15E0               B        ??ProcStNI_Action_0
    205                     }else{
    206                      Proc->Out=1;
   \                     ??ProcStNI_Action_3:
   \   0000004A   0120               MOVS     R0,#+1
   \   0000004C   6082               STRH     R0,[R4, #+18]
   \   0000004E   12E0               B        ??ProcStNI_Action_0
    207                     }
    208                   }else{
    209                     if (((Variables[Proc->Tag.Port/8]>> (Proc->Tag.Port%8))&0x1)==1)
   \                     ??ProcStNI_Action_2:
   \   00000050   207A               LDRB     R0,[R4, #+8]
   \   00000052   C010               ASRS     R0,R0,#+3
   \   00000054   ....               LDR      R1,??DataTable4  ;; Trap
   \   00000056   0818               ADDS     R0,R1,R0
   \   00000058   007C               LDRB     R0,[R0, #+16]
   \   0000005A   217A               LDRB     R1,[R4, #+8]
   \   0000005C   0A00               MOVS     R2,R1
   \   0000005E   D208               LSRS     R2,R2,#+3
   \   00000060   D200               LSLS     R2,R2,#+3
   \   00000062   891A               SUBS     R1,R1,R2
   \   00000064   0841               ASRS     R0,R0,R1
   \   00000066   0121               MOVS     R1,#+1
   \   00000068   0140               ANDS     R1,R1,R0
   \   0000006A   481E               SUBS     R0,R1,#+1
   \   0000006C   8041               SBCS     R0,R0,R0
   \   0000006E   C00F               LSRS     R0,R0,#+31
   \   00000070   6082               STRH     R0,[R4, #+18]
   \   00000072   00E0               B        ??ProcStNI_Action_0
    210                     {
    211                      Proc->Out=0; 
    212                     }else{
    213                      Proc->Out=1;
    214                     }
    215                   }
    216                 }else{
    217                   Proc->Out=0;
   \                     ??ProcStNI_Action_1:
   \   00000074   6082               STRH     R0,[R4, #+18]
    218                 }
    219             }
    220          
    221          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStNI_Action_0:
   \   00000076   10BC               POP      {R4}
   \   00000078   01BC               POP      {R0}
   \   0000007A   0047               BX       R0               ;; return
    222          
    223          
    224          
    225          
    226          //*-----------------------------------------------------------------------------
    227          //* Nazwa funkcji :    ProcGetAnal_Action
    228          //* Funkcja procedury "Stan wejœcia analogowego"
    229          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    230          void ProcGetReg_Action(_Procedure *Proc, _MainStage *MainStg) 
    231          {  
   \                     ProcGetReg_Action:
   \   00000000   70B5               PUSH     {R4-R6,LR}
    232            if (Proc->Nr>=0)
   \   00000002   184A               LDR      R2,??ProcGetReg_Action_0  ;; 0xffff8aaa
   \   00000004   0123               MOVS     R3,#+1
   \   00000006   C356               LDRSB    R3,[R0, R3]
   \   00000008   002B               CMP      R3,#+0
   \   0000000A   17D4               BMI      ??ProcGetReg_Action_1
    233            {
    234                if ((MainStg->StageI[Proc->Nr].Value[Proc->Tag.RegNr])!=(signed short int )0x8AAA)
   \   0000000C   A023               MOVS     R3,#+160
   \   0000000E   047A               LDRB     R4,[R0, #+8]
   \   00000010   6400               LSLS     R4,R4,#+1
   \   00000012   0125               MOVS     R5,#+1
   \   00000014   4557               LDRSB    R5,[R0, R5]
   \   00000016   1626               MOVS     R6,#+22
   \   00000018   7543               MULS     R5,R6,R5
   \   0000001A   4D19               ADDS     R5,R1,R5
   \   0000001C   2C19               ADDS     R4,R5,R4
   \   0000001E   E35E               LDRSH    R3,[R4, R3]
   \   00000020   9342               CMP      R3,R2
   \   00000022   1CD0               BEQ      ??ProcGetReg_Action_2
    235                {
    236                  Proc->Out=MainStg->StageI[Proc->Nr].Value[Proc->Tag.RegNr];  
   \   00000024   027A               LDRB     R2,[R0, #+8]
   \   00000026   5200               LSLS     R2,R2,#+1
   \   00000028   0123               MOVS     R3,#+1
   \   0000002A   C356               LDRSB    R3,[R0, R3]
   \   0000002C   3400               MOVS     R4,R6
   \   0000002E   6343               MULS     R3,R4,R3
   \   00000030   C918               ADDS     R1,R1,R3
   \   00000032   8918               ADDS     R1,R1,R2
   \   00000034   A031               ADDS     R1,R1,#+160
   \   00000036   0988               LDRH     R1,[R1, #+0]
   \   00000038   4182               STRH     R1,[R0, #+18]
   \   0000003A   10E0               B        ??ProcGetReg_Action_2
    237                }
    238            }else{
    239                if ((MainStg->StageI[Proc->Nr].Value[Proc->Tag.RegNr])!=(signed short int )0x8AAA)
   \                     ??ProcGetReg_Action_1:
   \   0000003C   A023               MOVS     R3,#+160
   \   0000003E   047A               LDRB     R4,[R0, #+8]
   \   00000040   6400               LSLS     R4,R4,#+1
   \   00000042   0125               MOVS     R5,#+1
   \   00000044   4557               LDRSB    R5,[R0, R5]
   \   00000046   1626               MOVS     R6,#+22
   \   00000048   7543               MULS     R5,R6,R5
   \   0000004A   4919               ADDS     R1,R1,R5
   \   0000004C   0919               ADDS     R1,R1,R4
   \   0000004E   C95E               LDRSH    R1,[R1, R3]
   \   00000050   9142               CMP      R1,R2
   \   00000052   04D0               BEQ      ??ProcGetReg_Action_2
    240                {
    241                  Proc->Out=VariablesAnal[Proc->Tag.RegNr];
   \   00000054   017A               LDRB     R1,[R0, #+8]
   \   00000056   4900               LSLS     R1,R1,#+1
   \   00000058   ....               LDR      R2,??DataTable7  ;; VariablesAnal
   \   0000005A   515A               LDRH     R1,[R2, R1]
   \   0000005C   4182               STRH     R1,[R0, #+18]
    242                }
    243            }
    244               
    245          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcGetReg_Action_2:
   \   0000005E   70BC               POP      {R4-R6}
   \   00000060   01BC               POP      {R0}
   \   00000062   0047               BX       R0               ;; return
   \                     ??ProcGetReg_Action_0:
   \   00000064   AA8AFFFF           DC32     0xffff8aaa
    246          
    247          
    248          
    249          //*-----------------------------------------------------------------------------
    250          //* Nazwa funkcji :    ProcSetAnal_Action
    251          //* Funkcja procedury "Ustawienie wyjœcia analogowego"
    252          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    253          void ProcSetAnal_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    254          {  
   \                     ProcSetAnal_Action:
   \   00000000   70B5               PUSH     {R4-R6,LR}
    255            if (Proc->Nr>=0)
   \   00000002   0123               MOVS     R3,#+1
   \   00000004   CB56               LDRSB    R3,[R1, R3]
   \   00000006   002B               CMP      R3,#+0
   \   00000008   0BD4               BMI      ??ProcSetAnal_Action_0
    256            {
    257                MainStg->StageQ[Proc->Nr].Value[Proc->Tag.RegNr]=*PrvOut;
   \   0000000A   ....               LDR      R3,??DataTable8  ;; 0x3a2
   \   0000000C   0C7A               LDRB     R4,[R1, #+8]
   \   0000000E   6400               LSLS     R4,R4,#+1
   \   00000010   0125               MOVS     R5,#+1
   \   00000012   4D57               LDRSB    R5,[R1, R5]
   \   00000014   1626               MOVS     R6,#+22
   \   00000016   7543               MULS     R5,R6,R5
   \   00000018   5219               ADDS     R2,R2,R5
   \   0000001A   1219               ADDS     R2,R2,R4
   \   0000001C   0488               LDRH     R4,[R0, #+0]
   \   0000001E   D452               STRH     R4,[R2, R3]
   \   00000020   04E0               B        ??ProcSetAnal_Action_1
    258            }else{
    259                VariablesAnal[Proc->Tag.RegNr]=*PrvOut;
   \                     ??ProcSetAnal_Action_0:
   \   00000022   0A7A               LDRB     R2,[R1, #+8]
   \   00000024   5200               LSLS     R2,R2,#+1
   \   00000026   ....               LDR      R3,??DataTable7  ;; VariablesAnal
   \   00000028   0488               LDRH     R4,[R0, #+0]
   \   0000002A   9C52               STRH     R4,[R3, R2]
    260            }  
    261            Proc->Out=*PrvOut;
   \                     ??ProcSetAnal_Action_1:
   \   0000002C   0088               LDRH     R0,[R0, #+0]
   \   0000002E   4882               STRH     R0,[R1, #+18]
    262           
    263          }//_______________________ Koniec funkcji  ____________________________
   \   00000030   70BC               POP      {R4-R6}
   \   00000032   01BC               POP      {R0}
   \   00000034   0047               BX       R0               ;; return
    264          
    265          
    266          
    267          
    268          //*-----------------------------------------------------------------------------
    269          //* Nazwa funkcji :    ProcConstAnal_Action
    270          //* Funkcja procedury "staa analogowa"
    271          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    272          void ProcConstAnal_Action(_Procedure *Proc) 
    273          {  
    274            Proc->Out=Proc->Tag.ConstAnValue;  
   \                     ProcConstAnal_Action:
   \   00000000   0189               LDRH     R1,[R0, #+8]
   \   00000002   4182               STRH     R1,[R0, #+18]
    275          }//_______________________ Koniec funkcji  ____________________________
   \   00000004   7047               BX       LR               ;; return
    276          
    277          
    278          
    279          
    280          
    281          //*-----------------------------------------------------------------------------
    282          
    283          
    284          
    285          
    286          
    287          //*-----------------------------------------------------------------------------
    288          //* Nazwa funkcji :    ProcStB_Action
    289          //* Funkcja procedury "Akcja przycisków przycisków"
    290          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    291          void ProcStB_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    292          {  
   \                     ProcStB_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    293             if (*PrvOut)
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C05E               LDRSH    R0,[R0, R3]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   06D0               BEQ      ??ProcStB_Action_0
    294             {
    295                Proc->Out=MainStg->StageButtonExe[Proc->Nr];  
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   0856               LDRSB    R0,[R1, R0]
   \   0000000E   1018               ADDS     R0,R2,R0
   \   00000010   5030               ADDS     R0,R0,#+80
   \   00000012   0078               LDRB     R0,[R0, #+0]
   \   00000014   4882               STRH     R0,[R1, #+18]
   \   00000016   00E0               B        ??ProcStB_Action_1
    296          
    297             }else{
    298               Proc->Out=0;
   \                     ??ProcStB_Action_0:
   \   00000018   4882               STRH     R0,[R1, #+18]
    299             }
    300          
    301          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStB_Action_1:
   \   0000001A   08BC               POP      {R3}
   \   0000001C   01BC               POP      {R0}
   \   0000001E   0047               BX       R0               ;; return
    302          
    303          
    304          
    305          //*-----------------------------------------------------------------------------
    306          //* Nazwa funkcji :    ProcStQ_Action
    307          //* Funkcja procedury "Stan wyjœcia"
    308          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    309          void ProcStQ_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    310          {  
   \                     ProcStQ_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0C00               MOVS     R4,R1
    311             if (*PrvOut)
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   405E               LDRSH    R0,[R0, R1]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   0DD0               BEQ      ??ProcStQ_Action_0
    312             {
    313                Proc->Out=PortStageRead(MainStg->StageQ[Proc->Nr].Port,Proc->Tag.Port);  
   \   0000000C   217A               LDRB     R1,[R4, #+8]
   \   0000000E   ....               LDR      R0,??DataTable8  ;; 0x3a2
   \   00000010   0123               MOVS     R3,#+1
   \   00000012   E356               LDRSB    R3,[R4, R3]
   \   00000014   1625               MOVS     R5,#+22
   \   00000016   6B43               MULS     R3,R5,R3
   \   00000018   D218               ADDS     R2,R2,R3
   \   0000001A   105A               LDRH     R0,[R2, R0]
   \   0000001C   0004               LSLS     R0,R0,#+16
   \   0000001E   0014               ASRS     R0,R0,#+16
   \   00000020   ........           BL       PortStageRead
   \   00000024   6082               STRH     R0,[R4, #+18]
   \   00000026   00E0               B        ??ProcStQ_Action_1
    314             }else{
    315                Proc->Out=0;
   \                     ??ProcStQ_Action_0:
   \   00000028   6082               STRH     R0,[R4, #+18]
    316             }
    317          
    318          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStQ_Action_1:
   \   0000002A   38BC               POP      {R3-R5}
   \   0000002C   01BC               POP      {R0}
   \   0000002E   0047               BX       R0               ;; return
    319          
    320          
    321          
    322          
    323          
    324          //*-----------------------------------------------------------------------------
    325          //* Nazwa funkcji :    ProcStS_Action
    326          //* Funkcja procedury "Stan sceny"
    327          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    328          void ProcStS_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    329          {  
   \                     ProcStS_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    330            Proc->Out=0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   4B82               STRH     R3,[R1, #+18]
    331             if (*PrvOut)
   \   00000006   C05E               LDRSH    R0,[R0, R3]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   07D0               BEQ      ??ProcStS_Action_0
    332             {
    333                if (Proc->Nr==MainStg->SceneNr) Proc->Out=1;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   0856               LDRSB    R0,[R1, R0]
   \   00000010   ....               LDR      R3,??DataTable9  ;; 0x6ea
   \   00000012   D25C               LDRB     R2,[R2, R3]
   \   00000014   9042               CMP      R0,R2
   \   00000016   01D1               BNE      ??ProcStS_Action_0
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   4882               STRH     R0,[R1, #+18]
    334             }
    335          
    336          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStS_Action_0:
   \   0000001C   08BC               POP      {R3}
   \   0000001E   01BC               POP      {R0}
   \   00000020   0047               BX       R0               ;; return
    337          
    338          
    339          
    340          /*
    341          
    342          //-----------------------------------------------------------------------------
    343          // Nazwa funkcji :    ProcStT_Action
    344          // Funkcja procedury "Stan timera"
    345          //-----------------------------------------------------------------------------
    346          void ProcStT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    347          {  
    348             if (*PrvOut)
    349             {
    350                Proc->Out=PortStageRead(MainStg->StageTimer[Proc->Nr].Port,Proc->Tag.Port);  
    351             }else{
    352                Proc->Out=0;
    353             }
    354          
    355          }//_______________________ Koniec funkcji  ____________________________
    356          
    357          
    358          
    359          
    360          //-----------------------------------------------------------------------------
    361          // Nazwa funkcji :    ProcStT_Action
    362          // Funkcja procedury "Stan timera"
    363          //-----------------------------------------------------------------------------
    364          void ProcStNT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    365          {  
    366             if (*PrvOut) 
    367             {
    368                if (PortStageRead(MainStg->StageTimer[Proc->Nr].Port,Proc->Tag.Port))
    369                {
    370                  Proc->Out=0;
    371                }else{
    372                  Proc->Out=1;  
    373                }
    374             }else{
    375                Proc->Out=0;
    376             }
    377          
    378          }//_______________________ Koniec funkcji  ____________________________
    379          */
    380          
    381          
    382          
    383           extern unsigned long long g_NextTimeProgram;
    384          
    385          
    386          //*-----------------------------------------------------------------------------
    387          //* Nazwa funkcji :    ProcWOUT_Action
    388          //* Funkcja procedury "Ustaw stan wyjœcia"
    389          //*-----------------------------------------------------------------------------
    390          

   \                                 In section Debug.txt, align 4, keep-with-next
    391          void ProcWOUT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    392          {  
   \                     ProcWOUT_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    393          
    394               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   205E               LDRSH    R0,[R4, R0]
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   37D1               BNE      ??ProcWOUT_Action_0
   \   00000010   1220               MOVS     R0,#+18
   \   00000012   285E               LDRSH    R0,[R5, R0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   33D1               BNE      ??ProcWOUT_Action_0
    395               {
    396                if ((Proc->Nr>=0) && (Proc->Nr!=0xFF))   //je¿eli wêze³
                                                     ^
Warning[Pa084]: pointless integer comparison with an out of range value
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   2856               LDRSB    R0,[R5, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   1ED4               BMI      ??ProcWOUT_Action_1
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   2856               LDRSB    R0,[R5, R0]
   \   00000024   FF28               CMP      R0,#+255
   \   00000026   1AD0               BEQ      ??ProcWOUT_Action_1
    397                {
    398                   PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,1); 
                                       ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000028   0122               MOVS     R2,#+1
   \   0000002A   297A               LDRB     R1,[R5, #+8]
   \   0000002C   3248               LDR      R0,??ProcWOUT_Action_2  ;; 0x3a2
   \   0000002E   1300               MOVS     R3,R2
   \   00000030   EB56               LDRSB    R3,[R5, R3]
   \   00000032   1627               MOVS     R7,#+22
   \   00000034   7B43               MULS     R3,R7,R3
   \   00000036   F318               ADDS     R3,R6,R3
   \   00000038   1818               ADDS     R0,R3,R0
   \   0000003A   ........           BL       PortStageSet
    399                   if (TransQuality.Mensur[Proc->Nr-1]>0)  MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   0000003E   0120               MOVS     R0,#+1
   \   00000040   2856               LDRSB    R0,[R5, R0]
   \   00000042   8000               LSLS     R0,R0,#+2
   \   00000044   2D49               LDR      R1,??ProcWOUT_Action_2+0x4  ;; TransQuality
   \   00000046   0818               ADDS     R0,R1,R0
   \   00000048   806C               LDR      R0,[R0, #+72]
   \   0000004A   0028               CMP      R0,#+0
   \   0000004C   18D0               BEQ      ??ProcWOUT_Action_0
   \   0000004E   2C48               LDR      R0,??ProcWOUT_Action_2+0x8  ;; 0x6eb
   \   00000050   0121               MOVS     R1,#+1
   \   00000052   6956               LDRSB    R1,[R5, R1]
   \   00000054   7118               ADDS     R1,R6,R1
   \   00000056   2B4A               LDR      R2,??ProcWOUT_Action_2+0xC  ;; ChangeStageFlag
   \   00000058   1278               LDRB     R2,[R2, #+0]
   \   0000005A   0A54               STRB     R2,[R1, R0]
   \   0000005C   10E0               B        ??ProcWOUT_Action_0
    400                 
    401                   #ifdef _LIVE_RJESTR 
    402                       LIVE_TAB[LIVE_TAB_IDX]=0xF000 | ((Proc->Nr&0xF)<<8) | ((MainStg->StageQ[Proc->Nr].Port)&0xFF);
    403                       if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    404                   #endif
    405          
    406                }else{  //je¿eli zmienna dwustanowa  
    407                    Variables[Proc->Tag.Port/8] |= 1<<(Proc->Tag.Port%8);
   \                     ??ProcWOUT_Action_1:
   \   0000005E   2A48               LDR      R0,??ProcWOUT_Action_2+0x10  ;; Trap
   \   00000060   297A               LDRB     R1,[R5, #+8]
   \   00000062   C910               ASRS     R1,R1,#+3
   \   00000064   4118               ADDS     R1,R0,R1
   \   00000066   2A7A               LDRB     R2,[R5, #+8]
   \   00000068   D210               ASRS     R2,R2,#+3
   \   0000006A   8018               ADDS     R0,R0,R2
   \   0000006C   007C               LDRB     R0,[R0, #+16]
   \   0000006E   0122               MOVS     R2,#+1
   \   00000070   2B7A               LDRB     R3,[R5, #+8]
   \   00000072   1F00               MOVS     R7,R3
   \   00000074   FF08               LSRS     R7,R7,#+3
   \   00000076   FF00               LSLS     R7,R7,#+3
   \   00000078   DB1B               SUBS     R3,R3,R7
   \   0000007A   9A40               LSLS     R2,R2,R3
   \   0000007C   0243               ORRS     R2,R2,R0
   \   0000007E   0A74               STRB     R2,[R1, #+16]
    408                    
    409                    #ifdef _LIVE_RJESTR   
    410                        LIVE_TAB[LIVE_TAB_IDX]=0xF000 | ((Proc->Nr&0xF)<<8) | ((MainStg->StageQ[Proc->Nr].Port)&0xFF);
    411                        if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    412                    #endif
    413                }
    414               }
    415          
    416               if ((*PrvOut==0) && (Proc->Out==1))
   \                     ??ProcWOUT_Action_0:
   \   00000080   0020               MOVS     R0,#+0
   \   00000082   205E               LDRSH    R0,[R4, R0]
   \   00000084   0028               CMP      R0,#+0
   \   00000086   32D1               BNE      ??ProcWOUT_Action_3
   \   00000088   1220               MOVS     R0,#+18
   \   0000008A   285E               LDRSH    R0,[R5, R0]
   \   0000008C   0128               CMP      R0,#+1
   \   0000008E   2ED1               BNE      ??ProcWOUT_Action_3
    417               {
    418                  if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000090   2856               LDRSB    R0,[R5, R0]
   \   00000092   0028               CMP      R0,#+0
   \   00000094   1AD4               BMI      ??ProcWOUT_Action_4
    419                  {
    420                     PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,0); 
                                         ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000096   0022               MOVS     R2,#+0
   \   00000098   297A               LDRB     R1,[R5, #+8]
   \   0000009A   1748               LDR      R0,??ProcWOUT_Action_2  ;; 0x3a2
   \   0000009C   0123               MOVS     R3,#+1
   \   0000009E   EB56               LDRSB    R3,[R5, R3]
   \   000000A0   1627               MOVS     R7,#+22
   \   000000A2   7B43               MULS     R3,R7,R3
   \   000000A4   F318               ADDS     R3,R6,R3
   \   000000A6   1818               ADDS     R0,R3,R0
   \   000000A8   ........           BL       PortStageSet
    421                   
    422                     if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \   000000AC   0120               MOVS     R0,#+1
   \   000000AE   2856               LDRSB    R0,[R5, R0]
   \   000000B0   8000               LSLS     R0,R0,#+2
   \   000000B2   1249               LDR      R1,??ProcWOUT_Action_2+0x4  ;; TransQuality
   \   000000B4   0818               ADDS     R0,R1,R0
   \   000000B6   806C               LDR      R0,[R0, #+72]
   \   000000B8   0028               CMP      R0,#+0
   \   000000BA   18D0               BEQ      ??ProcWOUT_Action_3
    423                     MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   000000BC   1048               LDR      R0,??ProcWOUT_Action_2+0x8  ;; 0x6eb
   \   000000BE   0121               MOVS     R1,#+1
   \   000000C0   6956               LDRSB    R1,[R5, R1]
   \   000000C2   7118               ADDS     R1,R6,R1
   \   000000C4   0F4A               LDR      R2,??ProcWOUT_Action_2+0xC  ;; ChangeStageFlag
   \   000000C6   1278               LDRB     R2,[R2, #+0]
   \   000000C8   0A54               STRB     R2,[R1, R0]
   \   000000CA   10E0               B        ??ProcWOUT_Action_3
    424                    
    425                  }else //je¿eli zmienna dwustanowa
    426                  { 
    427                      Variables[Proc->Tag.Port/8]&= ~(1<<(Proc->Tag.Port%8));
   \                     ??ProcWOUT_Action_4:
   \   000000CC   0E48               LDR      R0,??ProcWOUT_Action_2+0x10  ;; Trap
   \   000000CE   297A               LDRB     R1,[R5, #+8]
   \   000000D0   C910               ASRS     R1,R1,#+3
   \   000000D2   4118               ADDS     R1,R0,R1
   \   000000D4   2A7A               LDRB     R2,[R5, #+8]
   \   000000D6   D210               ASRS     R2,R2,#+3
   \   000000D8   8018               ADDS     R0,R0,R2
   \   000000DA   027C               LDRB     R2,[R0, #+16]
   \   000000DC   0123               MOVS     R3,#+1
   \   000000DE   287A               LDRB     R0,[R5, #+8]
   \   000000E0   0600               MOVS     R6,R0
   \   000000E2   F608               LSRS     R6,R6,#+3
   \   000000E4   F600               LSLS     R6,R6,#+3
   \   000000E6   801B               SUBS     R0,R0,R6
   \   000000E8   8340               LSLS     R3,R3,R0
   \   000000EA   9A43               BICS     R2,R2,R3
   \   000000EC   0A74               STRB     R2,[R1, #+16]
    428                      #ifdef _LIVE_RJESTR 
    429                        LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    430                        if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    431                      #endif
    432                  }  
    433               }
    434               Proc->Out=*PrvOut;
   \                     ??ProcWOUT_Action_3:
   \   000000EE   2088               LDRH     R0,[R4, #+0]
   \   000000F0   6882               STRH     R0,[R5, #+18]
    435            
    436          }//_______________________ Koniec funkcji  ____________________________
   \   000000F2   F8BC               POP      {R3-R7}
   \   000000F4   01BC               POP      {R0}
   \   000000F6   0047               BX       R0               ;; return
   \                     ??ProcWOUT_Action_2:
   \   000000F8   A2030000           DC32     0x3a2
   \   000000FC   ........           DC32     TransQuality
   \   00000100   EB060000           DC32     0x6eb
   \   00000104   ........           DC32     ChangeStageFlag
   \   00000108   ........           DC32     Trap
    437          
    438          
    439                
    440          
    441          //*-----------------------------------------------------------------------------
    442          //* Nazwa funkcji :    ProcWOUTS_Action
    443          //* Funkcja procedury "Ustaw stan wyjœcia na 1"
    444          //*-----------------------------------------------------------------------------
    445          

   \                                 In section Debug.txt, align 4, keep-with-next
    446          void ProcWOUTS_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    447          {  
   \                     ProcWOUTS_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    448          
    449               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   205E               LDRSH    R0,[R4, R0]
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   33D1               BNE      ??ProcWOUTS_Action_0
   \   00000010   1220               MOVS     R0,#+18
   \   00000012   285E               LDRSH    R0,[R5, R0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   2FD1               BNE      ??ProcWOUTS_Action_0
    450               {
    451                if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   2856               LDRSB    R0,[R5, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   1AD4               BMI      ??ProcWOUTS_Action_1
    452                {
    453                 PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,1); 
                                     ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000020   0122               MOVS     R2,#+1
   \   00000022   297A               LDRB     R1,[R5, #+8]
   \   00000024   1748               LDR      R0,??ProcWOUTS_Action_2  ;; 0x3a2
   \   00000026   1300               MOVS     R3,R2
   \   00000028   EB56               LDRSB    R3,[R5, R3]
   \   0000002A   1627               MOVS     R7,#+22
   \   0000002C   7B43               MULS     R3,R7,R3
   \   0000002E   F318               ADDS     R3,R6,R3
   \   00000030   1818               ADDS     R0,R3,R0
   \   00000032   ........           BL       PortStageSet
    454                 
    455                 if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \   00000036   0120               MOVS     R0,#+1
   \   00000038   2856               LDRSB    R0,[R5, R0]
   \   0000003A   8000               LSLS     R0,R0,#+2
   \   0000003C   1249               LDR      R1,??ProcWOUTS_Action_2+0x4  ;; TransQuality
   \   0000003E   0818               ADDS     R0,R1,R0
   \   00000040   806C               LDR      R0,[R0, #+72]
   \   00000042   0028               CMP      R0,#+0
   \   00000044   18D0               BEQ      ??ProcWOUTS_Action_0
    456                   MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   00000046   1148               LDR      R0,??ProcWOUTS_Action_2+0x8  ;; 0x6eb
   \   00000048   0121               MOVS     R1,#+1
   \   0000004A   6956               LDRSB    R1,[R5, R1]
   \   0000004C   7118               ADDS     R1,R6,R1
   \   0000004E   104A               LDR      R2,??ProcWOUTS_Action_2+0xC  ;; ChangeStageFlag
   \   00000050   1278               LDRB     R2,[R2, #+0]
   \   00000052   0A54               STRB     R2,[R1, R0]
   \   00000054   10E0               B        ??ProcWOUTS_Action_0
    457                
    458                 #ifdef _LIVE_RJESTR 
    459                 LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    460                 if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    461                 #endif
    462                 
    463                 //je¿eli zmienna dwustanowa  
    464                }else{
    465                    Variables[Proc->Tag.Port/8]|= 1<<(Proc->Tag.Port%8);
   \                     ??ProcWOUTS_Action_1:
   \   00000056   0F49               LDR      R1,??ProcWOUTS_Action_2+0x10  ;; Trap
   \   00000058   287A               LDRB     R0,[R5, #+8]
   \   0000005A   C010               ASRS     R0,R0,#+3
   \   0000005C   0818               ADDS     R0,R1,R0
   \   0000005E   2A7A               LDRB     R2,[R5, #+8]
   \   00000060   D210               ASRS     R2,R2,#+3
   \   00000062   8918               ADDS     R1,R1,R2
   \   00000064   0A7C               LDRB     R2,[R1, #+16]
   \   00000066   0123               MOVS     R3,#+1
   \   00000068   297A               LDRB     R1,[R5, #+8]
   \   0000006A   0E00               MOVS     R6,R1
   \   0000006C   F608               LSRS     R6,R6,#+3
   \   0000006E   F600               LSLS     R6,R6,#+3
   \   00000070   891B               SUBS     R1,R1,R6
   \   00000072   8B40               LSLS     R3,R3,R1
   \   00000074   1343               ORRS     R3,R3,R2
   \   00000076   0374               STRB     R3,[R0, #+16]
    466                }
    467               }
    468               Proc->Out=*PrvOut;
   \                     ??ProcWOUTS_Action_0:
   \   00000078   2088               LDRH     R0,[R4, #+0]
   \   0000007A   6882               STRH     R0,[R5, #+18]
    469            
    470          }//_______________________ Koniec funkcji  ____________________________
   \   0000007C   F8BC               POP      {R3-R7}
   \   0000007E   01BC               POP      {R0}
   \   00000080   0047               BX       R0               ;; return
   \   00000082   C046               Nop      
   \                     ??ProcWOUTS_Action_2:
   \   00000084   A2030000           DC32     0x3a2
   \   00000088   ........           DC32     TransQuality
   \   0000008C   EB060000           DC32     0x6eb
   \   00000090   ........           DC32     ChangeStageFlag
   \   00000094   ........           DC32     Trap
    471          
    472          
    473          //*-----------------------------------------------------------------------------
    474          //* Nazwa funkcji :    ProcWOUTR_Action
    475          //* Funkcja procedury "Ustaw stan wyjœcia  na 0"
    476          //*-----------------------------------------------------------------------------
    477          

   \                                 In section Debug.txt, align 4, keep-with-next
    478          void ProcWOUTR_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    479          {  
   \                     ProcWOUTR_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    480          
    481               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   205E               LDRSH    R0,[R4, R0]
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   33D1               BNE      ??ProcWOUTR_Action_0
   \   00000010   1220               MOVS     R0,#+18
   \   00000012   285E               LDRSH    R0,[R5, R0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   2FD1               BNE      ??ProcWOUTR_Action_0
    482               {
    483                if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   2856               LDRSB    R0,[R5, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   1AD4               BMI      ??ProcWOUTR_Action_1
    484                { 
    485                 PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,0); 
                                     ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000020   0022               MOVS     R2,#+0
   \   00000022   297A               LDRB     R1,[R5, #+8]
   \   00000024   1748               LDR      R0,??ProcWOUTR_Action_2  ;; 0x3a2
   \   00000026   0123               MOVS     R3,#+1
   \   00000028   EB56               LDRSB    R3,[R5, R3]
   \   0000002A   1627               MOVS     R7,#+22
   \   0000002C   7B43               MULS     R3,R7,R3
   \   0000002E   F318               ADDS     R3,R6,R3
   \   00000030   1818               ADDS     R0,R3,R0
   \   00000032   ........           BL       PortStageSet
    486                 
    487                 if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \   00000036   0120               MOVS     R0,#+1
   \   00000038   2856               LDRSB    R0,[R5, R0]
   \   0000003A   8000               LSLS     R0,R0,#+2
   \   0000003C   1249               LDR      R1,??ProcWOUTR_Action_2+0x4  ;; TransQuality
   \   0000003E   0818               ADDS     R0,R1,R0
   \   00000040   806C               LDR      R0,[R0, #+72]
   \   00000042   0028               CMP      R0,#+0
   \   00000044   18D0               BEQ      ??ProcWOUTR_Action_0
    488                   MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   00000046   1148               LDR      R0,??ProcWOUTR_Action_2+0x8  ;; 0x6eb
   \   00000048   0121               MOVS     R1,#+1
   \   0000004A   6956               LDRSB    R1,[R5, R1]
   \   0000004C   7118               ADDS     R1,R6,R1
   \   0000004E   104A               LDR      R2,??ProcWOUTR_Action_2+0xC  ;; ChangeStageFlag
   \   00000050   1278               LDRB     R2,[R2, #+0]
   \   00000052   0A54               STRB     R2,[R1, R0]
   \   00000054   10E0               B        ??ProcWOUTR_Action_0
    489                 
    490                 #ifdef _LIVE_RJESTR 
    491                  LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    492                  if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    493                 #endif
    494                  
    495                  //je¿eli zmienna dwustanowa  
    496                }else{
    497                    Variables[Proc->Tag.Port/8]&= ~(1<<(Proc->Tag.Port%8));
   \                     ??ProcWOUTR_Action_1:
   \   00000056   0F49               LDR      R1,??ProcWOUTR_Action_2+0x10  ;; Trap
   \   00000058   287A               LDRB     R0,[R5, #+8]
   \   0000005A   C010               ASRS     R0,R0,#+3
   \   0000005C   0818               ADDS     R0,R1,R0
   \   0000005E   2A7A               LDRB     R2,[R5, #+8]
   \   00000060   D210               ASRS     R2,R2,#+3
   \   00000062   8918               ADDS     R1,R1,R2
   \   00000064   0A7C               LDRB     R2,[R1, #+16]
   \   00000066   0123               MOVS     R3,#+1
   \   00000068   297A               LDRB     R1,[R5, #+8]
   \   0000006A   0E00               MOVS     R6,R1
   \   0000006C   F608               LSRS     R6,R6,#+3
   \   0000006E   F600               LSLS     R6,R6,#+3
   \   00000070   891B               SUBS     R1,R1,R6
   \   00000072   8B40               LSLS     R3,R3,R1
   \   00000074   9A43               BICS     R2,R2,R3
   \   00000076   0274               STRB     R2,[R0, #+16]
    498                }
    499               }
    500               Proc->Out=*PrvOut;
   \                     ??ProcWOUTR_Action_0:
   \   00000078   2088               LDRH     R0,[R4, #+0]
   \   0000007A   6882               STRH     R0,[R5, #+18]
    501            
    502          }//_______________________ Koniec funkcji  ____________________________
   \   0000007C   F8BC               POP      {R3-R7}
   \   0000007E   01BC               POP      {R0}
   \   00000080   0047               BX       R0               ;; return
   \   00000082   C046               Nop      
   \                     ??ProcWOUTR_Action_2:
   \   00000084   A2030000           DC32     0x3a2
   \   00000088   ........           DC32     TransQuality
   \   0000008C   EB060000           DC32     0x6eb
   \   00000090   ........           DC32     ChangeStageFlag
   \   00000094   ........           DC32     Trap
    503          
    504          
    505          
    506          
    507          //*-----------------------------------------------------------------------------
    508          //* Nazwa funkcji :    ProcWOUTC_Action
    509          //* Funkcja procedury "zmaina stanu wyjœcia/zmiennej na przeciwny "
    510          //*-----------------------------------------------------------------------------
    511          

   \                                 In section Debug.txt, align 4, keep-with-next
    512          void ProcWOUTC_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    513          {  
   \                     ProcWOUTC_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    514          
    515               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   205E               LDRSH    R0,[R4, R0]
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   6CD1               BNE      ??ProcWOUTC_Action_0
   \   00000010   1220               MOVS     R0,#+18
   \   00000012   285E               LDRSH    R0,[R5, R0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   68D1               BNE      ??ProcWOUTC_Action_0
    516               {
    517                if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   2856               LDRSB    R0,[R5, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   34D4               BMI      ??ProcWOUTC_Action_1
    518                {
    519                     if (PortStageRead(MainStg->StageQ[Proc->Nr].Port,Proc->Tag.Port)==1) //je¿eli wyjœcie w stanie wysokim to zeruj je¿eli nie to ustaw 1
   \   00000020   297A               LDRB     R1,[R5, #+8]
   \   00000022   3448               LDR      R0,??ProcWOUTC_Action_2  ;; 0x3a2
   \   00000024   0122               MOVS     R2,#+1
   \   00000026   AA56               LDRSB    R2,[R5, R2]
   \   00000028   1623               MOVS     R3,#+22
   \   0000002A   5A43               MULS     R2,R3,R2
   \   0000002C   B218               ADDS     R2,R6,R2
   \   0000002E   105A               LDRH     R0,[R2, R0]
   \   00000030   0004               LSLS     R0,R0,#+16
   \   00000032   0014               ASRS     R0,R0,#+16
   \   00000034   ........           BL       PortStageRead
   \   00000038   0128               CMP      R0,#+1
   \   0000003A   0BD1               BNE      ??ProcWOUTC_Action_3
    520                     { 
    521                        PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,0); 
                                            ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   0000003C   0022               MOVS     R2,#+0
   \   0000003E   297A               LDRB     R1,[R5, #+8]
   \   00000040   2C48               LDR      R0,??ProcWOUTC_Action_2  ;; 0x3a2
   \   00000042   0123               MOVS     R3,#+1
   \   00000044   EB56               LDRSB    R3,[R5, R3]
   \   00000046   1627               MOVS     R7,#+22
   \   00000048   7B43               MULS     R3,R7,R3
   \   0000004A   F318               ADDS     R3,R6,R3
   \   0000004C   1818               ADDS     R0,R3,R0
   \   0000004E   ........           BL       PortStageSet
   \   00000052   0AE0               B        ??ProcWOUTC_Action_4
    522                     }else{
    523                        PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,1);
                                            ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \                     ??ProcWOUTC_Action_3:
   \   00000054   0122               MOVS     R2,#+1
   \   00000056   297A               LDRB     R1,[R5, #+8]
   \   00000058   2648               LDR      R0,??ProcWOUTC_Action_2  ;; 0x3a2
   \   0000005A   1300               MOVS     R3,R2
   \   0000005C   EB56               LDRSB    R3,[R5, R3]
   \   0000005E   1627               MOVS     R7,#+22
   \   00000060   7B43               MULS     R3,R7,R3
   \   00000062   F318               ADDS     R3,R6,R3
   \   00000064   1818               ADDS     R0,R3,R0
   \   00000066   ........           BL       PortStageSet
    524                     }
    525                   
    526                     if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \                     ??ProcWOUTC_Action_4:
   \   0000006A   0120               MOVS     R0,#+1
   \   0000006C   2856               LDRSB    R0,[R5, R0]
   \   0000006E   8000               LSLS     R0,R0,#+2
   \   00000070   2149               LDR      R1,??ProcWOUTC_Action_2+0x4  ;; TransQuality
   \   00000072   0818               ADDS     R0,R1,R0
   \   00000074   806C               LDR      R0,[R0, #+72]
   \   00000076   0028               CMP      R0,#+0
   \   00000078   37D0               BEQ      ??ProcWOUTC_Action_0
    527                     MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   0000007A   2048               LDR      R0,??ProcWOUTC_Action_2+0x8  ;; 0x6eb
   \   0000007C   0121               MOVS     R1,#+1
   \   0000007E   6956               LDRSB    R1,[R5, R1]
   \   00000080   7118               ADDS     R1,R6,R1
   \   00000082   1F4A               LDR      R2,??ProcWOUTC_Action_2+0xC  ;; ChangeStageFlag
   \   00000084   1278               LDRB     R2,[R2, #+0]
   \   00000086   0A54               STRB     R2,[R1, R0]
   \   00000088   2FE0               B        ??ProcWOUTC_Action_0
    528                  
    529                     #ifdef _LIVE_RJESTR 
    530                      LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    531                      if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    532                     #endif
    533                   
    534                 
    535                 //je¿eli zmienna dwustanowa  
    536                }else{
    537                      if (Variables[Proc->Tag.Port/8] && (1<<(Proc->Tag.Port%8)))
   \                     ??ProcWOUTC_Action_1:
   \   0000008A   1E48               LDR      R0,??ProcWOUTC_Action_2+0x10  ;; Trap
   \   0000008C   297A               LDRB     R1,[R5, #+8]
   \   0000008E   C910               ASRS     R1,R1,#+3
   \   00000090   4118               ADDS     R1,R0,R1
   \   00000092   097C               LDRB     R1,[R1, #+16]
   \   00000094   0029               CMP      R1,#+0
   \   00000096   18D0               BEQ      ??ProcWOUTC_Action_5
   \   00000098   0121               MOVS     R1,#+1
   \   0000009A   2A7A               LDRB     R2,[R5, #+8]
   \   0000009C   1300               MOVS     R3,R2
   \   0000009E   DB08               LSRS     R3,R3,#+3
   \   000000A0   DB00               LSLS     R3,R3,#+3
   \   000000A2   D21A               SUBS     R2,R2,R3
   \   000000A4   9140               LSLS     R1,R1,R2
   \   000000A6   10D0               BEQ      ??ProcWOUTC_Action_5
    538                      {
    539                         Variables[Proc->Tag.Port/8] &= ~(1<<(Proc->Tag.Port%8));
   \   000000A8   297A               LDRB     R1,[R5, #+8]
   \   000000AA   C910               ASRS     R1,R1,#+3
   \   000000AC   4118               ADDS     R1,R0,R1
   \   000000AE   2A7A               LDRB     R2,[R5, #+8]
   \   000000B0   D210               ASRS     R2,R2,#+3
   \   000000B2   8018               ADDS     R0,R0,R2
   \   000000B4   027C               LDRB     R2,[R0, #+16]
   \   000000B6   0123               MOVS     R3,#+1
   \   000000B8   287A               LDRB     R0,[R5, #+8]
   \   000000BA   0600               MOVS     R6,R0
   \   000000BC   F608               LSRS     R6,R6,#+3
   \   000000BE   F600               LSLS     R6,R6,#+3
   \   000000C0   801B               SUBS     R0,R0,R6
   \   000000C2   8340               LSLS     R3,R3,R0
   \   000000C4   9A43               BICS     R2,R2,R3
   \   000000C6   0A74               STRB     R2,[R1, #+16]
   \   000000C8   0FE0               B        ??ProcWOUTC_Action_0
    540                      }else{
    541                         Variables[Proc->Tag.Port/8] |= (1<<(Proc->Tag.Port%8));
   \                     ??ProcWOUTC_Action_5:
   \   000000CA   297A               LDRB     R1,[R5, #+8]
   \   000000CC   C910               ASRS     R1,R1,#+3
   \   000000CE   4118               ADDS     R1,R0,R1
   \   000000D0   2A7A               LDRB     R2,[R5, #+8]
   \   000000D2   D210               ASRS     R2,R2,#+3
   \   000000D4   8018               ADDS     R0,R0,R2
   \   000000D6   027C               LDRB     R2,[R0, #+16]
   \   000000D8   0123               MOVS     R3,#+1
   \   000000DA   287A               LDRB     R0,[R5, #+8]
   \   000000DC   0600               MOVS     R6,R0
   \   000000DE   F608               LSRS     R6,R6,#+3
   \   000000E0   F600               LSLS     R6,R6,#+3
   \   000000E2   801B               SUBS     R0,R0,R6
   \   000000E4   8340               LSLS     R3,R3,R0
   \   000000E6   1343               ORRS     R3,R3,R2
   \   000000E8   0B74               STRB     R3,[R1, #+16]
    542                      }
    543                }
    544               }
    545               Proc->Out=*PrvOut;
   \                     ??ProcWOUTC_Action_0:
   \   000000EA   2088               LDRH     R0,[R4, #+0]
   \   000000EC   6882               STRH     R0,[R5, #+18]
    546            
    547          }//_______________________ Koniec funkcji  ____________________________
   \   000000EE   F8BC               POP      {R3-R7}
   \   000000F0   01BC               POP      {R0}
   \   000000F2   0047               BX       R0               ;; return
   \                     ??ProcWOUTC_Action_2:
   \   000000F4   A2030000           DC32     0x3a2
   \   000000F8   ........           DC32     TransQuality
   \   000000FC   EB060000           DC32     0x6eb
   \   00000100   ........           DC32     ChangeStageFlag
   \   00000104   ........           DC32     Trap
    548          
    549          
    550          
    551          
    552          
    553          /*
    554          //-----------------------------------------------------------------------------
    555          // Nazwa funkcji :    ProcSetT_Action
    556          // Funkcja procedury "Forsuj stan timera"
    557          //-----------------------------------------------------------------------------
    558          
    559          void ProcRstT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    560          {  
    561               if ((*PrvOut==1) && (Proc->Out==0))
    562               {
    563                  MainStg->StageTimer[Proc->Nr].Curent=0;
    564                  MainObiect.Timer[Proc->Nr]=0;
    565               }
    566               Proc->Out=*PrvOut;
    567            
    568          }//_______________________ Koniec funkcji  ____________________________
    569          */
    570          
    571          
    572          
    573          //*-----------------------------------------------------------------------------
    574          //* Nazwa funkcji :    ProcNOT_Action
    575          //* Funkcja procedury "Negacja
    576          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    577          void ProcNOT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    578          {  
    579             if (*PrvOut)
   \                     ProcNOT_Action:
   \   00000000   0022               MOVS     R2,#+0
   \   00000002   805E               LDRSH    R0,[R0, R2]
   \   00000004   421E               SUBS     R2,R0,#+1
   \   00000006   9241               SBCS     R2,R2,R2
   \   00000008   D20F               LSRS     R2,R2,#+31
   \   0000000A   4A82               STRH     R2,[R1, #+18]
    580             {
    581                Proc->Out=0;  
    582             }else{
    583                Proc->Out=1;
    584             }
    585          }//_______________________ Koniec funkcji__ ____________________________
   \   0000000C   7047               BX       LR               ;; return
    586          
    587          
    588          
    589          
    590          //*-----------------------------------------------------------------------------
    591          //* Nazwa funkcji :    ProcToggleT_Action
    592          //* Funkcja procedury "Przerzutnik typu T"
    593          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    594          void ProcToggleRS_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    595          {  
   \                     ProcToggleRS_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    596             if ((*PrvOut))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C05E               LDRSH    R0,[R0, R3]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   02D0               BEQ      ??ProcToggleRS_Action_0
    597             {
    598               Proc->Out=1;
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   5082               STRH     R0,[R2, #+18]
   \   0000000E   04E0               B        ??ProcToggleRS_Action_1
    599             }
    600             else if (*UpOut)
   \                     ??ProcToggleRS_Action_0:
   \   00000010   085E               LDRSH    R0,[R1, R0]
   \   00000012   0028               CMP      R0,#+0
   \   00000014   01D0               BEQ      ??ProcToggleRS_Action_1
    601             {
    602               Proc->Out=0;
   \   00000016   1800               MOVS     R0,R3
   \   00000018   5082               STRH     R0,[R2, #+18]
    603             }
    604             
    605          
    606               
    607          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcToggleRS_Action_1:
   \   0000001A   08BC               POP      {R3}
   \   0000001C   01BC               POP      {R0}
   \   0000001E   0047               BX       R0               ;; return
    608          
    609          
    610          
    611          
    612          //*-----------------------------------------------------------------------------
    613          //* Nazwa funkcji :    ProcToggleT_Action
    614          //* Funkcja procedury "Przerzutnik typu T"
    615          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    616          void ProcToggleT_Action(short int *PrvOut, _Procedure *Proc) 
    617          {  
   \                     ProcToggleT_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    618             if ((*PrvOut) && (Proc->LastIn==0) && (Proc->Out==0))
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   825E               LDRSH    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   09D0               BEQ      ??ProcToggleT_Action_0
   \   0000000A   0A7C               LDRB     R2,[R1, #+16]
   \   0000000C   002A               CMP      R2,#+0
   \   0000000E   06D1               BNE      ??ProcToggleT_Action_0
   \   00000010   1222               MOVS     R2,#+18
   \   00000012   8A5E               LDRSH    R2,[R1, R2]
   \   00000014   002A               CMP      R2,#+0
   \   00000016   02D1               BNE      ??ProcToggleT_Action_0
    619             {
    620               Proc->Out=1;
   \   00000018   0122               MOVS     R2,#+1
   \   0000001A   4A82               STRH     R2,[R1, #+18]
   \   0000001C   0CE0               B        ??ProcToggleT_Action_1
    621             }
    622             else if ((*PrvOut) && (Proc->LastIn==0) && (Proc->Out==1))
   \                     ??ProcToggleT_Action_0:
   \   0000001E   0022               MOVS     R2,#+0
   \   00000020   825E               LDRSH    R2,[R0, R2]
   \   00000022   002A               CMP      R2,#+0
   \   00000024   08D0               BEQ      ??ProcToggleT_Action_1
   \   00000026   0A7C               LDRB     R2,[R1, #+16]
   \   00000028   002A               CMP      R2,#+0
   \   0000002A   05D1               BNE      ??ProcToggleT_Action_1
   \   0000002C   1222               MOVS     R2,#+18
   \   0000002E   8A5E               LDRSH    R2,[R1, R2]
   \   00000030   012A               CMP      R2,#+1
   \   00000032   01D1               BNE      ??ProcToggleT_Action_1
    623             {
    624               Proc->Out=0;
   \   00000034   0022               MOVS     R2,#+0
   \   00000036   4A82               STRH     R2,[R1, #+18]
    625             }
    626             
    627             Proc->LastIn=*PrvOut;
   \                     ??ProcToggleT_Action_1:
   \   00000038   0088               LDRH     R0,[R0, #+0]
   \   0000003A   0874               STRB     R0,[R1, #+16]
    628                 
    629          
    630          
    631          }//_______________________ Koniec funkcji__ ____________________________
   \   0000003C   08BC               POP      {R3}
   \   0000003E   01BC               POP      {R0}
   \   00000040   0047               BX       R0               ;; return
    632          
    633          
    634          //*-----------------------------------------------------------------------------
    635          //* Nazwa funkcji :    ProcTLI1_Action
    636          //* Funkcja procedury "Procedura impulsu jednocyklowego
    637          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    638          void ProcTLI1_Action(short int *PrvOut, _Procedure *Proc) 
    639          {  
   \                     ProcTLI1_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    640             if ((*PrvOut) && (Proc->LastIn==0))
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   825E               LDRSH    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   05D0               BEQ      ??ProcTLI1_Action_0
   \   0000000A   0A7C               LDRB     R2,[R1, #+16]
   \   0000000C   531E               SUBS     R3,R2,#+1
   \   0000000E   9B41               SBCS     R3,R3,R3
   \   00000010   DB0F               LSRS     R3,R3,#+31
   \   00000012   4B82               STRH     R3,[R1, #+18]
   \   00000014   00E0               B        ??ProcTLI1_Action_1
    641             {
    642               Proc->Out=1;
    643             }
    644             else
    645             {
    646               Proc->Out=0;
   \                     ??ProcTLI1_Action_0:
   \   00000016   4A82               STRH     R2,[R1, #+18]
    647             }
    648             
    649             Proc->LastIn=*PrvOut;
   \                     ??ProcTLI1_Action_1:
   \   00000018   0088               LDRH     R0,[R0, #+0]
   \   0000001A   0874               STRB     R0,[R1, #+16]
    650                 
    651          
    652          
    653          }//_______________________ Koniec funkcji__ ____________________________
   \   0000001C   08BC               POP      {R3}
   \   0000001E   01BC               POP      {R0}
   \   00000020   0047               BX       R0               ;; return
    654          
    655          
    656          
    657          
    658          //*-----------------------------------------------------------------------------
    659          //* Nazwa funkcji :    ProcLim_Action
    660          //* Funkcja procedury "Porównanie wartoœci. Je¿eli 1>2 q=1"
    661          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    662          void ProcLim_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    663          {  
   \                     ProcLim_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    664             if ((*PrvOut)>(*UpOut))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C95E               LDRSH    R1,[R1, R3]
   \   00000006   C05E               LDRSH    R0,[R0, R3]
   \   00000008   8142               CMP      R1,R0
   \   0000000A   02DA               BGE      ??ProcLim_Action_0
    665             {
    666               Proc->Out=1;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   5082               STRH     R0,[R2, #+18]
   \   00000010   01E0               B        ??ProcLim_Action_1
    667             }
    668             else
    669             {
    670               Proc->Out=0;
   \                     ??ProcLim_Action_0:
   \   00000012   1800               MOVS     R0,R3
   \   00000014   5082               STRH     R0,[R2, #+18]
    671             }
    672               
    673          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcLim_Action_1:
   \   00000016   08BC               POP      {R3}
   \   00000018   01BC               POP      {R0}
   \   0000001A   0047               BX       R0               ;; return
    674          
    675          
    676          
    677          
    678          //*-----------------------------------------------------------------------------
    679          //* Nazwa funkcji :    ProcEven_Action
    680          //* Funkcja procedury "Porównanie wartoœci. Je¿eli 1=2 q=1"
    681          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    682          void ProcEven_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    683          {  
   \                     ProcEven_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    684             if ((*PrvOut)==(*UpOut))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C05E               LDRSH    R0,[R0, R3]
   \   00000006   C95E               LDRSH    R1,[R1, R3]
   \   00000008   8842               CMP      R0,R1
   \   0000000A   02D1               BNE      ??ProcEven_Action_0
    685             {
    686               Proc->Out=1;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   5082               STRH     R0,[R2, #+18]
   \   00000010   01E0               B        ??ProcEven_Action_1
    687             }
    688             else
    689             {
    690               Proc->Out=0;
   \                     ??ProcEven_Action_0:
   \   00000012   1800               MOVS     R0,R3
   \   00000014   5082               STRH     R0,[R2, #+18]
    691             }
    692             
    693          
    694               
    695          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcEven_Action_1:
   \   00000016   08BC               POP      {R3}
   \   00000018   01BC               POP      {R0}
   \   0000001A   0047               BX       R0               ;; return
    696          
    697          
    698          
    699          
    700          //*-----------------------------------------------------------------------------
    701          //* Nazwa funkcji :    ProcPlus_Action
    702          //* Funkcja procedury "Plus"
    703          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    704          void ProcPlus_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    705          {  
    706               Proc->Out=(*PrvOut)+(*UpOut);  
   \                     ProcPlus_Action:
   \   00000000   0023               MOVS     R3,#+0
   \   00000002   C05E               LDRSH    R0,[R0, R3]
   \   00000004   C95E               LDRSH    R1,[R1, R3]
   \   00000006   4018               ADDS     R0,R0,R1
   \   00000008   5082               STRH     R0,[R2, #+18]
    707          }//_______________________ Koniec funkcji__ ____________________________
   \   0000000A   7047               BX       LR               ;; return
    708          
    709          
    710          
    711          //*-----------------------------------------------------------------------------
    712          //* Nazwa funkcji :    ProcPlus_Action
    713          //* Funkcja procedury "Plus"
    714          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    715          void ProcMinus_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    716          {  
    717               Proc->Out=(*PrvOut)-(*UpOut);  
   \                     ProcMinus_Action:
   \   00000000   0023               MOVS     R3,#+0
   \   00000002   C05E               LDRSH    R0,[R0, R3]
   \   00000004   C95E               LDRSH    R1,[R1, R3]
   \   00000006   401A               SUBS     R0,R0,R1
   \   00000008   5082               STRH     R0,[R2, #+18]
    718          }//_______________________ Koniec funkcji__ ____________________________
   \   0000000A   7047               BX       LR               ;; return
    719          
    720          
    721          //*-----------------------------------------------------------------------------
    722          //* Nazwa funkcji :    ProcPlus_Action
    723          //* Funkcja procedury "Plus"
    724          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    725          void ProcMul_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    726          {    
   \                     ProcMul_Action:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   1400               MOVS     R4,R2
    727               int odp;
    728               odp=(*PrvOut)*(*UpOut)/10; 
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   805E               LDRSH    R0,[R0, R2]
   \   00000008   895E               LDRSH    R1,[R1, R2]
   \   0000000A   4843               MULS     R0,R1,R0
   \   0000000C   0A21               MOVS     R1,#+10
   \   0000000E   ........           BL       __aeabi_idivmod
    729               if (odp>30000)
   \   00000012   0749               LDR      R1,??ProcMul_Action_0  ;; 0x7531
   \   00000014   8842               CMP      R0,R1
   \   00000016   07DB               BLT      ??ProcMul_Action_1
    730               {
    731                  if (odp>0) Proc->Out=30000; else Proc->Out=-30000;
   \   00000018   0128               CMP      R0,#+1
   \   0000001A   02DB               BLT      ??ProcMul_Action_2
   \   0000001C   481E               SUBS     R0,R1,#+1
   \   0000001E   6082               STRH     R0,[R4, #+18]
   \   00000020   03E0               B        ??ProcMul_Action_3
   \                     ??ProcMul_Action_2:
   \   00000022   0448               LDR      R0,??ProcMul_Action_0+0x4  ;; 0xffff8ad0
   \   00000024   6082               STRH     R0,[R4, #+18]
   \   00000026   00E0               B        ??ProcMul_Action_3
    732               }else{
    733                  Proc->Out=odp; 
   \                     ??ProcMul_Action_1:
   \   00000028   6082               STRH     R0,[R4, #+18]
    734               }
    735          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcMul_Action_3:
   \   0000002A   10BC               POP      {R4}
   \   0000002C   01BC               POP      {R0}
   \   0000002E   0047               BX       R0               ;; return
   \                     ??ProcMul_Action_0:
   \   00000030   31750000           DC32     0x7531
   \   00000034   D08AFFFF           DC32     0xffff8ad0
    736          
    737          
    738          //*-----------------------------------------------------------------------------
    739          //* Nazwa funkcji :    ProcPlus_Action
    740          //* Funkcja procedury "Plus"
    741          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    742          void ProcDiv_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    743          {  
   \                     ProcDiv_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0E00               MOVS     R6,R1
   \   00000006   1700               MOVS     R7,R2
    744               if ((*UpOut)==0)
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   305E               LDRSH    R0,[R6, R0]
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   08D1               BNE      ??ProcDiv_Action_0
    745               {
    746                 if ((*PrvOut)>0) Proc->Out=30000; else Proc->Out=-30000;
   \   00000010   285E               LDRSH    R0,[R5, R0]
   \   00000012   0128               CMP      R0,#+1
   \   00000014   02DB               BLT      ??ProcDiv_Action_1
   \   00000016   1748               LDR      R0,??ProcDiv_Action_2  ;; 0x7530
   \   00000018   7882               STRH     R0,[R7, #+18]
   \   0000001A   27E0               B        ??ProcDiv_Action_3
   \                     ??ProcDiv_Action_1:
   \   0000001C   1648               LDR      R0,??ProcDiv_Action_2+0x4  ;; 0xffff8ad0
   \   0000001E   7882               STRH     R0,[R7, #+18]
   \   00000020   24E0               B        ??ProcDiv_Action_3
    747               }else{
    748                
    749                Proc->Out=((*PrvOut)*10)/(*UpOut); 
   \                     ??ProcDiv_Action_0:
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   285E               LDRSH    R0,[R5, R0]
   \   00000026   0A21               MOVS     R1,#+10
   \   00000028   4843               MULS     R0,R1,R0
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   715E               LDRSH    R1,[R6, R1]
   \   0000002E   ........           BL       __aeabi_idivmod
   \   00000032   7882               STRH     R0,[R7, #+18]
    750                if ( (((*PrvOut)*100)/(*UpOut))>((((*PrvOut)*10)/(*UpOut))*10)+5) Proc->Out++;
   \   00000034   0020               MOVS     R0,#+0
   \   00000036   285E               LDRSH    R0,[R5, R0]
   \   00000038   6421               MOVS     R1,#+100
   \   0000003A   4843               MULS     R0,R1,R0
   \   0000003C   0021               MOVS     R1,#+0
   \   0000003E   715E               LDRSH    R1,[R6, R1]
   \   00000040   ........           BL       __aeabi_idivmod
   \   00000044   0400               MOVS     R4,R0
   \   00000046   0020               MOVS     R0,#+0
   \   00000048   285E               LDRSH    R0,[R5, R0]
   \   0000004A   0A21               MOVS     R1,#+10
   \   0000004C   4843               MULS     R0,R1,R0
   \   0000004E   0021               MOVS     R1,#+0
   \   00000050   715E               LDRSH    R1,[R6, R1]
   \   00000052   ........           BL       __aeabi_idivmod
   \   00000056   0100               MOVS     R1,R0
   \   00000058   0A20               MOVS     R0,#+10
   \   0000005A   4143               MULS     R1,R0,R1
   \   0000005C   491D               ADDS     R1,R1,#+5
   \   0000005E   2000               MOVS     R0,R4
   \   00000060   8142               CMP      R1,R0
   \   00000062   03DA               BGE      ??ProcDiv_Action_3
   \   00000064   1220               MOVS     R0,#+18
   \   00000066   385E               LDRSH    R0,[R7, R0]
   \   00000068   401C               ADDS     R0,R0,#+1
   \   0000006A   7882               STRH     R0,[R7, #+18]
    751               }
    752          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcDiv_Action_3:
   \   0000006C   F8BC               POP      {R3-R7}
   \   0000006E   01BC               POP      {R0}
   \   00000070   0047               BX       R0               ;; return
   \   00000072   C046               Nop      
   \                     ??ProcDiv_Action_2:
   \   00000074   30750000           DC32     0x7530
   \   00000078   D08AFFFF           DC32     0xffff8ad0
    753          
    754          
    755          
    756          
    757          
    758          //*-----------------------------------------------------------------------------
    759          //* Nazwa funkcji :    ProcConect_Action
    760          //* Funkcja procedury "Przeniesienie stanu w prawo"
    761          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    762          void ProcConect_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    763          {  
    764                Proc->Out=*PrvOut;  
   \                     ProcConect_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    765            
    766          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    767          
    768          
    769          
    770          //*-----------------------------------------------------------------------------
    771          //* Nazwa funkcji :    ProcDown_Action
    772          //* Funkcja procedury "Przeniesienie stanu w dó³"
    773          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    774          void ProcDown_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    775          {  
    776                Proc->Out=*PrvOut;  
   \                     ProcDown_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    777          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    778          
    779          
    780          
    781          //*-----------------------------------------------------------------------------
    782          //* Nazwa funkcji :    ProcDownRight_Action
    783          //* Funkcja procedury "Przeniesienie stanu w dó³ i prawo"
    784          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    785          void ProcDownRight_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    786          {  
    787                Proc->Out=*PrvOut;
   \                     ProcDownRight_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    788          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    789          
    790          
    791          
    792          
    793          
    794          //*-----------------------------------------------------------------------------
    795          //* Nazwa funkcji :    ProcUpToRight_Action
    796          //* Funkcja procedury "Przeniesienie stanu z góry w prawo"
    797          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    798          void ProcUpToRight_Action(short int *PrvUpOut, _Procedure *Proc) 
    799          {  
    800                Proc->Out=*PrvUpOut;
   \                     ProcUpToRight_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    801          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    802          
    803          
    804          
    805          //*-----------------------------------------------------------------------------
    806          //* Nazwa funkcji :    ProcUpToRightDown_Action
    807          //* Funkcja procedury "Przeniesienie stanu z góry w prawo i dó³"
    808          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    809          void ProcUpToRightDown_Action(short int *PrvUpOut, _Procedure *Proc) 
    810          {  
    811                Proc->Out=*PrvUpOut;
   \                     ProcUpToRightDown_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    812          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    813          
    814          
    815          //*-----------------------------------------------------------------------------
    816          //* Nazwa funkcji :    ProcSetScn
    817          //* Funkcja procedury "Ustaw scenê"
    818          //*-----------------------------------------------------------------------------
    819          char LastScene=0;

   \                                 In section Debug.txt, align 4, keep-with-next
    820          void ProcSetScn_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    821          {  
   \                     ProcSetScn_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    822               
    823            
    824               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   012B               CMP      R3,#+1
   \   00000008   1AD1               BNE      ??ProcSetScn_Action_0
   \   0000000A   1223               MOVS     R3,#+18
   \   0000000C   CB5E               LDRSH    R3,[R1, R3]
   \   0000000E   002B               CMP      R3,#+0
   \   00000010   16D1               BNE      ??ProcSetScn_Action_0
    825               {  
    826                  //if (Proc->Tag.NrScene>NumberScene) Proc->Tag.NrScene=NumberScene;
    827                 if (Proc->Nr==0)  //je¿eli on/off scen
   \   00000012   0123               MOVS     R3,#+1
   \   00000014   CB56               LDRSB    R3,[R1, R3]
   \   00000016   002B               CMP      R3,#+0
   \   00000018   0FD1               BNE      ??ProcSetScn_Action_1
    828                 {
    829                   if (LastScene)
   \   0000001A   0C4B               LDR      R3,??ProcSetScn_Action_2  ;; Trap
   \   0000001C   5C7A               LDRB     R4,[R3, #+9]
   \   0000001E   002C               CMP      R4,#+0
   \   00000020   04D0               BEQ      ??ProcSetScn_Action_3
    830                   {
    831                      MainStg->SceneNr=LastScene;
   \   00000022   0B4D               LDR      R5,??ProcSetScn_Action_2+0x4  ;; 0x6ea
   \   00000024   5455               STRB     R4,[R2, R5]
    832                      LastScene=0;
   \   00000026   0022               MOVS     R2,#+0
   \   00000028   5A72               STRB     R2,[R3, #+9]
   \   0000002A   09E0               B        ??ProcSetScn_Action_0
    833                   }else{ 
    834                      LastScene=MainStg->SceneNr;
   \                     ??ProcSetScn_Action_3:
   \   0000002C   084C               LDR      R4,??ProcSetScn_Action_2+0x4  ;; 0x6ea
   \   0000002E   1219               ADDS     R2,R2,R4
   \   00000030   1478               LDRB     R4,[R2, #+0]
   \   00000032   5C72               STRB     R4,[R3, #+9]
    835                      MainStg->SceneNr=0;
   \   00000034   0023               MOVS     R3,#+0
   \   00000036   1370               STRB     R3,[R2, #+0]
   \   00000038   02E0               B        ??ProcSetScn_Action_0
    836                   }
    837                   
    838                 }else{
    839                  MainStg->SceneNr=Proc->Nr;
   \                     ??ProcSetScn_Action_1:
   \   0000003A   054B               LDR      R3,??ProcSetScn_Action_2+0x4  ;; 0x6ea
   \   0000003C   4C78               LDRB     R4,[R1, #+1]
   \   0000003E   D454               STRB     R4,[R2, R3]
    840                 }
    841               }
    842          
    843               
    844               Proc->Out=*PrvOut;
   \                     ??ProcSetScn_Action_0:
   \   00000040   0088               LDRH     R0,[R0, #+0]
   \   00000042   4882               STRH     R0,[R1, #+18]
    845          
    846          }//_______________________ Koniec funkcji__ ____________________________
   \   00000044   38BC               POP      {R3-R5}
   \   00000046   01BC               POP      {R0}
   \   00000048   0047               BX       R0               ;; return
   \   0000004A   C046               Nop      
   \                     ??ProcSetScn_Action_2:
   \   0000004C   ........           DC32     Trap
   \   00000050   EA060000           DC32     0x6ea
    847          
    848          
    849          
    850          
    851          //*-----------------------------------------------------------------------------
    852          //* Nazwa funkcji :    ProcInc_Action
    853          //* Funkcja procedury "Inkrementuj scenê"
    854          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    855          void ProcInc_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    856          {  
   \                     ProcInc_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    857               if ((*PrvOut) && (Proc->LastIn==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   002B               CMP      R3,#+0
   \   00000008   0DD0               BEQ      ??ProcInc_Action_0
   \   0000000A   0B7C               LDRB     R3,[R1, #+16]
   \   0000000C   002B               CMP      R3,#+0
   \   0000000E   0AD1               BNE      ??ProcInc_Action_0
    858               {  
    859                  
    860                    if (MainStg->SceneNr<NumberScene) MainStg->SceneNr++;
   \   00000010   084B               LDR      R3,??ProcInc_Action_1  ;; 0x6ea
   \   00000012   D218               ADDS     R2,R2,R3
   \   00000014   084B               LDR      R3,??ProcInc_Action_1+0x4  ;; Trap
   \   00000016   1478               LDRB     R4,[R2, #+0]
   \   00000018   1D7A               LDRB     R5,[R3, #+8]
   \   0000001A   AC42               CMP      R4,R5
   \   0000001C   01D2               BCS      ??ProcInc_Action_2
   \   0000001E   641C               ADDS     R4,R4,#+1
   \   00000020   1470               STRB     R4,[R2, #+0]
    861                    LastScene=0;
   \                     ??ProcInc_Action_2:
   \   00000022   0022               MOVS     R2,#+0
   \   00000024   5A72               STRB     R2,[R3, #+9]
    862               }
    863               
    864          
    865               Proc->LastIn=*PrvOut;
   \                     ??ProcInc_Action_0:
   \   00000026   0288               LDRH     R2,[R0, #+0]
   \   00000028   0A74               STRB     R2,[R1, #+16]
    866               Proc->Out=*PrvOut;
   \   0000002A   0088               LDRH     R0,[R0, #+0]
   \   0000002C   4882               STRH     R0,[R1, #+18]
    867           
    868          }//_______________________ Koniec funkcji__ ____________________________
   \   0000002E   38BC               POP      {R3-R5}
   \   00000030   01BC               POP      {R0}
   \   00000032   0047               BX       R0               ;; return
   \                     ??ProcInc_Action_1:
   \   00000034   EA060000           DC32     0x6ea
   \   00000038   ........           DC32     Trap
    869          
    870          
    871          //*-----------------------------------------------------------------------------
    872          //* Nazwa funkcji :    ProcIncDec_Action
    873          //* Funkcja procedury "Dekrementuj scenê"
    874          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    875          void ProcDec_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    876          {  
   \                     ProcDec_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    877               if ((*PrvOut) && (Proc->LastIn==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   002B               CMP      R3,#+0
   \   00000008   0CD0               BEQ      ??ProcDec_Action_0
   \   0000000A   0B7C               LDRB     R3,[R1, #+16]
   \   0000000C   002B               CMP      R3,#+0
   \   0000000E   09D1               BNE      ??ProcDec_Action_0
    878               {  
    879                  
    880                  if (MainStg->SceneNr>0) MainStg->SceneNr--;
   \   00000010   084B               LDR      R3,??ProcDec_Action_1  ;; 0x6ea
   \   00000012   D218               ADDS     R2,R2,R3
   \   00000014   1378               LDRB     R3,[R2, #+0]
   \   00000016   002B               CMP      R3,#+0
   \   00000018   01D0               BEQ      ??ProcDec_Action_2
   \   0000001A   5B1E               SUBS     R3,R3,#+1
   \   0000001C   1370               STRB     R3,[R2, #+0]
    881                  LastScene=0;
   \                     ??ProcDec_Action_2:
   \   0000001E   064A               LDR      R2,??ProcDec_Action_1+0x4  ;; Trap + 9
   \   00000020   0023               MOVS     R3,#+0
   \   00000022   1370               STRB     R3,[R2, #+0]
    882               }
    883               
    884          
    885               Proc->LastIn=*PrvOut;
   \                     ??ProcDec_Action_0:
   \   00000024   0288               LDRH     R2,[R0, #+0]
   \   00000026   0A74               STRB     R2,[R1, #+16]
    886               Proc->Out=*PrvOut;
   \   00000028   0088               LDRH     R0,[R0, #+0]
   \   0000002A   4882               STRH     R0,[R1, #+18]
    887          
    888          }//_______________________ Koniec funkcji__ ____________________________
   \   0000002C   08BC               POP      {R3}
   \   0000002E   01BC               POP      {R0}
   \   00000030   0047               BX       R0               ;; return
   \   00000032   C046               Nop      
   \                     ??ProcDec_Action_1:
   \   00000034   EA060000           DC32     0x6ea
   \   00000038   ........           DC32     Trap + 9
    889          
    890          
    891          
    892          //*-----------------------------------------------------------------------------
    893          //* Nazwa funkcji :    ProcSPK_Action
    894          //* Funkcja procedury "Dekrementuj scenê"
    895          //*-----------------------------------------------------------------------------
    896          extern     char Speaker[SPK_Amount];                                                   //sygna³ dŸwiêkowy

   \                                 In section Debug.txt, align 4, keep-with-next
    897          void ProcSPK_Action(short int *PrvOut, _Procedure *Proc) 
    898          {  
   \                     ProcSPK_Action:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0200               MOVS     R2,R0
   \   00000004   0B00               MOVS     R3,R1
    899               if ((*PrvOut) && (Proc->Out==0))
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   105E               LDRSH    R0,[R2, R0]
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   21D0               BEQ      ??ProcSPK_Action_0
   \   0000000E   1220               MOVS     R0,#+18
   \   00000010   185E               LDRSH    R0,[R3, R0]
   \   00000012   0028               CMP      R0,#+0
   \   00000014   1DD1               BNE      ??ProcSPK_Action_0
    900               {  
    901                  for (char i=0; i<SPK_Amount; i++) Speaker[i]=0;
   \   00000016   0100               MOVS     R1,R0
   \   00000018   1E4D               LDR      R5,??ProcSPK_Action_1  ;; Speaker
   \   0000001A   0600               MOVS     R6,R0
   \   0000001C   03E0               B        ??ProcSPK_Action_2
   \                     ??ProcSPK_Action_3:
   \   0000001E   2E55               STRB     R6,[R5, R4]
   \   00000020   491C               ADDS     R1,R1,#+1
   \   00000022   0906               LSLS     R1,R1,#+24
   \   00000024   090E               LSRS     R1,R1,#+24
   \                     ??ProcSPK_Action_2:
   \   00000026   0C00               MOVS     R4,R1
   \   00000028   042C               CMP      R4,#+4
   \   0000002A   F8D3               BCC      ??ProcSPK_Action_3
    902                  Speaker[Proc->Tag.SpeakerType]=1;
   \   0000002C   187A               LDRB     R0,[R3, #+8]
   \   0000002E   1949               LDR      R1,??ProcSPK_Action_1  ;; Speaker
   \   00000030   0124               MOVS     R4,#+1
   \   00000032   0C54               STRB     R4,[R1, R0]
    903                  if (Proc->Tag.SpeakerType==0) 
   \   00000034   187A               LDRB     R0,[R3, #+8]
   \   00000036   0028               CMP      R0,#+0
   \   00000038   1AD1               BNE      ??ProcSPK_Action_4
    904                  {
    905                         ButtonBipCounter=g_counter+300000;
   \   0000003A   174C               LDR      R4,??ProcSPK_Action_1+0x4  ;; ButtonBipCounter
   \   0000003C   1748               LDR      R0,??ProcSPK_Action_1+0x8  ;; g_counter
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   1749               LDR      R1,??ProcSPK_Action_1+0xC  ;; 0x493e0
   \   00000042   4018               ADDS     R0,R0,R1
   \   00000044   C117               ASRS     R1,R0,#+31
   \   00000046   03C4               STM      R4!,{R0,R1}
    906                         AT91C_BASE_PIOA->PIO_SODR =SpeakerPin;  
                                                           ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   00000048   1648               LDR      R0,??ProcSPK_Action_1+0x10  ;; 0xfffff430
   \   0000004A   8021               MOVS     R1,#+128
   \   0000004C   0906               LSLS     R1,R1,#+24       ;; #-2147483648
   \   0000004E   0160               STR      R1,[R0, #+0]
   \   00000050   0EE0               B        ??ProcSPK_Action_4
    907                  }
    908               }else if (*PrvOut==0) {
   \                     ??ProcSPK_Action_0:
   \   00000052   0020               MOVS     R0,#+0
   \   00000054   105E               LDRSH    R0,[R2, R0]
   \   00000056   0028               CMP      R0,#+0
   \   00000058   0AD1               BNE      ??ProcSPK_Action_4
    909                 for (char i=0; i<SPK_Amount; i++) Speaker[i]=0;
   \   0000005A   0100               MOVS     R1,R0
   \   0000005C   0D4D               LDR      R5,??ProcSPK_Action_1  ;; Speaker
   \   0000005E   0600               MOVS     R6,R0
   \   00000060   03E0               B        ??ProcSPK_Action_5
   \                     ??ProcSPK_Action_6:
   \   00000062   2E55               STRB     R6,[R5, R4]
   \   00000064   491C               ADDS     R1,R1,#+1
   \   00000066   0906               LSLS     R1,R1,#+24
   \   00000068   090E               LSRS     R1,R1,#+24
   \                     ??ProcSPK_Action_5:
   \   0000006A   0C00               MOVS     R4,R1
   \   0000006C   042C               CMP      R4,#+4
   \   0000006E   F8D3               BCC      ??ProcSPK_Action_6
    910               }
    911               if ((*PrvOut==0) && (Proc->Out==1))
   \                     ??ProcSPK_Action_4:
   \   00000070   0020               MOVS     R0,#+0
   \   00000072   105E               LDRSH    R0,[R2, R0]
   \   00000074   0028               CMP      R0,#+0
   \   00000076   07D1               BNE      ??ProcSPK_Action_7
   \   00000078   1220               MOVS     R0,#+18
   \   0000007A   185E               LDRSH    R0,[R3, R0]
   \   0000007C   0128               CMP      R0,#+1
   \   0000007E   03D1               BNE      ??ProcSPK_Action_7
    912               {  
    913                  AT91C_BASE_PIOA->PIO_CODR =SpeakerPin;  
                                                    ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   00000080   0948               LDR      R0,??ProcSPK_Action_1+0x14  ;; 0xfffff434
   \   00000082   8021               MOVS     R1,#+128
   \   00000084   0906               LSLS     R1,R1,#+24       ;; #-2147483648
   \   00000086   0160               STR      R1,[R0, #+0]
    914               }
    915               Proc->Out=*PrvOut;
   \                     ??ProcSPK_Action_7:
   \   00000088   1088               LDRH     R0,[R2, #+0]
   \   0000008A   5882               STRH     R0,[R3, #+18]
    916          }//_______________________ Koniec funkcji__ ____________________________
   \   0000008C   70BC               POP      {R4-R6}
   \   0000008E   01BC               POP      {R0}
   \   00000090   0047               BX       R0               ;; return
   \   00000092   C046               Nop      
   \                     ??ProcSPK_Action_1:
   \   00000094   ........           DC32     Speaker
   \   00000098   ........           DC32     ButtonBipCounter
   \   0000009C   ........           DC32     g_counter
   \   000000A0   E0930400           DC32     0x493e0
   \   000000A4   30F4FFFF           DC32     0xfffff430
   \   000000A8   34F4FFFF           DC32     0xfffff434
    917          
    918          
    919          
    920          
    921          
    922          //*-----------------------------------------------------------------------------
    923          //* Nazwa funkcji :    ProcSumL_Action
    924          //* Funkcja procedury "Sumy logicznej"
    925          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    926          void ProcSumL_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    927          {  
    928            Proc->Out=*PrvOut | *UpOut;   
   \                     ProcSumL_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   0988               LDRH     R1,[R1, #+0]
   \   00000004   0143               ORRS     R1,R1,R0
   \   00000006   5182               STRH     R1,[R2, #+18]
    929          }//_______________________ Koniec funkcji__ ____________________________
   \   00000008   7047               BX       LR               ;; return
    930          
    931          
    932          
    933          //*-----------------------------------------------------------------------------
    934          //* Nazwa funkcji :    ProcIncDec_Action
    935          //* Funkcja procedury "Inkrementuj scenê"
    936          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    937          void ProcTimerSet_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    938          {  
   \                     ProcTimerSet_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    939             if ((*PrvOut)==0)
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   825E               LDRSH    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   01D1               BNE      ??ProcTimerSet_Action_0
    940             {
    941               Proc->Out=0;
   \   0000000A   4A82               STRH     R2,[R1, #+18]
   \   0000000C   14E0               B        ??ProcTimerSet_Action_1
    942             }else{
    943               if ((*PrvOut) && (Proc->LastIn==0))
   \                     ??ProcTimerSet_Action_0:
   \   0000000E   0022               MOVS     R2,#+0
   \   00000010   825E               LDRSH    R2,[R0, R2]
   \   00000012   002A               CMP      R2,#+0
   \   00000014   07D0               BEQ      ??ProcTimerSet_Action_2
   \   00000016   0A7C               LDRB     R2,[R1, #+16]
   \   00000018   002A               CMP      R2,#+0
   \   0000001A   04D1               BNE      ??ProcTimerSet_Action_2
    944               {  
    945                 Proc->Tag.CounterStartTime=g_seconds_counter; 
   \   0000001C   094A               LDR      R2,??ProcTimerSet_Action_3  ;; g_seconds_counter
   \   0000001E   1268               LDR      R2,[R2, #+0]
   \   00000020   CA60               STR      R2,[R1, #+12]
    946                 Proc->Out=0;
   \   00000022   0022               MOVS     R2,#+0
   \   00000024   4A82               STRH     R2,[R1, #+18]
    947               }
    948               
    949               if ((Proc->Tag.CounterStartTime+Proc->Tag.SetCounter)<g_seconds_counter)
   \                     ??ProcTimerSet_Action_2:
   \   00000026   CA68               LDR      R2,[R1, #+12]
   \   00000028   8B68               LDR      R3,[R1, #+8]
   \   0000002A   D218               ADDS     R2,R2,R3
   \   0000002C   054B               LDR      R3,??ProcTimerSet_Action_3  ;; g_seconds_counter
   \   0000002E   1B68               LDR      R3,[R3, #+0]
   \   00000030   9A42               CMP      R2,R3
   \   00000032   9241               SBCS     R2,R2,R2
   \   00000034   D20F               LSRS     R2,R2,#+31
   \   00000036   4A82               STRH     R2,[R1, #+18]
    950               {
    951                 Proc->Out=1;
    952               }else{
    953                 Proc->Out=0;
    954               }
    955             }   
    956             
    957             Proc->LastIn=*PrvOut;
   \                     ??ProcTimerSet_Action_1:
   \   00000038   0088               LDRH     R0,[R0, #+0]
   \   0000003A   0874               STRB     R0,[R1, #+16]
    958          }//_______________________ Koniec funkcji__ ____________________________
   \   0000003C   08BC               POP      {R3}
   \   0000003E   01BC               POP      {R0}
   \   00000040   0047               BX       R0               ;; return
   \   00000042   C046               Nop      
   \                     ??ProcTimerSet_Action_3:
   \   00000044   ........           DC32     g_seconds_counter
    959          
    960          
    961          
    962          
    963          
    964          
    965          //*-----------------------------------------------------------------------------
    966          //* Nazwa funkcji :    ProcClock_Action
    967          //* Funkcja procedury "Zegar"
    968          //*-----------------------------------------------------------------------------
    969          

   \                                 In section Debug.txt, align 4, keep-with-next
    970          void ProcClock_Action(short int *PrvOut, _Procedure *Proc) 
    971          {  
   \                     ProcClock_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    972             Proc->Out=0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   4A82               STRH     R2,[R1, #+18]
    973             if (*PrvOut)
   \   00000006   805E               LDRSH    R0,[R0, R2]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   31D0               BEQ      ??ProcClock_Action_0
    974             {
    975                if ((Proc->Tag.ClkPrcType==PrcMounth) && (Proc->Tag.ClkPrcVal==DateTime.Mounth))  Proc->Out=1; 
   \   0000000C   087A               LDRB     R0,[R1, #+8]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   06D1               BNE      ??ProcClock_Action_1
   \   00000012   487A               LDRB     R0,[R1, #+9]
   \   00000014   184A               LDR      R2,??ProcClock_Action_2  ;; DateTime + 1
   \   00000016   1278               LDRB     R2,[R2, #+0]
   \   00000018   9042               CMP      R0,R2
   \   0000001A   01D1               BNE      ??ProcClock_Action_1
   \   0000001C   0120               MOVS     R0,#+1
   \   0000001E   4882               STRH     R0,[R1, #+18]
    976                if ((Proc->Tag.ClkPrcType==PrcDay)    && (Proc->Tag.ClkPrcVal==DateTime.Day))     Proc->Out=1; 
   \                     ??ProcClock_Action_1:
   \   00000020   087A               LDRB     R0,[R1, #+8]
   \   00000022   0128               CMP      R0,#+1
   \   00000024   06D1               BNE      ??ProcClock_Action_3
   \   00000026   487A               LDRB     R0,[R1, #+9]
   \   00000028   144A               LDR      R2,??ProcClock_Action_2+0x4  ;; DateTime + 2
   \   0000002A   1278               LDRB     R2,[R2, #+0]
   \   0000002C   9042               CMP      R0,R2
   \   0000002E   01D1               BNE      ??ProcClock_Action_3
   \   00000030   0120               MOVS     R0,#+1
   \   00000032   4882               STRH     R0,[R1, #+18]
    977                if ((Proc->Tag.ClkPrcType==PrcHour)   && (Proc->Tag.ClkPrcVal==DateTime.Hour))    Proc->Out=1; 
   \                     ??ProcClock_Action_3:
   \   00000034   087A               LDRB     R0,[R1, #+8]
   \   00000036   0228               CMP      R0,#+2
   \   00000038   06D1               BNE      ??ProcClock_Action_4
   \   0000003A   487A               LDRB     R0,[R1, #+9]
   \   0000003C   104A               LDR      R2,??ProcClock_Action_2+0x8  ;; DateTime + 3
   \   0000003E   1278               LDRB     R2,[R2, #+0]
   \   00000040   9042               CMP      R0,R2
   \   00000042   01D1               BNE      ??ProcClock_Action_4
   \   00000044   0120               MOVS     R0,#+1
   \   00000046   4882               STRH     R0,[R1, #+18]
    978                if ((Proc->Tag.ClkPrcType==PrcMinute) && (Proc->Tag.ClkPrcVal==DateTime.Minute))  Proc->Out=1;  
   \                     ??ProcClock_Action_4:
   \   00000048   087A               LDRB     R0,[R1, #+8]
   \   0000004A   0328               CMP      R0,#+3
   \   0000004C   06D1               BNE      ??ProcClock_Action_5
   \   0000004E   487A               LDRB     R0,[R1, #+9]
   \   00000050   0C4A               LDR      R2,??ProcClock_Action_2+0xC  ;; DateTime + 4
   \   00000052   1278               LDRB     R2,[R2, #+0]
   \   00000054   9042               CMP      R0,R2
   \   00000056   01D1               BNE      ??ProcClock_Action_5
   \   00000058   0120               MOVS     R0,#+1
   \   0000005A   4882               STRH     R0,[R1, #+18]
    979                if ((Proc->Tag.ClkPrcType==PrcSecond) && (Proc->Tag.ClkPrcVal==DateTime.Second))  Proc->Out=1; 
   \                     ??ProcClock_Action_5:
   \   0000005C   087A               LDRB     R0,[R1, #+8]
   \   0000005E   0428               CMP      R0,#+4
   \   00000060   06D1               BNE      ??ProcClock_Action_0
   \   00000062   487A               LDRB     R0,[R1, #+9]
   \   00000064   084A               LDR      R2,??ProcClock_Action_2+0x10  ;; DateTime + 5
   \   00000066   1278               LDRB     R2,[R2, #+0]
   \   00000068   9042               CMP      R0,R2
   \   0000006A   01D1               BNE      ??ProcClock_Action_0
   \   0000006C   0120               MOVS     R0,#+1
   \   0000006E   4882               STRH     R0,[R1, #+18]
    980                        
    981          
    982             }
    983          
    984          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcClock_Action_0:
   \   00000070   08BC               POP      {R3}
   \   00000072   01BC               POP      {R0}
   \   00000074   0047               BX       R0               ;; return
   \   00000076   C046               Nop      
   \                     ??ProcClock_Action_2:
   \   00000078   ........           DC32     DateTime + 1
   \   0000007C   ........           DC32     DateTime + 2
   \   00000080   ........           DC32     DateTime + 3
   \   00000084   ........           DC32     DateTime + 4
   \   00000088   ........           DC32     DateTime + 5
    985          
    986          
    987          
    988          //*-----------------------------------------------------------------------------
    989          //* Nazwa funkcji :    ProcDay_Action
    990          //* Funkcja procedury "Dnia tygodnia"
    991          //*-----------------------------------------------------------------------------
    992          

   \                                 In section Debug.txt, align 4, keep-with-next
    993          void ProcDay_Action(short int *PrvOut, _Procedure *Proc) 
    994          {  
   \                     ProcDay_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    995             Proc->Out=0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   4A82               STRH     R2,[R1, #+18]
    996             if (*PrvOut)
   \   00000006   805E               LDRSH    R0,[R0, R2]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   06D0               BEQ      ??ProcDay_Action_0
    997             {
    998                if (Proc->Tag.DayOfWeek==DateTime.DayOfWeek)  Proc->Out=1; 
   \   0000000C   087A               LDRB     R0,[R1, #+8]
   \   0000000E   044A               LDR      R2,??ProcDay_Action_1  ;; DateTime + 6
   \   00000010   1278               LDRB     R2,[R2, #+0]
   \   00000012   9042               CMP      R0,R2
   \   00000014   01D1               BNE      ??ProcDay_Action_0
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   4882               STRH     R0,[R1, #+18]
    999          
   1000             }
   1001          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcDay_Action_0:
   \   0000001A   08BC               POP      {R3}
   \   0000001C   01BC               POP      {R0}
   \   0000001E   0047               BX       R0               ;; return
   \                     ??ProcDay_Action_1:
   \   00000020   ........           DC32     DateTime + 6
   1002          
   1003          
   1004          
   1005          
   1006          
   1007          
   1008          
   1009          //*-----------------------------------------------------------------------------
   1010          //* Nazwa funkcji :    Program
   1011          //* Funkcja opóŸnienia
   1012          //*-----------------------------------------------------------------------------
   1013          volatile char Busy_program=0;
   1014          
   1015          char SceneNrLast=0;
   1016          char RealPrcLines=MaxPrcLines;
   1017          
   1018          int PtogTime=0;
   1019          unsigned long last_time;
   1020          

   \                                 In section Debug.txt, align 4, keep-with-next
   1021          void Program (_ProgramTab *ProgTab) 
   1022          { 
   \                     Program:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   1023              static int MemCol=0;
   1024              static int MemRow=0;
   1025              int StartLineNr=0;
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   2600               MOVS     R6,R4
   1026              int StartPrcInLine=0;
   \   00000008   0194               STR      R4,[SP, #+4]
   \   0000000A   CD4D               LDR      R5,??Program_1   ;; Trap
   \   0000000C   A87A               LDRB     R0,[R5, #+10]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   00D0               BEQ      .+4
   \   00000012   33E2               B        ??Program_2
   \   00000014   0120               MOVS     R0,#+1
   \   00000016   A872               STRB     R0,[R5, #+10]
   1027              
   1028              if (Busy_program==0)
   1029              {
   1030                Busy_program=1;
   1031              
   1032          
   1033             last_time=g_counter;
   \   00000018   CA48               LDR      R0,??Program_1+0x4  ;; g_counter
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   A863               STR      R0,[R5, #+56]
   1034            
   1035          
   1036            
   1037            short int StPrvPrc; //stan poprzedniej procedury
   1038            short int StUpPrc; //stan procedury z linii wy¿ej, z tej samej kolumny dla sumy logicznej
   1039            
   1040            if ((Trap.Enable) && (Trap.Change))
   \   0000001E   2878               LDRB     R0,[R5, #+0]
   \   00000020   0028               CMP      R0,#+0
   \   00000022   07D0               BEQ      ??Program_3
   \   00000024   2879               LDRB     R0,[R5, #+4]
   \   00000026   0028               CMP      R0,#+0
   \   00000028   04D0               BEQ      ??Program_3
   1041                  {
   1042                    StartPrcInLine=MemCol;
   \   0000002A   E86B               LDR      R0,[R5, #+60]
   \   0000002C   0190               STR      R0,[SP, #+4]
   1043                    StartLineNr=MemRow;
   \   0000002E   2E6C               LDR      R6,[R5, #+64]
   1044                    Trap.Change=0;
   \   00000030   2000               MOVS     R0,R4
   \   00000032   2871               STRB     R0,[R5, #+4]
   1045                  }
   1046            
   1047             
   1048                
   1049                          
   1050                 
   1051                   
   1052            
   1053                 for (char NB=0; NB<NumberButton; NB++)
   \                     ??Program_3:
   \   00000034   2100               MOVS     R1,R4
   \   00000036   08E0               B        ??Program_4
   1054                 {
   1055                      MainStage.StageButtonExe[NB]=MainStage.StageButton[NB];  
   \                     ??Program_5:
   \   00000038   0A00               MOVS     R2,R1
   \   0000003A   C348               LDR      R0,??Program_1+0x8  ;; MainStage
   \   0000003C   8318               ADDS     R3,R0,R2
   \   0000003E   5033               ADDS     R3,R3,#+80
   \   00000040   805C               LDRB     R0,[R0, R2]
   \   00000042   1870               STRB     R0,[R3, #+0]
   1056                 }
   \   00000044   491C               ADDS     R1,R1,#+1
   \   00000046   0906               LSLS     R1,R1,#+24
   \   00000048   090E               LSRS     R1,R1,#+24
   \                     ??Program_4:
   \   0000004A   0800               MOVS     R0,R1
   \   0000004C   5028               CMP      R0,#+80
   \   0000004E   F3D3               BCC      ??Program_5
   1057            
   1058            
   1059            
   1060                for (int LineNr=StartLineNr; LineNr<RealPrcLines; LineNr++)
   \   00000050   00E0               B        ??Program_6
   \                     ??Program_7:
   \   00000052   761C               ADDS     R6,R6,#+1
   \                     ??Program_6:
   \   00000054   287B               LDRB     R0,[R5, #+12]
   \   00000056   8642               CMP      R6,R0
   \   00000058   00DB               BLT      .+4
   \   0000005A   D4E1               B        ??Program_8
   1061                {
   1062                  for (int PrcInLine=StartPrcInLine; PrcInLine<MaxPrcInLine; PrcInLine++)
   \   0000005C   019F               LDR      R7,[SP, #+4]
   \   0000005E   1DE0               B        ??Program_9
   1063                  {
   1064                   
   1065                    
   1066          
   1067                    
   1068                    
   1069                    
   1070                   if ((Trap.Enable) &&  (Trap.Row==LineNr) && (Trap.Col==PrcInLine)) 
   1071                   {
   1072                     Trap.Activ=1; 
   1073                     MemCol=PrcInLine;
   1074                     MemRow=LineNr;
   1075                      
   1076                   }
   1077                   if ((Trap.Enable==0) || (Trap.Activ==0) )
   1078                   {
   1079          
   1080                     
   1081                   if (Trap.Enable==0)
   1082                   {
   1083                    MemCol=PrcInLine;
   1084                    MemRow=LineNr;
   1085                   }  
   1086                     
   1087                     
   1088                     if (ProgTab->Line[LineNr].Proc[PrcInLine].Type!=None)
   1089                     {
   1090                        if (PrcInLine==0)
   1091                        {
   1092                          StPrvPrc= 1;
   1093                        }else{
   1094                          StPrvPrc= (ProgTab->Line[LineNr].Proc[PrcInLine-1].Out);
   1095                        }
   1096                        
   1097                        
   1098          
   1099                        switch (ProgTab->Line[LineNr].Proc[PrcInLine].Type)
   1100                        {    
   1101                            case ProcConect     : ProcConect_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1102                            case ProcDown       : ProcDown_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1103                            case ProcDownRight  : ProcDownRight_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1104                            case ProcSumLogRight     : 
   1105                                                StUpPrc= 0;
   1106                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1107                                                ProcSumL_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1108                                                break;
   1109                            case ProcSumLogDown     : 
   1110                                                StUpPrc= 0;
   1111                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1112                                                ProcSumL_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1113                                                break;
   1114                            case ProcUpToRight     : 
   1115                                                StUpPrc= 0;
   1116                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1117                                                ProcUpToRight_Action(&StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1118                                                break;
   1119                                                
   1120                            case ProcUpToRightDown    : 
   1121                                                StUpPrc= 0;
   1122                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1123                                                ProcUpToRightDown_Action(&StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1124                                                break;                    
   1125                                             
   1126                           
   1127                            
   1128                            case ProcNOT        : ProcNOT_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;         
   1129                            case ProcToggleRS   : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1130                                                  ProcToggleRS_Action(&StPrvPrc, &StUpPrc,  &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;    
   1131                            case ProcToggleT    : ProcToggleT_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;         
   1132                            case ProcTLI1       : ProcTLI1_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;         
   1133                            case ProcStI        : ProcStI_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1134                            case ProcStNI       : ProcStNI_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1135                            case ProcStQ        : ProcStQ_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1136                            case ProcStB        : ProcStB_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1137                            case ProcStS        : ProcStS_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1138                            case ProcWOUT       : ProcWOUT_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1139                            case ProcWOUTS      : ProcWOUTS_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]),&MainStage); break;
   1140                            case ProcWOUTR      : ProcWOUTR_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]),&MainStage); break;
   1141                            case ProcWOUTC      : ProcWOUTC_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]),&MainStage); break;
   1142                            case ProcSetScn     : ProcSetScn_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1143                            case ProcInc        : ProcInc_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;             
   1144                            case ProcDec        : ProcDec_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;             
   1145                            case ProcSPK        : ProcSPK_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break; 
   1146                            case ProcTimerSet   : ProcTimerSet_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1147                            case ProcClock      : ProcClock_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1148                            case ProcDay        : ProcDay_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1149                            case ProcGetReg     : ProcGetReg_Action(&(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1150                            case ProcSetReg     : ProcSetAnal_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1151                            case ProcConstAnal  : ProcConstAnal_Action(&(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1152                            case ProcLim        : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1153                                                  ProcLim_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1154                            case ProcEven       : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1155                                                  ProcEven_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1156                            case ProcPlus       : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1157                                                  ProcPlus_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1158                            case ProcMinus      : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1159                                                  ProcMinus_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1160                            case ProcMul        : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1161                                                  ProcMul_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1162                            case ProcDiv        : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   \                     ??Program_10:
   \   00000060   002E               CMP      R6,#+0
   \   00000062   04D0               BEQ      ??Program_11
   \   00000064   6946               MOV      R1,SP
   \   00000066   0200               MOVS     R2,R0
   \   00000068   C63A               SUBS     R2,R2,#+198
   \   0000006A   1288               LDRH     R2,[R2, #+0]
   \   0000006C   4A80               STRH     R2,[R1, #+2]
   1163                                                  ProcDiv_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   \                     ??Program_11:
   \   0000006E   1830               ADDS     R0,R0,#+24
   \   00000070   0200               MOVS     R2,R0
   \   00000072   00A9               ADD      R1,SP,#+0
   \   00000074   891C               ADDS     R1,R1,#+2
   \   00000076   6846               MOV      R0,SP
   \   00000078   ........           BL       ProcDiv_Action
   1164          
   1165                            
   1166                        }
   1167                        
   1168                     }  
   1169                    
   1170                   
   1171                   
   1172                   
   1173                   
   1174                   
   1175                   if ((LineNr==RealPrcLines-1) && (PrcInLine==MaxPrcInLine-1))
   \                     ??Program_12:
   \   0000007C   287B               LDRB     R0,[R5, #+12]
   \   0000007E   401E               SUBS     R0,R0,#+1
   \   00000080   8642               CMP      R6,R0
   \   00000082   0AD1               BNE      ??Program_13
   \   00000084   092F               CMP      R7,#+9
   \   00000086   08D1               BNE      ??Program_13
   1176                    { 
   1177                    
   1178                        //ThermostatsExecute();
   1179          
   1180                          /* 
   1181                          for (char iNrQ=0; iNrQ<NumberNeurons; iNrQ++)
   1182                          {  
   1183                            for (char iNrReg=0; iNrReg<NumberReg; iNrReg++)
   1184                          {
   1185                            MainStage.StageQ[iNrQ].Value[iNrReg]=MainStage.StageQ_TMP[iNrQ].Value[iNrReg]; 
   1186                          }
   1187                          
   1188                          }
   1189                          */
   1190          
   1191                      /*
   1192                      for (char iNrReg=0; iNrReg<NumberReg; iNrReg++)
   1193                      {
   1194                        MainStage.StageI[0].Value[iNrReg]=MainStage.StageQ[0].Value[iNrReg]; 
   1195                      }
   1196                     */
   1197           
   1198            
   1199                      if (MainStage.SceneNr!=SceneNrLast)
   \   00000088   AF48               LDR      R0,??Program_1+0x8  ;; MainStage
   \   0000008A   B049               LDR      R1,??Program_1+0xC  ;; 0x6ea
   \   0000008C   405C               LDRB     R0,[R0, R1]
   \   0000008E   E97A               LDRB     R1,[R5, #+11]
   \   00000090   8842               CMP      R0,R1
   \   00000092   02D0               BEQ      ??Program_13
   1200                      {
   1201                        SceneNrLast=MainStage.SceneNr;
   \   00000094   E872               STRB     R0,[R5, #+11]
   1202                        MenuPaint();
   \   00000096   ........           BL       MenuPaint
   1203                      }
   1204           
   1205                   
   1206          
   1207                   }
   \                     ??Program_13:
   \   0000009A   7F1C               ADDS     R7,R7,#+1
   \                     ??Program_9:
   \   0000009C   0A2F               CMP      R7,#+10
   \   0000009E   D8DA               BGE      ??Program_7
   \   000000A0   2878               LDRB     R0,[R5, #+0]
   \   000000A2   0028               CMP      R0,#+0
   \   000000A4   09D0               BEQ      ??Program_14
   \   000000A6   6878               LDRB     R0,[R5, #+1]
   \   000000A8   B042               CMP      R0,R6
   \   000000AA   06D1               BNE      ??Program_14
   \   000000AC   A878               LDRB     R0,[R5, #+2]
   \   000000AE   B842               CMP      R0,R7
   \   000000B0   03D1               BNE      ??Program_14
   \   000000B2   0120               MOVS     R0,#+1
   \   000000B4   E870               STRB     R0,[R5, #+3]
   \   000000B6   EF63               STR      R7,[R5, #+60]
   \   000000B8   2E64               STR      R6,[R5, #+64]
   \                     ??Program_14:
   \   000000BA   2878               LDRB     R0,[R5, #+0]
   \   000000BC   0028               CMP      R0,#+0
   \   000000BE   02D0               BEQ      ??Program_15
   \   000000C0   E978               LDRB     R1,[R5, #+3]
   \   000000C2   0029               CMP      R1,#+0
   \   000000C4   E9D1               BNE      ??Program_13
   \                     ??Program_15:
   \   000000C6   0028               CMP      R0,#+0
   \   000000C8   01D1               BNE      ??Program_16
   \   000000CA   EF63               STR      R7,[R5, #+60]
   \   000000CC   2E64               STR      R6,[R5, #+64]
   \                     ??Program_16:
   \   000000CE   1820               MOVS     R0,#+24
   \   000000D0   7843               MULS     R0,R7,R0
   \   000000D2   F021               MOVS     R1,#+240
   \   000000D4   7143               MULS     R1,R6,R1
   \   000000D6   029A               LDR      R2,[SP, #+8]
   \   000000D8   5118               ADDS     R1,R2,R1
   \   000000DA   0818               ADDS     R0,R1,R0
   \   000000DC   0100               MOVS     R1,R0
   \   000000DE   1231               ADDS     R1,R1,#+18
   \   000000E0   8A79               LDRB     R2,[R1, #+6]
   \   000000E2   002A               CMP      R2,#+0
   \   000000E4   CAD0               BEQ      ??Program_12
   \   000000E6   002F               CMP      R7,#+0
   \   000000E8   6A46               MOV      R2,SP
   \   000000EA   02D1               BNE      ??Program_17
   \   000000EC   0123               MOVS     R3,#+1
   \   000000EE   1380               STRH     R3,[R2, #+0]
   \   000000F0   01E0               B        ??Program_18
   \                     ??Program_17:
   \   000000F2   0B88               LDRH     R3,[R1, #+0]
   \   000000F4   1380               STRH     R3,[R2, #+0]
   \                     ??Program_18:
   \   000000F6   8979               LDRB     R1,[R1, #+6]
   \   000000F8   891E               SUBS     R1,R1,#+2
   \   000000FA   3D29               CMP      R1,#+61
   \   000000FC   BED8               BHI      ??Program_12
   \   000000FE   02A2               ADR      R2,??Program_0
   \   00000100   4900               LSLS     R1,R1,#+1
   \   00000102   525E               LDRSH    R2,[R2, R1]
   \   00000104   9744               ADD      PC,PC,R2
   \   00000106   C046               Nop      
   \                     ??Program_0:
   \   00000108   7C008A009800       DC16     +124,+138,+152,+198
   \              C600        
   \   00000110   A600DA00FA00       DC16     +166,+218,+250,+282
   \              1A01        
   \   00000118   280146015201       DC16     +296,+326,+338,+65396
   \              74FF        
   \   00000120   74FF74FF74FF       DC16     +65396,+65396,+65396,+65396
   \              74FF        
   \   00000128   74FF74FF5E01       DC16     +65396,+65396,+350,+364
   \              6C01        
   \   00000130   7A0188019601       DC16     +378,+392,+406,+65396
   \              74FF        
   \   00000138   74FF74FF74FF       DC16     +65396,+65396,+65396,+65396
   \              74FF        
   \   00000140   74FF74FFA401       DC16     +65396,+65396,+420,+434
   \              B201        
   \   00000148   C001CE01DC01       DC16     +448,+462,+476,+490
   \              EA01        
   \   00000150   F801060274FF       DC16     +504,+518,+65396,+65396
   \              74FF        
   \   00000158   74FF74FF74FF       DC16     +65396,+65396,+65396,+530
   \              1202        
   \   00000160   20022C0274FF       DC16     +544,+556,+65396,+65396
   \              74FF        
   \   00000168   74FF74FF74FF       DC16     +65396,+65396,+65396,+65396
   \              74FF        
   \   00000170   74FF60024802       DC16     +65396,+608,+584,+594
   \              5202        
   \   00000178   68028602A402       DC16     +616,+646,+676,+706
   \              C202        
   \   00000180   E00258FF           DC16     +736,+65368
   \                     ??Program_19:
   \   00000184   704A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000186   1830               ADDS     R0,R0,#+24
   \   00000188   0100               MOVS     R1,R0
   \   0000018A   6846               MOV      R0,SP
   \   0000018C   ........           BL       ProcConect_Action
   \   00000190   74E7               B        ??Program_12
   \                     ??Program_20:
   \   00000192   6D4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000194   1830               ADDS     R0,R0,#+24
   \   00000196   0100               MOVS     R1,R0
   \   00000198   6846               MOV      R0,SP
   \   0000019A   ........           BL       ProcDown_Action
   \   0000019E   6DE7               B        ??Program_12
   \                     ??Program_21:
   \   000001A0   694A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000001A2   1830               ADDS     R0,R0,#+24
   \   000001A4   0100               MOVS     R1,R0
   \   000001A6   6846               MOV      R0,SP
   \   000001A8   ........           BL       ProcDownRight_Action
   \   000001AC   66E7               B        ??Program_12
   \                     ??Program_22:
   \   000001AE   6946               MOV      R1,SP
   \   000001B0   2200               MOVS     R2,R4
   \   000001B2   4A80               STRH     R2,[R1, #+2]
   \   000001B4   002E               CMP      R6,#+0
   \   000001B6   03D0               BEQ      ??Program_23
   \   000001B8   0200               MOVS     R2,R0
   \   000001BA   C63A               SUBS     R2,R2,#+198
   \   000001BC   1288               LDRH     R2,[R2, #+0]
   \   000001BE   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_23:
   \   000001C0   1830               ADDS     R0,R0,#+24
   \   000001C2   0200               MOVS     R2,R0
   \   000001C4   891C               ADDS     R1,R1,#+2
   \   000001C6   6846               MOV      R0,SP
   \   000001C8   ........           BL       ProcSumL_Action
   \   000001CC   56E7               B        ??Program_12
   \                     ??Program_24:
   \   000001CE   6946               MOV      R1,SP
   \   000001D0   2200               MOVS     R2,R4
   \   000001D2   4A80               STRH     R2,[R1, #+2]
   \   000001D4   002E               CMP      R6,#+0
   \   000001D6   F3D0               BEQ      ??Program_23
   \   000001D8   0200               MOVS     R2,R0
   \   000001DA   C63A               SUBS     R2,R2,#+198
   \   000001DC   1288               LDRH     R2,[R2, #+0]
   \   000001DE   4A80               STRH     R2,[R1, #+2]
   \   000001E0   EEE7               B        ??Program_23
   \                     ??Program_25:
   \   000001E2   6946               MOV      R1,SP
   \   000001E4   2200               MOVS     R2,R4
   \   000001E6   4A80               STRH     R2,[R1, #+2]
   \   000001E8   002E               CMP      R6,#+0
   \   000001EA   03D0               BEQ      ??Program_26
   \   000001EC   0200               MOVS     R2,R0
   \   000001EE   C63A               SUBS     R2,R2,#+198
   \   000001F0   1288               LDRH     R2,[R2, #+0]
   \   000001F2   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_26:
   \   000001F4   1830               ADDS     R0,R0,#+24
   \   000001F6   0100               MOVS     R1,R0
   \   000001F8   00A8               ADD      R0,SP,#+0
   \   000001FA   801C               ADDS     R0,R0,#+2
   \   000001FC   ........           BL       ProcUpToRight_Action
   \   00000200   3CE7               B        ??Program_12
   \                     ??Program_27:
   \   00000202   6946               MOV      R1,SP
   \   00000204   2200               MOVS     R2,R4
   \   00000206   4A80               STRH     R2,[R1, #+2]
   \   00000208   002E               CMP      R6,#+0
   \   0000020A   03D0               BEQ      ??Program_28
   \   0000020C   0200               MOVS     R2,R0
   \   0000020E   C63A               SUBS     R2,R2,#+198
   \   00000210   1288               LDRH     R2,[R2, #+0]
   \   00000212   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_28:
   \   00000214   1830               ADDS     R0,R0,#+24
   \   00000216   0100               MOVS     R1,R0
   \   00000218   00A8               ADD      R0,SP,#+0
   \   0000021A   801C               ADDS     R0,R0,#+2
   \   0000021C   ........           BL       ProcUpToRightDown_Action
   \   00000220   2CE7               B        ??Program_12
   \                     ??Program_29:
   \   00000222   494A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000224   1830               ADDS     R0,R0,#+24
   \   00000226   0100               MOVS     R1,R0
   \   00000228   6846               MOV      R0,SP
   \   0000022A   ........           BL       ProcNOT_Action
   \   0000022E   25E7               B        ??Program_12
   \                     ??Program_30:
   \   00000230   002E               CMP      R6,#+0
   \   00000232   04D0               BEQ      ??Program_31
   \   00000234   6946               MOV      R1,SP
   \   00000236   0200               MOVS     R2,R0
   \   00000238   C63A               SUBS     R2,R2,#+198
   \   0000023A   1288               LDRH     R2,[R2, #+0]
   \   0000023C   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_31:
   \   0000023E   1830               ADDS     R0,R0,#+24
   \   00000240   0200               MOVS     R2,R0
   \   00000242   00A9               ADD      R1,SP,#+0
   \   00000244   891C               ADDS     R1,R1,#+2
   \   00000246   6846               MOV      R0,SP
   \   00000248   ........           BL       ProcToggleRS_Action
   \   0000024C   16E7               B        ??Program_12
   \                     ??Program_32:
   \   0000024E   1830               ADDS     R0,R0,#+24
   \   00000250   0100               MOVS     R1,R0
   \   00000252   6846               MOV      R0,SP
   \   00000254   ........           BL       ProcToggleT_Action
   \   00000258   10E7               B        ??Program_12
   \                     ??Program_33:
   \   0000025A   1830               ADDS     R0,R0,#+24
   \   0000025C   0100               MOVS     R1,R0
   \   0000025E   6846               MOV      R0,SP
   \   00000260   ........           BL       ProcTLI1_Action
   \   00000264   0AE7               B        ??Program_12
   \                     ??Program_34:
   \   00000266   384A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000268   1830               ADDS     R0,R0,#+24
   \   0000026A   0100               MOVS     R1,R0
   \   0000026C   6846               MOV      R0,SP
   \   0000026E   ........           BL       ProcStI_Action
   \   00000272   03E7               B        ??Program_12
   \                     ??Program_35:
   \   00000274   344A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000276   1830               ADDS     R0,R0,#+24
   \   00000278   0100               MOVS     R1,R0
   \   0000027A   6846               MOV      R0,SP
   \   0000027C   ........           BL       ProcStNI_Action
   \   00000280   FCE6               B        ??Program_12
   \                     ??Program_36:
   \   00000282   314A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000284   1830               ADDS     R0,R0,#+24
   \   00000286   0100               MOVS     R1,R0
   \   00000288   6846               MOV      R0,SP
   \   0000028A   ........           BL       ProcStQ_Action
   \   0000028E   F5E6               B        ??Program_12
   \                     ??Program_37:
   \   00000290   2D4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000292   1830               ADDS     R0,R0,#+24
   \   00000294   0100               MOVS     R1,R0
   \   00000296   6846               MOV      R0,SP
   \   00000298   ........           BL       ProcStB_Action
   \   0000029C   EEE6               B        ??Program_12
   \                     ??Program_38:
   \   0000029E   2A4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002A0   1830               ADDS     R0,R0,#+24
   \   000002A2   0100               MOVS     R1,R0
   \   000002A4   6846               MOV      R0,SP
   \   000002A6   ........           BL       ProcStS_Action
   \   000002AA   E7E6               B        ??Program_12
   \                     ??Program_39:
   \   000002AC   264A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002AE   1830               ADDS     R0,R0,#+24
   \   000002B0   0100               MOVS     R1,R0
   \   000002B2   6846               MOV      R0,SP
   \   000002B4   ........           BL       ProcWOUT_Action
   \   000002B8   E0E6               B        ??Program_12
   \                     ??Program_40:
   \   000002BA   234A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002BC   1830               ADDS     R0,R0,#+24
   \   000002BE   0100               MOVS     R1,R0
   \   000002C0   6846               MOV      R0,SP
   \   000002C2   ........           BL       ProcWOUTS_Action
   \   000002C6   D9E6               B        ??Program_12
   \                     ??Program_41:
   \   000002C8   1F4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002CA   1830               ADDS     R0,R0,#+24
   \   000002CC   0100               MOVS     R1,R0
   \   000002CE   6846               MOV      R0,SP
   \   000002D0   ........           BL       ProcWOUTR_Action
   \   000002D4   D2E6               B        ??Program_12
   \                     ??Program_42:
   \   000002D6   1C4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002D8   1830               ADDS     R0,R0,#+24
   \   000002DA   0100               MOVS     R1,R0
   \   000002DC   6846               MOV      R0,SP
   \   000002DE   ........           BL       ProcWOUTC_Action
   \   000002E2   CBE6               B        ??Program_12
   \                     ??Program_43:
   \   000002E4   184A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002E6   1830               ADDS     R0,R0,#+24
   \   000002E8   0100               MOVS     R1,R0
   \   000002EA   6846               MOV      R0,SP
   \   000002EC   ........           BL       ProcSetScn_Action
   \   000002F0   C4E6               B        ??Program_12
   \                     ??Program_44:
   \   000002F2   154A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002F4   1830               ADDS     R0,R0,#+24
   \   000002F6   0100               MOVS     R1,R0
   \   000002F8   6846               MOV      R0,SP
   \   000002FA   ........           BL       ProcInc_Action
   \   000002FE   BDE6               B        ??Program_12
   \                     ??Program_45:
   \   00000300   114A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000302   1830               ADDS     R0,R0,#+24
   \   00000304   0100               MOVS     R1,R0
   \   00000306   6846               MOV      R0,SP
   \   00000308   ........           BL       ProcDec_Action
   \   0000030C   B6E6               B        ??Program_12
   \                     ??Program_46:
   \   0000030E   1830               ADDS     R0,R0,#+24
   \   00000310   0100               MOVS     R1,R0
   \   00000312   6846               MOV      R0,SP
   \   00000314   ........           BL       ProcSPK_Action
   \   00000318   B0E6               B        ??Program_12
   \                     ??Program_47:
   \   0000031A   0B4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   0000031C   1830               ADDS     R0,R0,#+24
   \   0000031E   0100               MOVS     R1,R0
   \   00000320   6846               MOV      R0,SP
   \   00000322   ........           BL       ProcTimerSet_Action
   \   00000326   A9E6               B        ??Program_12
   \                     ??Program_48:
   \   00000328   1830               ADDS     R0,R0,#+24
   \   0000032A   0100               MOVS     R1,R0
   \   0000032C   6846               MOV      R0,SP
   \   0000032E   ........           BL       ProcClock_Action
   \   00000332   A3E6               B        ??Program_12
   \                     ??Program_49:
   \   00000334   1830               ADDS     R0,R0,#+24
   \   00000336   0100               MOVS     R1,R0
   \   00000338   6846               MOV      R0,SP
   \   0000033A   ........           BL       ProcDay_Action
   \   0000033E   9DE6               B        ??Program_12
   \                     ??Program_1:
   \   00000340   ........           DC32     Trap
   \   00000344   ........           DC32     g_counter
   \   00000348   ........           DC32     MainStage
   \   0000034C   EA060000           DC32     0x6ea
   \                     ??Program_50:
   \   00000350   4E49               LDR      R1,??Program_51  ;; MainStage
   \   00000352   1830               ADDS     R0,R0,#+24
   \   00000354   ........           BL       ProcGetReg_Action
   \   00000358   90E6               B        ??Program_12
   \                     ??Program_52:
   \   0000035A   4C4A               LDR      R2,??Program_51  ;; MainStage
   \   0000035C   1830               ADDS     R0,R0,#+24
   \   0000035E   0100               MOVS     R1,R0
   \   00000360   6846               MOV      R0,SP
   \   00000362   ........           BL       ProcSetAnal_Action
   \   00000366   89E6               B        ??Program_12
   \                     ??Program_53:
   \   00000368   1830               ADDS     R0,R0,#+24
   \   0000036A   ........           BL       ProcConstAnal_Action
   \   0000036E   85E6               B        ??Program_12
   \                     ??Program_54:
   \   00000370   002E               CMP      R6,#+0
   \   00000372   04D0               BEQ      ??Program_55
   \   00000374   6946               MOV      R1,SP
   \   00000376   0200               MOVS     R2,R0
   \   00000378   C63A               SUBS     R2,R2,#+198
   \   0000037A   1288               LDRH     R2,[R2, #+0]
   \   0000037C   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_55:
   \   0000037E   1830               ADDS     R0,R0,#+24
   \   00000380   0200               MOVS     R2,R0
   \   00000382   00A9               ADD      R1,SP,#+0
   \   00000384   891C               ADDS     R1,R1,#+2
   \   00000386   6846               MOV      R0,SP
   \   00000388   ........           BL       ProcLim_Action
   \   0000038C   76E6               B        ??Program_12
   \                     ??Program_56:
   \   0000038E   002E               CMP      R6,#+0
   \   00000390   04D0               BEQ      ??Program_57
   \   00000392   6946               MOV      R1,SP
   \   00000394   0200               MOVS     R2,R0
   \   00000396   C63A               SUBS     R2,R2,#+198
   \   00000398   1288               LDRH     R2,[R2, #+0]
   \   0000039A   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_57:
   \   0000039C   1830               ADDS     R0,R0,#+24
   \   0000039E   0200               MOVS     R2,R0
   \   000003A0   00A9               ADD      R1,SP,#+0
   \   000003A2   891C               ADDS     R1,R1,#+2
   \   000003A4   6846               MOV      R0,SP
   \   000003A6   ........           BL       ProcEven_Action
   \   000003AA   67E6               B        ??Program_12
   \                     ??Program_58:
   \   000003AC   002E               CMP      R6,#+0
   \   000003AE   04D0               BEQ      ??Program_59
   \   000003B0   6946               MOV      R1,SP
   \   000003B2   0200               MOVS     R2,R0
   \   000003B4   C63A               SUBS     R2,R2,#+198
   \   000003B6   1288               LDRH     R2,[R2, #+0]
   \   000003B8   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_59:
   \   000003BA   1830               ADDS     R0,R0,#+24
   \   000003BC   0200               MOVS     R2,R0
   \   000003BE   00A9               ADD      R1,SP,#+0
   \   000003C0   891C               ADDS     R1,R1,#+2
   \   000003C2   6846               MOV      R0,SP
   \   000003C4   ........           BL       ProcPlus_Action
   \   000003C8   58E6               B        ??Program_12
   \                     ??Program_60:
   \   000003CA   002E               CMP      R6,#+0
   \   000003CC   04D0               BEQ      ??Program_61
   \   000003CE   6946               MOV      R1,SP
   \   000003D0   0200               MOVS     R2,R0
   \   000003D2   C63A               SUBS     R2,R2,#+198
   \   000003D4   1288               LDRH     R2,[R2, #+0]
   \   000003D6   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_61:
   \   000003D8   1830               ADDS     R0,R0,#+24
   \   000003DA   0200               MOVS     R2,R0
   \   000003DC   00A9               ADD      R1,SP,#+0
   \   000003DE   891C               ADDS     R1,R1,#+2
   \   000003E0   6846               MOV      R0,SP
   \   000003E2   ........           BL       ProcMinus_Action
   \   000003E6   49E6               B        ??Program_12
   \                     ??Program_62:
   \   000003E8   002E               CMP      R6,#+0
   \   000003EA   04D0               BEQ      ??Program_63
   \   000003EC   6946               MOV      R1,SP
   \   000003EE   0200               MOVS     R2,R0
   \   000003F0   C63A               SUBS     R2,R2,#+198
   \   000003F2   1288               LDRH     R2,[R2, #+0]
   \   000003F4   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_63:
   \   000003F6   1830               ADDS     R0,R0,#+24
   \   000003F8   0200               MOVS     R2,R0
   \   000003FA   00A9               ADD      R1,SP,#+0
   \   000003FC   891C               ADDS     R1,R1,#+2
   \   000003FE   6846               MOV      R0,SP
   \   00000400   ........           BL       ProcMul_Action
   \   00000404   3AE6               B        ??Program_12
   1208                   
   1209                   
   1210                  }
   1211                  
   1212                  
   1213                }
   1214              }
   1215            
   1216            
   1217            
   1218            //zerowanie wyjœæ  z flagami impulsu      
   1219                 for (char iNrQ=0; iNrQ<NumberNeurons; iNrQ++)
   \                     ??Program_8:
   \   00000406   2100               MOVS     R1,R4
   \   00000408   21E0               B        ??Program_64
   1220                 {
   1221                    if ((MainStage.StageQImpulse[iNrQ]) && (MainStage.SendStageChange[iNrQ]==0))
   \                     ??Program_65:
   \   0000040A   0F00               MOVS     R7,R1
   \   0000040C   1F48               LDR      R0,??Program_51  ;; MainStage
   \   0000040E   204A               LDR      R2,??Program_51+0x4  ;; 0x6a4
   \   00000410   7B00               LSLS     R3,R7,#+1
   \   00000412   C318               ADDS     R3,R0,R3
   \   00000414   9A18               ADDS     R2,R3,R2
   \   00000416   1388               LDRH     R3,[R2, #+0]
   \   00000418   002B               CMP      R3,#+0
   \   0000041A   15D0               BEQ      ??Program_66
   \   0000041C   1D4B               LDR      R3,??Program_51+0x8  ;; 0x6eb
   \   0000041E   C619               ADDS     R6,R0,R7
   \   00000420   F318               ADDS     R3,R6,R3
   \   00000422   1E78               LDRB     R6,[R3, #+0]
   \   00000424   002E               CMP      R6,#+0
   \   00000426   0FD1               BNE      ??Program_66
   1222                    {
   1223                      MainStage.StageQ[iNrQ].Port &=~(MainStage.StageQImpulse[iNrQ]); 
   \   00000428   1B4E               LDR      R6,??Program_51+0xC  ;; 0x3a2
   \   0000042A   B446               MOV      R12,R6
   \   0000042C   1626               MOVS     R6,#+22
   \   0000042E   7743               MULS     R7,R6,R7
   \   00000430   C019               ADDS     R0,R0,R7
   \   00000432   6646               MOV      R6,R12
   \   00000434   8019               ADDS     R0,R0,R6
   \   00000436   0688               LDRH     R6,[R0, #+0]
   \   00000438   1788               LDRH     R7,[R2, #+0]
   \   0000043A   BE43               BICS     R6,R6,R7
   \   0000043C   0680               STRH     R6,[R0, #+0]
   1224                      MainStage.StageQImpulse[iNrQ]=0;
   \   0000043E   2000               MOVS     R0,R4
   \   00000440   1080               STRH     R0,[R2, #+0]
   1225                      MainStage.SendStageChange[iNrQ]=ChangeStageFlag;
   \   00000442   1648               LDR      R0,??Program_51+0x10  ;; ChangeStageFlag
   \   00000444   0078               LDRB     R0,[R0, #+0]
   \   00000446   1870               STRB     R0,[R3, #+0]
   1226                    } 
   1227                 }
   \                     ??Program_66:
   \   00000448   491C               ADDS     R1,R1,#+1
   \   0000044A   0906               LSLS     R1,R1,#+24
   \   0000044C   090E               LSRS     R1,R1,#+24
   \                     ??Program_64:
   \   0000044E   0800               MOVS     R0,R1
   \   00000450   2328               CMP      R0,#+35
   \   00000452   DAD3               BCC      ??Program_65
   1228            
   1229            //zerowanie zmiennych  z flagami impulsu  
   1230            for (char i=0; i<sizeof(VariablesImpulse); i++)
   \   00000454   2000               MOVS     R0,R4
   \   00000456   0EE0               B        ??Program_67
   1231            {
   1232              if (VariablesImpulse[i]>0)
   \                     ??Program_68:
   \   00000458   0100               MOVS     R1,R0
   \   0000045A   6918               ADDS     R1,R5,R1
   \   0000045C   2022               MOVS     R2,#+32
   \   0000045E   8A5C               LDRB     R2,[R1, R2]
   \   00000460   002A               CMP      R2,#+0
   \   00000462   05D0               BEQ      ??Program_69
   1233              {
   1234                Variables[i]&=~(VariablesImpulse[i]);
   \   00000464   0B7C               LDRB     R3,[R1, #+16]
   \   00000466   9343               BICS     R3,R3,R2
   \   00000468   0B74               STRB     R3,[R1, #+16]
   1235                VariablesImpulse[i]=0;
   \   0000046A   2031               ADDS     R1,R1,#+32
   \   0000046C   2200               MOVS     R2,R4
   \   0000046E   0A70               STRB     R2,[R1, #+0]
   1236              }
   1237            }
   \                     ??Program_69:
   \   00000470   401C               ADDS     R0,R0,#+1
   \   00000472   0006               LSLS     R0,R0,#+24
   \   00000474   000E               LSRS     R0,R0,#+24
   \                     ??Program_67:
   \   00000476   0D28               CMP      R0,#+13
   \   00000478   EED3               BCC      ??Program_68
   1238            
   1239            
   1240            
   1241            Busy_program=0;
   \   0000047A   AC72               STRB     R4,[R5, #+10]
   1242            
   1243              }
   1244             
   1245              
   1246              PtogTime=g_counter-last_time;
   \                     ??Program_2:
   \   0000047C   0848               LDR      R0,??Program_51+0x14  ;; g_counter
   \   0000047E   0068               LDR      R0,[R0, #+0]
   \   00000480   A96B               LDR      R1,[R5, #+56]
   \   00000482   401A               SUBS     R0,R0,R1
   \   00000484   6863               STR      R0,[R5, #+52]
   1247          
   1248          }//_______________________ Koniec funkcji program__ ____________________________
   \   00000486   FEBC               POP      {R1-R7}
   \   00000488   01BC               POP      {R0}
   \   0000048A   0047               BX       R0               ;; return
   \                     ??Program_51:
   \   0000048C   ........           DC32     MainStage
   \   00000490   A4060000           DC32     0x6a4
   \   00000494   EB060000           DC32     0x6eb
   \   00000498   A2030000           DC32     0x3a2
   \   0000049C   ........           DC32     ChangeStageFlag
   \   000004A0   ........           DC32     g_counter

   \                                 In section .data, align 4
   \                     Trap:
   \   00000000   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \                     NumberScene:
   \   00000008   0A                 DC8 10
   \                     LastScene:
   \   00000009   00                 DC8 0
   \                     Busy_program:
   \   0000000A   00                 DC8 0
   \                     SceneNrLast:
   \   0000000B   00                 DC8 0
   \                     RealPrcLines:
   \   0000000C   C8                 DC8 200
   \   0000000D   000000             DC8 0, 0, 0
   \                     Variables:
   \   00000010   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     VariablesImpulse:
   \   00000020   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     ScreenUse:
   \   00000030   0000               DC8 0, 0
   \   00000032   0000               DC8 0, 0
   \                     PtogTime:
   \   00000034   00000000           DC32 0
   \                     last_time:
   \   00000038   00000000           DC8 0, 0, 0, 0
   \   0000003C   00000000           DC32 0
   \   00000040   00000000           DC32 0

   \                                 In section .data, align 4
   \                     pProg:
   \   00000000   ........           DC32 gProg
   1249          
   1250          
   1251          
   1252          //-----------------------------------------------------------------------------
   1253          // Nazwa funkcji :    SceneNrCount
   1254          // Funkcja zlicza u¿ywane w programie u¿ytkowym sceny. Odpowiedzi¹ jest iloœæ scen
   1255          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1256          char SceneNrCount(_ProgramTab *ProgTab)
   1257          {
   \                     SceneNrCount:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0100               MOVS     R1,R0
   1258                char MaxScnNr=0;
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   1000               MOVS     R0,R2
   1259                for (int LineNr=0; LineNr<MaxPrcLines; LineNr++)
   \   00000008   1300               MOVS     R3,R2
   \   0000000A   14E0               B        ??SceneNrCount_0
   1260                {
   1261                  for (int PrcInLine=0; PrcInLine<MaxPrcInLine; PrcInLine++)
   1262                  {
   1263                     if ((ProgTab->Line[LineNr].Proc[PrcInLine].Type==ProcStS) && (ProgTab->Line[LineNr].Proc[PrcInLine].Nr>MaxScnNr))
   \                     ??SceneNrCount_1:
   \   0000000C   1825               MOVS     R5,#+24
   \   0000000E   6543               MULS     R5,R4,R5
   \   00000010   F026               MOVS     R6,#+240
   \   00000012   5E43               MULS     R6,R3,R6
   \   00000014   8E19               ADDS     R6,R1,R6
   \   00000016   7519               ADDS     R5,R6,R5
   \   00000018   2E7E               LDRB     R6,[R5, #+24]
   \   0000001A   182E               CMP      R6,#+24
   \   0000001C   07D1               BNE      ??SceneNrCount_2
   \   0000001E   0600               MOVS     R6,R0
   \   00000020   1927               MOVS     R7,#+25
   \   00000022   EF57               LDRSB    R7,[R5, R7]
   \   00000024   BE42               CMP      R6,R7
   \   00000026   02DA               BGE      ??SceneNrCount_2
   1264                     {
   1265                       MaxScnNr=ProgTab->Line[LineNr].Proc[PrcInLine].Nr;
   \   00000028   3800               MOVS     R0,R7
   \   0000002A   0006               LSLS     R0,R0,#+24
   \   0000002C   000E               LSRS     R0,R0,#+24
   1266                     }
   1267                  }
   \                     ??SceneNrCount_2:
   \   0000002E   641C               ADDS     R4,R4,#+1
   \                     ??SceneNrCount_3:
   \   00000030   0A2C               CMP      R4,#+10
   \   00000032   EBDB               BLT      ??SceneNrCount_1
   \   00000034   5B1C               ADDS     R3,R3,#+1
   \                     ??SceneNrCount_0:
   \   00000036   C82B               CMP      R3,#+200
   \   00000038   01DA               BGE      ??SceneNrCount_4
   \   0000003A   1400               MOVS     R4,R2
   \   0000003C   F8E7               B        ??SceneNrCount_3
   1268                  
   1269                }
   1270            
   1271                return MaxScnNr;
   \                     ??SceneNrCount_4:
   \   0000003E   F8BC               POP      {R3-R7}
   \   00000040   02BC               POP      {R1}
   \   00000042   0847               BX       R1               ;; return
   1272          }//_______________________ Koniec funkcji_______________________________________
   1273          
   1274          
   1275          
   1276          
   1277             
   1278          //-----------------------------------------------------------------------------
   1279          // Nazwa funkcji :    ScreenNrCount
   1280          // Funkcja zlicza u¿ywane ekrany. Odpowiedzi¹ jest suma logiczna u¿ywanych ekranów
   1281          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1282          short CheckScreenUse(_ProgramTab *ProgTab)
   1283          {
   \                     CheckScreenUse:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0120               MOVS     R0,#+1
   1284            
   1285                short ScreenUse=1; 
   1286               
   1287                char f=1;  
   \   00000004   0100               MOVS     R1,R0
   \   00000006   0022               MOVS     R2,#+0
   \   00000008   28E0               B        ??CheckScreenUse_0
   1288            
   1289                char sc=0;
   1290                _ScreenPaternDesign *ScreenPaternDesign; 
   1291                while ((f)&&(sc<ScreenNr))
   1292                {
   1293                  f=0;
   1294                  
   1295                       if (sc==0) 
   1296                      {
   1297                        ScreenPaternDesign=ScreenSetTab_0;
   1298                      }else{
   1299                        ScreenPaternDesign=ScreenSetTab_1; 
   1300                      }  
   1301          
   1302                  for (int bt=0; bt<ScrenButtonNr; bt++)
   1303                  {
   1304                    if ((ScreenPaternDesign[ProgTab->Screen[sc].PaternDesign].Button[bt].Width>0) && (ProgTab->Screen[sc].Button[bt].OpenPage>0) )
   \                     ??CheckScreenUse_1:
   \   0000000A   1500               MOVS     R5,R2
   \   0000000C   A026               MOVS     R6,#+160
   \   0000000E   7543               MULS     R5,R6,R5
   \   00000010   009E               LDR      R6,[SP, #+0]
   \   00000012   7519               ADDS     R5,R6,R5
   \   00000014   A700               LSLS     R7,R4,#+2
   \   00000016   BC46               MOV      R12,R7
   \   00000018   184E               LDR      R6,??CheckScreenUse_2  ;; 0xbb98
   \   0000001A   AF5D               LDRB     R7,[R5, R6]
   \   0000001C   5826               MOVS     R6,#+88
   \   0000001E   7743               MULS     R7,R6,R7
   \   00000020   DE19               ADDS     R6,R3,R7
   \   00000022   6746               MOV      R7,R12
   \   00000024   F619               ADDS     R6,R6,R7
   \   00000026   B678               LDRB     R6,[R6, #+2]
   \   00000028   002E               CMP      R6,#+0
   \   0000002A   11D0               BEQ      ??CheckScreenUse_3
   \   0000002C   144E               LDR      R6,??CheckScreenUse_2+0x4  ;; 0xbbaa
   \   0000002E   E700               LSLS     R7,R4,#+3
   \   00000030   ED19               ADDS     R5,R5,R7
   \   00000032   AD19               ADDS     R5,R5,R6
   \   00000034   0F26               MOVS     R6,#+15
   \   00000036   2F78               LDRB     R7,[R5, #+0]
   \   00000038   3742               TST      R7,R6
   \   0000003A   09D0               BEQ      ??CheckScreenUse_3
   1305                    {
   1306                      ScreenUse |=1<<(ProgTab->Screen[sc].Button[bt].OpenPage-1);
   \   0000003C   0121               MOVS     R1,#+1
   \   0000003E   3D00               MOVS     R5,R7
   \   00000040   2E40               ANDS     R6,R6,R5
   \   00000042   751E               SUBS     R5,R6,#+1
   \   00000044   A940               LSLS     R1,R1,R5
   \   00000046   0143               ORRS     R1,R1,R0
   \   00000048   0904               LSLS     R1,R1,#+16
   \   0000004A   0914               ASRS     R1,R1,#+16
   \   0000004C   0800               MOVS     R0,R1
   1307                      f=1;
   \   0000004E   0121               MOVS     R1,#+1
   1308                    }
   1309                  }
   \                     ??CheckScreenUse_3:
   \   00000050   641C               ADDS     R4,R4,#+1
   \                     ??CheckScreenUse_4:
   \   00000052   092C               CMP      R4,#+9
   \   00000054   D9DB               BLT      ??CheckScreenUse_1
   1310                  sc++;
   \   00000056   521C               ADDS     R2,R2,#+1
   \   00000058   1206               LSLS     R2,R2,#+24
   \   0000005A   120E               LSRS     R2,R2,#+24
   \                     ??CheckScreenUse_0:
   \   0000005C   0029               CMP      R1,#+0
   \   0000005E   0AD0               BEQ      ??CheckScreenUse_5
   \   00000060   1100               MOVS     R1,R2
   \   00000062   0829               CMP      R1,#+8
   \   00000064   07D2               BCS      ??CheckScreenUse_5
   \   00000066   0021               MOVS     R1,#+0
   \   00000068   1300               MOVS     R3,R2
   \   0000006A   01D1               BNE      ??CheckScreenUse_6
   \   0000006C   054B               LDR      R3,??CheckScreenUse_2+0x8  ;; ScreenSetTab_0
   \   0000006E   00E0               B        ??CheckScreenUse_7
   \                     ??CheckScreenUse_6:
   \   00000070   054B               LDR      R3,??CheckScreenUse_2+0xC  ;; ScreenSetTab_1
   \                     ??CheckScreenUse_7:
   \   00000072   0C00               MOVS     R4,R1
   \   00000074   EDE7               B        ??CheckScreenUse_4
   1311                  
   1312                }
   1313                
   1314           
   1315            
   1316                return ScreenUse;
   \                     ??CheckScreenUse_5:
   \   00000076   F8BC               POP      {R3-R7}
   \   00000078   02BC               POP      {R1}
   \   0000007A   0847               BX       R1               ;; return
   \                     ??CheckScreenUse_2:
   \   0000007C   98BB0000           DC32     0xbb98
   \   00000080   AABB0000           DC32     0xbbaa
   \   00000084   ........           DC32     ScreenSetTab_0
   \   00000088   ........           DC32     ScreenSetTab_1
   1317            
   1318          }//_______________________ Koniec funkcji_______________________________________
   1319          
   1320          
   1321               
   1322               
   1323               

   \                                 In section Debug.txt, align 4, keep-with-next
   1324          void CountLines(_ProgramTab *ProgTab)
   1325          {
   \                     CountLines:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   1326               char UseLine=0;
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0A00               MOVS     R2,R1
   1327                  for (char j=0; j<MaxPrcLines; j++)
   \   00000006   0B00               MOVS     R3,R1
   \   00000008   13E0               B        ??CountLines_0
   1328                    for (char i=0; i<MaxPrcInLine; i++) 
   1329                      if (ProgTab->Line[j].Proc[i].Type>0) UseLine=j;
   \                     ??CountLines_1:
   \   0000000A   1826               MOVS     R6,#+24
   \   0000000C   7543               MULS     R5,R6,R5
   \   0000000E   1E00               MOVS     R6,R3
   \   00000010   F027               MOVS     R7,#+240
   \   00000012   7E43               MULS     R6,R7,R6
   \   00000014   8619               ADDS     R6,R0,R6
   \   00000016   7519               ADDS     R5,R6,R5
   \   00000018   2D7E               LDRB     R5,[R5, #+24]
   \   0000001A   002D               CMP      R5,#+0
   \   0000001C   00D0               BEQ      ??CountLines_2
   \   0000001E   1A00               MOVS     R2,R3
   \                     ??CountLines_2:
   \   00000020   641C               ADDS     R4,R4,#+1
   \   00000022   2406               LSLS     R4,R4,#+24
   \   00000024   240E               LSRS     R4,R4,#+24
   \                     ??CountLines_3:
   \   00000026   2500               MOVS     R5,R4
   \   00000028   0A2D               CMP      R5,#+10
   \   0000002A   EED3               BCC      ??CountLines_1
   \   0000002C   5B1C               ADDS     R3,R3,#+1
   \   0000002E   1B06               LSLS     R3,R3,#+24
   \   00000030   1B0E               LSRS     R3,R3,#+24
   \                     ??CountLines_0:
   \   00000032   1C00               MOVS     R4,R3
   \   00000034   C82C               CMP      R4,#+200
   \   00000036   01D2               BCS      ??CountLines_4
   \   00000038   0C00               MOVS     R4,R1
   \   0000003A   F4E7               B        ??CountLines_3
   1330              RealPrcLines=UseLine+1; 
   \                     ??CountLines_4:
   \   0000003C   0248               LDR      R0,??CountLines_5  ;; Trap + 12
   \   0000003E   521C               ADDS     R2,R2,#+1
   \   00000040   0270               STRB     R2,[R0, #+0]
   1331          }
   \   00000042   F8BC               POP      {R3-R7}
   \   00000044   01BC               POP      {R0}
   \   00000046   0047               BX       R0               ;; return
   \                     ??CountLines_5:
   \   00000048   ........           DC32     Trap + 12
   1332          
   1333          
   1334          

   \                                 In section Debug.txt, align 4, keep-with-next
   1335          void RefreshNeuronsList(_ProgramTab *ProgTab)
   1336          {
   \                     RefreshNeuronsList:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0024               MOVS     R4,#+0
   \   00000004   09E0               B        ??RefreshNeuronsList_0
   1337            for (char i=0; i<NumberNeurons; i++)
   1338            {
   1339             if (ProgTab->NeuronsIdTab[i]>0)
   1340             {
   1341                 NeuronsList[i].NeuronType=(_NeuronType)((ProgTab->NeuronsIdTab[i])/1000000);
   1342                 NeuronsList[i].NeuronID=(ProgTab->NeuronsIdTab[i])-(NeuronsList[i].NeuronType*1000000);
   1343             }else{
   1344                 NeuronsList[i].NeuronType=(_NeuronType)0;
   \                     ??RefreshNeuronsList_1:
   \   00000006   0C21               MOVS     R1,#+12
   \   00000008   4843               MULS     R0,R1,R0
   \   0000000A   1349               LDR      R1,??RefreshNeuronsList_2  ;; NeuronsList
   \   0000000C   0E18               ADDS     R6,R1,R0
   \   0000000E   0020               MOVS     R0,#+0
   \   00000010   3070               STRB     R0,[R6, #+0]
   1345                 NeuronsList[i].NeuronID=0;
   \   00000012   7060               STR      R0,[R6, #+4]
   1346             }
   \                     ??RefreshNeuronsList_3:
   \   00000014   641C               ADDS     R4,R4,#+1
   \   00000016   2406               LSLS     R4,R4,#+24
   \   00000018   240E               LSRS     R4,R4,#+24
   \                     ??RefreshNeuronsList_0:
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   2328               CMP      R0,#+35
   \   0000001E   17D2               BCS      ??RefreshNeuronsList_4
   \   00000020   0E49               LDR      R1,??RefreshNeuronsList_2+0x4  ;; 0xc098
   \   00000022   8200               LSLS     R2,R0,#+2
   \   00000024   009B               LDR      R3,[SP, #+0]
   \   00000026   9A18               ADDS     R2,R3,R2
   \   00000028   5518               ADDS     R5,R2,R1
   \   0000002A   2968               LDR      R1,[R5, #+0]
   \   0000002C   0129               CMP      R1,#+1
   \   0000002E   EADB               BLT      ??RefreshNeuronsList_1
   \   00000030   0C21               MOVS     R1,#+12
   \   00000032   4843               MULS     R0,R1,R0
   \   00000034   0849               LDR      R1,??RefreshNeuronsList_2  ;; NeuronsList
   \   00000036   0E18               ADDS     R6,R1,R0
   \   00000038   094F               LDR      R7,??RefreshNeuronsList_2+0x8  ;; 0xf4240
   \   0000003A   2868               LDR      R0,[R5, #+0]
   \   0000003C   3900               MOVS     R1,R7
   \   0000003E   ........           BL       __aeabi_idivmod
   \   00000042   3070               STRB     R0,[R6, #+0]
   \   00000044   2868               LDR      R0,[R5, #+0]
   \   00000046   3178               LDRB     R1,[R6, #+0]
   \   00000048   7943               MULS     R1,R7,R1
   \   0000004A   401A               SUBS     R0,R0,R1
   \   0000004C   7060               STR      R0,[R6, #+4]
   \   0000004E   E1E7               B        ??RefreshNeuronsList_3
   1347            }
   1348          }
   \                     ??RefreshNeuronsList_4:
   \   00000050   F8BC               POP      {R3-R7}
   \   00000052   01BC               POP      {R0}
   \   00000054   0047               BX       R0               ;; return
   \   00000056   C046               Nop      
   \                     ??RefreshNeuronsList_2:
   \   00000058   ........           DC32     NeuronsList
   \   0000005C   98C00000           DC32     0xc098
   \   00000060   40420F00           DC32     0xf4240
   1349          
   1350          
   1351          
   1352          //-----------------------------------------------------------------------------
   1353          // Nazwa funkcji :    AddRsTask
   1354          // Funkcja ustawia dodanie zadania dla transmisji Rs
   1355          // Ord - typ rozkazu : odczyt wejœæ, zapis
   1356          // Node - nr wêz³a/urz¹dzenia
   1357          // Reg  - nr rejestru w wêŸle 
   1358          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1359          void AddRsTask(_OrderType Ord, char Node, char Reg)
   1360          { 
   \                     AddRsTask:
   \   00000000   F4B5               PUSH     {R2,R4-R7,LR}
   1361               ptr_ZD_MODBUS ZD_MODBUS;
   1362               ZD_MODBUS         =   ZD_MODBUS_0;
   1363               
   1364              char OrdExist=0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   1400               MOVS     R4,R2
   1365              char RfOrd=0;
   \   00000006   1300               MOVS     R3,R2
   1366              char FreePlace=0;
   1367              
   1368              
   1369              //przepisanie rozkazu na zrozumia³y dla tablicy zadañ Rs
   1370              if (Ord==SI) RfOrd=0x4; 
   \   00000008   0128               CMP      R0,#+1
   \   0000000A   00D1               BNE      ??AddRsTask_0
   \   0000000C   0423               MOVS     R3,#+4
   1371              if (Ord==SQ) RfOrd=0xF; 
   \                     ??AddRsTask_0:
   \   0000000E   0228               CMP      R0,#+2
   \   00000010   00D1               BNE      ??AddRsTask_1
   \   00000012   0F23               MOVS     R3,#+15
   1372          
   1373                
   1374          
   1375                    
   1376              //Sprawdzenie czy taki rozkaz nie istnieje w tablicy
   1377              char i=0;
   \                     ??AddRsTask_1:
   \   00000014   1000               MOVS     R0,R2
   \   00000016   1FE0               B        ??AddRsTask_2
   1378              while ((i<ZD_MODBUS_Tab_Max) && (OrdExist==0))
   1379              {
   1380                 if ((ZD_MODBUS[i].Adress==Node) && 
   1381                     (ZD_MODBUS[i].Function==RfOrd) &&
   1382                     (ZD_MODBUS[i].Target==Reg) &&
   1383                     (ZD_MODBUS[i].StartAdr==Node-0))
   \                     ??AddRsTask_3:
   \   00000018   264D               LDR      R5,??AddRsTask_4  ;; ZD_MODBUS_0
   \   0000001A   0600               MOVS     R6,R0
   \   0000001C   0D27               MOVS     R7,#+13
   \   0000001E   7E43               MULS     R6,R7,R6
   \   00000020   AD19               ADDS     R5,R5,R6
   \   00000022   2E78               LDRB     R6,[R5, #+0]
   \   00000024   8E42               CMP      R6,R1
   \   00000026   14D1               BNE      ??AddRsTask_5
   \   00000028   6E78               LDRB     R6,[R5, #+1]
   \   0000002A   9E42               CMP      R6,R3
   \   0000002C   11D1               BNE      ??AddRsTask_5
   \   0000002E   AE78               LDRB     R6,[R5, #+2]
   \   00000030   EF78               LDRB     R7,[R5, #+3]
   \   00000032   3F06               LSLS     R7,R7,#+24
   \   00000034   3F0C               LSRS     R7,R7,#+16
   \   00000036   3E43               ORRS     R6,R6,R7
   \   00000038   6F46               MOV      R7,SP
   \   0000003A   3F78               LDRB     R7,[R7, #+0]
   \   0000003C   BE42               CMP      R6,R7
   \   0000003E   08D1               BNE      ??AddRsTask_5
   \   00000040   2E79               LDRB     R6,[R5, #+4]
   \   00000042   6F79               LDRB     R7,[R5, #+5]
   \   00000044   3F06               LSLS     R7,R7,#+24
   \   00000046   3F0C               LSRS     R7,R7,#+16
   \   00000048   3E43               ORRS     R6,R6,R7
   \   0000004A   0D00               MOVS     R5,R1
   \   0000004C   AE42               CMP      R6,R5
   \   0000004E   00D1               BNE      ??AddRsTask_5
   1384                    {
   1385                      OrdExist=1;
   \   00000050   0124               MOVS     R4,#+1
   1386                    }
   1387                 i++;
   \                     ??AddRsTask_5:
   \   00000052   401C               ADDS     R0,R0,#+1
   \   00000054   0006               LSLS     R0,R0,#+24
   \   00000056   000E               LSRS     R0,R0,#+24
   1388              }
   \                     ??AddRsTask_2:
   \   00000058   0500               MOVS     R5,R0
   \   0000005A   142D               CMP      R5,#+20
   \   0000005C   01D2               BCS      ??AddRsTask_6
   \   0000005E   2500               MOVS     R5,R4
   \   00000060   DAD0               BEQ      ??AddRsTask_3
   1389              
   1390              //je¿eli rozkaz nie istnieje to dodaj
   1391              if (OrdExist==0)
   \                     ??AddRsTask_6:
   \   00000062   002C               CMP      R4,#+0
   \   00000064   23D1               BNE      ??AddRsTask_7
   1392              {
   1393                //znajdŸ wolne miejsce w tablicy zadañ 
   1394                FreePlace=0;
   \   00000066   02E0               B        ??AddRsTask_8
   1395                while ((FreePlace<ZD_MODBUS_Tab_Max) && (ZD_MODBUS[FreePlace].Adress!=0)) FreePlace++;
   \                     ??AddRsTask_9:
   \   00000068   521C               ADDS     R2,R2,#+1
   \   0000006A   1206               LSLS     R2,R2,#+24
   \   0000006C   120E               LSRS     R2,R2,#+24
   \                     ??AddRsTask_8:
   \   0000006E   1000               MOVS     R0,R2
   \   00000070   1428               CMP      R0,#+20
   \   00000072   05D2               BCS      ??AddRsTask_10
   \   00000074   0D24               MOVS     R4,#+13
   \   00000076   6043               MULS     R0,R4,R0
   \   00000078   0E4C               LDR      R4,??AddRsTask_4  ;; ZD_MODBUS_0
   \   0000007A   205C               LDRB     R0,[R4, R0]
   \   0000007C   0028               CMP      R0,#+0
   \   0000007E   F3D1               BNE      ??AddRsTask_9
   1396                
   1397                
   1398                if (FreePlace<ZD_MODBUS_Tab_Max)     //jezeli jest miejsce w tablicy to dodaj
   \                     ??AddRsTask_10:
   \   00000080   1000               MOVS     R0,R2
   \   00000082   1428               CMP      R0,#+20
   \   00000084   13D2               BCS      ??AddRsTask_7
   1399                { 
   1400                  ZD_MODBUS[FreePlace].Adress=Node;
   \   00000086   0B4D               LDR      R5,??AddRsTask_4  ;; ZD_MODBUS_0
   \   00000088   0D20               MOVS     R0,#+13
   \   0000008A   4243               MULS     R2,R0,R2
   \   0000008C   A818               ADDS     R0,R5,R2
   \   0000008E   0170               STRB     R1,[R0, #+0]
   1401                  ZD_MODBUS[FreePlace].Function=RfOrd;
   \   00000090   4370               STRB     R3,[R0, #+1]
   1402                  ZD_MODBUS[FreePlace].Target=Reg;
   \   00000092   6A46               MOV      R2,SP
   \   00000094   1278               LDRB     R2,[R2, #+0]
   \   00000096   8270               STRB     R2,[R0, #+2]
   \   00000098   120A               LSRS     R2,R2,#+8
   \   0000009A   C270               STRB     R2,[R0, #+3]
   1403                  ZD_MODBUS[FreePlace].StartAdr=Node-0;   //miejsce w pamiêci do pobrania danych (odpowiada nodowi)
   \   0000009C   0171               STRB     R1,[R0, #+4]
   \   0000009E   090A               LSRS     R1,R1,#+8
   \   000000A0   4171               STRB     R1,[R0, #+5]
   1404                  ZD_MODBUS[FreePlace].Coil=16;
   \   000000A2   1021               MOVS     R1,#+16
   \   000000A4   8171               STRB     R1,[R0, #+6]
   \   000000A6   090A               LSRS     R1,R1,#+8
   \   000000A8   C171               STRB     R1,[R0, #+7]
   1405                  ZD_MODBUS[FreePlace].Error=0x0; 
   \   000000AA   C172               STRB     R1,[R0, #+11]
   \   000000AC   0173               STRB     R1,[R0, #+12]
   1406                }
   1407                
   1408                
   1409              }
   1410              
   1411                
   1412          
   1413                
   1414                          
   1415          }//_______________________ Koniec funkcji  AddRsTask _________________
   \                     ??AddRsTask_7:
   \   000000AE   F8BC               POP      {R3-R7}
   \   000000B0   01BC               POP      {R0}
   \   000000B2   0047               BX       R0               ;; return
   \                     ??AddRsTask_4:
   \   000000B4   ........           DC32     ZD_MODBUS_0
   1416          
   1417          
   1418          
   1419          
   1420          
   1421          //-----------------------------------------------------------------------------
   1422          // Nazwa funkcji :    AddRfTask_SearchNode
   1423          // Funkcja ustawia dodanie zadania dla transmisji Rs "Ramka rozg³oœna z wyszukaniem wêz³a"
   1424          // Funkcja zastêpuje wszystkie zadanie z rozkazem R_RegOrd (odczytu statusu) rz¹danego wêz³a oraz blokuje odpytywanie wêz³a
   1425          // Node - nr wêz³a/urz¹dzeia
   1426          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1427          void AddRfTask_SearchNodeTask(char Node)
   1428          { 
   \                     AddRfTask_SearchNodeTask:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   1429              if (NeuronsList[Node-1].ReadSuspend) return;
   \   00000002   0C21               MOVS     R1,#+12
   \   00000004   4143               MULS     R1,R0,R1
   \   00000006   1C4A               LDR      R2,??AddRfTask_SearchNodeTask_0  ;; NeuronsList
   \   00000008   5118               ADDS     R1,R2,R1
   \   0000000A   0839               SUBS     R1,R1,#+8
   \   0000000C   0A79               LDRB     R2,[R1, #+4]
   \   0000000E   5207               LSLS     R2,R2,#+29
   \   00000010   2ED4               BMI      ??AddRfTask_SearchNodeTask_1
   1430          
   1431              for (char i=0; i<RF_Tasks-1; i++)  
   \   00000012   0022               MOVS     R2,#+0
   \   00000014   0CE0               B        ??AddRfTask_SearchNodeTask_2
   1432              {
   1433                 //znalezienie rozkazu odpytania statusu
   1434                 if ((RF_TaskTab[i].Node==Node) && 
   1435                     (RF_TaskTab[i].Command.ID==NeuronsList[Node-1].NeuronID) &&
   1436                     ((RF_TaskTab[i].Command.Order==R_RegOrd) || (RF_TaskTab[i].Command.Order==W_RegOrd)) )
   1437                 {
   1438                     if (RF_TaskTab[i].Command.Order==R_RegOrd)
   1439                     {
   1440                        RF_TaskTab[i].Command.Order=R_BC_Order;
   1441                     }else{
   1442                        RF_TaskTab[i].Command.Order=W_BC_Order;
   \                     ??AddRfTask_SearchNodeTask_3:
   \   00000016   194D               LDR      R5,??AddRfTask_SearchNodeTask_0+0x4  ;; 0xff0fffff
   \   00000018   2540               ANDS     R5,R5,R4
   \   0000001A   8024               MOVS     R4,#+128
   \   0000001C   2404               LSLS     R4,R4,#+16       ;; #+8388608
   \   0000001E   2C43               ORRS     R4,R4,R5
   \   00000020   5C60               STR      R4,[R3, #+4]
   1443                     }
   1444                     NeuronsList[Node-1].ReadSuspend=1;
   \                     ??AddRfTask_SearchNodeTask_4:
   \   00000022   0B79               LDRB     R3,[R1, #+4]
   \   00000024   0424               MOVS     R4,#+4
   \   00000026   1C43               ORRS     R4,R4,R3
   \   00000028   0C71               STRB     R4,[R1, #+4]
   \                     ??AddRfTask_SearchNodeTask_5:
   \   0000002A   521C               ADDS     R2,R2,#+1
   \   0000002C   1206               LSLS     R2,R2,#+24
   \   0000002E   120E               LSRS     R2,R2,#+24
   \                     ??AddRfTask_SearchNodeTask_2:
   \   00000030   1300               MOVS     R3,R2
   \   00000032   452B               CMP      R3,#+69
   \   00000034   1CD2               BCS      ??AddRfTask_SearchNodeTask_1
   \   00000036   DB00               LSLS     R3,R3,#+3
   \   00000038   114C               LDR      R4,??AddRfTask_SearchNodeTask_0+0x8  ;; RF_TaskTab
   \   0000003A   E318               ADDS     R3,R4,R3
   \   0000003C   1C78               LDRB     R4,[R3, #+0]
   \   0000003E   8442               CMP      R4,R0
   \   00000040   F3D1               BNE      ??AddRfTask_SearchNodeTask_5
   \   00000042   5C68               LDR      R4,[R3, #+4]
   \   00000044   2503               LSLS     R5,R4,#+12
   \   00000046   2D0B               LSRS     R5,R5,#+12
   \   00000048   0E68               LDR      R6,[R1, #+0]
   \   0000004A   B542               CMP      R5,R6
   \   0000004C   EDD1               BNE      ??AddRfTask_SearchNodeTask_5
   \   0000004E   F025               MOVS     R5,#+240
   \   00000050   2D04               LSLS     R5,R5,#+16       ;; #+15728640
   \   00000052   2540               ANDS     R5,R5,R4
   \   00000054   2D0D               LSRS     R5,R5,#+20
   \   00000056   012D               CMP      R5,#+1
   \   00000058   01D0               BEQ      ??AddRfTask_SearchNodeTask_6
   \   0000005A   022D               CMP      R5,#+2
   \   0000005C   E5D1               BNE      ??AddRfTask_SearchNodeTask_5
   \                     ??AddRfTask_SearchNodeTask_6:
   \   0000005E   012D               CMP      R5,#+1
   \   00000060   D9D1               BNE      ??AddRfTask_SearchNodeTask_3
   \   00000062   064D               LDR      R5,??AddRfTask_SearchNodeTask_0+0x4  ;; 0xff0fffff
   \   00000064   2540               ANDS     R5,R5,R4
   \   00000066   E024               MOVS     R4,#+224
   \   00000068   E403               LSLS     R4,R4,#+15       ;; #+7340032
   \   0000006A   2C43               ORRS     R4,R4,R5
   \   0000006C   5C60               STR      R4,[R3, #+4]
   \   0000006E   D8E7               B        ??AddRfTask_SearchNodeTask_4
   1445                 }
   1446              } 
   \                     ??AddRfTask_SearchNodeTask_1:
   \   00000070   70BC               POP      {R4-R6}
   \   00000072   01BC               POP      {R0}
   \   00000074   0047               BX       R0               ;; return
   \   00000076   C046               Nop      
   \                     ??AddRfTask_SearchNodeTask_0:
   \   00000078   ........           DC32     NeuronsList
   \   0000007C   FFFF0FFF           DC32     0xff0fffff
   \   00000080   ........           DC32     RF_TaskTab
   1447          }
   1448          
   1449          
   1450          //-----------------------------------------------------------------------------
   1451          // Nazwa funkcji :    AddRfTask_SearchNode
   1452          // Funkcja ustawia dodanie zadania dla transmisji Rs "Wy³¹czenie ramki rozg³oœnej z wyszukaniem wêz³a"
   1453          // Funkcja w³¹cza ponowne odpytanie wêz³a zablokowanego funkcj¹ AddRfTask_SearchNode
   1454          // Node - nr wêz³a/urz¹dzeia
   1455          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1456          void AddRfTask_RemoveSearchNodeTask(char Node)
   1457          { 
   \                     AddRfTask_RemoveSearchNodeTask:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   1458              for (char i=0; i<RF_Tasks-1; i++)  
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0CE0               B        ??AddRfTask_RemoveSearchNodeTask_0
   1459              {
   1460                 //znalezienie rozkazu odpytania statusu
   1461                 if ((RF_TaskTab[i].Node==Node) && 
   1462                     (RF_TaskTab[i].Command.ID==NeuronsList[Node-1].NeuronID) &&
   1463                     ((RF_TaskTab[i].Command.Order==R_BC_Order) || (RF_TaskTab[i].Command.Order==W_BC_Order)))
   1464                 {
   1465                     if (RF_TaskTab[i].Command.Order==R_BC_Order)
   1466                     {
   1467                        RF_TaskTab[i].Command.Order=R_RegOrd;
   1468                     }else{
   1469                        RF_TaskTab[i].Command.Order=W_RegOrd;
   \                     ??AddRfTask_RemoveSearchNodeTask_1:
   \   00000006   1A4D               LDR      R5,??AddRfTask_RemoveSearchNodeTask_2  ;; 0xff0fffff
   \   00000008   2540               ANDS     R5,R5,R4
   \   0000000A   8024               MOVS     R4,#+128
   \   0000000C   A403               LSLS     R4,R4,#+14       ;; #+2097152
   \   0000000E   2C43               ORRS     R4,R4,R5
   \   00000010   5C60               STR      R4,[R3, #+4]
   1470                     }
   1471                     NeuronsList[Node-1].ReadSuspend=0;
   \                     ??AddRfTask_RemoveSearchNodeTask_3:
   \   00000012   1379               LDRB     R3,[R2, #+4]
   \   00000014   FB24               MOVS     R4,#+251
   \   00000016   1C40               ANDS     R4,R4,R3
   \   00000018   1471               STRB     R4,[R2, #+4]
   \                     ??AddRfTask_RemoveSearchNodeTask_4:
   \   0000001A   491C               ADDS     R1,R1,#+1
   \   0000001C   0906               LSLS     R1,R1,#+24
   \   0000001E   090E               LSRS     R1,R1,#+24
   \                     ??AddRfTask_RemoveSearchNodeTask_0:
   \   00000020   0A00               MOVS     R2,R1
   \   00000022   452A               CMP      R2,#+69
   \   00000024   21D2               BCS      ??AddRfTask_RemoveSearchNodeTask_5
   \   00000026   D200               LSLS     R2,R2,#+3
   \   00000028   124B               LDR      R3,??AddRfTask_RemoveSearchNodeTask_2+0x4  ;; RF_TaskTab
   \   0000002A   9B18               ADDS     R3,R3,R2
   \   0000002C   1A78               LDRB     R2,[R3, #+0]
   \   0000002E   8242               CMP      R2,R0
   \   00000030   F3D1               BNE      ??AddRfTask_RemoveSearchNodeTask_4
   \   00000032   5C68               LDR      R4,[R3, #+4]
   \   00000034   0C22               MOVS     R2,#+12
   \   00000036   4243               MULS     R2,R0,R2
   \   00000038   0F4D               LDR      R5,??AddRfTask_RemoveSearchNodeTask_2+0x8  ;; NeuronsList
   \   0000003A   AA18               ADDS     R2,R5,R2
   \   0000003C   083A               SUBS     R2,R2,#+8
   \   0000003E   2503               LSLS     R5,R4,#+12
   \   00000040   2D0B               LSRS     R5,R5,#+12
   \   00000042   1668               LDR      R6,[R2, #+0]
   \   00000044   B542               CMP      R5,R6
   \   00000046   E8D1               BNE      ??AddRfTask_RemoveSearchNodeTask_4
   \   00000048   F025               MOVS     R5,#+240
   \   0000004A   2D04               LSLS     R5,R5,#+16       ;; #+15728640
   \   0000004C   2540               ANDS     R5,R5,R4
   \   0000004E   2D0D               LSRS     R5,R5,#+20
   \   00000050   072D               CMP      R5,#+7
   \   00000052   01D0               BEQ      ??AddRfTask_RemoveSearchNodeTask_6
   \   00000054   082D               CMP      R5,#+8
   \   00000056   E0D1               BNE      ??AddRfTask_RemoveSearchNodeTask_4
   \                     ??AddRfTask_RemoveSearchNodeTask_6:
   \   00000058   072D               CMP      R5,#+7
   \   0000005A   D4D1               BNE      ??AddRfTask_RemoveSearchNodeTask_1
   \   0000005C   044D               LDR      R5,??AddRfTask_RemoveSearchNodeTask_2  ;; 0xff0fffff
   \   0000005E   2540               ANDS     R5,R5,R4
   \   00000060   8024               MOVS     R4,#+128
   \   00000062   6403               LSLS     R4,R4,#+13       ;; #+1048576
   \   00000064   2C43               ORRS     R4,R4,R5
   \   00000066   5C60               STR      R4,[R3, #+4]
   \   00000068   D3E7               B        ??AddRfTask_RemoveSearchNodeTask_3
   1472                 }
   1473              } 
   1474          }
   \                     ??AddRfTask_RemoveSearchNodeTask_5:
   \   0000006A   70BC               POP      {R4-R6}
   \   0000006C   01BC               POP      {R0}
   \   0000006E   0047               BX       R0               ;; return
   \                     ??AddRfTask_RemoveSearchNodeTask_2:
   \   00000070   FFFF0FFF           DC32     0xff0fffff
   \   00000074   ........           DC32     RF_TaskTab
   \   00000078   ........           DC32     NeuronsList
   1475          
   1476          
   1477          //usuñ wszystkie zadania dla tego wêz³a

   \                                 In section Debug.txt, align 4, keep-with-next
   1478          char RemoveRfNodeAllTaska( char Node)
   1479          {
   \                     RemoveRfNodeAllTaska:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   1480            for (char TSK=0; TSK<RF_Tasks-1; TSK++)
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   0100               MOVS     R1,R0
   \   00000006   37E0               B        ??RemoveRfNodeAllTaska_0
   1481            {
   1482               if (RF_TaskTab[TSK].Node==Node) //wyczyœæ wêze³
   1483               {
   1484                  RF_TaskTab[TSK].Node=0;
   1485                  RF_TaskTab[TSK].Command.ID=0;
   1486                  RF_TaskTab[TSK].Command.Order=0;
   1487                  RF_TaskTab[TSK].Command.Auxi=0;
   1488               }
   1489               
   1490               //przesuñ pozosta³e zadania do góry
   1491               char Tp=TSK;
   1492               while ((Tp+1<RF_Tasks-1) && (RF_TaskTab[Tp+1].Node))
   1493               {
   1494                 RF_TaskTab[Tp].Node=RF_TaskTab[Tp+1].Node;
   \                     ??RemoveRfNodeAllTaska_1:
   \   00000008   1570               STRB     R5,[R2, #+0]
   1495                 RF_TaskTab[Tp].Command.ID=RF_TaskTab[Tp+1].Command.ID;
   \   0000000A   5568               LDR      R5,[R2, #+4]
   \   0000000C   2D0D               LSRS     R5,R5,#+20
   \   0000000E   2D05               LSLS     R5,R5,#+20
   \   00000010   D668               LDR      R6,[R2, #+12]
   \   00000012   3703               LSLS     R7,R6,#+12
   \   00000014   3F0B               LSRS     R7,R7,#+12
   \   00000016   2F43               ORRS     R7,R7,R5
   \   00000018   5760               STR      R7,[R2, #+4]
   1496                 RF_TaskTab[Tp].Command.Order=RF_TaskTab[Tp+1].Command.Order;
   \   0000001A   F025               MOVS     R5,#+240
   \   0000001C   2D04               LSLS     R5,R5,#+16       ;; #+15728640
   \   0000001E   204E               LDR      R6,??RemoveRfNodeAllTaska_2  ;; 0xff0fffff
   \   00000020   3E40               ANDS     R6,R6,R7
   \   00000022   D768               LDR      R7,[R2, #+12]
   \   00000024   3F0D               LSRS     R7,R7,#+20
   \   00000026   3F05               LSLS     R7,R7,#+20
   \   00000028   2F40               ANDS     R7,R7,R5
   \   0000002A   3743               ORRS     R7,R7,R6
   \   0000002C   5760               STR      R7,[R2, #+4]
   1497                 RF_TaskTab[Tp].Command.Auxi=RF_TaskTab[Tp+1].Command.Order;
   \   0000002E   3E02               LSLS     R6,R7,#+8
   \   00000030   360A               LSRS     R6,R6,#+8
   \   00000032   D768               LDR      R7,[R2, #+12]
   \   00000034   3D40               ANDS     R5,R5,R7
   \   00000036   2D0D               LSRS     R5,R5,#+20
   \   00000038   2D06               LSLS     R5,R5,#+24
   \   0000003A   3543               ORRS     R5,R5,R6
   \   0000003C   5560               STR      R5,[R2, #+4]
   1498                 Tp++;
   \   0000003E   641C               ADDS     R4,R4,#+1
   \   00000040   2406               LSLS     R4,R4,#+24
   \   00000042   240E               LSRS     R4,R4,#+24
   1499               }
   \                     ??RemoveRfNodeAllTaska_3:
   \   00000044   2200               MOVS     R2,R4
   \   00000046   521C               ADDS     R2,R2,#+1
   \   00000048   1204               LSLS     R2,R2,#+16
   \   0000004A   120C               LSRS     R2,R2,#+16
   \   0000004C   452A               CMP      R2,#+69
   \   0000004E   05D2               BCS      ??RemoveRfNodeAllTaska_4
   \   00000050   2200               MOVS     R2,R4
   \   00000052   D200               LSLS     R2,R2,#+3
   \   00000054   9A18               ADDS     R2,R3,R2
   \   00000056   157A               LDRB     R5,[R2, #+8]
   \   00000058   002D               CMP      R5,#+0
   \   0000005A   D5D1               BNE      ??RemoveRfNodeAllTaska_1
   1500               
   1501               //usuñ pozosta³oœæ po czyszczeniu
   1502               if ((Tp<RF_Tasks-1) && (RF_TaskTab[Tp].Node))
   \                     ??RemoveRfNodeAllTaska_4:
   \   0000005C   2200               MOVS     R2,R4
   \   0000005E   452A               CMP      R2,#+69
   \   00000060   07D2               BCS      ??RemoveRfNodeAllTaska_5
   \   00000062   E200               LSLS     R2,R4,#+3
   \   00000064   9A18               ADDS     R2,R3,R2
   \   00000066   1378               LDRB     R3,[R2, #+0]
   \   00000068   002B               CMP      R3,#+0
   \   0000006A   02D0               BEQ      ??RemoveRfNodeAllTaska_5
   1503               {
   1504                  RF_TaskTab[Tp].Node=0;
   \   0000006C   0300               MOVS     R3,R0
   \   0000006E   1370               STRB     R3,[R2, #+0]
   1505                  RF_TaskTab[Tp].Command.ID=0;
   1506                  RF_TaskTab[Tp].Command.Order=0;
   1507                  RF_TaskTab[Tp].Command.Auxi=0; 
   \   00000070   5060               STR      R0,[R2, #+4]
   1508               } 
   \                     ??RemoveRfNodeAllTaska_5:
   \   00000072   491C               ADDS     R1,R1,#+1
   \   00000074   0906               LSLS     R1,R1,#+24
   \   00000076   090E               LSRS     R1,R1,#+24
   \                     ??RemoveRfNodeAllTaska_0:
   \   00000078   0A00               MOVS     R2,R1
   \   0000007A   452A               CMP      R2,#+69
   \   0000007C   0CD2               BCS      ??RemoveRfNodeAllTaska_6
   \   0000007E   094B               LDR      R3,??RemoveRfNodeAllTaska_2+0x4  ;; RF_TaskTab
   \   00000080   D200               LSLS     R2,R2,#+3
   \   00000082   9A18               ADDS     R2,R3,R2
   \   00000084   1478               LDRB     R4,[R2, #+0]
   \   00000086   6D46               MOV      R5,SP
   \   00000088   2D78               LDRB     R5,[R5, #+0]
   \   0000008A   AC42               CMP      R4,R5
   \   0000008C   02D1               BNE      ??RemoveRfNodeAllTaska_7
   \   0000008E   0400               MOVS     R4,R0
   \   00000090   1470               STRB     R4,[R2, #+0]
   \   00000092   5060               STR      R0,[R2, #+4]
   \                     ??RemoveRfNodeAllTaska_7:
   \   00000094   0C00               MOVS     R4,R1
   \   00000096   D5E7               B        ??RemoveRfNodeAllTaska_3
   1509            }  
   1510          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "RemoveRfNodeAllTaska"
   \                     ??RemoveRfNodeAllTaska_6:
   \   00000098   F8BC               POP      {R3-R7}
   \   0000009A   01BC               POP      {R0}
   \   0000009C   0047               BX       R0               ;; return
   \   0000009E   C046               Nop      
   \                     ??RemoveRfNodeAllTaska_2:
   \   000000A0   FFFF0FFF           DC32     0xff0fffff
   \   000000A4   ........           DC32     RF_TaskTab
   1511          
   1512          
   1513          
   1514          
   1515          //usuñ wszystkie zadania dla tego wêz³a

   \                                 In section Debug.txt, align 4, keep-with-next
   1516          char RemoveRfTask(char TSK)
   1517          {
   \                     RemoveRfTask:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   1518          
   1519                RF_TaskTab[TSK].Node=0;
   \   00000002   1F49               LDR      R1,??RemoveRfTask_0  ;; RF_TaskTab
   \   00000004   C200               LSLS     R2,R0,#+3
   \   00000006   8B18               ADDS     R3,R1,R2
   \   00000008   0022               MOVS     R2,#+0
   \   0000000A   1400               MOVS     R4,R2
   \   0000000C   1C70               STRB     R4,[R3, #+0]
   1520                RF_TaskTab[TSK].Command.ID=0;
   1521                RF_TaskTab[TSK].Command.Order=0;
   1522                RF_TaskTab[TSK].Command.Auxi=0;
   \   0000000E   5A60               STR      R2,[R3, #+4]
   1523          
   1524               //przesuñ pozosta³e zadania do góry
   1525               char Tp=TSK;
   \   00000010   1CE0               B        ??RemoveRfTask_1
   1526               while ((Tp+1<RF_Tasks-1) && (RF_TaskTab[Tp+1].Node))
   1527               {
   1528                 RF_TaskTab[Tp].Node=RF_TaskTab[Tp+1].Node;
   \                     ??RemoveRfTask_2:
   \   00000012   1C70               STRB     R4,[R3, #+0]
   1529                 RF_TaskTab[Tp].Command.ID=RF_TaskTab[Tp+1].Command.ID;
   \   00000014   5C68               LDR      R4,[R3, #+4]
   \   00000016   240D               LSRS     R4,R4,#+20
   \   00000018   2405               LSLS     R4,R4,#+20
   \   0000001A   DD68               LDR      R5,[R3, #+12]
   \   0000001C   2D03               LSLS     R5,R5,#+12
   \   0000001E   2D0B               LSRS     R5,R5,#+12
   \   00000020   2543               ORRS     R5,R5,R4
   \   00000022   5D60               STR      R5,[R3, #+4]
   1530                 RF_TaskTab[Tp].Command.Order=RF_TaskTab[Tp+1].Command.Order;
   \   00000024   174C               LDR      R4,??RemoveRfTask_0+0x4  ;; 0xff0fffff
   \   00000026   2C40               ANDS     R4,R4,R5
   \   00000028   DD68               LDR      R5,[R3, #+12]
   \   0000002A   2D0D               LSRS     R5,R5,#+20
   \   0000002C   2E05               LSLS     R6,R5,#+20
   \   0000002E   F025               MOVS     R5,#+240
   \   00000030   2D04               LSLS     R5,R5,#+16       ;; #+15728640
   \   00000032   3540               ANDS     R5,R5,R6
   \   00000034   2543               ORRS     R5,R5,R4
   \   00000036   5D60               STR      R5,[R3, #+4]
   1531                 RF_TaskTab[Tp].Command.Auxi=RF_TaskTab[Tp+1].Command.Auxi;
   \   00000038   2C02               LSLS     R4,R5,#+8
   \   0000003A   240A               LSRS     R4,R4,#+8
   \   0000003C   DD68               LDR      R5,[R3, #+12]
   \   0000003E   2D0E               LSRS     R5,R5,#+24
   \   00000040   2D06               LSLS     R5,R5,#+24
   \   00000042   2543               ORRS     R5,R5,R4
   \   00000044   5D60               STR      R5,[R3, #+4]
   1532                 Tp++;
   \   00000046   401C               ADDS     R0,R0,#+1
   \   00000048   0006               LSLS     R0,R0,#+24
   \   0000004A   000E               LSRS     R0,R0,#+24
   1533               }
   \                     ??RemoveRfTask_1:
   \   0000004C   0300               MOVS     R3,R0
   \   0000004E   5B1C               ADDS     R3,R3,#+1
   \   00000050   1B04               LSLS     R3,R3,#+16
   \   00000052   1B0C               LSRS     R3,R3,#+16
   \   00000054   452B               CMP      R3,#+69
   \   00000056   05D2               BCS      ??RemoveRfTask_3
   \   00000058   0300               MOVS     R3,R0
   \   0000005A   DB00               LSLS     R3,R3,#+3
   \   0000005C   CB18               ADDS     R3,R1,R3
   \   0000005E   1C7A               LDRB     R4,[R3, #+8]
   \   00000060   002C               CMP      R4,#+0
   \   00000062   D6D1               BNE      ??RemoveRfTask_2
   1534               
   1535               //usuñ pozosta³oœæ po czyszczeniu
   1536               if ((Tp<RF_Tasks-1) && (RF_TaskTab[Tp].Node))
   \                     ??RemoveRfTask_3:
   \   00000064   0300               MOVS     R3,R0
   \   00000066   452B               CMP      R3,#+69
   \   00000068   07D2               BCS      ??RemoveRfTask_4
   \   0000006A   C000               LSLS     R0,R0,#+3
   \   0000006C   0B18               ADDS     R3,R1,R0
   \   0000006E   1878               LDRB     R0,[R3, #+0]
   \   00000070   0028               CMP      R0,#+0
   \   00000072   02D0               BEQ      ??RemoveRfTask_4
   1537               {
   1538                  RF_TaskTab[Tp].Node=0;
   \   00000074   1000               MOVS     R0,R2
   \   00000076   1870               STRB     R0,[R3, #+0]
   1539                  RF_TaskTab[Tp].Command.ID=0;
   1540                  RF_TaskTab[Tp].Command.Order=0;
   1541                  RF_TaskTab[Tp].Command.Auxi=0; 
   \   00000078   5A60               STR      R2,[R3, #+4]
   1542               } 
   1543           
   1544          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "RemoveRfTask"
   \                     ??RemoveRfTask_4:
   \   0000007A   70BC               POP      {R4-R6}
   \   0000007C   01BC               POP      {R0}
   \   0000007E   0047               BX       R0               ;; return
   \                     ??RemoveRfTask_0:
   \   00000080   ........           DC32     RF_TaskTab
   \   00000084   FFFF0FFF           DC32     0xff0fffff
   1545          
   1546          
   1547          
   1548          //-----------------------------------------------------------------------------
   1549          // Nazwa funkcji :    AddRfTask
   1550          // Funkcja ustawia dodanie zadania dla transmisji Rs
   1551          // Ord - typ rozkazu : odczyt wejœæ, zapis
   1552          // Node - nr wêz³a/urz¹dzeia
   1553          // Reg  - nr rejestru w wêŸle 
   1554          //-----------------------------------------------------------------------------
   1555          // Funkcja zwrca 1- je¿eli powodzenie dodawania zadania
   1556          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1557          char AddRfTask(_OrderType Ord, char Node, char Reg)
   1558          { 
   \                     AddRfTask:
   \   00000000   F2B5               PUSH     {R1,R4-R7,LR}
   \   00000002   84B0               SUB      SP,SP,#+16
   \   00000004   6946               MOV      R1,SP
   \   00000006   097C               LDRB     R1,[R1, #+16]
   \   00000008   0C24               MOVS     R4,#+12
   \   0000000A   6143               MULS     R1,R4,R1
   \   0000000C   724C               LDR      R4,??AddRfTask_0  ;; NeuronsList
   \   0000000E   6118               ADDS     R1,R4,R1
   \   00000010   0839               SUBS     R1,R1,#+8
   \   00000012   0968               LDR      R1,[R1, #+0]
   \   00000014   0291               STR      R1,[SP, #+8]
   \   00000016   0029               CMP      R1,#+0
   \   00000018   01D1               BNE      ??AddRfTask_1
   1559          
   1560              if (NeuronsList[Node-1].NeuronID==0) return 0;
   \                     ??AddRfTask_2:
   \   0000001A   0020               MOVS     R0,#+0
   \   0000001C   D8E0               B        ??AddRfTask_3
   \                     ??AddRfTask_1:
   \   0000001E   0024               MOVS     R4,#+0
   1561             
   1562              //1-dodano zadanie, 0-niedodano
   1563              char OrdExist=0;
   1564              char RfOrd;
   1565              char FreePlace=0;
   1566              char FirstOccureNode=0xFF;        //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   \   00000020   FF21               MOVS     R1,#+255
   1567              char LastOccureNode=0xFF;        //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   \   00000022   0091               STR      R1,[SP, #+0]
   1568             
   1569              //zabezpieczenie przed przekroczeniami
   1570              if (Node>NumberNeurons) return 0;
   \   00000024   6D46               MOV      R5,SP
   \   00000026   2D7C               LDRB     R5,[R5, #+16]
   \   00000028   242D               CMP      R5,#+36
   \   0000002A   F6D2               BCS      ??AddRfTask_2
   1571              if (Reg>99) return 0;
   \   0000002C   642A               CMP      R2,#+100
   \   0000002E   F4D2               BCS      ??AddRfTask_2
   1572              
   1573              
   1574              //przepisanie rozkazu na zrozumia³y dla tablicy zadañ RF
   1575              switch (Ord)
   \   00000030   0128               CMP      R0,#+1
   \   00000032   06D0               BEQ      ??AddRfTask_4
   \   00000034   0228               CMP      R0,#+2
   \   00000036   06D0               BEQ      ??AddRfTask_5
   \   00000038   0428               CMP      R0,#+4
   \   0000003A   06D0               BEQ      ??AddRfTask_6
   \   0000003C   0528               CMP      R0,#+5
   \   0000003E   06D0               BEQ      ??AddRfTask_7
   \   00000040   06E0               B        ??AddRfTask_8
   1576              {
   1577                  case SI:      RfOrd=R_RegOrd; break; 
   \                     ??AddRfTask_4:
   \   00000042   0123               MOVS     R3,#+1
   \   00000044   04E0               B        ??AddRfTask_8
   1578                  case SQ:      RfOrd=W_RegOrd; break; 
   \                     ??AddRfTask_5:
   \   00000046   0223               MOVS     R3,#+2
   \   00000048   02E0               B        ??AddRfTask_8
   1579                  case SNewId:  RfOrd=W_NewIdOrd; break; 
   \                     ??AddRfTask_6:
   \   0000004A   0523               MOVS     R3,#+5
   \   0000004C   00E0               B        ??AddRfTask_8
   1580                  case SBC:     RfOrd=R_BC_Order; break; 
   \                     ??AddRfTask_7:
   \   0000004E   0723               MOVS     R3,#+7
   1581              }  
   1582           
   1583          
   1584                
   1585              //Sprawdzenie czy taki rozkaz nie istnieje w tablicy
   1586              char i=0;
   \                     ??AddRfTask_8:
   \   00000050   2500               MOVS     R5,R4
   \   00000052   1DE0               B        ??AddRfTask_9
   1587              while ((i<RF_Tasks-1) && (OrdExist==0))
   1588              {
   1589                 if ((RF_TaskTab[i].Node==Node) && 
   1590                     (RF_TaskTab[i].Command.ID==NeuronsList[Node-1].NeuronID) &&
   1591                     (RF_TaskTab[i].Command.Order==RfOrd) &&
   1592                     (RF_TaskTab[i].Command.Auxi==Reg))
   \                     ??AddRfTask_10:
   \   00000054   6148               LDR      R0,??AddRfTask_0+0x4  ;; RF_TaskTab
   \   00000056   2E00               MOVS     R6,R5
   \   00000058   F600               LSLS     R6,R6,#+3
   \   0000005A   8019               ADDS     R0,R0,R6
   \   0000005C   0678               LDRB     R6,[R0, #+0]
   \   0000005E   6F46               MOV      R7,SP
   \   00000060   3F7C               LDRB     R7,[R7, #+16]
   \   00000062   BE42               CMP      R6,R7
   \   00000064   11D1               BNE      ??AddRfTask_11
   \   00000066   4068               LDR      R0,[R0, #+4]
   \   00000068   0603               LSLS     R6,R0,#+12
   \   0000006A   360B               LSRS     R6,R6,#+12
   \   0000006C   029F               LDR      R7,[SP, #+8]
   \   0000006E   BE42               CMP      R6,R7
   \   00000070   0BD1               BNE      ??AddRfTask_11
   \   00000072   F026               MOVS     R6,#+240
   \   00000074   3604               LSLS     R6,R6,#+16       ;; #+15728640
   \   00000076   0640               ANDS     R6,R6,R0
   \   00000078   360D               LSRS     R6,R6,#+20
   \   0000007A   1B06               LSLS     R3,R3,#+24
   \   0000007C   1B0E               LSRS     R3,R3,#+24
   \   0000007E   9E42               CMP      R6,R3
   \   00000080   03D1               BNE      ??AddRfTask_11
   \   00000082   000E               LSRS     R0,R0,#+24
   \   00000084   9042               CMP      R0,R2
   \   00000086   00D1               BNE      ??AddRfTask_11
   1593                    {
   1594                      OrdExist=1;
   \   00000088   0124               MOVS     R4,#+1
   1595                    }
   1596                
   1597                 i++;
   \                     ??AddRfTask_11:
   \   0000008A   6D1C               ADDS     R5,R5,#+1
   \   0000008C   2D06               LSLS     R5,R5,#+24
   \   0000008E   2D0E               LSRS     R5,R5,#+24
   1598              }
   \                     ??AddRfTask_9:
   \   00000090   2800               MOVS     R0,R5
   \   00000092   4528               CMP      R0,#+69
   \   00000094   01D2               BCS      ??AddRfTask_12
   \   00000096   2000               MOVS     R0,R4
   \   00000098   DCD0               BEQ      ??AddRfTask_10
   1599              
   1600              i=0;
   \                     ??AddRfTask_12:
   \   0000009A   0026               MOVS     R6,#+0
   1601              char Rf_Zad=0; //iloœæ zadañ.  
   \   0000009C   3500               MOVS     R5,R6
   \   0000009E   25E0               B        ??AddRfTask_13
   1602              //Odszukanie ostatniego i ewentualnie pierwszego zadania z tym wêz³em - ma to na cenu u³o¿enie zadañ wêz³ów po kolei co jest konieczne do prawid³owego odpytywania sterowników w trybie slave. Sterowniki takie czekaj¹ na wszystkie swoje odpytania a je¿eli wyst¹pi odpytanie innego wêz³a lub ponowne odpytanie rejestru 0 odpytywanego sterownika to prze³¹czaj¹ sie na tryb master, wykonuj¹ w³asne odpytania a nastêpnie prze³¹czaj¹ siê ponownie w trym slave. Pierwszym zadaniem w kolejce zawsze musi byæ odpytanie rejestru 0
   1603              //Obliczenie iloœci zadañ
   1604              while (i<RF_Tasks-1)
   1605              {
   1606                   if (RF_TaskTab[i].Node==Node)
   \                     ??AddRfTask_14:
   \   000000A0   4E48               LDR      R0,??AddRfTask_0+0x4  ;; RF_TaskTab
   \   000000A2   3700               MOVS     R7,R6
   \   000000A4   FF00               LSLS     R7,R7,#+3
   \   000000A6   C019               ADDS     R0,R0,R7
   \   000000A8   0190               STR      R0,[SP, #+4]
   \   000000AA   0078               LDRB     R0,[R0, #+0]
   \   000000AC   6F46               MOV      R7,SP
   \   000000AE   3F7C               LDRB     R7,[R7, #+16]
   \   000000B0   B842               CMP      R0,R7
   \   000000B2   11D1               BNE      ??AddRfTask_15
   1607                   {
   1608                     if ((RF_TaskTab[i].Command.Order==R_RegOrd) && (Reg==0) &&  (FirstOccureNode==0xFF))  FirstOccureNode=Rf_Zad; //pierwsze wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   \   000000B4   0198               LDR      R0,[SP, #+4]
   \   000000B6   4068               LDR      R0,[R0, #+4]
   \   000000B8   F027               MOVS     R7,#+240
   \   000000BA   3F04               LSLS     R7,R7,#+16       ;; #+15728640
   \   000000BC   0740               ANDS     R7,R7,R0
   \   000000BE   3800               MOVS     R0,R7
   \   000000C0   000D               LSRS     R0,R0,#+20
   \   000000C2   0128               CMP      R0,#+1
   \   000000C4   07D1               BNE      ??AddRfTask_16
   \   000000C6   002A               CMP      R2,#+0
   \   000000C8   05D1               BNE      ??AddRfTask_16
   \   000000CA   0800               MOVS     R0,R1
   \   000000CC   0006               LSLS     R0,R0,#+24
   \   000000CE   000E               LSRS     R0,R0,#+24
   \   000000D0   FF28               CMP      R0,#+255
   \   000000D2   00D1               BNE      ??AddRfTask_16
   \   000000D4   2900               MOVS     R1,R5
   1609                     //if (FirstOccureNode==0xFF)  FirstOccureNode=Rf_Zad; //pierwsze wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   1610                     LastOccureNode=Rf_Zad;                                               //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   \                     ??AddRfTask_16:
   \   000000D6   0095               STR      R5,[SP, #+0]
   1611                   }
   1612                   
   1613                   if (RF_TaskTab[i].Node!=0) Rf_Zad++;
   \                     ??AddRfTask_15:
   \   000000D8   0198               LDR      R0,[SP, #+4]
   \   000000DA   0078               LDRB     R0,[R0, #+0]
   \   000000DC   0028               CMP      R0,#+0
   \   000000DE   02D0               BEQ      ??AddRfTask_17
   \   000000E0   6D1C               ADDS     R5,R5,#+1
   \   000000E2   2D06               LSLS     R5,R5,#+24
   \   000000E4   2D0E               LSRS     R5,R5,#+24
   1614                   i++;    
   \                     ??AddRfTask_17:
   \   000000E6   761C               ADDS     R6,R6,#+1
   \   000000E8   3606               LSLS     R6,R6,#+24
   \   000000EA   360E               LSRS     R6,R6,#+24
   1615              }
   \                     ??AddRfTask_13:
   \   000000EC   3000               MOVS     R0,R6
   \   000000EE   4528               CMP      R0,#+69
   \   000000F0   D6D3               BCC      ??AddRfTask_14
   1616              if(Rf_Zad>=RF_Tasks-1) return 0;    //je¿eli nie ma ju¿ miejsca na nowe zadania to wyjdŸ z funkcji
   \   000000F2   2800               MOVS     R0,R5
   \   000000F4   4528               CMP      R0,#+69
   \   000000F6   90D2               BCS      ??AddRfTask_2
   1617              
   1618              
   1619              
   1620              //je¿eli rozkaz nie istnieje to dodaj. Je¿eli na liœcie s¹ ju¿ 
   1621              if (OrdExist==0)
   \   000000F8   002C               CMP      R4,#+0
   \   000000FA   68D1               BNE      ??AddRfTask_18
   1622              {
   1623                if (FirstOccureNode!=0xFF)                                                //znajdŸ miejsce w tablicy zadañ dla nowego zadania
   \   000000FC   0800               MOVS     R0,R1
   \   000000FE   0006               LSLS     R0,R0,#+24
   \   00000100   000E               LSRS     R0,R0,#+24
   \   00000102   FF28               CMP      R0,#+255
   \   00000104   01D0               BEQ      ??AddRfTask_19
   1624                {
   1625                   FreePlace=FirstOccureNode;                                              //miejsce w tablicy na nowe zadanie przed dotychczasowymi zadaniami
   \   00000106   0C00               MOVS     R4,R1
   \   00000108   0AE0               B        ??AddRfTask_20
   1626                }
   1627                else if (LastOccureNode!=0xFF)  
   \                     ??AddRfTask_19:
   \   0000010A   0098               LDR      R0,[SP, #+0]
   \   0000010C   0006               LSLS     R0,R0,#+24
   \   0000010E   000E               LSRS     R0,R0,#+24
   \   00000110   FF28               CMP      R0,#+255
   \   00000112   04D0               BEQ      ??AddRfTask_21
   1628                {
   1629                   FreePlace=LastOccureNode+1;                                             //miejsce w tablicy na nowe zadanie za dotychczasowymi zadaniami
   \   00000114   009C               LDR      R4,[SP, #+0]
   \   00000116   641C               ADDS     R4,R4,#+1
   \   00000118   2406               LSLS     R4,R4,#+24
   \   0000011A   240E               LSRS     R4,R4,#+24
   \   0000011C   00E0               B        ??AddRfTask_20
   1630                }else{
   1631                   FreePlace=Rf_Zad;                                                          //miejsce w tablicy na nowe zadanie
   \                     ??AddRfTask_21:
   \   0000011E   2C00               MOVS     R4,R5
   1632                }
   1633                
   1634                //je¿eli zadanie ma byæ wprowadzone pomiêdzy inne zadania
   1635                if (((FirstOccureNode!=0xFF) && (FirstOccureNode+1>Rf_Zad)) || 
   1636                    ((LastOccureNode!=0xFF)  && (LastOccureNode<Rf_Zad)))
   \                     ??AddRfTask_20:
   \   00000120   0800               MOVS     R0,R1
   \   00000122   0006               LSLS     R0,R0,#+24
   \   00000124   000E               LSRS     R0,R0,#+24
   \   00000126   FF28               CMP      R0,#+255
   \   00000128   03D0               BEQ      ??AddRfTask_22
   \   0000012A   2800               MOVS     R0,R5
   \   0000012C   491C               ADDS     R1,R1,#+1
   \   0000012E   8842               CMP      R0,R1
   \   00000130   0ADB               BLT      ??AddRfTask_23
   \                     ??AddRfTask_22:
   \   00000132   0098               LDR      R0,[SP, #+0]
   \   00000134   0006               LSLS     R0,R0,#+24
   \   00000136   000E               LSRS     R0,R0,#+24
   \   00000138   FF28               CMP      R0,#+255
   \   0000013A   2FD0               BEQ      ??AddRfTask_24
   \   0000013C   0098               LDR      R0,[SP, #+0]
   \   0000013E   2900               MOVS     R1,R5
   \   00000140   0006               LSLS     R0,R0,#+24
   \   00000142   000E               LSRS     R0,R0,#+24
   \   00000144   8842               CMP      R0,R1
   \   00000146   29D2               BCS      ??AddRfTask_24
   1637                {
   1638                  //rozsuniêcie zadañ
   1639                  signed char  Pz=Rf_Zad-1;
   \                     ??AddRfTask_23:
   \   00000148   691E               SUBS     R1,R5,#+1
   \   0000014A   0906               LSLS     R1,R1,#+24
   \   0000014C   0916               ASRS     R1,R1,#+24
   \   0000014E   20E0               B        ??AddRfTask_25
   1640                  while (Pz>=FreePlace)
   1641                  {
   1642                     RF_TaskTab[Pz+1].Node=RF_TaskTab[Pz].Node;
   \                     ??AddRfTask_26:
   \   00000150   2248               LDR      R0,??AddRfTask_0+0x4  ;; RF_TaskTab
   \   00000152   CD00               LSLS     R5,R1,#+3
   \   00000154   4019               ADDS     R0,R0,R5
   \   00000156   0578               LDRB     R5,[R0, #+0]
   \   00000158   0572               STRB     R5,[R0, #+8]
   \   0000015A   C568               LDR      R5,[R0, #+12]
   \   0000015C   2D0D               LSRS     R5,R5,#+20
   \   0000015E   2D05               LSLS     R5,R5,#+20
   \   00000160   4668               LDR      R6,[R0, #+4]
   \   00000162   3603               LSLS     R6,R6,#+12
   \   00000164   360B               LSRS     R6,R6,#+12
   \   00000166   2E43               ORRS     R6,R6,R5
   \   00000168   C660               STR      R6,[R0, #+12]
   \   0000016A   1D4D               LDR      R5,??AddRfTask_0+0x8  ;; 0xff0fffff
   \   0000016C   3540               ANDS     R5,R5,R6
   \   0000016E   4668               LDR      R6,[R0, #+4]
   \   00000170   360D               LSRS     R6,R6,#+20
   \   00000172   3705               LSLS     R7,R6,#+20
   \   00000174   F026               MOVS     R6,#+240
   \   00000176   3604               LSLS     R6,R6,#+16       ;; #+15728640
   \   00000178   3E40               ANDS     R6,R6,R7
   \   0000017A   2E43               ORRS     R6,R6,R5
   \   0000017C   C660               STR      R6,[R0, #+12]
   1643                     RF_TaskTab[Pz+1].Command.ID=RF_TaskTab[Pz].Command.ID;
   1644                     RF_TaskTab[Pz+1].Command.Order=RF_TaskTab[Pz].Command.Order;
   1645                     RF_TaskTab[Pz+1].Command.Auxi=RF_TaskTab[Pz].Command.Auxi;
   \   0000017E   3502               LSLS     R5,R6,#+8
   \   00000180   2D0A               LSRS     R5,R5,#+8
   \   00000182   4668               LDR      R6,[R0, #+4]
   \   00000184   360E               LSRS     R6,R6,#+24
   \   00000186   3606               LSLS     R6,R6,#+24
   \   00000188   2E43               ORRS     R6,R6,R5
   \   0000018A   C660               STR      R6,[R0, #+12]
   1646                     Pz--;
   \   0000018C   491E               SUBS     R1,R1,#+1
   \   0000018E   0906               LSLS     R1,R1,#+24
   \   00000190   0916               ASRS     R1,R1,#+24
   1647                  }
   \                     ??AddRfTask_25:
   \   00000192   2000               MOVS     R0,R4
   \   00000194   0006               LSLS     R0,R0,#+24
   \   00000196   000E               LSRS     R0,R0,#+24
   \   00000198   8142               CMP      R1,R0
   \   0000019A   D9DA               BGE      ??AddRfTask_26
   1648                }
   1649                
   1650                 //while ((FreePlace<RF_Tasks) && (RF_TaskTab[FreePlace].Node!=0)) FreePlace++;   //tak by³o do wersji 1.2 w³acznie
   1651                if (FreePlace<RF_Tasks-1)     //jezeli jest miejsce w tablicy to dodaj
   \                     ??AddRfTask_24:
   \   0000019C   2000               MOVS     R0,R4
   \   0000019E   0006               LSLS     R0,R0,#+24
   \   000001A0   000E               LSRS     R0,R0,#+24
   \   000001A2   4528               CMP      R0,#+69
   \   000001A4   13D2               BCS      ??AddRfTask_18
   \   000001A6   0D48               LDR      R0,??AddRfTask_0+0x4  ;; RF_TaskTab
   \   000001A8   2406               LSLS     R4,R4,#+24
   \   000001AA   240E               LSRS     R4,R4,#+24
   \   000001AC   E100               LSLS     R1,R4,#+3
   \   000001AE   4018               ADDS     R0,R0,R1
   \   000001B0   6946               MOV      R1,SP
   \   000001B2   097C               LDRB     R1,[R1, #+16]
   \   000001B4   0170               STRB     R1,[R0, #+0]
   1652                {
   1653                  RF_TaskTab[FreePlace].Node=Node;
   1654                  RF_TaskTab[FreePlace].Command.ID=NeuronsList[Node-1].NeuronID;
   1655                  RF_TaskTab[FreePlace].Command.Order=RfOrd;
   1656                  RF_TaskTab[FreePlace].Command.Auxi=Reg;
   \   000001B6   0299               LDR      R1,[SP, #+8]
   \   000001B8   094C               LDR      R4,??AddRfTask_0+0x8  ;; 0xff0fffff
   \   000001BA   0C40               ANDS     R4,R4,R1
   \   000001BC   1B06               LSLS     R3,R3,#+24
   \   000001BE   1B0E               LSRS     R3,R3,#+24
   \   000001C0   1905               LSLS     R1,R3,#+20
   \   000001C2   2143               ORRS     R1,R1,R4
   \   000001C4   0902               LSLS     R1,R1,#+8
   \   000001C6   090A               LSRS     R1,R1,#+8
   \   000001C8   1206               LSLS     R2,R2,#+24
   \   000001CA   0A43               ORRS     R2,R2,R1
   \   000001CC   4260               STR      R2,[R0, #+4]
   1657                  
   1658                }
   1659                
   1660                
   1661              }
   1662          
   1663              return 1; 
   \                     ??AddRfTask_18:
   \   000001CE   0120               MOVS     R0,#+1
   \                     ??AddRfTask_3:
   \   000001D0   05B0               ADD      SP,SP,#+20
   \   000001D2   F0BC               POP      {R4-R7}
   \   000001D4   02BC               POP      {R1}
   \   000001D6   0847               BX       R1               ;; return
   \                     ??AddRfTask_0:
   \   000001D8   ........           DC32     NeuronsList
   \   000001DC   ........           DC32     RF_TaskTab
   \   000001E0   FFFF0FFF           DC32     0xff0fffff
   1664          
   1665          
   1666          }//_______________________ Koniec funkcji  AddRfTask _________________
   1667          
   1668          
   1669          
   1670          
   1671          
   1672          
   1673          

   \                                 In section Debug.txt, align 4, keep-with-next
   1674          char AddRfTaskTMP(_OrderType Ord, char Node, char Reg)
   1675          { 
   \                     AddRfTaskTMP:
   \   00000000   01B5               PUSH     {R0,LR}
   1676          
   1677              if (NeuronsList[Node-1].NeuronID==0) return 0;
   \   00000002   0C20               MOVS     R0,#+12
   \   00000004   4843               MULS     R0,R1,R0
   \   00000006   0A4B               LDR      R3,??AddRfTaskTMP_0  ;; NeuronsList
   \   00000008   1818               ADDS     R0,R3,R0
   \   0000000A   0838               SUBS     R0,R0,#+8
   \   0000000C   0068               LDR      R0,[R0, #+0]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   0BD0               BEQ      ??AddRfTaskTMP_1
   1678             
   1679              //1-dodano zadanie, 0-niedodano
   1680              char OrdExist=0;
                          ^
Warning[Pe177]: variable "OrdExist" was declared but never referenced
   1681              char RfOrd;
                          ^
Warning[Pe550]: variable "RfOrd" was set but never used
   1682              char FreePlace=0;
                          ^
Warning[Pe177]: variable "FreePlace" was declared but never referenced
   1683              char FirstOccureNode=0xFF;        //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
                          ^
Warning[Pe177]: variable "FirstOccureNode" was declared but never referenced
   1684              char LastOccureNode=0xFF;        //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
                          ^
Warning[Pe177]: variable "LastOccureNode" was declared but never referenced
   1685             
   1686              //zabezpieczenie przed przekroczeniami
   1687              if (Node>NumberNeurons) return 0;
   \   00000012   2429               CMP      R1,#+36
   \   00000014   01D3               BCC      ??AddRfTaskTMP_2
   \   00000016   0020               MOVS     R0,#+0
   \   00000018   07E0               B        ??AddRfTaskTMP_1
   1688              if (Reg>99) return 0;
   \                     ??AddRfTaskTMP_2:
   \   0000001A   642A               CMP      R2,#+100
   \   0000001C   01D3               BCC      ??AddRfTaskTMP_3
   \   0000001E   0020               MOVS     R0,#+0
   \   00000020   03E0               B        ??AddRfTaskTMP_1
   1689              
   1690              
   1691              //przepisanie rozkazu na zrozumia³y dla tablicy zadañ RF
   1692              switch (Ord)
   1693              {
   1694                  case SI:      RfOrd=R_RegOrd; break; 
   1695                  case SQ:      RfOrd=W_RegOrd; break; 
   1696                  case SNewId:  RfOrd=W_NewIdOrd; break; 
   1697                  case SBC:     RfOrd=R_BC_Order; break; 
   1698              }  
   1699           
   1700          
   1701               
   1702             /*
   1703              //Sprawdzenie czy taki rozkaz nie istnieje w tablicy
   1704              char i=0;
   1705              while ((i<35) && (OrdExist==0))
   1706              {
   1707                 if ((RF_TaskTab[i].Node==Node) && 
   1708                     (RF_TaskTab[i].Command.ID==NeuronsList[Node-1].NeuronID) &&
   1709                     (RF_TaskTab[i].Command.Order==R_RegOrd) &&
   1710                     (RF_TaskTab[i].Command.Auxi==Reg))
   1711                    {
   1712                      OrdExist=1;
   1713                    }
   1714                
   1715                 i++;
   1716              }
   1717              */
   1718              Delay(0xFF);
   \                     ??AddRfTaskTMP_3:
   \   00000022   FF20               MOVS     R0,#+255
   \   00000024   ........           BL       Delay
   1719            
   1720           /*
   1721              while ((i<35) && (OrdExist==0))
   1722              {
   1723                 if ((RF_TaskTab[i].Node==Node) && 
   1724                     (RF_TaskTab[i].Command.ID==NeuronsList[Node-1].NeuronID) &&
   1725                     (RF_TaskTab[i].Command.Order==R_RegOrd) &&
   1726                     (RF_TaskTab[i].Command.Auxi==Reg))
   1727                    {
   1728                      OrdExist=1;
   1729                    }
   1730                
   1731                 i++;
   1732              }
   1733           */ 
   1734          
   1735              
   1736          /*
   1737              i=0;
   1738              char Rf_Zad=0; //iloœæ zadañ.  
   1739              //Odszukanie ostatniego i ewentualnie pierwszego zadania z tym wêz³em - ma to na cenu u³o¿enie zadañ wêz³ów po kolei co jest konieczne do prawid³owego odpytywania sterowników w trybie slave. Sterowniki takie czekaj¹ na wszystkie swoje odpytania a je¿eli wyst¹pi odpytanie innego wêz³a lub ponowne odpytanie rejestru 0 odpytywanego sterownika to prze³¹czaj¹ sie na tryb master, wykonuj¹ w³asne odpytania a nastêpnie prze³¹czaj¹ siê ponownie w trym slave. Pierwszym zadaniem w kolejce zawsze musi byæ odpytanie rejestru 0
   1740              //Obliczenie iloœci zadañ
   1741              while (i<RF_Tasks-1)
   1742              {
   1743                   if (RF_TaskTab[i].Node==Node)
   1744                   {
   1745                     if ((RfOrd==R_RegOrd) && (Reg==0) &&  (FirstOccureNode==0xFF))  FirstOccureNode=Rf_Zad; //pierwsze wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   1746                     LastOccureNode=Rf_Zad;                                               //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   1747                   }
   1748                   
   1749                   if (RF_TaskTab[i].Node!=0) Rf_Zad++;
   1750                   i++;    
   1751              }
   1752              if(Rf_Zad>=RF_Tasks-1) return 0;    //je¿eli nie ma ju¿ miejsca na nowe zadania to wyjdŸ z funkcji
   1753            */  
   1754             /* 
   1755             
   1756              //je¿eli rozkaz nie istnieje to dodaj. Je¿eli na liœcie s¹ ju¿ 
   1757              if (OrdExist==0)
   1758              {
   1759                if (FirstOccureNode!=0xFF)                                                //znajdŸ miejsce w tablicy zadañ dla nowego zadania
   1760                {
   1761                   FreePlace=FirstOccureNode;                                              //miejsce w tablicy na nowe zadanie przed dotychczasowymi zadaniami
   1762                }
   1763                else if (LastOccureNode!=0xFF)  
   1764                {
   1765                   FreePlace=LastOccureNode+1;                                             //miejsce w tablicy na nowe zadanie za dotychczasowymi zadaniami
   1766                }else{
   1767                   FreePlace=Rf_Zad;                                                          //miejsce w tablicy na nowe zadanie
   1768                }
   1769                
   1770                //je¿eli zadanie ma byæ wprowadzone pomiêdzy inne zadania
   1771                if (((FirstOccureNode!=0xFF) && (FirstOccureNode+1>Rf_Zad)) || 
   1772                    ((LastOccureNode!=0xFF)  && (LastOccureNode<Rf_Zad)))
   1773                {
   1774                  //rozsuniêcie zadañ
   1775                  unsigned char  Pz=Rf_Zad-1;
   1776                  while (Pz>=FreePlace)
   1777                  {
   1778                     RF_TaskTab[Pz+1].Node=RF_TaskTab[Pz].Node;
   1779                     RF_TaskTab[Pz+1].Command.ID=RF_TaskTab[Pz].Command.ID;
   1780                     RF_TaskTab[Pz+1].Command.Order=RF_TaskTab[Pz].Command.Order;
   1781                     RF_TaskTab[Pz+1].Command.Auxi=RF_TaskTab[Pz].Command.Auxi;
   1782                     Pz--;
   1783                  }
   1784                }
   1785                
   1786                 //while ((FreePlace<RF_Tasks) && (RF_TaskTab[FreePlace].Node!=0)) FreePlace++;   //tak by³o do wersji 1.2 w³acznie
   1787                if (FreePlace<RF_Tasks-1)     //jezeli jest miejsce w tablicy to dodaj
   1788                {
   1789                  RF_TaskTab[FreePlace].Node=Node;
   1790                  RF_TaskTab[FreePlace].Command.ID=NeuronsList[Node-1].NeuronID;
   1791                  RF_TaskTab[FreePlace].Command.Order=RfOrd;
   1792                  RF_TaskTab[FreePlace].Command.Auxi=Reg;
   1793                  
   1794                }
   1795                
   1796                
   1797              }
   1798              */
   1799             
   1800            
   1801          
   1802            /*
   1803            RF_TaskTab[5].Node=Node;
   1804            RF_TaskTab[5].Command.ID=100008;
   1805            RF_TaskTab[5].Command.Order=R_RegOrd;
   1806            RF_TaskTab[5].Command.Auxi=Reg;
   1807            */
   1808              return 1; 
   \   00000028   0120               MOVS     R0,#+1
   \                     ??AddRfTaskTMP_1:
   \   0000002A   08BC               POP      {R3}
   \   0000002C   02BC               POP      {R1}
   \   0000002E   0847               BX       R1               ;; return
   \                     ??AddRfTaskTMP_0:
   \   00000030   ........           DC32     NeuronsList
   1809          
   1810          
   1811          }//_______________________ Koniec funkcji  AddRfTask _________________
   1812          
   1813          
   1814          
   1815          
   1816          
   1817          //-----------------------------------------------------------------------------
   1818          // Nazwa funkcji :    SetTask
   1819          // Funkcja ustawia zadania transmisji RS oraz RF
   1820          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1821          void SetTask(_ProgramTab *ProgTab)
   1822          { 
   \                     SetTask:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   8AB0               SUB      SP,SP,#+40
   1823                _Procedure Proc; 
   1824                _OrderType SetOrd=NonOrd;
   1825                char       RegOrd=0;
   1826            
   1827                
   1828                //wyczyszczenie tablicy zadañ
   1829                for (char i=0; i<RF_Tasks; i++) 
   \   00000004   0025               MOVS     R5,#+0
   \   00000006   2800               MOVS     R0,R5
   \   00000008   08E0               B        ??SetTask_0
   1830                {
   1831                  RF_TaskTab[i].Node=0;
   \                     ??SetTask_1:
   \   0000000A   C900               LSLS     R1,R1,#+3
   \   0000000C   8D4A               LDR      R2,??SetTask_2   ;; RF_TaskTab
   \   0000000E   5118               ADDS     R1,R2,R1
   \   00000010   2A00               MOVS     R2,R5
   \   00000012   0A70               STRB     R2,[R1, #+0]
   1832                  RF_TaskTab[i].Command.ID=0;
   1833                  RF_TaskTab[i].Command.Order=0;
   1834                  RF_TaskTab[i].Command.Auxi=0;
   \   00000014   4D60               STR      R5,[R1, #+4]
   1835                }
   \   00000016   401C               ADDS     R0,R0,#+1
   \   00000018   0006               LSLS     R0,R0,#+24
   \   0000001A   000E               LSRS     R0,R0,#+24
   \                     ??SetTask_0:
   \   0000001C   0100               MOVS     R1,R0
   \   0000001E   4629               CMP      R1,#+70
   \   00000020   F3D3               BCC      ??SetTask_1
   1836                
   1837                for (char node=0; node<NumberNeurons; node++)
   \   00000022   2C00               MOVS     R4,R5
   \   00000024   15E0               B        ??SetTask_3
   1838                {
   1839                   if((NeuronsList[node].NeuronType!=NoneNodeType) && (NeuronsList[node].NeuronType>=BeginRF) && (NeuronsList[node].NeuronType<=EndRF))  AddRfTask(SI, node+1, 0);
   \                     ??SetTask_4:
   \   00000026   8848               LDR      R0,??SetTask_2+0x4  ;; NeuronsList
   \   00000028   2100               MOVS     R1,R4
   \   0000002A   0C22               MOVS     R2,#+12
   \   0000002C   5143               MULS     R1,R2,R1
   \   0000002E   405C               LDRB     R0,[R0, R1]
   \   00000030   0028               CMP      R0,#+0
   \   00000032   0BD0               BEQ      ??SetTask_5
   \   00000034   0228               CMP      R0,#+2
   \   00000036   09D3               BCC      ??SetTask_5
   \   00000038   0628               CMP      R0,#+6
   \   0000003A   07D2               BCS      ??SetTask_5
   \   0000003C   2A00               MOVS     R2,R5
   \   0000003E   2100               MOVS     R1,R4
   \   00000040   491C               ADDS     R1,R1,#+1
   \   00000042   0906               LSLS     R1,R1,#+24
   \   00000044   090E               LSRS     R1,R1,#+24
   \   00000046   0120               MOVS     R0,#+1
   \   00000048   ........           BL       AddRfTask
   1840                }
   \                     ??SetTask_5:
   \   0000004C   641C               ADDS     R4,R4,#+1
   \   0000004E   2406               LSLS     R4,R4,#+24
   \   00000050   240E               LSRS     R4,R4,#+24
   \                     ??SetTask_3:
   \   00000052   2000               MOVS     R0,R4
   \   00000054   2328               CMP      R0,#+35
   \   00000056   E6D3               BCC      ??SetTask_4
   1841                
   1842                
   1843                for (int LineNr=0; LineNr<RealPrcLines; LineNr++)
   \   00000058   0095               STR      R5,[SP, #+0]
   \   0000005A   02E0               B        ??SetTask_6
   \                     ??SetTask_7:
   \   0000005C   0098               LDR      R0,[SP, #+0]
   \   0000005E   401C               ADDS     R0,R0,#+1
   \   00000060   0090               STR      R0,[SP, #+0]
   \                     ??SetTask_6:
   \   00000062   0098               LDR      R0,[SP, #+0]
   \   00000064   7949               LDR      R1,??SetTask_2+0x8  ;; Trap + 12
   \   00000066   0978               LDRB     R1,[R1, #+0]
   \   00000068   8842               CMP      R0,R1
   \   0000006A   58DA               BGE      ??SetTask_8
   1844                {
   1845                  for (int PrcInLine=0; PrcInLine<MaxPrcInLine; PrcInLine++)
   \   0000006C   2C00               MOVS     R4,R5
   \   0000006E   2FE0               B        ??SetTask_9
   1846                  {
   1847          
   1848                        Proc=ProgTab->Line[LineNr].Proc[PrcInLine];
   1849                        
   1850                        RegOrd=Proc.Tag.RegNr;
   1851                        SetOrd=NonOrd;
   1852                        //wybór typu rozkazu
   1853                        switch (Proc.Type)
   1854                        {
   1855                           case ProcWOUT:       SetOrd=SQ;  RegOrd=0; break;
   1856                           case ProcWOUTS:      SetOrd=SQ;  RegOrd=0; break;
   1857                           case ProcWOUTR:      SetOrd=SQ;  RegOrd=0; break;
   1858                           case ProcWOUTC:      SetOrd=SQ;  RegOrd=0; break;
   1859                           case ProcStI:        SetOrd=SI;  RegOrd=0; break;
   1860                           case ProcStNI:       SetOrd=SI;  RegOrd=0; break;
   1861                           case ProcSetReg:     SetOrd=SQ;  RegOrd=Proc.Tag.RegNr; break;
   1862                           case ProcGetReg:     SetOrd=SI;  RegOrd=Proc.Tag.RegNr; break;
   \                     ??SetTask_10:
   \   00000070   0127               MOVS     R7,#+1
   1863                        }     
   1864                         
   1865                        
   1866                        //je¿eli rozkaz
   1867                        if (SetOrd!=NonOrd)
   \                     ??SetTask_11:
   \   00000072   002F               CMP      R7,#+0
   \   00000074   2BD0               BEQ      ??SetTask_12
   1868                        {
   1869                              
   1870                                //Je¿eli nody z transmisj¹ RS
   1871                                if (((NeuronsList[Proc.Nr-1].NeuronType>=BeginRS) && (NeuronsList[Proc.Nr-1].NeuronType<=EndRS)) || (NeuronsList[Proc.Nr-1].NeuronType==0))
   \   00000076   6846               MOV      R0,SP
   \   00000078   04A9               ADD      R1,SP,#+16
   \   0000007A   4978               LDRB     R1,[R1, #+1]
   \   0000007C   0172               STRB     R1,[R0, #+8]
   \   0000007E   7248               LDR      R0,??SetTask_2+0x4  ;; NeuronsList
   \   00000080   6A46               MOV      R2,SP
   \   00000082   0821               MOVS     R1,#+8
   \   00000084   5156               LDRSB    R1,[R2, R1]
   \   00000086   0C22               MOVS     R2,#+12
   \   00000088   5143               MULS     R1,R2,R1
   \   0000008A   4018               ADDS     R0,R0,R1
   \   0000008C   0C38               SUBS     R0,R0,#+12
   \   0000008E   0190               STR      R0,[SP, #+4]
   \   00000090   0078               LDRB     R0,[R0, #+0]
   \   00000092   0028               CMP      R0,#+0
   \   00000094   01D0               BEQ      ??SetTask_13
   \   00000096   0328               CMP      R0,#+3
   \   00000098   01D3               BCC      ??SetTask_14
   \                     ??SetTask_13:
   \   0000009A   0028               CMP      R0,#+0
   \   0000009C   08D1               BNE      ??SetTask_15
   1872                                {
   1873                                  AddRsTask(SetOrd, Proc.Nr, RegOrd);                //Dodaj rozkaz do tablicy zadañ Modbus
   \                     ??SetTask_14:
   \   0000009E   3200               MOVS     R2,R6
   \   000000A0   6946               MOV      R1,SP
   \   000000A2   0820               MOVS     R0,#+8
   \   000000A4   0956               LDRSB    R1,[R1, R0]
   \   000000A6   0906               LSLS     R1,R1,#+24
   \   000000A8   090E               LSRS     R1,R1,#+24
   \   000000AA   3800               MOVS     R0,R7
   \   000000AC   ........           BL       AddRsTask
   1874                                }
   1875                                //Je¿eli nody z transmisj¹ RF
   1876                                if ((NeuronsList[Proc.Nr-1].NeuronType>=BeginRF) && (NeuronsList[Proc.Nr-1].NeuronType<=EndRF))
   \                     ??SetTask_15:
   \   000000B0   0198               LDR      R0,[SP, #+4]
   \   000000B2   0078               LDRB     R0,[R0, #+0]
   \   000000B4   0228               CMP      R0,#+2
   \   000000B6   0AD3               BCC      ??SetTask_12
   \   000000B8   0628               CMP      R0,#+6
   \   000000BA   08D2               BCS      ??SetTask_12
   1877                                {
   1878                                   AddRfTask(SetOrd, Proc.Nr, RegOrd);                //Dodaj rozkaz do tablicy zadañ RF
   \   000000BC   3200               MOVS     R2,R6
   \   000000BE   6946               MOV      R1,SP
   \   000000C0   0820               MOVS     R0,#+8
   \   000000C2   0956               LDRSB    R1,[R1, R0]
   \   000000C4   0906               LSLS     R1,R1,#+24
   \   000000C6   090E               LSRS     R1,R1,#+24
   \   000000C8   3800               MOVS     R0,R7
   \   000000CA   ........           BL       AddRfTask
   1879                                }
   1880                        }  
   \                     ??SetTask_12:
   \   000000CE   641C               ADDS     R4,R4,#+1
   \                     ??SetTask_9:
   \   000000D0   0A2C               CMP      R4,#+10
   \   000000D2   C3DA               BGE      ??SetTask_7
   \   000000D4   04A8               ADD      R0,SP,#+16
   \   000000D6   1821               MOVS     R1,#+24
   \   000000D8   6143               MULS     R1,R4,R1
   \   000000DA   009A               LDR      R2,[SP, #+0]
   \   000000DC   F023               MOVS     R3,#+240
   \   000000DE   5A43               MULS     R2,R3,R2
   \   000000E0   0A9B               LDR      R3,[SP, #+40]
   \   000000E2   9A18               ADDS     R2,R3,R2
   \   000000E4   5118               ADDS     R1,R2,R1
   \   000000E6   1831               ADDS     R1,R1,#+24
   \   000000E8   1822               MOVS     R2,#+24
   \   000000EA   ........           BL       __aeabi_memcpy4
   \   000000EE   04A8               ADD      R0,SP,#+16
   \   000000F0   067A               LDRB     R6,[R0, #+8]
   \   000000F2   2F00               MOVS     R7,R5
   \   000000F4   6846               MOV      R0,SP
   \   000000F6   007C               LDRB     R0,[R0, #+16]
   \   000000F8   1438               SUBS     R0,R0,#+20
   \   000000FA   0128               CMP      R0,#+1
   \   000000FC   0AD9               BLS      ??SetTask_16
   \   000000FE   0C38               SUBS     R0,R0,#+12
   \   00000100   0328               CMP      R0,#+3
   \   00000102   04D9               BLS      ??SetTask_17
   \   00000104   1838               SUBS     R0,R0,#+24
   \   00000106   B3D0               BEQ      ??SetTask_10
   \   00000108   401E               SUBS     R0,R0,#+1
   \   0000010A   06D0               BEQ      ??SetTask_18
   \   0000010C   B1E7               B        ??SetTask_11
   \                     ??SetTask_17:
   \   0000010E   0227               MOVS     R7,#+2
   \   00000110   2E00               MOVS     R6,R5
   \   00000112   AEE7               B        ??SetTask_11
   \                     ??SetTask_16:
   \   00000114   0127               MOVS     R7,#+1
   \   00000116   2E00               MOVS     R6,R5
   \   00000118   ABE7               B        ??SetTask_11
   \                     ??SetTask_18:
   \   0000011A   0227               MOVS     R7,#+2
   \   0000011C   A9E7               B        ??SetTask_11
   1881                        
   1882                  }
   1883                  
   1884                }
   1885                
   1886                
   1887                
   1888                
   1889                
   1890                //Bezpoœrednie zmienne ekranowe
   1891                volatile _Screen* ScreenLokal;
   1892                 _ScreenPaternDesign *ScreenPaternDesign;
   1893          
   1894                
   1895                 for (char Sheet=0; Sheet<ScreenNr; Sheet++)
   \                     ??SetTask_8:
   \   0000011E   2E00               MOVS     R6,R5
   \   00000120   4AE0               B        ??SetTask_19
   1896                 {
   1897                     if (ScreenUse&1<<Sheet)
   1898                     {
   1899                        if (Sheet==0) 
   1900                        {
   1901                          ScreenPaternDesign=ScreenSetTab_0;
   1902                        }else{
   1903                          ScreenPaternDesign=ScreenSetTab_1; 
   1904                        } 
   1905                       
   1906                       ScreenLokal=&gProg.Screen[Sheet];
   1907                       for (char i=0; i<ScrenAnalogNr; i++)
   1908                          {
   1909          
   1910                                if ( (ScreenPaternDesign[ScreenLokal->PaternDesign].Value[i].Width>0) && ((ScreenLokal->Analog[i].Nr>0) || ((ScreenLokal->Analog[i].Nr==0)&&(ScreenLokal->Analog[i].Reg>0))))
   1911                                 {
   1912                                    AddRfTask(SI, ScreenLokal->Analog[i].Nr, ScreenLokal->Analog[i].Reg);
   1913                                 }
   1914                          }
   1915                       for (char i=0; i<ScrenGraphNr; i++)
   1916                          {
   1917                                if ((ScreenPaternDesign[ScreenLokal->PaternDesign].Graph[i].Width>0) && ((ScreenLokal->Graph[i].Type==GraphOnOff) || (ScreenLokal->Graph[i].PlusOnOff==1) || (ScreenLokal->Graph[i].Type==GraphWartosc)))
   \                     ??SetTask_20:
   \   00000122   8100               LSLS     R1,R0,#+2
   \   00000124   2278               LDRB     R2,[R4, #+0]
   \   00000126   5823               MOVS     R3,#+88
   \   00000128   5A43               MULS     R2,R3,R2
   \   0000012A   009B               LDR      R3,[SP, #+0]
   \   0000012C   9A18               ADDS     R2,R3,R2
   \   0000012E   5118               ADDS     R1,R2,R1
   \   00000130   2631               ADDS     R1,R1,#+38
   \   00000132   0978               LDRB     R1,[R1, #+0]
   \   00000134   0029               CMP      R1,#+0
   \   00000136   11D0               BEQ      ??SetTask_21
   \   00000138   0721               MOVS     R1,#+7
   \   0000013A   4843               MULS     R0,R1,R0
   \   0000013C   2018               ADDS     R0,R4,R0
   \   0000013E   5330               ADDS     R0,R0,#+83
   \   00000140   0178               LDRB     R1,[R0, #+0]
   \   00000142   0B29               CMP      R1,#+11
   \   00000144   05D0               BEQ      ??SetTask_22
   \   00000146   8179               LDRB     R1,[R0, #+6]
   \   00000148   C907               LSLS     R1,R1,#+31
   \   0000014A   02D4               BMI      ??SetTask_22
   \   0000014C   0178               LDRB     R1,[R0, #+0]
   \   0000014E   0A29               CMP      R1,#+10
   \   00000150   04D1               BNE      ??SetTask_21
   1918                                 {
   1919                                    AddRfTask(SI, ScreenLokal->Graph[i].Nr, ScreenLokal->Graph[i].Reg);
   \                     ??SetTask_22:
   \   00000152   4279               LDRB     R2,[R0, #+5]
   \   00000154   0179               LDRB     R1,[R0, #+4]
   \   00000156   0120               MOVS     R0,#+1
   \   00000158   ........           BL       AddRfTask
   1920                                 }
   1921                          }
   \                     ??SetTask_21:
   \   0000015C   7F1C               ADDS     R7,R7,#+1
   \   0000015E   3F06               LSLS     R7,R7,#+24
   \   00000160   3F0E               LSRS     R7,R7,#+24
   \                     ??SetTask_23:
   \   00000162   3800               MOVS     R0,R7
   \   00000164   0428               CMP      R0,#+4
   \   00000166   DCD3               BCC      ??SetTask_20
   1922                       
   1923                       //je¿eli na stronie jest termostat
   1924                       if (((Sheet==0) && (gProg.Screen[Sheet].PaternDesign==MainScreenTermo)) || 
   1925                              ((Sheet) && (gProg.Screen[Sheet].PaternDesign==SubScreenTermo)))
   \   00000168   3000               MOVS     R0,R6
   \   0000016A   03D1               BNE      ??SetTask_24
   \   0000016C   0198               LDR      R0,[SP, #+4]
   \   0000016E   0078               LDRB     R0,[R0, #+0]
   \   00000170   0828               CMP      R0,#+8
   \   00000172   05D0               BEQ      ??SetTask_25
   \                     ??SetTask_24:
   \   00000174   3000               MOVS     R0,R6
   \   00000176   1CD0               BEQ      ??SetTask_26
   \   00000178   0198               LDR      R0,[SP, #+4]
   \   0000017A   0078               LDRB     R0,[R0, #+0]
   \   0000017C   0528               CMP      R0,#+5
   \   0000017E   18D1               BNE      ??SetTask_26
   1926                        {
   1927                        
   1928                       if (ScreenLokal->Thermo.ActorNode>0)
   \                     ??SetTask_25:
   \   00000180   8C34               ADDS     R4,R4,#+140
   \   00000182   0020               MOVS     R0,#+0
   \   00000184   2056               LDRSB    R0,[R4, R0]
   \   00000186   0128               CMP      R0,#+1
   \   00000188   07DB               BLT      ??SetTask_27
   1929                                 {
   1930                                    AddRfTask(SQ, ScreenLokal->Thermo.ActorNode, ScreenLokal->Thermo.ActorPort);
   \   0000018A   6278               LDRB     R2,[R4, #+1]
   \   0000018C   0020               MOVS     R0,#+0
   \   0000018E   2156               LDRSB    R1,[R4, R0]
   \   00000190   0906               LSLS     R1,R1,#+24
   \   00000192   090E               LSRS     R1,R1,#+24
   \   00000194   0220               MOVS     R0,#+2
   \   00000196   ........           BL       AddRfTask
   1931                                 }   
   1932                       if (ScreenLokal->Thermo.SensorNode>0)
   \                     ??SetTask_27:
   \   0000019A   0320               MOVS     R0,#+3
   \   0000019C   2056               LDRSB    R0,[R4, R0]
   \   0000019E   0128               CMP      R0,#+1
   \   000001A0   07DB               BLT      ??SetTask_26
   1933                                 {
   1934                                    AddRfTask(SI, ScreenLokal->Thermo.SensorNode, ScreenLokal->Thermo.SensorReg);
   \   000001A2   2279               LDRB     R2,[R4, #+4]
   \   000001A4   0320               MOVS     R0,#+3
   \   000001A6   2156               LDRSB    R1,[R4, R0]
   \   000001A8   0906               LSLS     R1,R1,#+24
   \   000001AA   090E               LSRS     R1,R1,#+24
   \   000001AC   0120               MOVS     R0,#+1
   \   000001AE   ........           BL       AddRfTask
   1935                                 }  
   1936                       
   1937                        }
   \                     ??SetTask_26:
   \   000001B2   761C               ADDS     R6,R6,#+1
   \   000001B4   3606               LSLS     R6,R6,#+24
   \   000001B6   360E               LSRS     R6,R6,#+24
   \                     ??SetTask_19:
   \   000001B8   3000               MOVS     R0,R6
   \   000001BA   0828               CMP      R0,#+8
   \   000001BC   3DD2               BCS      ??SetTask_28
   \   000001BE   3020               MOVS     R0,#+48
   \   000001C0   2349               LDR      R1,??SetTask_2+0xC  ;; Trap
   \   000001C2   085E               LDRSH    R0,[R1, R0]
   \   000001C4   0121               MOVS     R1,#+1
   \   000001C6   B140               LSLS     R1,R1,R6
   \   000001C8   0140               ANDS     R1,R1,R0
   \   000001CA   F2D0               BEQ      ??SetTask_26
   \   000001CC   3000               MOVS     R0,R6
   \   000001CE   02D1               BNE      ??SetTask_29
   \   000001D0   2048               LDR      R0,??SetTask_2+0x10  ;; ScreenSetTab_0
   \   000001D2   0090               STR      R0,[SP, #+0]
   \   000001D4   01E0               B        ??SetTask_30
   \                     ??SetTask_29:
   \   000001D6   2048               LDR      R0,??SetTask_2+0x14  ;; ScreenSetTab_1
   \   000001D8   0090               STR      R0,[SP, #+0]
   \                     ??SetTask_30:
   \   000001DA   2048               LDR      R0,??SetTask_2+0x18  ;; 0xbb98
   \   000001DC   3100               MOVS     R1,R6
   \   000001DE   A022               MOVS     R2,#+160
   \   000001E0   5143               MULS     R1,R2,R1
   \   000001E2   1F4A               LDR      R2,??SetTask_2+0x1C  ;; gProg
   \   000001E4   5118               ADDS     R1,R2,R1
   \   000001E6   0818               ADDS     R0,R1,R0
   \   000001E8   0190               STR      R0,[SP, #+4]
   \   000001EA   0400               MOVS     R4,R0
   \   000001EC   2F00               MOVS     R7,R5
   \   000001EE   1FE0               B        ??SetTask_31
   \                     ??SetTask_32:
   \   000001F0   8100               LSLS     R1,R0,#+2
   \   000001F2   2278               LDRB     R2,[R4, #+0]
   \   000001F4   5823               MOVS     R3,#+88
   \   000001F6   5A43               MULS     R2,R3,R2
   \   000001F8   009B               LDR      R3,[SP, #+0]
   \   000001FA   9A18               ADDS     R2,R3,R2
   \   000001FC   5118               ADDS     R1,R2,R1
   \   000001FE   3631               ADDS     R1,R1,#+54
   \   00000200   0978               LDRB     R1,[R1, #+0]
   \   00000202   0029               CMP      R1,#+0
   \   00000204   11D0               BEQ      ??SetTask_33
   \   00000206   0721               MOVS     R1,#+7
   \   00000208   4843               MULS     R0,R1,R0
   \   0000020A   2018               ADDS     R0,R4,R0
   \   0000020C   7330               ADDS     R0,R0,#+115
   \   0000020E   0178               LDRB     R1,[R0, #+0]
   \   00000210   0029               CMP      R1,#+0
   \   00000212   05D1               BNE      ??SetTask_34
   \   00000214   0178               LDRB     R1,[R0, #+0]
   \   00000216   0029               CMP      R1,#+0
   \   00000218   07D1               BNE      ??SetTask_33
   \   0000021A   4178               LDRB     R1,[R0, #+1]
   \   0000021C   0029               CMP      R1,#+0
   \   0000021E   04D0               BEQ      ??SetTask_33
   \                     ??SetTask_34:
   \   00000220   4278               LDRB     R2,[R0, #+1]
   \   00000222   0178               LDRB     R1,[R0, #+0]
   \   00000224   0120               MOVS     R0,#+1
   \   00000226   ........           BL       AddRfTask
   \                     ??SetTask_33:
   \   0000022A   7F1C               ADDS     R7,R7,#+1
   \   0000022C   3F06               LSLS     R7,R7,#+24
   \   0000022E   3F0E               LSRS     R7,R7,#+24
   \                     ??SetTask_31:
   \   00000230   3800               MOVS     R0,R7
   \   00000232   0428               CMP      R0,#+4
   \   00000234   DCD3               BCC      ??SetTask_32
   \   00000236   2F00               MOVS     R7,R5
   \   00000238   93E7               B        ??SetTask_23
   1938                     
   1939                     }
   1940          
   1941                 }
   1942                //-------------------------------
   1943                
   1944                
   1945                //Dodanie standardowego odpytywania wez³ów nie u¿ywanych w programie
   1946                 /*
   1947                 char ExstF=0;
   1948                
   1949                for (char i=0; i<NumberNeurons; i++)
   1950                {
   1951                  ExstF=0;
   1952                  if (NeuronsList[i].NeuronID!=0)
   1953                  {
   1954                     for (char j=0; j<RF_Tasks; j++)
   1955                     {
   1956                       if (RF_TaskTab[j].Command.ID==0)  //je¿eli brak zadañ to wyjdŸ
   1957                       { 
   1958                         j=RF_Tasks;
   1959                       }else if (RF_TaskTab[j].Command.ID==NeuronsList[i].NeuronID)    //je¿eli zadanie dla tego noda istnieje
   1960                       {
   1961                         ExstF=1;   //ustaw flagê
   1962                       }
   1963                     }
   1964                     
   1965                     //je¿eli nie znaleziono zadania dla wez³a przypisz pytanie standardowe
   1966                     if (ExstF==0)
   1967                     {
   1968                         AddRfTask(SI, i+1, 0);                //Dodaj pytanie standardowe do tablicy zadañ RF
   1969                     }
   1970                  }
   1971                  
   1972                }
   1973                 */
   1974               
   1975                
   1976                
   1977                          
   1978          }//_______________________ Koniec funkcji  SetTask_________________
   \                     ??SetTask_28:
   \   0000023A   0BB0               ADD      SP,SP,#+44
   \   0000023C   F0BC               POP      {R4-R7}
   \   0000023E   01BC               POP      {R0}
   \   00000240   0047               BX       R0               ;; return
   \   00000242   C046               Nop      
   \                     ??SetTask_2:
   \   00000244   ........           DC32     RF_TaskTab
   \   00000248   ........           DC32     NeuronsList
   \   0000024C   ........           DC32     Trap + 12
   \   00000250   ........           DC32     Trap
   \   00000254   ........           DC32     ScreenSetTab_0
   \   00000258   ........           DC32     ScreenSetTab_1
   \   0000025C   98BB0000           DC32     0xbb98
   \   00000260   ........           DC32     gProg
   1979          
   1980          
   1981          
   1982          
   1983          
   1984          
   1985          
   1986          
   1987          //-----------------------------------------------------------------------------
   1988          // Nazwa funkcji :    ProgramChangeSave
   1989          // Funkcja zapisu zmian w programie u¿ytkowym
   1990          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1991          void ProgramChangeExecute(_ProgramTab *ProgTab)
   1992          {
   \                     ProgramChangeExecute:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1993             //obliczenie iloœci u¿ywanych scen
   1994             NumberScene=SceneNrCount(ProgTab);
   \   00000004   094D               LDR      R5,??ProgramChangeExecute_0  ;; Trap
   \   00000006   ........           BL       SceneNrCount
   \   0000000A   2872               STRB     R0,[R5, #+8]
   1995             
   1996             //obliczenie iloœci u¿ywanych linii
   1997             CountLines(ProgTab);
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       CountLines
   1998             
   1999             //obliczenie iloœci u¿ywanych stron ekranowych
   2000             ScreenUse=CheckScreenUse(ProgTab);
   \   00000012   2000               MOVS     R0,R4
   \   00000014   ........           BL       CheckScreenUse
   \   00000018   2886               STRH     R0,[R5, #+48]
   2001             
   2002          
   2003             
   2004             //odœwierzenie/przepisanie listy neuronów
   2005             RefreshNeuronsList(ProgTab);
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       RefreshNeuronsList
   2006             
   2007             
   2008             //ustawienie zadañ Rs i RF
   2009             SetTask(ProgTab);
   \   00000020   2000               MOVS     R0,R4
   \   00000022   ........           BL       SetTask
   2010            
   2011          }//_______________________ Koniec funkcji zapisu zmian programu_________________
   \   00000026   38BC               POP      {R3-R5}
   \   00000028   01BC               POP      {R0}
   \   0000002A   0047               BX       R0               ;; return
   \                     ??ProgramChangeExecute_0:
   \   0000002C   ........           DC32     Trap
   2012          
   2013          
   2014          
   2015          
   2016          
   2017          
   2018          //*-----------------------------------------------------------------------------
   2019          //* Nazwa funkcji :    GetBinVarPack
   2020          //* Funkcja zwraca paczkê w tablicy wartoœci zmienncyh dwustanowych z zakresu B000 - B700
   2021          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   2022          void GetBinVarPack(WORD adr, WORD Length,unsigned char *Tab )
   2023          {
   2024            /*
   2025                  WORD  RamByte=(adr/8);
   2026                  WORD  RamBit= (adr) % 8;
   2027                  char  CurentByte;
   2028                  char  CurentBit;  
   2029            
   2030              
   2031                for (WORD i=0; i<Length; i++)
   2032                      {
   2033                         Tab[CurentByte] &= ~(1<<CurentBit);
   2034                         Tab[CurentByte] |=  (((ram.BinVarRAM[RamByte]>>RamBit) & 0x1)<< CurentBit);
   2035                                   
   2036                         if (CurentBit<7) {CurentBit++;} else {CurentBit=0; CurentByte++;}
   2037                         if (RamBit<7) {RamBit++;} else {RamBit=0; RamByte++;}
   2038                      }  
   2039            
   2040           */
   2041          }//_______________________ Koniec funkcji GetBinVar ____________________________
   \                     GetBinVarPack:
   \   00000000   7047               BX       LR               ;; return
   2042          
   2043          
   2044          
   2045          
   2046          
   2047          
   2048          
   2049          
   2050          
   2051          //*-----------------------------------------------------------------------------
   2052          //* Nazwa funkcji :    GetBinVar
   2053          //* Funkcja przepisuje paczkê wartoœci zmiennych dwustanowej komunikacyjnej DA00 - DDFF do Tab
   2054          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   2055          void GetBinVarPackComm(WORD adr, WORD Length, unsigned char* Tab )
   2056          {
   \                     GetBinVarPackComm:
   \   00000000   F7B5               PUSH     {R0-R2,R4-R7,LR}
   2057                  WORD  RamByte=adr;
   \   00000002   0021               MOVS     R1,#+0
   2058                  WORD  RamBit= 0;
   2059                  char  CurentByte = 0;
   \   00000004   0A00               MOVS     R2,R1
   2060                  char  CurentBit = 0;  
   \   00000006   0B00               MOVS     R3,R1
   2061          
   2062                  for (char i=0; i<16; i++)  {Tab[i]=0;}
   \   00000008   0C00               MOVS     R4,R1
   \   0000000A   0E00               MOVS     R6,R1
   \   0000000C   05E0               B        ??GetBinVarPackComm_0
   \                     ??GetBinVarPackComm_1:
   \   0000000E   2700               MOVS     R7,R4
   \   00000010   029D               LDR      R5,[SP, #+8]
   \   00000012   EE55               STRB     R6,[R5, R7]
   \   00000014   641C               ADDS     R4,R4,#+1
   \   00000016   2406               LSLS     R4,R4,#+24
   \   00000018   240E               LSRS     R4,R4,#+24
   \                     ??GetBinVarPackComm_0:
   \   0000001A   2500               MOVS     R5,R4
   \   0000001C   102D               CMP      R5,#+16
   \   0000001E   F6D3               BCC      ??GetBinVarPackComm_1
   2063               
   2064              
   2065                for (WORD i=0; i<Length; i++)
   \   00000020   0C00               MOVS     R4,R1
   \   00000022   06E0               B        ??GetBinVarPackComm_2
   2066                      {
   2067                         if ((ram.VarCom_Word[RamByte]>>RamBit) & 0x1) { Tab[CurentByte] |= 0x1<<CurentBit;} else {Tab[CurentByte] &= ~(0x1<<CurentBit);}
   2068                        
   2069                         
   2070                         if (CurentBit<7) {CurentBit++;} else {CurentBit=0; CurentByte++; Tab[CurentByte]=0;}
   2071                         if (RamBit<7) {RamBit++;} else {RamBit=0; RamByte++;}
   \                     ??GetBinVarPackComm_3:
   \   00000024   0021               MOVS     R1,#+0
   \   00000026   401C               ADDS     R0,R0,#+1
   \   00000028   0004               LSLS     R0,R0,#+16
   \   0000002A   000C               LSRS     R0,R0,#+16
   \                     ??GetBinVarPackComm_4:
   \   0000002C   641C               ADDS     R4,R4,#+1
   \   0000002E   2404               LSLS     R4,R4,#+16
   \   00000030   240C               LSRS     R4,R4,#+16
   \                     ??GetBinVarPackComm_2:
   \   00000032   2500               MOVS     R5,R4
   \   00000034   6E46               MOV      R6,SP
   \   00000036   B688               LDRH     R6,[R6, #+4]
   \   00000038   B542               CMP      R5,R6
   \   0000003A   2DD2               BCS      ??GetBinVarPackComm_5
   \   0000003C   0500               MOVS     R5,R0
   \   0000003E   6D00               LSLS     R5,R5,#+1
   \   00000040   174E               LDR      R6,??GetBinVarPackComm_6  ;; ram
   \   00000042   755B               LDRH     R5,[R6, R5]
   \   00000044   0D41               ASRS     R5,R5,R1
   \   00000046   ED07               LSLS     R5,R5,#+31
   \   00000048   08D5               BPL      ??GetBinVarPackComm_7
   \   0000004A   1500               MOVS     R5,R2
   \   0000004C   029E               LDR      R6,[SP, #+8]
   \   0000004E   7519               ADDS     R5,R6,R5
   \   00000050   2E78               LDRB     R6,[R5, #+0]
   \   00000052   0127               MOVS     R7,#+1
   \   00000054   9F40               LSLS     R7,R7,R3
   \   00000056   3743               ORRS     R7,R7,R6
   \   00000058   2F70               STRB     R7,[R5, #+0]
   \   0000005A   07E0               B        ??GetBinVarPackComm_8
   \                     ??GetBinVarPackComm_7:
   \   0000005C   1500               MOVS     R5,R2
   \   0000005E   029E               LDR      R6,[SP, #+8]
   \   00000060   7519               ADDS     R5,R6,R5
   \   00000062   2E78               LDRB     R6,[R5, #+0]
   \   00000064   0127               MOVS     R7,#+1
   \   00000066   9F40               LSLS     R7,R7,R3
   \   00000068   BE43               BICS     R6,R6,R7
   \   0000006A   2E70               STRB     R6,[R5, #+0]
   \                     ??GetBinVarPackComm_8:
   \   0000006C   1D00               MOVS     R5,R3
   \   0000006E   072D               CMP      R5,#+7
   \   00000070   03D2               BCS      ??GetBinVarPackComm_9
   \   00000072   5B1C               ADDS     R3,R3,#+1
   \   00000074   1B06               LSLS     R3,R3,#+24
   \   00000076   1B0E               LSRS     R3,R3,#+24
   \   00000078   07E0               B        ??GetBinVarPackComm_10
   \                     ??GetBinVarPackComm_9:
   \   0000007A   0023               MOVS     R3,#+0
   \   0000007C   521C               ADDS     R2,R2,#+1
   \   0000007E   1206               LSLS     R2,R2,#+24
   \   00000080   120E               LSRS     R2,R2,#+24
   \   00000082   1700               MOVS     R7,R2
   \   00000084   029D               LDR      R5,[SP, #+8]
   \   00000086   1E00               MOVS     R6,R3
   \   00000088   EE55               STRB     R6,[R5, R7]
   \                     ??GetBinVarPackComm_10:
   \   0000008A   0D00               MOVS     R5,R1
   \   0000008C   072D               CMP      R5,#+7
   \   0000008E   C9D2               BCS      ??GetBinVarPackComm_3
   \   00000090   491C               ADDS     R1,R1,#+1
   \   00000092   0904               LSLS     R1,R1,#+16
   \   00000094   090C               LSRS     R1,R1,#+16
   \   00000096   C9E7               B        ??GetBinVarPackComm_4
   2072                      }  
   2073          }//_______________________ Koniec funkcji GetBinVarComm ________________________
   \                     ??GetBinVarPackComm_5:
   \   00000098   FEBC               POP      {R1-R7}
   \   0000009A   01BC               POP      {R0}
   \   0000009C   0047               BX       R0               ;; return
   \   0000009E   C046               Nop      
   \                     ??GetBinVarPackComm_6:
   \   000000A0   ........           DC32     ram
   2074          
   2075          
   2076          //*-----------------------------------------------------------------------------
   2077          //* Nazwa funkcji :    GetRegPackComm
   2078          //* Funkcja przepisuje StageQ
   2079          //*   Adr - nr StageQ
   2080          //*   Reg - nr rejestru
   2081          //*   LengthBit - ile bitów do kopiowania je¿eli wiêcej ni¿ 16 to kopiuje z nastêpnego rejestru
   2082          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   2083          void GetRegPackComm(short int  Adr, char Reg, char LengthBit, unsigned char* Tab )
   2084          {
   \                     GetRegPackComm:
   \   00000000   FDB5               PUSH     {R0,R2-R7,LR}
   2085                  WORD  RamWord=Reg;
   \   00000002   0C00               MOVS     R4,R1
   \   00000004   0023               MOVS     R3,#+0
   2086                  WORD  RamBitInWord= 0;
   2087                  char  CurentByte = 0;
   \   00000006   1900               MOVS     R1,R3
   2088                  char  CurentBit = 0;  
   \   00000008   0A00               MOVS     R2,R1
   2089           
   2090                  Adr+=1;
   \   0000000A   6D46               MOV      R5,SP
   \   0000000C   401C               ADDS     R0,R0,#+1
   \   0000000E   2880               STRH     R0,[R5, #+0]
   2091                  
   2092                  for (char i=0; i<16; i++)  {Tab[i]=0;}
   \   00000010   0800               MOVS     R0,R1
   \   00000012   0600               MOVS     R6,R0
   \   00000014   05E0               B        ??GetRegPackComm_0
   \                     ??GetRegPackComm_1:
   \   00000016   0700               MOVS     R7,R0
   \   00000018   029D               LDR      R5,[SP, #+8]
   \   0000001A   EE55               STRB     R6,[R5, R7]
   \   0000001C   401C               ADDS     R0,R0,#+1
   \   0000001E   0006               LSLS     R0,R0,#+24
   \   00000020   000E               LSRS     R0,R0,#+24
   \                     ??GetRegPackComm_0:
   \   00000022   0500               MOVS     R5,R0
   \   00000024   102D               CMP      R5,#+16
   \   00000026   F6D3               BCC      ??GetRegPackComm_1
   2093               
   2094              
   2095                for (WORD i=0; i<LengthBit; i++)
   \   00000028   0D00               MOVS     R5,R1
   \   0000002A   06E0               B        ??GetRegPackComm_2
   2096                      {
   2097                         if ((MainStage.StageQ[Adr].Value[RamWord]>>RamBitInWord) & 0x1) { Tab[CurentByte] |= 0x1<<CurentBit;} else {Tab[CurentByte] &= ~(0x1<<CurentBit);}
   2098                        
   2099                         
   2100                         if (CurentBit<7) {CurentBit++;} else {CurentBit=0; CurentByte++; Tab[CurentByte]=0;}
   2101                         if (RamBitInWord<15) {RamBitInWord++;} else {RamBitInWord=0; RamWord++;}
   \                     ??GetRegPackComm_3:
   \   0000002C   0023               MOVS     R3,#+0
   \   0000002E   641C               ADDS     R4,R4,#+1
   \   00000030   2404               LSLS     R4,R4,#+16
   \   00000032   240C               LSRS     R4,R4,#+16
   \                     ??GetRegPackComm_4:
   \   00000034   6D1C               ADDS     R5,R5,#+1
   \   00000036   2D04               LSLS     R5,R5,#+16
   \   00000038   2D0C               LSRS     R5,R5,#+16
   \                     ??GetRegPackComm_2:
   \   0000003A   2800               MOVS     R0,R5
   \   0000003C   6E46               MOV      R6,SP
   \   0000003E   3679               LDRB     R6,[R6, #+4]
   \   00000040   B042               CMP      R0,R6
   \   00000042   37D2               BCS      ??GetRegPackComm_5
   \   00000044   1D48               LDR      R0,??GetRegPackComm_6  ;; 0x3a2
   \   00000046   8446               MOV      R12,R0
   \   00000048   2000               MOVS     R0,R4
   \   0000004A   4600               LSLS     R6,R0,#+1
   \   0000004C   6F46               MOV      R7,SP
   \   0000004E   0020               MOVS     R0,#+0
   \   00000050   385E               LDRSH    R0,[R7, R0]
   \   00000052   1627               MOVS     R7,#+22
   \   00000054   7843               MULS     R0,R7,R0
   \   00000056   1A4F               LDR      R7,??GetRegPackComm_6+0x4  ;; MainStage
   \   00000058   3818               ADDS     R0,R7,R0
   \   0000005A   8619               ADDS     R6,R0,R6
   \   0000005C   6046               MOV      R0,R12
   \   0000005E   305E               LDRSH    R0,[R6, R0]
   \   00000060   1841               ASRS     R0,R0,R3
   \   00000062   C007               LSLS     R0,R0,#+31
   \   00000064   08D5               BPL      ??GetRegPackComm_7
   \   00000066   0800               MOVS     R0,R1
   \   00000068   029E               LDR      R6,[SP, #+8]
   \   0000006A   3018               ADDS     R0,R6,R0
   \   0000006C   0678               LDRB     R6,[R0, #+0]
   \   0000006E   0127               MOVS     R7,#+1
   \   00000070   9740               LSLS     R7,R7,R2
   \   00000072   3743               ORRS     R7,R7,R6
   \   00000074   0770               STRB     R7,[R0, #+0]
   \   00000076   07E0               B        ??GetRegPackComm_8
   \                     ??GetRegPackComm_7:
   \   00000078   0800               MOVS     R0,R1
   \   0000007A   029E               LDR      R6,[SP, #+8]
   \   0000007C   3018               ADDS     R0,R6,R0
   \   0000007E   0678               LDRB     R6,[R0, #+0]
   \   00000080   0127               MOVS     R7,#+1
   \   00000082   9740               LSLS     R7,R7,R2
   \   00000084   BE43               BICS     R6,R6,R7
   \   00000086   0670               STRB     R6,[R0, #+0]
   \                     ??GetRegPackComm_8:
   \   00000088   1000               MOVS     R0,R2
   \   0000008A   0728               CMP      R0,#+7
   \   0000008C   03D2               BCS      ??GetRegPackComm_9
   \   0000008E   521C               ADDS     R2,R2,#+1
   \   00000090   1206               LSLS     R2,R2,#+24
   \   00000092   120E               LSRS     R2,R2,#+24
   \   00000094   07E0               B        ??GetRegPackComm_10
   \                     ??GetRegPackComm_9:
   \   00000096   0022               MOVS     R2,#+0
   \   00000098   491C               ADDS     R1,R1,#+1
   \   0000009A   0906               LSLS     R1,R1,#+24
   \   0000009C   090E               LSRS     R1,R1,#+24
   \   0000009E   0F00               MOVS     R7,R1
   \   000000A0   0298               LDR      R0,[SP, #+8]
   \   000000A2   1600               MOVS     R6,R2
   \   000000A4   C655               STRB     R6,[R0, R7]
   \                     ??GetRegPackComm_10:
   \   000000A6   1800               MOVS     R0,R3
   \   000000A8   0F28               CMP      R0,#+15
   \   000000AA   BFD2               BCS      ??GetRegPackComm_3
   \   000000AC   5B1C               ADDS     R3,R3,#+1
   \   000000AE   1B04               LSLS     R3,R3,#+16
   \   000000B0   1B0C               LSRS     R3,R3,#+16
   \   000000B2   BFE7               B        ??GetRegPackComm_4
   2102                      }  
   2103          }//_______________________ Koniec funkcji GetRegPackComm ________________________
   \                     ??GetRegPackComm_5:
   \   000000B4   FEBC               POP      {R1-R7}
   \   000000B6   01BC               POP      {R0}
   \   000000B8   0047               BX       R0               ;; return
   \   000000BA   C046               Nop      
   \                     ??GetRegPackComm_6:
   \   000000BC   A2030000           DC32     0x3a2
   \   000000C0   ........           DC32     MainStage

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   ........           DC32     ZD_MODBUS_0

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   AA8A0000           DC32     0x8aaa

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   ........           DC32     Trap

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     VariablesAnal

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   A2030000           DC32     0x3a2

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   EA060000           DC32     0x6ea
   2104          
   2105          
   2106          
   2107          
   2108          
   2109          
   2110          //****************************************************************************//
   2111          //****************************************************************************//
   2112          //*************************** P R O C E D U R Y ******************************//
   2113          //****************************************************************************//
   2114          //****************************************************************************//
   2115          
   2116          
   2117          
   2118          
   2119          
   2120          
   2121          
   2122          
   2123          
   2124          
   2125          

   Maximum stack usage in bytes:

     Function                       .cstack
     --------                       -------
     AddRfTask                          40
     AddRfTaskTMP                        8
     AddRfTask_RemoveSearchNodeTask     16
     AddRfTask_SearchNodeTask           16
     AddRsTask                          24
     CheckScreenUse                     24
     CountLines                         24
     GetBinVarPack                       0
     GetBinVarPackComm                  32
     GetRegPackComm                     32
     PortStageRead                       0
     PortStageSet                        8
     ProcClock_Action                    8
     ProcConect_Action                   0
     ProcConstAnal_Action                0
     ProcDay_Action                      8
     ProcDec_Action                      8
     ProcDiv_Action                     24
     ProcDownRight_Action                0
     ProcDown_Action                     0
     ProcEven_Action                     8
     ProcGetReg_Action                  16
     ProcInc_Action                     16
     ProcLim_Action                      8
     ProcMinus_Action                    0
     ProcMul_Action                      8
     ProcNOT_Action                      0
     ProcPlus_Action                     0
     ProcSPK_Action                     16
     ProcSetAnal_Action                 16
     ProcSetScn_Action                  16
     ProcStB_Action                      8
     ProcStI_Action                      8
     ProcStNI_Action                     8
     ProcStQ_Action                     16
     ProcStS_Action                      8
     ProcSumL_Action                     0
     ProcTLI1_Action                     8
     ProcTimerSet_Action                 8
     ProcToggleRS_Action                 8
     ProcToggleT_Action                  8
     ProcUpToRightDown_Action            0
     ProcUpToRight_Action                0
     ProcWOUTC_Action                   24
     ProcWOUTR_Action                   24
     ProcWOUTS_Action                   24
     ProcWOUT_Action                    24
     Program                            32
     ProgramChangeExecute               16
     RefreshNeuronsList                 24
     RemoveRfNodeAllTaska               24
     RemoveRfTask                       16
     SceneNrCount                       24
     SetModbusTask                       0
     SetTask                            64


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     SceneBefOff                        1
     TransQuality                     216
     ProgConvers_DW_F                   4
     ButtonExe                        576
     gProg                          50800
     NeuronsList                      420
     VariablesAnal                     40
     MainStage                       1808
     SetModbusTask                    110
     PortStageRead                     10
     PortStageSet                      24
     ProcStI_Action                   106
     ProcStNI_Action                  124
     ProcGetReg_Action                104
     ProcSetAnal_Action                54
     ProcConstAnal_Action               6
     ProcStB_Action                    32
     ProcStQ_Action                    48
     ProcStS_Action                    34
     ProcWOUT_Action                  268
     ProcWOUTS_Action                 152
     ProcWOUTR_Action                 152
     ProcWOUTC_Action                 264
     ProcNOT_Action                    14
     ProcToggleRS_Action               32
     ProcToggleT_Action                66
     ProcTLI1_Action                   34
     ProcLim_Action                    28
     ProcEven_Action                   28
     ProcPlus_Action                   12
     ProcMinus_Action                  12
     ProcMul_Action                    56
     ProcDiv_Action                   124
     ProcConect_Action                  6
     ProcDown_Action                    6
     ProcDownRight_Action               6
     ProcUpToRight_Action               6
     ProcUpToRightDown_Action           6
     ProcSetScn_Action                 84
     ProcInc_Action                    60
     ProcDec_Action                    60
     ProcSPK_Action                   172
     ProcSumL_Action                   10
     ProcTimerSet_Action               72
     ProcClock_Action                 140
     ProcDay_Action                    36
     Program                         1188
     Trap                              68
     pProg                              4
     SceneNrCount                      68
     CheckScreenUse                   140
     CountLines                        76
     RefreshNeuronsList               100
     AddRsTask                        184
     AddRfTask_SearchNodeTask         132
     AddRfTask_RemoveSearchNodeTask   124
     RemoveRfNodeAllTaska             168
     RemoveRfTask                     136
     AddRfTask                        484
     AddRfTaskTMP                      52
     SetTask                          612
     ProgramChangeExecute              48
     GetBinVarPack                      2
     GetBinVarPackComm                164
     GetRegPackComm                   196
     ??DataTable0                       4
     ??DataTable3                       4
     ??DataTable4                       4
     ??DataTable7                       4
     ??DataTable8                       4
     ??DataTable9                       4

 
 53 865 bytes in section .bss
     72 bytes in section .data
  6 456 bytes in section Debug.txt
 
  6 456 bytes of CODE memory
 53 937 bytes of DATA memory

Errors: none
Warnings: 17
