###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           04/Jun/2013  20:16:54 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\Framework\flash.c                             #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\Framework\flash.c" -D AT91SAM7S256 -D         #
#                    AT91SAM7SEK -D iH -D __ALARM -D __WIFI_MODULE -D         #
#                    __MaxRf -D S300iMax -lC "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v1.3 - 04.06.2013\S300iMax\List\" --diag_suppress  #
#                    Pa082 -o "D:\Zeuron\Projekty\S300\S300-program v1.3 -    #
#                    04.06.2013\S300iMax\Obj\" --no_unroll --no_inline        #
#                    --no_tbaa --no_scheduling --debug --endian little --cpu  #
#                    ARM7TDMI -e --fpu None --dlib_config "C:\Program Files   #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    5.0\ARM\INC\DLib_Config_Normal.h" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v1.3 - 04.06.2013\cdc\" -I "D:\Zeuron\Projekty\S300\S300 #
#                    -program v1.3 - 04.06.2013\core\" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\startup\" -I "D:\Zeuron\Projekty\S300\S300-pr #
#                    ogram v1.3 - 04.06.2013\Framework\" -I                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 -             #
#                    04.06.2013\Framework\Configuration\" -I "C:\Program      #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    5.0\ARM\INC\" --section .text=Debug.txt --interwork      #
#                    --cpu_mode thumb -Om                                     #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300iMax\List\flash.lst                       #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 -              #
#                    04.06.2013\S300iMax\Obj\flash.o                          #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c
      1          #include "flash.h"
      2          #include <intrinsics.h>
      3          
      4          
      5          
      6          

   \                                 In section Debug.txt, align 4, keep-with-next
      7          void InitFlash(void)
      8          {
      9          
     10            AT91C_BASE_MC->MC_FMR = (((0x48)<<16) | AT91C_MC_FWS_2FWS);     // konfiguracja MC_FMR
   \                     InitFlash:
   \   00000000   9F20               MOVS     R0,#+159
   \   00000002   C043               MVNS     R0,R0            ;; #-160
   \   00000004   0349               LDR      R1,??InitFlash_0  ;; 0x480200
   \   00000006   0160               STR      R1,[R0, #+0]
     11          
     12            SET(AT91C_BASE_MC->MC_FMR, ((AT91C_MASTER_CLOCK / 666666)) << 16);
   \   00000008   0168               LDR      R1,[R0, #+0]
   \   0000000A   9022               MOVS     R2,#+144
   \   0000000C   D203               LSLS     R2,R2,#+15       ;; #+4718592
   \   0000000E   0A43               ORRS     R2,R2,R1
   \   00000010   0260               STR      R2,[R0, #+0]
     13              
     14            
     15          }
   \   00000012   7047               BX       LR               ;; return
   \                     ??InitFlash_0:
   \   00000014   00024800           DC32     0x480200
     16          
     17          
     18          
     19          
     20          //*-----------------------------------------------------------------------------
     21          //* Nazwa funkcji :    at91flashWrite
     22          //* Funkcja zapisu do flash
     23          //*-----------------------------------------------------------------------------
     24          //*  ofset  - przesuniêcie
     25          //*  cell   - pierwsza komórka zapisu
     26          //*  value  - wartoœæ do zapisu
     27          //*  length - wielkoœæ danych
     28          //*----------------------------------------------------------------------------
     29          

   \                                 In section .textrw, align 4, keep-with-next
     30          __ramfunc void at91flashWrite(  unsigned int ofset, unsigned int cell, char *value,  int length)
     31           {
   \                     at91flashWrite:
   \   00000000   F4B5               PUSH     {R2,R4-R7,LR}
   \   00000002   C2B0               SUB      SP,SP,#+264
   \   00000004   0A00               MOVS     R2,R1
     32             
     33             unsigned int Page=ofset+cell/256;
   \   00000006   090A               LSRS     R1,R1,#+8
   \   00000008   4118               ADDS     R1,R0,R1
     34             unsigned int komorka=ofset+cell%256;
   \   0000000A   1206               LSLS     R2,R2,#+24
   \   0000000C   120E               LSRS     R2,R2,#+24
   \   0000000E   8018               ADDS     R0,R0,R2
   \   00000010   0090               STR      R0,[SP, #+0]
   \   00000012   0024               MOVS     R4,#+0
     35             int length_tmp;
     36             int data = 0; 
     37             unsigned long *memory;
     38             
     39          
     40             
     41            // TRACE_INFO("\n\r---  FlashWrite  --- Ofset: %d, Komorka: %d, Rozmar: %dB\n\r",ofset,cell,length );  
     42             
     43             union 
     44             {
     45                         char tab_B[256];
     46                unsigned long tab_DW[64];
     47             };
     48          
     49             do
     50             {
     51               if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
   \                     ??at91flashWrite_0:
   \   00000014   0098               LDR      R0,[SP, #+0]
   \   00000016   C018               ADDS     R0,R0,R3
   \   00000018   FF22               MOVS     R2,#+255
   \   0000001A   921C               ADDS     R2,R2,#+2        ;; #+257
   \   0000001C   9042               CMP      R0,R2
   \   0000001E   03D3               BCC      ??at91flashWrite_1
   \   00000020   501E               SUBS     R0,R2,#+1
   \   00000022   009A               LDR      R2,[SP, #+0]
   \   00000024   821A               SUBS     R2,R0,R2
   \   00000026   00E0               B        ??at91flashWrite_2
   \                     ??at91flashWrite_1:
   \   00000028   1A00               MOVS     R2,R3
   \                     ??at91flashWrite_2:
   \   0000002A   0802               LSLS     R0,R1,#+8
   \   0000002C   0190               STR      R0,[SP, #+4]
     52          
     53                memory=(unsigned long*) (Page*256);  //zmiana z memory=(unsigned long*) (ofset+page*256);
     54               for (unsigned int i=0; i<=63; i++)
   \   0000002E   0020               MOVS     R0,#+0
   \   00000030   05E0               B        ??at91flashWrite_3
     55                {  
     56                  tab_DW[i]=memory[i];     
   \                     ??at91flashWrite_4:
   \   00000032   8500               LSLS     R5,R0,#+2
   \   00000034   02AE               ADD      R6,SP,#+8
   \   00000036   019F               LDR      R7,[SP, #+4]
   \   00000038   7F59               LDR      R7,[R7, R5]
   \   0000003A   7751               STR      R7,[R6, R5]
     57                }  
   \   0000003C   401C               ADDS     R0,R0,#+1
   \                     ??at91flashWrite_3:
   \   0000003E   4028               CMP      R0,#+64
   \   00000040   F7D3               BCC      ??at91flashWrite_4
     58               
     59               for (int i=komorka; i<=komorka+length_tmp-1; i++)
   \   00000042   0098               LDR      R0,[SP, #+0]
   \   00000044   05E0               B        ??at91flashWrite_5
     60                {
     61                  tab_B[i]=(unsigned long)value[data];
   \                     ??at91flashWrite_6:
   \   00000046   02AD               ADD      R5,SP,#+8
   \   00000048   429E               LDR      R6,[SP, #+264]
   \   0000004A   365D               LDRB     R6,[R6, R4]
   \   0000004C   2E54               STRB     R6,[R5, R0]
     62                  data++;
   \   0000004E   641C               ADDS     R4,R4,#+1
     63                }
   \   00000050   401C               ADDS     R0,R0,#+1
   \                     ??at91flashWrite_5:
   \   00000052   009D               LDR      R5,[SP, #+0]
   \   00000054   AD18               ADDS     R5,R5,R2
   \   00000056   6D1E               SUBS     R5,R5,#+1
   \   00000058   8542               CMP      R5,R0
   \   0000005A   F4D2               BCS      ??at91flashWrite_6
     64            
     65               for (unsigned int i=0; i<=63; i++)
   \   0000005C   0020               MOVS     R0,#+0
   \   0000005E   06E0               B        ??at91flashWrite_7
     66                {
     67                  AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
   \                     ??at91flashWrite_8:
   \   00000060   8500               LSLS     R5,R0,#+2
   \   00000062   9826               MOVS     R6,#+152
   \   00000064   7603               LSLS     R6,R6,#+13       ;; #+1245184
   \   00000066   02AF               ADD      R7,SP,#+8
   \   00000068   7F59               LDR      R7,[R7, R5]
   \   0000006A   7751               STR      R7,[R6, R5]
     68                }  
   \   0000006C   401C               ADDS     R0,R0,#+1
   \                     ??at91flashWrite_7:
   \   0000006E   4028               CMP      R0,#+64
   \   00000070   F6D3               BCC      ??at91flashWrite_8
     69             
     70               unsigned int Status = AT91C_BASE_MC->MC_FSR;
   \   00000072   9725               MOVS     R5,#+151
   \   00000074   ED43               MVNS     R5,R5            ;; #-152
   \   00000076   2868               LDR      R0,[R5, #+0]
     71          
     72               SET(AT91C_BASE_MC->MC_FCR,
     73                  AT91C_MC_CORRECT_KEY
     74                  | AT91C_MC_FCMD_START_PROG
     75                  | (((Page) << 8) & AT91C_MC_PAGEN));   //zmaina page+(ofset/256)
   \   00000078   9B26               MOVS     R6,#+155
   \   0000007A   F643               MVNS     R6,R6            ;; #-156
   \   0000007C   3068               LDR      R0,[R6, #+0]
   \   0000007E   8446               MOV      R12,R0
   \   00000080   0F02               LSLS     R7,R1,#+8
   \   00000082   ....               LDR      R0,??DataTable6  ;; 0x3ff00
   \   00000084   3840               ANDS     R0,R0,R7
   \   00000086   ....               LDR      R7,??DataTable7  ;; 0x5a000001
   \   00000088   0743               ORRS     R7,R7,R0
   \   0000008A   6046               MOV      R0,R12
   \   0000008C   0743               ORRS     R7,R7,R0
   \   0000008E   3760               STR      R7,[R6, #+0]
     76              
     77               while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);   
   \                     ??at91flashWrite_9:
   \   00000090   2868               LDR      R0,[R5, #+0]
   \   00000092   C007               LSLS     R0,R0,#+31
   \   00000094   FCD5               BPL      ??at91flashWrite_9
     78              
     79               komorka = 0;
   \   00000096   0020               MOVS     R0,#+0
   \   00000098   0090               STR      R0,[SP, #+0]
     80               length = length-length_tmp;
   \   0000009A   9B1A               SUBS     R3,R3,R2
     81               Page++;
   \   0000009C   491C               ADDS     R1,R1,#+1
     82              
     83             }while (length>0); 
   \   0000009E   012B               CMP      R3,#+1
   \   000000A0   B8DA               BGE      ??at91flashWrite_0
     84              
     85          
     86          }
   \   000000A2   43B0               ADD      SP,SP,#+268
   \   000000A4   F0BC               POP      {R4-R7}
   \   000000A6   01BC               POP      {R0}
   \   000000A8   0047               BX       R0               ;; return
     87          
     88          
     89          
     90          
     91          
     92          
     93          
     94          
     95          
     96          
     97          
     98          
     99          #define FLASH_PAGE_SIZE_BYTE 512
    100          
    101          
    102          
    103          
    104          //*---------------------------------------------------------------------------- 
    105          //* \fn    AT91F_Flash_Ready 
    106          //* \brief Czekanie na zapis Flash'a 
    107          //*---------------------------------------------------------------------------- 

   \                                 In section .textrw, align 4, keep-with-next
    108          __ramfunc int AT91F_Flash_Ready (void) 
    109          { 
   \                     AT91F_Flash_Ready:
   \   00000000   01B5               PUSH     {R0,LR}
    110              unsigned int status; 
    111              status = 0; 
   \   00000002   0020               MOVS     R0,#+0
   \   00000004   02E0               B        ??AT91F_Flash_Ready_0
    112          
    113              // Wait the end of command 
    114                  while ((status & AT91C_MC_FRDY) != AT91C_MC_FRDY ) 
    115                  { 
    116                    status = AT91C_BASE_MC->MC_FSR; 
   \                     ??AT91F_Flash_Ready_1:
   \   00000006   9720               MOVS     R0,#+151
   \   00000008   C043               MVNS     R0,R0            ;; #-152
   \   0000000A   0068               LDR      R0,[R0, #+0]
    117                  } 
   \                     ??AT91F_Flash_Ready_0:
   \   0000000C   0100               MOVS     R1,R0
   \   0000000E   C907               LSLS     R1,R1,#+31
   \   00000010   F9D5               BPL      ??AT91F_Flash_Ready_1
    118                  return status; 
   \   00000012   08BC               POP      {R3}
   \   00000014   02BC               POP      {R1}
   \   00000016   0847               BX       R1               ;; return
    119          } 
    120          
    121          
    122          

   \                                 In section .textrw, align 4, keep-with-next
    123          __ramfunc int AT91F_Flash_Write( unsigned int Flash_Address ,int size ,unsigned int * buff) 
    124          { 
   \                     AT91F_Flash_Write:
   \   00000000   70B5               PUSH     {R4-R6,LR}
    125              // set the Flash controller base address 
    126              AT91PS_MC ptMC = AT91C_BASE_MC; 
    127              unsigned int i, page, status; 
    128              unsigned int * Flash; 
    129              
    130              // init flash pointer 
    131              Flash = (unsigned int *) Flash_Address; 
    132              // Get the Flash page number 
    133              page = ((Flash_Address - (unsigned int)AT91C_IFLASH ) /FLASH_PAGE_SIZE_BYTE); 
   \   00000002   1B4B               LDR      R3,??AT91F_Flash_Write_0  ;; 0xfff00000
   \   00000004   C318               ADDS     R3,R0,R3
   \   00000006   5B0A               LSRS     R3,R3,#+9
    134              // copy the new value 
    135              
    136          
    137              
    138              
    139              for (i=0; (i < FLASH_PAGE_SIZE_BYTE) & (size > 0) ;i++, Flash++,buff++,size-=4 )
   \   00000008   0024               MOVS     R4,#+0
   \   0000000A   2500               MOVS     R5,R4
   \   0000000C   05E0               B        ??AT91F_Flash_Write_1
    140              { 
    141              *Flash=*buff; 
   \                     ??AT91F_Flash_Write_2:
   \   0000000E   1668               LDR      R6,[R2, #+0]
   \   00000010   0660               STR      R6,[R0, #+0]
    142              } 
   \   00000012   6D1C               ADDS     R5,R5,#+1
   \   00000014   001D               ADDS     R0,R0,#+4
   \   00000016   121D               ADDS     R2,R2,#+4
   \   00000018   091F               SUBS     R1,R1,#+4
   \                     ??AT91F_Flash_Write_1:
   \   0000001A   8026               MOVS     R6,#+128
   \   0000001C   B600               LSLS     R6,R6,#+2        ;; #+512
   \   0000001E   B542               CMP      R5,R6
   \   00000020   01D2               BCS      ??AT91F_Flash_Write_3
   \   00000022   0129               CMP      R1,#+1
   \   00000024   F3DA               BGE      ??AT91F_Flash_Write_2
    143              
    144              
    145              __disable_interrupt();
   \                     ??AT91F_Flash_Write_3:
   \   00000026   ........           BL       __iar_disable_interrupt
    146              unsigned long ulIntrStat = AT91C_BASE_AIC->AIC_IMR; 
   \   0000002A   1248               LDR      R0,??AT91F_Flash_Write_0+0x4  ;; 0xfffff110
   \   0000002C   0068               LDR      R0,[R0, #+0]
    147              AT91C_BASE_AIC->AIC_IDCR = 0xFFFFFFFF; 
   \   0000002E   1249               LDR      R1,??AT91F_Flash_Write_0+0x8  ;; 0xfffff124
   \   00000030   0022               MOVS     R2,#+0
   \   00000032   D243               MVNS     R2,R2            ;; #-1
   \   00000034   0A60               STR      R2,[R1, #+0]
    148              
    149              // Write the write page command 
    150              ptMC->MC_FCR = AT91C_MC_CORRECT_KEY | AT91C_MC_FCMD_START_PROG | (AT91C_MC_PAGEN & (page <<8)) ; 
   \   00000036   9B21               MOVS     R1,#+155
   \   00000038   C943               MVNS     R1,R1            ;; #-156
   \   0000003A   1A02               LSLS     R2,R3,#+8
   \   0000003C   ....               LDR      R3,??DataTable6  ;; 0x3ff00
   \   0000003E   1340               ANDS     R3,R3,R2
   \   00000040   ....               LDR      R2,??DataTable7  ;; 0x5a000001
   \   00000042   1A43               ORRS     R2,R2,R3
   \   00000044   0A60               STR      R2,[R1, #+0]
    151              
    152              //for a certain ammount of time you cant do any operation over flash memory. 
    153              for(i=0;i<100000;i++) asm("nop"); 
   \   00000046   0D49               LDR      R1,??AT91F_Flash_Write_0+0xC  ;; 0x186a0
   \   00000048   01E0               B        ??AT91F_Flash_Write_4
   \                     ??AT91F_Flash_Write_5:
   \   0000004A   C046               nop              
   \   0000004C   641C               ADDS     R4,R4,#+1
   \                     ??AT91F_Flash_Write_4:
   \   0000004E   8C42               CMP      R4,R1
   \   00000050   FBD3               BCC      ??AT91F_Flash_Write_5
    154              
    155              //Enable ints 
    156              AT91C_BASE_AIC->AIC_IECR = ulIntrStat; 
   \   00000052   0B49               LDR      R1,??AT91F_Flash_Write_0+0x10  ;; 0xfffff120
   \   00000054   0860               STR      R0,[R1, #+0]
    157              
    158              // Wait the end of command 
    159              status = AT91F_Flash_Ready(); 
   \   00000056   ........           BL       AT91F_Flash_Ready
    160              
    161               __enable_interrupt();
   \   0000005A   ........           BL       __iar_enable_interrupt
    162              // Check the result 
    163              if ( (status & ( AT91C_MC_PROGE | AT91C_MC_LOCKE ))!=0) 
   \   0000005E   0C21               MOVS     R1,#+12
   \   00000060   0140               ANDS     R1,R1,R0
   \   00000062   481E               SUBS     R0,R1,#+1
   \   00000064   8041               SBCS     R0,R0,R0
   \   00000066   C00F               LSRS     R0,R0,#+31
    164              return false; 
    165              return true; 
   \   00000068   70BC               POP      {R4-R6}
   \   0000006A   02BC               POP      {R1}
   \   0000006C   0847               BX       R1               ;; return
   \   0000006E   C046               Nop      
   \                     ??AT91F_Flash_Write_0:
   \   00000070   0000F0FF           DC32     0xfff00000
   \   00000074   10F1FFFF           DC32     0xfffff110
   \   00000078   24F1FFFF           DC32     0xfffff124
   \   0000007C   A0860100           DC32     0x186a0
   \   00000080   20F1FFFF           DC32     0xfffff120
    166          } 
    167          
    168          
    169          
    170          
    171             /*
    172          
    173          //__ramfunc int AT91F_Flash_Write( unsigned int Flash_Address ,int size ,unsigned int * buff) 
    174          __ramfunc  void FlashWrite(volatile char *ptrMem,volatile char *value,volatile int length)
    175          { 
    176            
    177          
    178              // set the Flash controller base address 
    179              AT91PS_MC ptMC = AT91C_BASE_MC; 
    180              unsigned int i, page, status; 
    181              unsigned int * Flash; 
    182              
    183              // init flash pointer 
    184              Flash = (unsigned int *) Flash_Address; 
    185              // Get the Flash page number 
    186              page = ((Flash_Address - (unsigned int)AT91C_IFLASH ) /FLASH_PAGE_SIZE_BYTE); 
    187              // copy the new value 
    188          
    189          
    190          
    191          
    192            volatile int page=     (int)ptrMem/256;
    193             volatile int komorka = (int)ptrMem%256;   
    194             volatile int PtrInt=(int)ptrMem;
    195             volatile int length_tmp;
    196             volatile int data = 0; 
    197             volatile int *UptrMem;
    198             volatile char* ptrMem2;
    199          
    200             if ((PtrInt>0x00140000) || (PtrInt<0x00120000) || (komorka>0xFF))
    201             {
    202                 char mess[]="Blad zapisu. Przekroczenie dozwolonego obszaru";
    203                 MESSAGE(mess); 
    204             }else{
    205           
    206                 union 
    207                 {
    208                             char B[256];
    209                    unsigned long DW[64];
    210                 }tab;
    211              
    212                 do
    213                 {
    214                   if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
    215                   
    216                   //przepisanie strony pamiêci do RAMu
    217                   ptrMem2=(char*)(page*256);
    218                   for (short i=0; i<256; i++)
    219                    {  
    220                      tab.B[i]=ptrMem2[i];     
    221                    }  
    222                   
    223                      //dodanie nowych danych
    224                      for (int i=komorka; i<=komorka+length_tmp-1; i++)
    225                      {
    226                        tab.B[i]=value[data];
    227                        data++;
    228                      }
    229                
    230                      //UptrMem=(int*)ptrMem;  
    231                      UptrMem=(int*)(page*256);
    232                        
    233                      //zapis do tymczasowego obszar
    234                      //for (unsigned int i=0; i<=63; i++) AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    235                      for (unsigned int i=0; i<=63; i++) UptrMem[i]=tab.DW[i];
    236                 
    237                      //oczekiwanie na flagê FRDY 
    238                      while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
    239                      //volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    240                      
    241                      //Zapis FCMD i PAGENB do MC_FCR
    242                      SET(AT91C_BASE_MC->MC_FCR,
    243                          AT91C_MC_CORRECT_KEY
    244                          | AT91C_MC_FCMD_START_PROG
    245                          | ((page << 8) & AT91C_MC_PAGEN)); 
    246                  
    247                      //oczekiwanie na flagê FRDY 
    248                      long long MaxCount=0;
    249                      while(((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY) || (MaxCount>0xFFFE)) {MaxCount++;};  
    250                      if (MaxCount==0xFFFF)  
    251                      {
    252                        char mess[]="Blad zapisu do flash";
    253                        MESSAGE(mess); 
    254                      }
    255                      //Sprawdzenie czy nie naruszona blokada regionu
    256                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_LOCKE) 
    257                      {
    258                         MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
    259                      }
    260                      
    261                      //Sprawdzenie czy zapis wykonany poprawnie
    262                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_PROGE) 
    263                      {
    264                        MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
    265                      }
    266                      
    267                   komorka = 0;
    268                   length = length-length_tmp;
    269                   page++;
    270                  
    271                 }while (length>0); 
    272             }
    273            
    274          }
    275          */    
    276              
    277              
    278          
    279          
    280          
    281          
    282          
    283          
    284          //*-----------------------------------------------------------------------------
    285          //* Nazwa funkcji :    FlashWrite
    286          //* Funkcja zapisu do flash
    287          //*-----------------------------------------------------------------------------
    288          //*  ofset  - przesuniêcie
    289          //*  cell   - pierwsza komórka zapisu
    290          //*  ptrMem - wskaŸnik na komórke pamiêci flash
    291          //*  value  - wartoœæ do zapisu
    292          //*  length - wielkoœæ danych
    293          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    294          void FlashWrite( char *ptrMem, char *value, int length)
    295           {
   \                     FlashWrite:
   \   00000000   1FB5               PUSH     {R0-R4,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0B00               MOVS     R3,R1
    296             volatile int page    = (int)ptrMem/256;
   \   00000006   C011               ASRS     R0,R0,#+7
   \   00000008   000E               LSRS     R0,R0,#+24
   \   0000000A   0019               ADDS     R0,R0,R4
   \   0000000C   0012               ASRS     R0,R0,#+8
   \   0000000E   0090               STR      R0,[SP, #+0]
    297             volatile int komorka = (int)ptrMem%256; 
   \   00000010   0002               LSLS     R0,R0,#+8
   \   00000012   201A               SUBS     R0,R4,R0
   \   00000014   0190               STR      R0,[SP, #+4]
    298             volatile int PtrInt  = (int)ptrMem;
   \   00000016   0294               STR      R4,[SP, #+8]
    299             
    300             FlashWriteExe(PtrInt, page, komorka, value, length);
   \   00000018   82B0               SUB      SP,SP,#+8
   \   0000001A   0092               STR      R2,[SP, #+0]
   \   0000001C   039A               LDR      R2,[SP, #+12]
   \   0000001E   0299               LDR      R1,[SP, #+8]
   \   00000020   0498               LDR      R0,[SP, #+16]
   \   00000022   ........           BL       FlashWriteExe
   \   00000026   02B0               ADD      SP,SP,#+8
    301           } 
   \   00000028   1FBC               POP      {R0-R4}
   \   0000002A   01BC               POP      {R0}
   \   0000002C   0047               BX       R0               ;; return
    302             
    303          
    304          

   \                                 In section .textrw, align 4, keep-with-next
    305          __ramfunc  void FlashWriteExe(volatile int  PtrInt,  volatile int  page, volatile int  komorka, char *value, int length)
    306           {
   \                     FlashWriteExe:
   \   00000000   FFB5               PUSH     {R0-R7,LR}
   \   00000002   D5B0               SUB      SP,SP,#+340
   \   00000004   5E9C               LDR      R4,[SP, #+376]
    307          
    308             volatile int length_tmp;
    309             volatile int data = 0; 
   \   00000006   0027               MOVS     R7,#+0
   \   00000008   0197               STR      R7,[SP, #+4]
    310             volatile int *UptrMem;
    311             volatile char* ptrMem2;
    312          
    313             if ((PtrInt>(int)0x00140000) || (PtrInt<(int)0x00120000) || (komorka>0xFF))
   \   0000000A   5598               LDR      R0,[SP, #+340]
   \   0000000C   4749               LDR      R1,??FlashWriteExe_0  ;; 0x140001
   \   0000000E   8842               CMP      R0,R1
   \   00000010   09DA               BGE      ??FlashWriteExe_1
   \   00000012   5598               LDR      R0,[SP, #+340]
   \   00000014   9021               MOVS     R1,#+144
   \   00000016   4903               LSLS     R1,R1,#+13       ;; #+1179648
   \   00000018   8842               CMP      R0,R1
   \   0000001A   04DB               BLT      ??FlashWriteExe_1
   \   0000001C   8026               MOVS     R6,#+128
   \   0000001E   7600               LSLS     R6,R6,#+1        ;; #+256
   \   00000020   5798               LDR      R0,[SP, #+348]
   \   00000022   B042               CMP      R0,R6
   \   00000024   08DB               BLT      ??FlashWriteExe_2
    314             {
    315                 char mess[]="Blad zapisu. Przekroczenie dozwolonego obszaru";
   \                     ??FlashWriteExe_1:
   \   00000026   42A8               ADD      R0,SP,#+264
   \   00000028   4149               LDR      R1,??FlashWriteExe_0+0x4  ;; `?<Constant "Blad zapisu. Przekroc...">`
   \   0000002A   3022               MOVS     R2,#+48
   \   0000002C   ........           BL       __aeabi_memcpy4
    316                 MESSAGE(mess); 
                        ^
Warning[Pe223]: function "MESSAGE" declared implicitly

         MESSAGE(mess); 
         ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",316  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function
   \   00000030   42A8               ADD      R0,SP,#+264
   \   00000032   ........           BL       MESSAGE
   \   00000036   75E0               B        ??FlashWriteExe_3
    317             }else{
    318           
    319                 union 
    320                 {
    321                             char B[256];
    322                    unsigned long DW[64];
    323                 }tab;
    324              
    325                 do
    326                 {
    327                   if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
   \                     ??FlashWriteExe_2:
   \   00000038   5798               LDR      R0,[SP, #+348]
   \   0000003A   0019               ADDS     R0,R0,R4
   \   0000003C   711C               ADDS     R1,R6,#+1
   \   0000003E   8842               CMP      R0,R1
   \   00000040   03DB               BLT      ??FlashWriteExe_4
   \   00000042   5798               LDR      R0,[SP, #+348]
   \   00000044   301A               SUBS     R0,R6,R0
   \   00000046   0090               STR      R0,[SP, #+0]
   \   00000048   00E0               B        ??FlashWriteExe_5
   \                     ??FlashWriteExe_4:
   \   0000004A   0094               STR      R4,[SP, #+0]
    328                   
    329                   //przepisanie strony pamiêci do RAMu
    330                   ptrMem2=(char*)(page*256);
   \                     ??FlashWriteExe_5:
   \   0000004C   5698               LDR      R0,[SP, #+344]
   \   0000004E   0002               LSLS     R0,R0,#+8
    331                   for (short i=0; i<256; i++)
   \   00000050   3900               MOVS     R1,R7
   \   00000052   05E0               B        ??FlashWriteExe_6
    332                    {  
    333                      tab.B[i]=ptrMem2[i];     
   \                     ??FlashWriteExe_7:
   \   00000054   02AA               ADD      R2,SP,#+8
   \   00000056   435C               LDRB     R3,[R0, R1]
   \   00000058   5354               STRB     R3,[R2, R1]
    334                    }  
   \   0000005A   491C               ADDS     R1,R1,#+1
   \   0000005C   0904               LSLS     R1,R1,#+16
   \   0000005E   0914               ASRS     R1,R1,#+16
   \                     ??FlashWriteExe_6:
   \   00000060   B142               CMP      R1,R6
   \   00000062   F7DB               BLT      ??FlashWriteExe_7
    335                   
    336                      //dodanie nowych danych
    337                      for (int i=komorka; i<=komorka+length_tmp-1; i++)
   \   00000064   5798               LDR      R0,[SP, #+348]
   \   00000066   08E0               B        ??FlashWriteExe_8
    338                      {
    339                        tab.B[i]=value[data];
   \                     ??FlashWriteExe_9:
   \   00000068   02A9               ADD      R1,SP,#+8
   \   0000006A   019A               LDR      R2,[SP, #+4]
   \   0000006C   589B               LDR      R3,[SP, #+352]
   \   0000006E   9A5C               LDRB     R2,[R3, R2]
   \   00000070   0A54               STRB     R2,[R1, R0]
    340                        data++;
   \   00000072   0199               LDR      R1,[SP, #+4]
   \   00000074   491C               ADDS     R1,R1,#+1
   \   00000076   0191               STR      R1,[SP, #+4]
    341                      }
   \   00000078   401C               ADDS     R0,R0,#+1
   \                     ??FlashWriteExe_8:
   \   0000007A   5799               LDR      R1,[SP, #+348]
   \   0000007C   009A               LDR      R2,[SP, #+0]
   \   0000007E   8918               ADDS     R1,R1,R2
   \   00000080   491E               SUBS     R1,R1,#+1
   \   00000082   8142               CMP      R1,R0
   \   00000084   F0DA               BGE      ??FlashWriteExe_9
    342                
    343                      //UptrMem=(int*)ptrMem;  
    344                      UptrMem=(int*)(page*256);
   \   00000086   5698               LDR      R0,[SP, #+344]
   \   00000088   0002               LSLS     R0,R0,#+8
    345                        
    346                      //zapis do tymczasowego obszar
    347                      //for (unsigned int i=0; i<=63; i++) AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    348                      for (unsigned int i=0; i<=63; i++) UptrMem[i]=tab.DW[i];
   \   0000008A   3900               MOVS     R1,R7
   \   0000008C   04E0               B        ??FlashWriteExe_10
   \                     ??FlashWriteExe_11:
   \   0000008E   8A00               LSLS     R2,R1,#+2
   \   00000090   02AB               ADD      R3,SP,#+8
   \   00000092   9B58               LDR      R3,[R3, R2]
   \   00000094   8350               STR      R3,[R0, R2]
   \   00000096   491C               ADDS     R1,R1,#+1
   \                     ??FlashWriteExe_10:
   \   00000098   4029               CMP      R1,#+64
   \   0000009A   F8D3               BCC      ??FlashWriteExe_11
    349                 
    350                      //oczekiwanie na flagê FRDY 
    351                      while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
   \                     ??FlashWriteExe_12:
   \   0000009C   9725               MOVS     R5,#+151
   \   0000009E   ED43               MVNS     R5,R5            ;; #-152
   \   000000A0   2868               LDR      R0,[R5, #+0]
   \   000000A2   C007               LSLS     R0,R0,#+31
   \   000000A4   FAD5               BPL      ??FlashWriteExe_12
    352                      //volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    353                      
    354                      //Zapis FCMD i PAGENB do MC_FCR
    355                      SET(AT91C_BASE_MC->MC_FCR,
    356                          AT91C_MC_CORRECT_KEY
    357                          | AT91C_MC_FCMD_START_PROG
    358                          | ((page << 8) & AT91C_MC_PAGEN)); 
   \   000000A6   9B20               MOVS     R0,#+155
   \   000000A8   C043               MVNS     R0,R0            ;; #-156
   \   000000AA   0168               LDR      R1,[R0, #+0]
   \   000000AC   569A               LDR      R2,[SP, #+344]
   \   000000AE   1302               LSLS     R3,R2,#+8
   \   000000B0   ....               LDR      R2,??DataTable6  ;; 0x3ff00
   \   000000B2   1A40               ANDS     R2,R2,R3
   \   000000B4   ....               LDR      R3,??DataTable7  ;; 0x5a000001
   \   000000B6   1343               ORRS     R3,R3,R2
   \   000000B8   0B43               ORRS     R3,R3,R1
   \   000000BA   0360               STR      R3,[R0, #+0]
    359                  
    360                      //oczekiwanie na flagê FRDY 
    361                      long long MaxCount=0;
   \   000000BC   3800               MOVS     R0,R7
   \   000000BE   0100               MOVS     R1,R0
   \   000000C0   02E0               B        ??FlashWriteExe_13
    362                      while(((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY) || (MaxCount>0xFFFE)) {MaxCount++;};  
   \                     ??FlashWriteExe_14:
   \   000000C2   0022               MOVS     R2,#+0
   \   000000C4   401C               ADDS     R0,R0,#+1
   \   000000C6   5141               ADCS     R1,R1,R2
   \                     ??FlashWriteExe_13:
   \   000000C8   2A68               LDR      R2,[R5, #+0]
   \   000000CA   D207               LSLS     R2,R2,#+31
   \   000000CC   F9D5               BPL      ??FlashWriteExe_14
   \   000000CE   2A0C               LSRS     R2,R5,#+16
   \   000000D0   3B00               MOVS     R3,R7
   \   000000D2   9942               CMP      R1,R3
   \   000000D4   F5DC               BGT      ??FlashWriteExe_14
   \   000000D6   01DB               BLT      ??FlashWriteExe_15
   \   000000D8   9042               CMP      R0,R2
   \   000000DA   F2D2               BCS      ??FlashWriteExe_14
    363                      if (MaxCount==0xFFFF)  
   \                     ??FlashWriteExe_15:
   \   000000DC   0200               MOVS     R2,R0
   \   000000DE   0B00               MOVS     R3,R1
   \   000000E0   280C               LSRS     R0,R5,#+16
   \   000000E2   3900               MOVS     R1,R7
   \   000000E4   8B42               CMP      R3,R1
   \   000000E6   09D1               BNE      ??FlashWriteExe_16
   \   000000E8   8242               CMP      R2,R0
   \   000000EA   07D1               BNE      ??FlashWriteExe_16
    364                      {
    365                        char mess[]="Blad zapisu do flash";
   \   000000EC   4EA8               ADD      R0,SP,#+312
   \   000000EE   1149               LDR      R1,??FlashWriteExe_0+0x8  ;; `?<Constant "Blad zapisu. Przekroc...">` + 48
   \   000000F0   1822               MOVS     R2,#+24
   \   000000F2   ........           BL       __aeabi_memcpy4
    366                        MESSAGE(mess); 
                               ^
Warning[Pe223]: function "MESSAGE" declared implicitly

                MESSAGE(mess); 
                ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",366  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function
   \   000000F6   4EA8               ADD      R0,SP,#+312
   \   000000F8   ........           BL       MESSAGE
    367                      }
    368                      //Sprawdzenie czy nie naruszona blokada regionu
    369                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_LOCKE) 
   \                     ??FlashWriteExe_16:
   \   000000FC   2868               LDR      R0,[R5, #+0]
   \   000000FE   4007               LSLS     R0,R0,#+29
   \   00000100   02D5               BPL      ??FlashWriteExe_17
    370                      {
    371                         MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
                                ^
Warning[Pe223]: function "MESSAGE" declared implicitly

                 MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
                 ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",371  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function
   \   00000102   0D48               LDR      R0,??FlashWriteExe_0+0xC  ;; `?<Constant "Blad zapisu. Przekroc...">` + 72
   \   00000104   ........           BL       MESSAGE
    372                      }
    373                      
    374                      //Sprawdzenie czy zapis wykonany poprawnie
    375                      if (AT91C_BASE_MC->MC_FSR & AT91C_MC_PROGE) 
   \                     ??FlashWriteExe_17:
   \   00000108   2868               LDR      R0,[R5, #+0]
   \   0000010A   0007               LSLS     R0,R0,#+28
   \   0000010C   02D5               BPL      ??FlashWriteExe_18
    376                      {
    377                        MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
                               ^
Warning[Pe223]: function "MESSAGE" declared implicitly

                MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
                ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",377  Warning[Ta023]: 
          Call to a non __ramfunc function (MESSAGE) from within a __ramfunc
          function

      __disable_interrupt();
      ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",145  Warning[Ta021]: 
          Library call (__iar_disable_interrupt) from within a __ramfunc
          function

       __enable_interrupt();
       ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",161  Warning[Ta021]: 
          Library call (__iar_enable_interrupt) from within a __ramfunc
          function

         char mess[]="Blad zapisu. Przekroczenie dozwolonego obszaru";
                    ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",315  Warning[Ta022]: 
          Possible rom access (<Constant "Blad zapisu. Przekroc...">) from
          within a __ramfunc function

                char mess[]="Blad zapisu do flash";
                           ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",365  Warning[Ta022]: 
          Possible rom access (<Constant "Blad zapisu. Przekroc...">) from
          within a __ramfunc function

                 MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
                 ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",371  Warning[Ta022]: 
          Possible rom access (<Constant "Blad zapisu. Przekroc...">) from
          within a __ramfunc function

                MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
                ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 - 04.06.2013\Framework\flash.c",377  Warning[Ta022]: 
          Possible rom access (<Constant "Blad zapisu. Przekroc...">) from
          within a __ramfunc function
   \   0000010E   0B48               LDR      R0,??FlashWriteExe_0+0x10  ;; `?<Constant "Blad zapisu. Przekroc...">` + 116
   \   00000110   ........           BL       MESSAGE
    378                      }
    379                      
    380                   komorka = 0;
   \                     ??FlashWriteExe_18:
   \   00000114   5797               STR      R7,[SP, #+348]
    381                   length = length-length_tmp;
   \   00000116   0098               LDR      R0,[SP, #+0]
   \   00000118   241A               SUBS     R4,R4,R0
    382                   page++;
   \   0000011A   5698               LDR      R0,[SP, #+344]
   \   0000011C   401C               ADDS     R0,R0,#+1
   \   0000011E   5690               STR      R0,[SP, #+344]
    383                  
    384                 }while (length>0); 
   \   00000120   012C               CMP      R4,#+1
   \   00000122   89DA               BGE      ??FlashWriteExe_2
    385             }
    386              
    387          }
   \                     ??FlashWriteExe_3:
   \   00000124   59B0               ADD      SP,SP,#+356
   \   00000126   F0BC               POP      {R4-R7}
   \   00000128   01BC               POP      {R0}
   \   0000012A   0047               BX       R0               ;; return
   \                     ??FlashWriteExe_0:
   \   0000012C   01001400           DC32     0x140001
   \   00000130   ........           DC32     `?<Constant "Blad zapisu. Przekroc...">`
   \   00000134   ........           DC32     `?<Constant "Blad zapisu. Przekroc...">` + 48
   \   00000138   ........           DC32     `?<Constant "Blad zapisu. Przekroc...">` + 72
   \   0000013C   ........           DC32     `?<Constant "Blad zapisu. Przekroc...">` + 116
    388          
    389          
    390          
    391          
    392          
    393          
    394          

   \                                 In section .textrw, align 4, keep-with-next
    395          __ramfunc void CleanFlash(char *ptrMem, int length)
    396           {
   \                     CleanFlash:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   C2B0               SUB      SP,SP,#+264
    397             int page=     (int)ptrMem/256;
   \   00000004   0300               MOVS     R3,R0
   \   00000006   C011               ASRS     R0,R0,#+7
   \   00000008   000E               LSRS     R0,R0,#+24
   \   0000000A   C018               ADDS     R0,R0,R3
   \   0000000C   0200               MOVS     R2,R0
   \   0000000E   1212               ASRS     R2,R2,#+8
    398             int komorka = (int)ptrMem%256;   
   \   00000010   1002               LSLS     R0,R2,#+8
   \   00000012   181A               SUBS     R0,R3,R0
    399             int length_tmp;
    400             int data = 0; 
    401             int *UptrMem;
    402          
    403             union 
    404             {
    405                         char B[256];
    406                unsigned long DW[64];
    407             }tab;
    408          
    409             do
    410             {
    411               if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
   \                     ??CleanFlash_0:
   \   00000014   4318               ADDS     R3,R0,R1
   \   00000016   FF24               MOVS     R4,#+255
   \   00000018   A41C               ADDS     R4,R4,#+2        ;; #+257
   \   0000001A   A342               CMP      R3,R4
   \   0000001C   02DB               BLT      ??CleanFlash_1
   \   0000001E   631E               SUBS     R3,R4,#+1
   \   00000020   1B1A               SUBS     R3,R3,R0
   \   00000022   00E0               B        ??CleanFlash_2
   \                     ??CleanFlash_1:
   \   00000024   0B00               MOVS     R3,R1
   \                     ??CleanFlash_2:
   \   00000026   1402               LSLS     R4,R2,#+8
   \   00000028   0094               STR      R4,[SP, #+0]
   \   0000002A   009C               LDR      R4,[SP, #+0]
   \   0000002C   4294               STR      R4,[SP, #+264]
    412               
    413               //przepisanie strony pamiêci do RAMu
    414               ptrMem=(char*)(page*256);
    415               for (short i=0; i<256; i++)
   \   0000002E   0024               MOVS     R4,#+0
   \   00000030   2500               MOVS     R5,R4
   \   00000032   06E0               B        ??CleanFlash_3
    416                {  
    417                  tab.B[i]=ptrMem[i];     
   \                     ??CleanFlash_4:
   \   00000034   01AE               ADD      R6,SP,#+4
   \   00000036   429F               LDR      R7,[SP, #+264]
   \   00000038   7F5D               LDRB     R7,[R7, R5]
   \   0000003A   7755               STRB     R7,[R6, R5]
    418                }  
   \   0000003C   6D1C               ADDS     R5,R5,#+1
   \   0000003E   2D04               LSLS     R5,R5,#+16
   \   00000040   2D14               ASRS     R5,R5,#+16
   \                     ??CleanFlash_3:
   \   00000042   FF2D               CMP      R5,#+255
   \   00000044   F6DD               BLE      ??CleanFlash_4
    419               
    420                  //dodanie nowych danych
    421                  for (int i=komorka; i<=komorka+length_tmp-1; i++)
   \   00000046   0500               MOVS     R5,R0
   \   00000048   03E0               B        ??CleanFlash_5
    422                  {
    423                    tab.B[i]=0;
   \                     ??CleanFlash_6:
   \   0000004A   01AE               ADD      R6,SP,#+4
   \   0000004C   2700               MOVS     R7,R4
   \   0000004E   7755               STRB     R7,[R6, R5]
    424                    data++;
    425                  }
   \   00000050   6D1C               ADDS     R5,R5,#+1
   \                     ??CleanFlash_5:
   \   00000052   C618               ADDS     R6,R0,R3
   \   00000054   761E               SUBS     R6,R6,#+1
   \   00000056   AE42               CMP      R6,R5
   \   00000058   F7DA               BGE      ??CleanFlash_6
    426            
    427                  //UptrMem=(int*)ptrMem;  
    428                  UptrMem=(int*)(page*256);
   \   0000005A   0098               LDR      R0,[SP, #+0]
    429                    
    430                  //zapis do tymczasowego obszar
    431                  //for (unsigned int i=0; i<=63; i++) AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    432                  for (unsigned int i=0; i<=63; i++) UptrMem[i]=tab.DW[i];
   \   0000005C   2500               MOVS     R5,R4
   \   0000005E   04E0               B        ??CleanFlash_7
   \                     ??CleanFlash_8:
   \   00000060   AE00               LSLS     R6,R5,#+2
   \   00000062   01AF               ADD      R7,SP,#+4
   \   00000064   BF59               LDR      R7,[R7, R6]
   \   00000066   8751               STR      R7,[R0, R6]
   \   00000068   6D1C               ADDS     R5,R5,#+1
   \                     ??CleanFlash_7:
   \   0000006A   402D               CMP      R5,#+64
   \   0000006C   F8D3               BCC      ??CleanFlash_8
    433             
    434                  //oczekiwanie na flagê FRDY 
    435                  while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
   \                     ??CleanFlash_9:
   \   0000006E   9725               MOVS     R5,#+151
   \   00000070   ED43               MVNS     R5,R5            ;; #-152
   \   00000072   2868               LDR      R0,[R5, #+0]
   \   00000074   C007               LSLS     R0,R0,#+31
   \   00000076   FAD5               BPL      ??CleanFlash_9
    436                  //volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    437                  
    438                  //Zapis FCMD i PAGENB do MC_FCR
    439                  SET(AT91C_BASE_MC->MC_FCR,
    440                      AT91C_MC_CORRECT_KEY
    441                      | AT91C_MC_FCMD_START_PROG
    442                      | ((page << 8) & AT91C_MC_PAGEN)); 
   \   00000078   9B26               MOVS     R6,#+155
   \   0000007A   F643               MVNS     R6,R6            ;; #-156
   \   0000007C   3068               LDR      R0,[R6, #+0]
   \   0000007E   8446               MOV      R12,R0
   \   00000080   1702               LSLS     R7,R2,#+8
   \   00000082   ....               LDR      R0,??DataTable6  ;; 0x3ff00
   \   00000084   3840               ANDS     R0,R0,R7
   \   00000086   ....               LDR      R7,??DataTable7  ;; 0x5a000001
   \   00000088   0743               ORRS     R7,R7,R0
   \   0000008A   6046               MOV      R0,R12
   \   0000008C   0743               ORRS     R7,R7,R0
   \   0000008E   3760               STR      R7,[R6, #+0]
    443              
    444                  //oczekiwanie na flagê FRDY 
    445                  while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);  
   \                     ??CleanFlash_10:
   \   00000090   2868               LDR      R0,[R5, #+0]
   \   00000092   C007               LSLS     R0,R0,#+31
   \   00000094   FCD5               BPL      ??CleanFlash_10
    446                  
    447                  //Sprawdzenie czy nie naruszona blokada regionu
    448                  if (AT91C_BASE_MC->MC_FSR & AT91C_MC_LOCKE) 
   \   00000096   2868               LDR      R0,[R5, #+0]
    449                  {
    450                    // MESSAGE("B³¹d naruszenia zablokowanego regionu flash"); 
    451                  }
    452                  
    453                  //Sprawdzenie czy zapis wykonany poprawnie
    454                  if (AT91C_BASE_MC->MC_FSR & AT91C_MC_PROGE) 
   \   00000098   2868               LDR      R0,[R5, #+0]
    455                  {
    456                    //MESSAGE("Z³y klucz lub b³edna komenda zapisu flash"); 
    457                  }
    458                  
    459               komorka = 0;
   \   0000009A   2000               MOVS     R0,R4
    460               length = length-length_tmp;
   \   0000009C   C91A               SUBS     R1,R1,R3
    461               page++;
   \   0000009E   521C               ADDS     R2,R2,#+1
    462              
    463             }while (length>0); 
   \   000000A0   0129               CMP      R1,#+1
   \   000000A2   B7DA               BGE      ??CleanFlash_0
    464          
    465              
    466          }
   \   000000A4   43B0               ADD      SP,SP,#+268
   \   000000A6   F0BC               POP      {R4-R7}
   \   000000A8   01BC               POP      {R0}
   \   000000AA   0047               BX       R0               ;; return
    467          
    468          
    469          
    470          /*
    471          __ramfunc void CleanFlash(int ofset,unsigned int cell, int length)
    472            {
    473             int page=     cell/256;
    474             int komorka = cell%256;
    475             int length_tmp;
    476             int data = 0; 
    477             unsigned long *memory;
    478             bool find; 
    479             int tmp_i =0;
    480             
    481             
    482           //  TRACE_INFO("\n\r---  CleanFlash  --- Ofset: %d, Komorka: %d, Rozmar: %dB\n\r",ofset,cell,length );
    483          
    484             
    485             union 
    486             {
    487                         char tab_B[256];
    488                unsigned long tab_DW[64];
    489             };
    490          
    491             do
    492             {
    493               if ((komorka+length)>256) {length_tmp=256-komorka;} else {length_tmp = length;};
    494               
    495               
    496                memory=(unsigned long*) (ofset+page*256);
    497          
    498               find = false;
    499          
    500                tmp_i=0;
    501                do 
    502                {
    503                  if (memory[tmp_i]>0)
    504                  {
    505                    find = true;
    506                    break;
    507                  }
    508                  tmp_i++;
    509                } while (tmp_i<=63);
    510          
    511                
    512               if (find==true)    
    513               {
    514                  data=0;
    515                  for (int i=komorka; i<=komorka+length_tmp-1; i++)
    516                    {
    517                      tab_B[i]=0;
    518                      data++;
    519                    }
    520            
    521                  for (unsigned int i=0; i<=63; i++)
    522                    {
    523                      AT91C_IFLASH_MEM->MEM_PAGE_0[i]=tab_DW[i];
    524                    }  
    525             
    526                  volatile unsigned int Status = AT91C_BASE_MC->MC_FSR;
    527          
    528                  SET(AT91C_BASE_MC->MC_FCR,
    529                      AT91C_MC_CORRECT_KEY
    530                      | AT91C_MC_FCMD_START_PROG
    531                      | (((page+(ofset/256)) << 8) & AT91C_MC_PAGEN)); 
    532              
    533                  while((AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY) != AT91C_MC_FRDY);   
    534                }
    535               
    536               komorka = 0;
    537               length = length-length_tmp;
    538               page++;
    539              
    540             }while (length>0); 
    541              
    542           //  TRACE_INFO("\n\r ---Koniec  CleanFlash  --- \n\r");
    543          }
    544          
    545          */
    546          
    547          
    548          
    549          

   \                                 In section Debug.txt, align 4, keep-with-next
    550           void at91flashErase(void)
    551           {
   \                     at91flashErase:
   \   00000000   01B5               PUSH     {R0,LR}
    552             // erase flash
    553               AT91C_BASE_MC->MC_FCR =(0x5A<<24) | AT91C_MC_FCMD_ERASE_ALL;
   \   00000002   9B20               MOVS     R0,#+155
   \   00000004   C043               MVNS     R0,R0            ;; #-156
   \   00000006   0549               LDR      R1,??at91flashErase_0  ;; 0x5a000008
   \   00000008   0160               STR      R1,[R0, #+0]
    554               // wait for flash done/ready
    555               while(!(AT91C_BASE_MC->MC_FSR & AT91C_MC_FRDY));
   \                     ??at91flashErase_1:
   \   0000000A   9720               MOVS     R0,#+151
   \   0000000C   C043               MVNS     R0,R0            ;; #-152
   \   0000000E   0068               LDR      R0,[R0, #+0]
   \   00000010   C007               LSLS     R0,R0,#+31
   \   00000012   FAD5               BPL      ??at91flashErase_1
    556          
    557           }
   \   00000014   08BC               POP      {R3}
   \   00000016   01BC               POP      {R0}
   \   00000018   0047               BX       R0               ;; return
   \   0000001A   C046               Nop      
   \                     ??at91flashErase_0:
   \   0000001C   0800005A           DC32     0x5a000008

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   00FF0300           DC32     0x3ff00

   \                                 In section .textrw, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   0100005A           DC32     0x5a000001

   \                                 In section .rodata, align 4
   \                     `?<Constant "Blad zapisu. Przekroc...">`:
   \   00000000   426C6164207A       DC8 "Blad zapisu. Przekroczenie dozwolonego obszaru"
   \              61706973752E
   \              2050727A656B
   \              726F637A656E
   \              696520646F7A
   \              776F6C6F6E65
   \              676F206F6273
   \              7A61727500  
   \   0000002F   00                 DC8 0
   \   00000030   426C6164207A       DC8 "Blad zapisu do flash"
   \              617069737520
   \              646F20666C61
   \              736800      
   \   00000045   000000             DC8 0, 0, 0
   \   00000048   42B3B964206E       DC8 "B³¹d naruszenia zablokowanego regionu flash"
   \              617275737A65
   \              6E6961207A61
   \              626C6F6B6F77
   \              616E65676F20
   \              726567696F6E
   \              7520666C6173
   \              6800        
   \   00000074   5AB379206B6C       DC8 "Z³y klucz lub b³edna komenda zapisu flash"
   \              75637A206C75
   \              622062B36564
   \              6E61206B6F6D
   \              656E6461207A
   \              617069737520
   \              666C61736800
   \   0000009E   0000               DC8 0, 0
    558          

   Maximum stack usage in bytes:

     Function          .cstack
     --------          -------
     AT91F_Flash_Ready      8
     AT91F_Flash_Write     16
     CleanFlash           288
     FlashWrite            32
     FlashWriteExe        376
     InitFlash              0
     at91flashErase         8
     at91flashWrite       288


   Section sizes:

     Function/Label                 Bytes
     --------------                 -----
     InitFlash                        24
     at91flashWrite                  170
     AT91F_Flash_Ready                24
     AT91F_Flash_Write               132
     FlashWrite                       46
     FlashWriteExe                   320
     CleanFlash                      172
     at91flashErase                   32
     ??DataTable6                      4
     ??DataTable7                      4
     ?<Constant "Blad zapisu. Przekroc...">
                                     160
      Others                          32

 
 160 bytes in section .rodata
 826 bytes in section .textrw
 134 bytes in section Debug.txt
 
 928 bytes of CODE  memory (+ 32 bytes shared)
 160 bytes of CONST memory

Errors: none
Warnings: 14
