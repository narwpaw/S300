###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           20/Mar/2013  07:53:30 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 BETA-          #
#                    14.03.2013\Framework\Application_prog.c                  #
#    Command line =  "D:\Zeuron\Projekty\S300\S300-program v1.3 BETA-         #
#                    14.03.2013\Framework\Application_prog.c" -D              #
#                    AT91SAM7S256 -D AT91SAM7SEK -D iH -D __ALARM -D          #
#                    __WIFI_MODULE -D S300i -D _TESTER_ -lC                   #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 BETA-         #
#                    14.03.2013\TESTER S300i\List\" --diag_suppress Pa082 -o  #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 BETA-         #
#                    14.03.2013\TESTER S300i\Obj\" --no_unroll --no_inline    #
#                    --no_tbaa --no_scheduling --debug --endian little --cpu  #
#                    ARM7TDMI -e --fpu None --dlib_config "C:\Program Files   #
#                    (x86)\IAR Systems\Embedded Workbench                     #
#                    5.0\ARM\INC\DLib_Config_Normal.h" -I                     #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 BETA-         #
#                    14.03.2013\lib\AT91SAM7S256\" -I                         #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 BETA-         #
#                    14.03.2013\lib\AT91SAM7S64\" -I                          #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 BETA-         #
#                    14.03.2013\" -I "D:\Zeuron\Projekty\S300\S300-program    #
#                    v1.3 BETA- 14.03.2013\cdc\" -I                           #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 BETA-         #
#                    14.03.2013\core\" -I "D:\Zeuron\Projekty\S300\S300-progr #
#                    am v1.3 BETA- 14.03.2013\startup\" -I                    #
#                    "D:\Zeuron\Projekty\S300\S300-program v1.3 BETA-         #
#                    14.03.2013\Framework\" -I "D:\Zeuron\Projekty\S300\S300- #
#                    program v1.3 BETA- 14.03.2013\Framework\Configuration\"  #
#                    -I "C:\Program Files (x86)\IAR Systems\Embedded          #
#                    Workbench 5.0\ARM\INC\" --section .text=Debug.txt        #
#                    --interwork --cpu_mode thumb -Om                         #
#    List file    =  D:\Zeuron\Projekty\S300\S300-program v1.3 BETA-          #
#                    14.03.2013\TESTER S300i\List\Application_prog.lst        #
#    Object file  =  D:\Zeuron\Projekty\S300\S300-program v1.3 BETA-          #
#                    14.03.2013\TESTER S300i\Obj\Application_prog.o           #
#                                                                             #
#                                                                             #
###############################################################################

D:\Zeuron\Projekty\S300\S300-program v1.3 BETA- 14.03.2013\Framework\Application_prog.c
      1          //****************************************************************************//
      2          //*--------------------------------------------------------------------------*//
      3          //*                                 CEURON                                   *//                       
      4          //*--------------------------------------------------------------------------*//
      5          //*--------------------------------------------------------------------------*//
      6          //*  Nazwa pliku                  : Application_prog.c                       *//
      7          //*  Opis                         : Plik obs³ugi programu u¿ytkowego         *//
      8          //*  Autor                        : Pawe³ Narwojsz                           *//
      9          //*  Data utrzorzenia             : 10.09.2007                               *//
     10          //*  Data ostatniej modyfikacji   : --.--.----                               *//
     11          //*--------------------------------------------------------------------------*//
     12          //*                                                                          *//
     13          //*--------------------------------------------------------------------------*//
     14          //* Rejestr zmian  (data - opis):                                            *//
     15          //*                                                                          *//
     16          //*                               Brak zmian                                 *//
     17          //*                                                                          *//
     18          //*__________________________________________________________________________*// 
     19          //****************************************************************************//
     20          //****************************************************************************//
     21          
     22          
     23          
     24          
     25          #include "Application_prog.h" 
     26          
     27          #include "Framework.h"
     28          #include "core/device.h"                                                        //aduje bibliotreki dla odpowiedniego procesora
     29          #include "modbus.h"

                                          
                                          ^
"D:\Zeuron\Projekty\S300\S300-program v1.3 BETA- 14.03.2013\Framework\Configuration\InterruptPriority.h",59  Warning[Pe001]: 
          last line of file ends without a newline
     30          #include "usart.h"
     31          #include "RF_Exe.h"
     32          #include "ScreenMENU2.h"
     33          
     34          
     35          //Zmienne globalne -------------------------------------------------------------
     36            char NumberScene=NumberSceneMax;  //iloœæ u¿ywanych scen. Wartoœæ pierwotnie NumberSceneMax nastêpnie wyliczana
     37            short ScreenUse;

   \                                 In section .bss, align 1
     38            char SceneBefOff=0; //Je¿eli >0 to oznacza ¿e sceny zosta³y wy³¹czone przyskiem/zdarzeniem off.  SceneBefOff= nr sceny przed wy³¹czeniem
   \                     SceneBefOff:
   \   00000000                      DS8 1

   \                                 In section .bss, align 4
     39            _TransQuality TransQuality; //tablica informacyjna jakoœci po³¹czenia pola odpowiadaj¹ polom _ProgramTab.NeuronsIdTab
   \                     TransQuality:
   \   00000000                      DS8 216
     40          
     41            //___________________________Koniec zmiennych globalnych________________________
     42          
     43          
     44          
     45          
     46          #ifdef _LIVE_RJESTR   
     47            extern unsigned short LIVE_TAB[LIVE_TAB_SIZE];
     48            extern char LIVE_TAB_IDX;
     49          #endif
     50            
     51          
     52          extern RAM ram;
     53          extern int g_US0_BAUDRATE;
     54          //extern FlashPagesOffset;

   \                                 In section .bss, align 4
     55          Convers_DW_F ProgConvers_DW_F;
   \                     ProgConvers_DW_F:
   \   00000000                      DS8 4
     56          
     57          extern  _ScreenPaternDesign ScreenSetTab_0[];
     58          extern  _ScreenPaternDesign ScreenSetTab_1[];
     59          extern int int1;
     60          extern int FlashProgramOfset;
     61          extern int g_counter;
     62          extern char AdressModbus;
     63          extern char q_US0_Comm_Mode;
     64          extern char US0_MasterMODBUS_ENABLE;
     65          extern void Delay (unsigned long a);
     66          extern char g_Stop_Program;                                                     //1- zatrzymuje program
     67          extern char g_Restart_Program;                                                  //1- restartuje program
     68          extern unsigned int CyklPerSek;
     69          extern _DateTime DateTime;
     70          extern _RF_TaskTab  RF_TaskTab;

   \                                 In section .bss, align 4
     71          _ButtonGraph  ButtonExe[ScreenNr][ScrenButtonNr];                                         //do tej zmiennej przepisywane sa stany 1 z Button
   \                     ButtonExe:
   \   00000000                      DS8 576
     72          
     73          

   \                                 In section .bss, align 8
     74          volatile _ProgramTab gProg;
   \                     gProg:
   \   00000000                      DS8 50800
     75          char        *pProg=(char*)&gProg;

   \                                 In section .bss, align 4
     76          _NeuronsListUnit NeuronsList[NumberNeurons];
   \                     NeuronsList:
   \   00000000                      DS8 420
     77          
     78          
     79          
     80          
     81          char Variables[13];    //zmienne
     82          char VariablesImpulse[13];    //zmienne - flaga impulsu
     83          //char VariablesNetTmp[13];    //zmienne tyczmasowe dla komunikacji WiFi stosowana jako separacja  Variables[] ¿eby nie nadpisywaæ zmiennych

   \                                 In section .bss, align 4
     84          short int VariablesAnal[AnalogVarAmount];    //zmienne
   \                     VariablesAnal:
   \   00000000                      DS8 40
     85          
     86          
     87          

   \                                 In section .bss, align 4
     88          _MainStage  MainStage; 
   \                     MainStage:
   \   00000000                      DS8 1808
     89          _Trap      Trap;
     90          
     91          extern _ZD_MODBUS ZD_MODBUS_0[ZD_MODBUS_Tab_Max];

   \                                 In section Debug.txt, align 4, keep-with-next
     92          void SetModbusTask(void)
     93          {
     94          
     95                ptr_ZD_MODBUS ZD_MODBUS;
     96          
     97          
     98                ZD_MODBUS         =   ZD_MODBUS_0;
     99            
    100          
    101             
    102                
    103                char i=0; 
    104            
    105           
    106                   
    107                ZD_MODBUS[i].Adress=1;
   \                     SetModbusTask:
   \   00000000   ....               LDR      R0,??DataTable0  ;; ZD_MODBUS_0
   \   00000002   0121               MOVS     R1,#+1
   \   00000004   0170               STRB     R1,[R0, #+0]
    108                ZD_MODBUS[i].Function=0xF;
   \   00000006   0F21               MOVS     R1,#+15
   \   00000008   0A00               MOVS     R2,R1
   \   0000000A   4270               STRB     R2,[R0, #+1]
    109                ZD_MODBUS[i].Target=0x0;
   \   0000000C   0022               MOVS     R2,#+0
   \   0000000E   8270               STRB     R2,[R0, #+2]
   \   00000010   C270               STRB     R2,[R0, #+3]
    110                ZD_MODBUS[i].StartAdr=0;
   \   00000012   0271               STRB     R2,[R0, #+4]
   \   00000014   4271               STRB     R2,[R0, #+5]
    111                ZD_MODBUS[i].Coil=8;
   \   00000016   0822               MOVS     R2,#+8
   \   00000018   8271               STRB     R2,[R0, #+6]
   \   0000001A   120A               LSRS     R2,R2,#+8
   \   0000001C   C271               STRB     R2,[R0, #+7]
    112                ZD_MODBUS[i].Error=0x0;
   \   0000001E   C272               STRB     R2,[R0, #+11]
   \   00000020   0273               STRB     R2,[R0, #+12]
    113                
    114                i=1; 
    115                ZD_MODBUS[i].Adress=2;
   \   00000022   0222               MOVS     R2,#+2
   \   00000024   4273               STRB     R2,[R0, #+13]
    116                ZD_MODBUS[i].Function=0xF;
   \   00000026   0A00               MOVS     R2,R1
   \   00000028   8273               STRB     R2,[R0, #+14]
    117                ZD_MODBUS[i].Target=0x0;
   \   0000002A   0022               MOVS     R2,#+0
   \   0000002C   C273               STRB     R2,[R0, #+15]
   \   0000002E   0274               STRB     R2,[R0, #+16]
    118                ZD_MODBUS[i].StartAdr=1;
   \   00000030   0122               MOVS     R2,#+1
   \   00000032   4274               STRB     R2,[R0, #+17]
   \   00000034   120A               LSRS     R2,R2,#+8
   \   00000036   8274               STRB     R2,[R0, #+18]
    119                ZD_MODBUS[i].Coil=8;
   \   00000038   0822               MOVS     R2,#+8
   \   0000003A   C274               STRB     R2,[R0, #+19]
   \   0000003C   120A               LSRS     R2,R2,#+8
   \   0000003E   0275               STRB     R2,[R0, #+20]
    120                ZD_MODBUS[i].Error=0x0;
   \   00000040   0276               STRB     R2,[R0, #+24]
   \   00000042   4276               STRB     R2,[R0, #+25]
    121           
    122                i=2; 
    123                ZD_MODBUS[i].Adress=3;
   \   00000044   0322               MOVS     R2,#+3
   \   00000046   8276               STRB     R2,[R0, #+26]
    124                ZD_MODBUS[i].Function=0xF;
   \   00000048   C176               STRB     R1,[R0, #+27]
    125                ZD_MODBUS[i].Target=0x0;
   \   0000004A   0021               MOVS     R1,#+0
   \   0000004C   0177               STRB     R1,[R0, #+28]
   \   0000004E   4177               STRB     R1,[R0, #+29]
    126                ZD_MODBUS[i].StartAdr=2;
   \   00000050   0221               MOVS     R1,#+2
   \   00000052   8177               STRB     R1,[R0, #+30]
   \   00000054   090A               LSRS     R1,R1,#+8
   \   00000056   C177               STRB     R1,[R0, #+31]
    127                ZD_MODBUS[i].Coil=8;
   \   00000058   0100               MOVS     R1,R0
   \   0000005A   2031               ADDS     R1,R1,#+32
   \   0000005C   0822               MOVS     R2,#+8
   \   0000005E   0A70               STRB     R2,[R1, #+0]
   \   00000060   120A               LSRS     R2,R2,#+8
   \   00000062   4A70               STRB     R2,[R1, #+1]
    128                ZD_MODBUS[i].Error=0x0;      
   \   00000064   2530               ADDS     R0,R0,#+37
   \   00000066   1100               MOVS     R1,R2
   \   00000068   0170               STRB     R1,[R0, #+0]
   \   0000006A   4170               STRB     R1,[R0, #+1]
    129          
    130               
    131                
    132          }
   \   0000006C   7047               BX       LR               ;; return
    133          
    134          
    135          //*-----------------------------------------------------------------------------
    136          //* Nazwa funkcji :    PortStageRead
    137          //* Funkcja wydobywa wartoœæ bitu o numerze PortNr ze zmiennej pod adresem *Stage 
    138          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    139          char PortStageRead(short int Stage, char PortNr)
    140          {
   \                     PortStageRead:
   \   00000000   0200               MOVS     R2,R0
    141              char odp=0;
    142              odp=(Stage>>PortNr)&0x1;
    143              return odp;
   \   00000002   0A41               ASRS     R2,R2,R1
   \   00000004   0120               MOVS     R0,#+1
   \   00000006   1040               ANDS     R0,R0,R2
   \   00000008   7047               BX       LR               ;; return
    144          }
    145          
    146          //*-----------------------------------------------------------------------------
    147          //* Nazwa funkcji :    PortStageSet
    148          //* Funkcja ustawia stan portu (bit PortNr dla zmiennej pod adresem *Stage) na Value 
    149          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    150          void PortStageSet(short int *Stage, char PortNr, char Value)
    151          {
   \                     PortStageSet:
   \   00000000   11B4               PUSH     {R0,R4}
    152              Value&=0x1;
    153              *Stage=(*Stage&(~(0x1<<PortNr))) | (Value<<PortNr);
   \   00000002   0388               LDRH     R3,[R0, #+0]
   \   00000004   0124               MOVS     R4,#+1
   \   00000006   8C40               LSLS     R4,R4,R1
   \   00000008   A343               BICS     R3,R3,R4
   \   0000000A   0124               MOVS     R4,#+1
   \   0000000C   1440               ANDS     R4,R4,R2
   \   0000000E   8C40               LSLS     R4,R4,R1
   \   00000010   1C43               ORRS     R4,R4,R3
   \   00000012   0480               STRH     R4,[R0, #+0]
    154          }
   \   00000014   18BC               POP      {R3,R4}
   \   00000016   7047               BX       LR               ;; return
    155          
    156          
    157          
    158          //*-----------------------------------------------------------------------------
    159          //* Nazwa funkcji :    ProcStI_Action
    160          //* Funkcja procedury "Stan wejœcia"
    161          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    162          void ProcStI_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    163          {  
   \                     ProcStI_Action:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0C00               MOVS     R4,R1
    164            //je¿eli port w wêŸle == 1 i wiarygodny pomiar
    165            if (Proc->Nr>=0)
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   6156               LDRSB    R1,[R4, R1]
   \   00000008   0029               CMP      R1,#+0
   \   0000000A   1DD4               BMI      ??ProcStI_Action_0
    166            {
    167              if ((MainStg->StageI[Proc->Nr].Port !=0x8AAA))
   \   0000000C   0121               MOVS     R1,#+1
   \   0000000E   6156               LDRSB    R1,[R4, R1]
   \   00000010   1623               MOVS     R3,#+22
   \   00000012   5943               MULS     R1,R3,R1
   \   00000014   5118               ADDS     R1,R2,R1
   \   00000016   A031               ADDS     R1,R1,#+160
   \   00000018   0988               LDRH     R1,[R1, #+0]
   \   0000001A   ....               LDR      R3,??DataTable3  ;; 0x8aaa
   \   0000001C   9942               CMP      R1,R3
   \   0000001E   21D0               BEQ      ??ProcStI_Action_1
    168              {
    169                 if (*PrvOut)
   \   00000020   0021               MOVS     R1,#+0
   \   00000022   405E               LDRSH    R0,[R0, R1]
   \   00000024   0028               CMP      R0,#+0
   \   00000026   0DD0               BEQ      ??ProcStI_Action_2
    170                 {
    171                    Proc->Out=PortStageRead(MainStg->StageI[Proc->Nr].Port, Proc->Tag.Port);  
   \   00000028   217A               LDRB     R1,[R4, #+8]
   \   0000002A   0120               MOVS     R0,#+1
   \   0000002C   2056               LDRSB    R0,[R4, R0]
   \   0000002E   1623               MOVS     R3,#+22
   \   00000030   5843               MULS     R0,R3,R0
   \   00000032   1018               ADDS     R0,R2,R0
   \   00000034   A030               ADDS     R0,R0,#+160
   \   00000036   0088               LDRH     R0,[R0, #+0]
   \   00000038   0004               LSLS     R0,R0,#+16
   \   0000003A   0014               ASRS     R0,R0,#+16
   \   0000003C   ........           BL       PortStageRead
   \   00000040   6082               STRH     R0,[R4, #+18]
   \   00000042   0FE0               B        ??ProcStI_Action_1
    172                 }else{
    173                   Proc->Out=0;
   \                     ??ProcStI_Action_2:
   \   00000044   6082               STRH     R0,[R4, #+18]
   \   00000046   0DE0               B        ??ProcStI_Action_1
    174                 }
    175              }
    176              
    177            //je¿eli zmienna dwustanowa  
    178            }else{
    179                Proc->Out= (Variables[Proc->Tag.Port/8]>> (Proc->Tag.Port%8))&0x1;
   \                     ??ProcStI_Action_0:
   \   00000048   207A               LDRB     R0,[R4, #+8]
   \   0000004A   C010               ASRS     R0,R0,#+3
   \   0000004C   ....               LDR      R1,??DataTable15  ;; Trap
   \   0000004E   0818               ADDS     R0,R1,R0
   \   00000050   007C               LDRB     R0,[R0, #+16]
   \   00000052   217A               LDRB     R1,[R4, #+8]
   \   00000054   0A00               MOVS     R2,R1
   \   00000056   D208               LSRS     R2,R2,#+3
   \   00000058   D200               LSLS     R2,R2,#+3
   \   0000005A   891A               SUBS     R1,R1,R2
   \   0000005C   0841               ASRS     R0,R0,R1
   \   0000005E   0121               MOVS     R1,#+1
   \   00000060   0140               ANDS     R1,R1,R0
   \   00000062   6182               STRH     R1,[R4, #+18]
    180            }
    181          
    182          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStI_Action_1:
   \   00000064   10BC               POP      {R4}
   \   00000066   01BC               POP      {R0}
   \   00000068   0047               BX       R0               ;; return
    183          
    184          
    185          
    186          //*-----------------------------------------------------------------------------
    187          //* Nazwa funkcji :    ProcStI_Action
    188          //* Funkcja procedury "Stan wejœcia"
    189          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    190          void ProcStNI_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    191          {  
   \                     ProcStNI_Action:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   0C00               MOVS     R4,R1
    192                   //je¿eli port w wêŸle == 1 i wiarygodny pomiar
    193            if ((MainStg->StageI[Proc->Nr].Port !=0x8AAA))
   \   00000004   0121               MOVS     R1,#+1
   \   00000006   6156               LDRSB    R1,[R4, R1]
   \   00000008   1623               MOVS     R3,#+22
   \   0000000A   5943               MULS     R1,R3,R1
   \   0000000C   5118               ADDS     R1,R2,R1
   \   0000000E   A031               ADDS     R1,R1,#+160
   \   00000010   0988               LDRH     R1,[R1, #+0]
   \   00000012   ....               LDR      R3,??DataTable3  ;; 0x8aaa
   \   00000014   9942               CMP      R1,R3
   \   00000016   2ED0               BEQ      ??ProcStNI_Action_0
    194            {
    195            
    196             if (*PrvOut)
   \   00000018   0021               MOVS     R1,#+0
   \   0000001A   405E               LDRSH    R0,[R0, R1]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   29D0               BEQ      ??ProcStNI_Action_1
    197             {
    198          
    199                   if (Proc->Nr>=0)
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   2056               LDRSB    R0,[R4, R0]
   \   00000024   0028               CMP      R0,#+0
   \   00000026   13D4               BMI      ??ProcStNI_Action_2
    200                   {
    201                     if (PortStageRead(MainStg->StageI[Proc->Nr].Port, Proc->Tag.Port)==1)
   \   00000028   217A               LDRB     R1,[R4, #+8]
   \   0000002A   0120               MOVS     R0,#+1
   \   0000002C   2056               LDRSB    R0,[R4, R0]
   \   0000002E   1623               MOVS     R3,#+22
   \   00000030   5843               MULS     R0,R3,R0
   \   00000032   1018               ADDS     R0,R2,R0
   \   00000034   A030               ADDS     R0,R0,#+160
   \   00000036   0088               LDRH     R0,[R0, #+0]
   \   00000038   0004               LSLS     R0,R0,#+16
   \   0000003A   0014               ASRS     R0,R0,#+16
   \   0000003C   ........           BL       PortStageRead
   \   00000040   0128               CMP      R0,#+1
   \   00000042   02D1               BNE      ??ProcStNI_Action_3
    202                     {
    203                      Proc->Out=0; 
   \   00000044   0020               MOVS     R0,#+0
   \   00000046   6082               STRH     R0,[R4, #+18]
   \   00000048   15E0               B        ??ProcStNI_Action_0
    204                     }else{
    205                      Proc->Out=1;
   \                     ??ProcStNI_Action_3:
   \   0000004A   0120               MOVS     R0,#+1
   \   0000004C   6082               STRH     R0,[R4, #+18]
   \   0000004E   12E0               B        ??ProcStNI_Action_0
    206                     }
    207                   }else{
    208                     if (((Variables[Proc->Tag.Port/8]>> (Proc->Tag.Port%8))&0x1)==1)
   \                     ??ProcStNI_Action_2:
   \   00000050   207A               LDRB     R0,[R4, #+8]
   \   00000052   C010               ASRS     R0,R0,#+3
   \   00000054   ....               LDR      R1,??DataTable15  ;; Trap
   \   00000056   0818               ADDS     R0,R1,R0
   \   00000058   007C               LDRB     R0,[R0, #+16]
   \   0000005A   217A               LDRB     R1,[R4, #+8]
   \   0000005C   0A00               MOVS     R2,R1
   \   0000005E   D208               LSRS     R2,R2,#+3
   \   00000060   D200               LSLS     R2,R2,#+3
   \   00000062   891A               SUBS     R1,R1,R2
   \   00000064   0841               ASRS     R0,R0,R1
   \   00000066   0121               MOVS     R1,#+1
   \   00000068   0140               ANDS     R1,R1,R0
   \   0000006A   481E               SUBS     R0,R1,#+1
   \   0000006C   8041               SBCS     R0,R0,R0
   \   0000006E   C00F               LSRS     R0,R0,#+31
   \   00000070   6082               STRH     R0,[R4, #+18]
   \   00000072   00E0               B        ??ProcStNI_Action_0
    209                     {
    210                      Proc->Out=0; 
    211                     }else{
    212                      Proc->Out=1;
    213                     }
    214                   }
    215                 }else{
    216                   Proc->Out=0;
   \                     ??ProcStNI_Action_1:
   \   00000074   6082               STRH     R0,[R4, #+18]
    217                 }
    218             }
    219          
    220          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStNI_Action_0:
   \   00000076   10BC               POP      {R4}
   \   00000078   01BC               POP      {R0}
   \   0000007A   0047               BX       R0               ;; return
    221          
    222          
    223          
    224          
    225          //*-----------------------------------------------------------------------------
    226          //* Nazwa funkcji :    ProcGetAnal_Action
    227          //* Funkcja procedury "Stan wejœcia analogowego"
    228          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    229          void ProcGetReg_Action(_Procedure *Proc, _MainStage *MainStg) 
    230          {  
   \                     ProcGetReg_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    231            if (Proc->Nr>=0)
   \   00000002   0122               MOVS     R2,#+1
   \   00000004   8256               LDRSB    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   18D4               BMI      ??ProcGetReg_Action_0
    232            {
    233                if ((MainStg->StageI[Proc->Nr].Value[Proc->Tag.RegNr])!=(signed short int )0x8AAA)
   \   0000000A   A022               MOVS     R2,#+160
   \   0000000C   037A               LDRB     R3,[R0, #+8]
   \   0000000E   5B00               LSLS     R3,R3,#+1
   \   00000010   0124               MOVS     R4,#+1
   \   00000012   0457               LDRSB    R4,[R0, R4]
   \   00000014   1625               MOVS     R5,#+22
   \   00000016   6C43               MULS     R4,R5,R4
   \   00000018   0C19               ADDS     R4,R1,R4
   \   0000001A   E318               ADDS     R3,R4,R3
   \   0000001C   9A5E               LDRSH    R2,[R3, R2]
   \   0000001E   0B4B               LDR      R3,??ProcGetReg_Action_1  ;; 0xffff8aaa
   \   00000020   9A42               CMP      R2,R3
   \   00000022   10D0               BEQ      ??ProcGetReg_Action_2
    234                {
    235                  Proc->Out=MainStg->StageI[Proc->Nr].Value[Proc->Tag.RegNr];  
   \   00000024   027A               LDRB     R2,[R0, #+8]
   \   00000026   5200               LSLS     R2,R2,#+1
   \   00000028   0123               MOVS     R3,#+1
   \   0000002A   C356               LDRSB    R3,[R0, R3]
   \   0000002C   2C00               MOVS     R4,R5
   \   0000002E   6343               MULS     R3,R4,R3
   \   00000030   C918               ADDS     R1,R1,R3
   \   00000032   8918               ADDS     R1,R1,R2
   \   00000034   A031               ADDS     R1,R1,#+160
   \   00000036   0988               LDRH     R1,[R1, #+0]
   \   00000038   4182               STRH     R1,[R0, #+18]
   \   0000003A   04E0               B        ??ProcGetReg_Action_2
    236                }
    237            }else{
    238                Proc->Out=VariablesAnal[Proc->Tag.RegNr];
   \                     ??ProcGetReg_Action_0:
   \   0000003C   017A               LDRB     R1,[R0, #+8]
   \   0000003E   4900               LSLS     R1,R1,#+1
   \   00000040   ....               LDR      R2,??DataTable7  ;; VariablesAnal
   \   00000042   515A               LDRH     R1,[R2, R1]
   \   00000044   4182               STRH     R1,[R0, #+18]
    239            }
    240               
    241          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcGetReg_Action_2:
   \   00000046   38BC               POP      {R3-R5}
   \   00000048   01BC               POP      {R0}
   \   0000004A   0047               BX       R0               ;; return
   \                     ??ProcGetReg_Action_1:
   \   0000004C   AA8AFFFF           DC32     0xffff8aaa
    242          
    243          
    244          
    245          //*-----------------------------------------------------------------------------
    246          //* Nazwa funkcji :    ProcSetAnal_Action
    247          //* Funkcja procedury "Ustawienie wyjœcia analogowego"
    248          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    249          void ProcSetAnal_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    250          {  
   \                     ProcSetAnal_Action:
   \   00000000   70B5               PUSH     {R4-R6,LR}
    251            if (Proc->Nr>=0)
   \   00000002   0123               MOVS     R3,#+1
   \   00000004   CB56               LDRSB    R3,[R1, R3]
   \   00000006   002B               CMP      R3,#+0
   \   00000008   0BD4               BMI      ??ProcSetAnal_Action_0
    252            {
    253                MainStg->StageQ[Proc->Nr].Value[Proc->Tag.RegNr]=*PrvOut;
   \   0000000A   ....               LDR      R3,??DataTable8  ;; 0x3a2
   \   0000000C   0C7A               LDRB     R4,[R1, #+8]
   \   0000000E   6400               LSLS     R4,R4,#+1
   \   00000010   0125               MOVS     R5,#+1
   \   00000012   4D57               LDRSB    R5,[R1, R5]
   \   00000014   1626               MOVS     R6,#+22
   \   00000016   7543               MULS     R5,R6,R5
   \   00000018   5219               ADDS     R2,R2,R5
   \   0000001A   1219               ADDS     R2,R2,R4
   \   0000001C   0488               LDRH     R4,[R0, #+0]
   \   0000001E   D452               STRH     R4,[R2, R3]
   \   00000020   04E0               B        ??ProcSetAnal_Action_1
    254            }else{
    255                VariablesAnal[Proc->Tag.RegNr]=*PrvOut;
   \                     ??ProcSetAnal_Action_0:
   \   00000022   0A7A               LDRB     R2,[R1, #+8]
   \   00000024   5200               LSLS     R2,R2,#+1
   \   00000026   ....               LDR      R3,??DataTable7  ;; VariablesAnal
   \   00000028   0488               LDRH     R4,[R0, #+0]
   \   0000002A   9C52               STRH     R4,[R3, R2]
    256            }  
    257            Proc->Out=*PrvOut;
   \                     ??ProcSetAnal_Action_1:
   \   0000002C   0088               LDRH     R0,[R0, #+0]
   \   0000002E   4882               STRH     R0,[R1, #+18]
    258           
    259          }//_______________________ Koniec funkcji  ____________________________
   \   00000030   70BC               POP      {R4-R6}
   \   00000032   01BC               POP      {R0}
   \   00000034   0047               BX       R0               ;; return
    260          
    261          
    262          
    263          
    264          //*-----------------------------------------------------------------------------
    265          //* Nazwa funkcji :    ProcConstAnal_Action
    266          //* Funkcja procedury "staa analogowa"
    267          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    268          void ProcConstAnal_Action(_Procedure *Proc) 
    269          {  
    270            Proc->Out=Proc->Tag.ConstAnValue;  
   \                     ProcConstAnal_Action:
   \   00000000   0189               LDRH     R1,[R0, #+8]
   \   00000002   4182               STRH     R1,[R0, #+18]
    271          }//_______________________ Koniec funkcji  ____________________________
   \   00000004   7047               BX       LR               ;; return
    272          
    273          
    274          
    275          
    276          
    277          //*-----------------------------------------------------------------------------
    278          
    279          
    280          
    281          
    282          
    283          //*-----------------------------------------------------------------------------
    284          //* Nazwa funkcji :    ProcStB_Action
    285          //* Funkcja procedury "Akcja przycisków przycisków"
    286          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    287          void ProcStB_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    288          {  
   \                     ProcStB_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    289             if (*PrvOut)
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C05E               LDRSH    R0,[R0, R3]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   06D0               BEQ      ??ProcStB_Action_0
    290             {
    291                Proc->Out=MainStg->StageButtonExe[Proc->Nr];  
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   0856               LDRSB    R0,[R1, R0]
   \   0000000E   1018               ADDS     R0,R2,R0
   \   00000010   5030               ADDS     R0,R0,#+80
   \   00000012   0078               LDRB     R0,[R0, #+0]
   \   00000014   4882               STRH     R0,[R1, #+18]
   \   00000016   00E0               B        ??ProcStB_Action_1
    292          
    293             }else{
    294               Proc->Out=0;
   \                     ??ProcStB_Action_0:
   \   00000018   4882               STRH     R0,[R1, #+18]
    295             }
    296          
    297          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStB_Action_1:
   \   0000001A   08BC               POP      {R3}
   \   0000001C   01BC               POP      {R0}
   \   0000001E   0047               BX       R0               ;; return
    298          
    299          
    300          
    301          //*-----------------------------------------------------------------------------
    302          //* Nazwa funkcji :    ProcStQ_Action
    303          //* Funkcja procedury "Stan wyjœcia"
    304          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    305          void ProcStQ_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    306          {  
   \                     ProcStQ_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0C00               MOVS     R4,R1
    307             if (*PrvOut)
   \   00000004   0021               MOVS     R1,#+0
   \   00000006   405E               LDRSH    R0,[R0, R1]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   0DD0               BEQ      ??ProcStQ_Action_0
    308             {
    309                Proc->Out=PortStageRead(MainStg->StageQ[Proc->Nr].Port,Proc->Tag.Port);  
   \   0000000C   217A               LDRB     R1,[R4, #+8]
   \   0000000E   ....               LDR      R0,??DataTable8  ;; 0x3a2
   \   00000010   0123               MOVS     R3,#+1
   \   00000012   E356               LDRSB    R3,[R4, R3]
   \   00000014   1625               MOVS     R5,#+22
   \   00000016   6B43               MULS     R3,R5,R3
   \   00000018   D218               ADDS     R2,R2,R3
   \   0000001A   105A               LDRH     R0,[R2, R0]
   \   0000001C   0004               LSLS     R0,R0,#+16
   \   0000001E   0014               ASRS     R0,R0,#+16
   \   00000020   ........           BL       PortStageRead
   \   00000024   6082               STRH     R0,[R4, #+18]
   \   00000026   00E0               B        ??ProcStQ_Action_1
    310             }else{
    311                Proc->Out=0;
   \                     ??ProcStQ_Action_0:
   \   00000028   6082               STRH     R0,[R4, #+18]
    312             }
    313          
    314          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStQ_Action_1:
   \   0000002A   38BC               POP      {R3-R5}
   \   0000002C   01BC               POP      {R0}
   \   0000002E   0047               BX       R0               ;; return
    315          
    316          
    317          
    318          
    319          
    320          //*-----------------------------------------------------------------------------
    321          //* Nazwa funkcji :    ProcStS_Action
    322          //* Funkcja procedury "Stan sceny"
    323          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    324          void ProcStS_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    325          {  
   \                     ProcStS_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    326            Proc->Out=0;
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   4B82               STRH     R3,[R1, #+18]
    327             if (*PrvOut)
   \   00000006   C05E               LDRSH    R0,[R0, R3]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   07D0               BEQ      ??ProcStS_Action_0
    328             {
    329                if (Proc->Nr==MainStg->SceneNr) Proc->Out=1;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   0856               LDRSB    R0,[R1, R0]
   \   00000010   ....               LDR      R3,??DataTable9  ;; 0x6ea
   \   00000012   D25C               LDRB     R2,[R2, R3]
   \   00000014   9042               CMP      R0,R2
   \   00000016   01D1               BNE      ??ProcStS_Action_0
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   4882               STRH     R0,[R1, #+18]
    330             }
    331          
    332          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcStS_Action_0:
   \   0000001C   08BC               POP      {R3}
   \   0000001E   01BC               POP      {R0}
   \   00000020   0047               BX       R0               ;; return
    333          
    334          
    335          
    336          /*
    337          
    338          //-----------------------------------------------------------------------------
    339          // Nazwa funkcji :    ProcStT_Action
    340          // Funkcja procedury "Stan timera"
    341          //-----------------------------------------------------------------------------
    342          void ProcStT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    343          {  
    344             if (*PrvOut)
    345             {
    346                Proc->Out=PortStageRead(MainStg->StageTimer[Proc->Nr].Port,Proc->Tag.Port);  
    347             }else{
    348                Proc->Out=0;
    349             }
    350          
    351          }//_______________________ Koniec funkcji  ____________________________
    352          
    353          
    354          
    355          
    356          //-----------------------------------------------------------------------------
    357          // Nazwa funkcji :    ProcStT_Action
    358          // Funkcja procedury "Stan timera"
    359          //-----------------------------------------------------------------------------
    360          void ProcStNT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    361          {  
    362             if (*PrvOut) 
    363             {
    364                if (PortStageRead(MainStg->StageTimer[Proc->Nr].Port,Proc->Tag.Port))
    365                {
    366                  Proc->Out=0;
    367                }else{
    368                  Proc->Out=1;  
    369                }
    370             }else{
    371                Proc->Out=0;
    372             }
    373          
    374          }//_______________________ Koniec funkcji  ____________________________
    375          */
    376          
    377          
    378          
    379           extern unsigned long long g_NextTimeProgram;
    380          
    381          
    382          //*-----------------------------------------------------------------------------
    383          //* Nazwa funkcji :    ProcWOUT_Action
    384          //* Funkcja procedury "Ustaw stan wyjœcia"
    385          //*-----------------------------------------------------------------------------
    386          

   \                                 In section Debug.txt, align 4, keep-with-next
    387          void ProcWOUT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    388          {  
   \                     ProcWOUT_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    389          
    390               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   205E               LDRSH    R0,[R4, R0]
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   36D1               BNE      ??ProcWOUT_Action_0
   \   00000010   1220               MOVS     R0,#+18
   \   00000012   285E               LDRSH    R0,[R5, R0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   32D1               BNE      ??ProcWOUT_Action_0
    391               {
    392                if ((Proc->Nr>=0) && (Proc->Nr!=0xFF))   //je¿eli wêze³
                                                     ^
Warning[Pa084]: pointless integer comparison with an out of range value
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   2856               LDRSB    R0,[R5, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   1DD4               BMI      ??ProcWOUT_Action_1
   \   00000020   0120               MOVS     R0,#+1
   \   00000022   2856               LDRSB    R0,[R5, R0]
   \   00000024   FF28               CMP      R0,#+255
   \   00000026   19D0               BEQ      ??ProcWOUT_Action_1
    393                {
    394                   PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,1); 
                                       ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000028   0122               MOVS     R2,#+1
   \   0000002A   297A               LDRB     R1,[R5, #+8]
   \   0000002C   3148               LDR      R0,??ProcWOUT_Action_2  ;; 0x3a2
   \   0000002E   1300               MOVS     R3,R2
   \   00000030   EB56               LDRSB    R3,[R5, R3]
   \   00000032   1627               MOVS     R7,#+22
   \   00000034   7B43               MULS     R3,R7,R3
   \   00000036   F318               ADDS     R3,R6,R3
   \   00000038   1818               ADDS     R0,R3,R0
   \   0000003A   ........           BL       PortStageSet
    395                   if (TransQuality.Mensur[Proc->Nr-1]>0)  MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   0000003E   0120               MOVS     R0,#+1
   \   00000040   2856               LDRSB    R0,[R5, R0]
   \   00000042   8000               LSLS     R0,R0,#+2
   \   00000044   ....               LDR      R1,??DataTable13  ;; TransQuality
   \   00000046   0818               ADDS     R0,R1,R0
   \   00000048   806C               LDR      R0,[R0, #+72]
   \   0000004A   0028               CMP      R0,#+0
   \   0000004C   17D0               BEQ      ??ProcWOUT_Action_0
   \   0000004E   ....               LDR      R0,??DataTable14  ;; 0x6eb
   \   00000050   0121               MOVS     R1,#+1
   \   00000052   6956               LDRSB    R1,[R5, R1]
   \   00000054   7118               ADDS     R1,R6,R1
   \   00000056   0A22               MOVS     R2,#+10
   \   00000058   0A54               STRB     R2,[R1, R0]
   \   0000005A   10E0               B        ??ProcWOUT_Action_0
    396                 
    397                   #ifdef _LIVE_RJESTR 
    398                       LIVE_TAB[LIVE_TAB_IDX]=0xF000 | ((Proc->Nr&0xF)<<8) | ((MainStg->StageQ[Proc->Nr].Port)&0xFF);
    399                       if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    400                   #endif
    401          
    402                }else{  //je¿eli zmienna dwustanowa  
    403                    Variables[Proc->Tag.Port/8] |= 1<<(Proc->Tag.Port%8);
   \                     ??ProcWOUT_Action_1:
   \   0000005C   ....               LDR      R0,??DataTable15  ;; Trap
   \   0000005E   297A               LDRB     R1,[R5, #+8]
   \   00000060   C910               ASRS     R1,R1,#+3
   \   00000062   4118               ADDS     R1,R0,R1
   \   00000064   2A7A               LDRB     R2,[R5, #+8]
   \   00000066   D210               ASRS     R2,R2,#+3
   \   00000068   8018               ADDS     R0,R0,R2
   \   0000006A   007C               LDRB     R0,[R0, #+16]
   \   0000006C   0122               MOVS     R2,#+1
   \   0000006E   2B7A               LDRB     R3,[R5, #+8]
   \   00000070   1F00               MOVS     R7,R3
   \   00000072   FF08               LSRS     R7,R7,#+3
   \   00000074   FF00               LSLS     R7,R7,#+3
   \   00000076   DB1B               SUBS     R3,R3,R7
   \   00000078   9A40               LSLS     R2,R2,R3
   \   0000007A   0243               ORRS     R2,R2,R0
   \   0000007C   0A74               STRB     R2,[R1, #+16]
    404                    
    405                    #ifdef _LIVE_RJESTR   
    406                        LIVE_TAB[LIVE_TAB_IDX]=0xF000 | ((Proc->Nr&0xF)<<8) | ((MainStg->StageQ[Proc->Nr].Port)&0xFF);
    407                        if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    408                    #endif
    409                }
    410               }
    411          
    412               if ((*PrvOut==0) && (Proc->Out==1))
   \                     ??ProcWOUT_Action_0:
   \   0000007E   0020               MOVS     R0,#+0
   \   00000080   205E               LDRSH    R0,[R4, R0]
   \   00000082   0028               CMP      R0,#+0
   \   00000084   31D1               BNE      ??ProcWOUT_Action_3
   \   00000086   1220               MOVS     R0,#+18
   \   00000088   285E               LDRSH    R0,[R5, R0]
   \   0000008A   0128               CMP      R0,#+1
   \   0000008C   2DD1               BNE      ??ProcWOUT_Action_3
    413               {
    414                  if (Proc->Nr>=0)    //je¿eli wêze³
   \   0000008E   2856               LDRSB    R0,[R5, R0]
   \   00000090   0028               CMP      R0,#+0
   \   00000092   19D4               BMI      ??ProcWOUT_Action_4
    415                  {
    416                     PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,0); 
                                         ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000094   0022               MOVS     R2,#+0
   \   00000096   297A               LDRB     R1,[R5, #+8]
   \   00000098   1648               LDR      R0,??ProcWOUT_Action_2  ;; 0x3a2
   \   0000009A   0123               MOVS     R3,#+1
   \   0000009C   EB56               LDRSB    R3,[R5, R3]
   \   0000009E   1627               MOVS     R7,#+22
   \   000000A0   7B43               MULS     R3,R7,R3
   \   000000A2   F318               ADDS     R3,R6,R3
   \   000000A4   1818               ADDS     R0,R3,R0
   \   000000A6   ........           BL       PortStageSet
    417                   
    418                     if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \   000000AA   0120               MOVS     R0,#+1
   \   000000AC   2856               LDRSB    R0,[R5, R0]
   \   000000AE   8000               LSLS     R0,R0,#+2
   \   000000B0   ....               LDR      R1,??DataTable13  ;; TransQuality
   \   000000B2   0818               ADDS     R0,R1,R0
   \   000000B4   806C               LDR      R0,[R0, #+72]
   \   000000B6   0028               CMP      R0,#+0
   \   000000B8   17D0               BEQ      ??ProcWOUT_Action_3
    419                     MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   000000BA   ....               LDR      R0,??DataTable14  ;; 0x6eb
   \   000000BC   0121               MOVS     R1,#+1
   \   000000BE   6956               LDRSB    R1,[R5, R1]
   \   000000C0   7118               ADDS     R1,R6,R1
   \   000000C2   0A22               MOVS     R2,#+10
   \   000000C4   0A54               STRB     R2,[R1, R0]
   \   000000C6   10E0               B        ??ProcWOUT_Action_3
    420                    
    421                  }else //je¿eli zmienna dwustanowa
    422                  { 
    423                      Variables[Proc->Tag.Port/8]&= ~(1<<(Proc->Tag.Port%8));
   \                     ??ProcWOUT_Action_4:
   \   000000C8   ....               LDR      R0,??DataTable15  ;; Trap
   \   000000CA   297A               LDRB     R1,[R5, #+8]
   \   000000CC   C910               ASRS     R1,R1,#+3
   \   000000CE   4118               ADDS     R1,R0,R1
   \   000000D0   2A7A               LDRB     R2,[R5, #+8]
   \   000000D2   D210               ASRS     R2,R2,#+3
   \   000000D4   8018               ADDS     R0,R0,R2
   \   000000D6   027C               LDRB     R2,[R0, #+16]
   \   000000D8   0123               MOVS     R3,#+1
   \   000000DA   287A               LDRB     R0,[R5, #+8]
   \   000000DC   0600               MOVS     R6,R0
   \   000000DE   F608               LSRS     R6,R6,#+3
   \   000000E0   F600               LSLS     R6,R6,#+3
   \   000000E2   801B               SUBS     R0,R0,R6
   \   000000E4   8340               LSLS     R3,R3,R0
   \   000000E6   9A43               BICS     R2,R2,R3
   \   000000E8   0A74               STRB     R2,[R1, #+16]
    424                      #ifdef _LIVE_RJESTR 
    425                        LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    426                        if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    427                      #endif
    428                  }  
    429               }
    430               Proc->Out=*PrvOut;
   \                     ??ProcWOUT_Action_3:
   \   000000EA   2088               LDRH     R0,[R4, #+0]
   \   000000EC   6882               STRH     R0,[R5, #+18]
    431            
    432          }//_______________________ Koniec funkcji  ____________________________
   \   000000EE   F8BC               POP      {R3-R7}
   \   000000F0   01BC               POP      {R0}
   \   000000F2   0047               BX       R0               ;; return
   \                     ??ProcWOUT_Action_2:
   \   000000F4   A2030000           DC32     0x3a2
    433          
    434          
    435                
    436          
    437          //*-----------------------------------------------------------------------------
    438          //* Nazwa funkcji :    ProcWOUTS_Action
    439          //* Funkcja procedury "Ustaw stan wyjœcia na 1"
    440          //*-----------------------------------------------------------------------------
    441          

   \                                 In section Debug.txt, align 4, keep-with-next
    442          void ProcWOUTS_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    443          {  
   \                     ProcWOUTS_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    444          
    445               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   205E               LDRSH    R0,[R4, R0]
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   32D1               BNE      ??ProcWOUTS_Action_0
   \   00000010   1220               MOVS     R0,#+18
   \   00000012   285E               LDRSH    R0,[R5, R0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   2ED1               BNE      ??ProcWOUTS_Action_0
    446               {
    447                if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   2856               LDRSB    R0,[R5, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   19D4               BMI      ??ProcWOUTS_Action_1
    448                {
    449                 PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,1); 
                                     ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000020   0122               MOVS     R2,#+1
   \   00000022   297A               LDRB     R1,[R5, #+8]
   \   00000024   1648               LDR      R0,??ProcWOUTS_Action_2  ;; 0x3a2
   \   00000026   1300               MOVS     R3,R2
   \   00000028   EB56               LDRSB    R3,[R5, R3]
   \   0000002A   1627               MOVS     R7,#+22
   \   0000002C   7B43               MULS     R3,R7,R3
   \   0000002E   F318               ADDS     R3,R6,R3
   \   00000030   1818               ADDS     R0,R3,R0
   \   00000032   ........           BL       PortStageSet
    450                 
    451                 if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \   00000036   0120               MOVS     R0,#+1
   \   00000038   2856               LDRSB    R0,[R5, R0]
   \   0000003A   8000               LSLS     R0,R0,#+2
   \   0000003C   1149               LDR      R1,??ProcWOUTS_Action_2+0x4  ;; TransQuality
   \   0000003E   0818               ADDS     R0,R1,R0
   \   00000040   806C               LDR      R0,[R0, #+72]
   \   00000042   0028               CMP      R0,#+0
   \   00000044   17D0               BEQ      ??ProcWOUTS_Action_0
    452                   MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   00000046   1048               LDR      R0,??ProcWOUTS_Action_2+0x8  ;; 0x6eb
   \   00000048   0121               MOVS     R1,#+1
   \   0000004A   6956               LDRSB    R1,[R5, R1]
   \   0000004C   7118               ADDS     R1,R6,R1
   \   0000004E   0A22               MOVS     R2,#+10
   \   00000050   0A54               STRB     R2,[R1, R0]
   \   00000052   10E0               B        ??ProcWOUTS_Action_0
    453                
    454                 #ifdef _LIVE_RJESTR 
    455                 LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    456                 if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    457                 #endif
    458                 
    459                 //je¿eli zmienna dwustanowa  
    460                }else{
    461                    Variables[Proc->Tag.Port/8]|= 1<<(Proc->Tag.Port%8);
   \                     ??ProcWOUTS_Action_1:
   \   00000054   0D49               LDR      R1,??ProcWOUTS_Action_2+0xC  ;; Trap
   \   00000056   287A               LDRB     R0,[R5, #+8]
   \   00000058   C010               ASRS     R0,R0,#+3
   \   0000005A   0818               ADDS     R0,R1,R0
   \   0000005C   2A7A               LDRB     R2,[R5, #+8]
   \   0000005E   D210               ASRS     R2,R2,#+3
   \   00000060   8918               ADDS     R1,R1,R2
   \   00000062   0A7C               LDRB     R2,[R1, #+16]
   \   00000064   0123               MOVS     R3,#+1
   \   00000066   297A               LDRB     R1,[R5, #+8]
   \   00000068   0E00               MOVS     R6,R1
   \   0000006A   F608               LSRS     R6,R6,#+3
   \   0000006C   F600               LSLS     R6,R6,#+3
   \   0000006E   891B               SUBS     R1,R1,R6
   \   00000070   8B40               LSLS     R3,R3,R1
   \   00000072   1343               ORRS     R3,R3,R2
   \   00000074   0374               STRB     R3,[R0, #+16]
    462                }
    463               }
    464               Proc->Out=*PrvOut;
   \                     ??ProcWOUTS_Action_0:
   \   00000076   2088               LDRH     R0,[R4, #+0]
   \   00000078   6882               STRH     R0,[R5, #+18]
    465            
    466          }//_______________________ Koniec funkcji  ____________________________
   \   0000007A   F8BC               POP      {R3-R7}
   \   0000007C   01BC               POP      {R0}
   \   0000007E   0047               BX       R0               ;; return
   \                     ??ProcWOUTS_Action_2:
   \   00000080   A2030000           DC32     0x3a2
   \   00000084   ........           DC32     TransQuality
   \   00000088   EB060000           DC32     0x6eb
   \   0000008C   ........           DC32     Trap
    467          
    468          
    469          //*-----------------------------------------------------------------------------
    470          //* Nazwa funkcji :    ProcWOUTR_Action
    471          //* Funkcja procedury "Ustaw stan wyjœcia  na 0"
    472          //*-----------------------------------------------------------------------------
    473          

   \                                 In section Debug.txt, align 4, keep-with-next
    474          void ProcWOUTR_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    475          {  
   \                     ProcWOUTR_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    476          
    477               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   205E               LDRSH    R0,[R4, R0]
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   32D1               BNE      ??ProcWOUTR_Action_0
   \   00000010   1220               MOVS     R0,#+18
   \   00000012   285E               LDRSH    R0,[R5, R0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   2ED1               BNE      ??ProcWOUTR_Action_0
    478               {
    479                if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   2856               LDRSB    R0,[R5, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   19D4               BMI      ??ProcWOUTR_Action_1
    480                { 
    481                 PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,0); 
                                     ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   00000020   0022               MOVS     R2,#+0
   \   00000022   297A               LDRB     R1,[R5, #+8]
   \   00000024   1648               LDR      R0,??ProcWOUTR_Action_2  ;; 0x3a2
   \   00000026   0123               MOVS     R3,#+1
   \   00000028   EB56               LDRSB    R3,[R5, R3]
   \   0000002A   1627               MOVS     R7,#+22
   \   0000002C   7B43               MULS     R3,R7,R3
   \   0000002E   F318               ADDS     R3,R6,R3
   \   00000030   1818               ADDS     R0,R3,R0
   \   00000032   ........           BL       PortStageSet
    482                 
    483                 if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \   00000036   0120               MOVS     R0,#+1
   \   00000038   2856               LDRSB    R0,[R5, R0]
   \   0000003A   8000               LSLS     R0,R0,#+2
   \   0000003C   1149               LDR      R1,??ProcWOUTR_Action_2+0x4  ;; TransQuality
   \   0000003E   0818               ADDS     R0,R1,R0
   \   00000040   806C               LDR      R0,[R0, #+72]
   \   00000042   0028               CMP      R0,#+0
   \   00000044   17D0               BEQ      ??ProcWOUTR_Action_0
    484                   MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   00000046   1048               LDR      R0,??ProcWOUTR_Action_2+0x8  ;; 0x6eb
   \   00000048   0121               MOVS     R1,#+1
   \   0000004A   6956               LDRSB    R1,[R5, R1]
   \   0000004C   7118               ADDS     R1,R6,R1
   \   0000004E   0A22               MOVS     R2,#+10
   \   00000050   0A54               STRB     R2,[R1, R0]
   \   00000052   10E0               B        ??ProcWOUTR_Action_0
    485                 
    486                 #ifdef _LIVE_RJESTR 
    487                  LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    488                  if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    489                 #endif
    490                  
    491                  //je¿eli zmienna dwustanowa  
    492                }else{
    493                    Variables[Proc->Tag.Port/8]&= ~(1<<(Proc->Tag.Port%8));
   \                     ??ProcWOUTR_Action_1:
   \   00000054   0D49               LDR      R1,??ProcWOUTR_Action_2+0xC  ;; Trap
   \   00000056   287A               LDRB     R0,[R5, #+8]
   \   00000058   C010               ASRS     R0,R0,#+3
   \   0000005A   0818               ADDS     R0,R1,R0
   \   0000005C   2A7A               LDRB     R2,[R5, #+8]
   \   0000005E   D210               ASRS     R2,R2,#+3
   \   00000060   8918               ADDS     R1,R1,R2
   \   00000062   0A7C               LDRB     R2,[R1, #+16]
   \   00000064   0123               MOVS     R3,#+1
   \   00000066   297A               LDRB     R1,[R5, #+8]
   \   00000068   0E00               MOVS     R6,R1
   \   0000006A   F608               LSRS     R6,R6,#+3
   \   0000006C   F600               LSLS     R6,R6,#+3
   \   0000006E   891B               SUBS     R1,R1,R6
   \   00000070   8B40               LSLS     R3,R3,R1
   \   00000072   9A43               BICS     R2,R2,R3
   \   00000074   0274               STRB     R2,[R0, #+16]
    494                }
    495               }
    496               Proc->Out=*PrvOut;
   \                     ??ProcWOUTR_Action_0:
   \   00000076   2088               LDRH     R0,[R4, #+0]
   \   00000078   6882               STRH     R0,[R5, #+18]
    497            
    498          }//_______________________ Koniec funkcji  ____________________________
   \   0000007A   F8BC               POP      {R3-R7}
   \   0000007C   01BC               POP      {R0}
   \   0000007E   0047               BX       R0               ;; return
   \                     ??ProcWOUTR_Action_2:
   \   00000080   A2030000           DC32     0x3a2
   \   00000084   ........           DC32     TransQuality
   \   00000088   EB060000           DC32     0x6eb
   \   0000008C   ........           DC32     Trap
    499          
    500          
    501          
    502          
    503          //*-----------------------------------------------------------------------------
    504          //* Nazwa funkcji :    ProcWOUTC_Action
    505          //* Funkcja procedury "zmaina stanu wyjœcia/zmiennej na przeciwny "
    506          //*-----------------------------------------------------------------------------
    507          

   \                                 In section Debug.txt, align 4, keep-with-next
    508          void ProcWOUTC_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    509          {  
   \                     ProcWOUTC_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0D00               MOVS     R5,R1
   \   00000006   1600               MOVS     R6,R2
    510          
    511               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   205E               LDRSH    R0,[R4, R0]
   \   0000000C   0128               CMP      R0,#+1
   \   0000000E   6BD1               BNE      ??ProcWOUTC_Action_0
   \   00000010   1220               MOVS     R0,#+18
   \   00000012   285E               LDRSH    R0,[R5, R0]
   \   00000014   0028               CMP      R0,#+0
   \   00000016   67D1               BNE      ??ProcWOUTC_Action_0
    512               {
    513                if (Proc->Nr>=0)    //je¿eli wêze³
   \   00000018   0120               MOVS     R0,#+1
   \   0000001A   2856               LDRSB    R0,[R5, R0]
   \   0000001C   0028               CMP      R0,#+0
   \   0000001E   33D4               BMI      ??ProcWOUTC_Action_1
    514                {
    515                     if (PortStageRead(MainStg->StageQ[Proc->Nr].Port,Proc->Tag.Port)==1) //je¿eli wyjœcie w stanie wysokim to zeruj je¿eli nie to ustaw 1
   \   00000020   297A               LDRB     R1,[R5, #+8]
   \   00000022   3448               LDR      R0,??ProcWOUTC_Action_2  ;; 0x3a2
   \   00000024   0122               MOVS     R2,#+1
   \   00000026   AA56               LDRSB    R2,[R5, R2]
   \   00000028   1623               MOVS     R3,#+22
   \   0000002A   5A43               MULS     R2,R3,R2
   \   0000002C   B218               ADDS     R2,R6,R2
   \   0000002E   105A               LDRH     R0,[R2, R0]
   \   00000030   0004               LSLS     R0,R0,#+16
   \   00000032   0014               ASRS     R0,R0,#+16
   \   00000034   ........           BL       PortStageRead
   \   00000038   0128               CMP      R0,#+1
   \   0000003A   0BD1               BNE      ??ProcWOUTC_Action_3
    516                     { 
    517                        PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,0); 
                                            ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \   0000003C   0022               MOVS     R2,#+0
   \   0000003E   297A               LDRB     R1,[R5, #+8]
   \   00000040   2C48               LDR      R0,??ProcWOUTC_Action_2  ;; 0x3a2
   \   00000042   0123               MOVS     R3,#+1
   \   00000044   EB56               LDRSB    R3,[R5, R3]
   \   00000046   1627               MOVS     R7,#+22
   \   00000048   7B43               MULS     R3,R7,R3
   \   0000004A   F318               ADDS     R3,R6,R3
   \   0000004C   1818               ADDS     R0,R3,R0
   \   0000004E   ........           BL       PortStageSet
   \   00000052   0AE0               B        ??ProcWOUTC_Action_4
    518                     }else{
    519                        PortStageSet((&(MainStg->StageQ[Proc->Nr].Port)),Proc->Tag.Port,1);
                                            ^
Warning[Pe167]: argument of type "unsigned short *" is incompatible with
          parameter of type "short *"
   \                     ??ProcWOUTC_Action_3:
   \   00000054   0122               MOVS     R2,#+1
   \   00000056   297A               LDRB     R1,[R5, #+8]
   \   00000058   2648               LDR      R0,??ProcWOUTC_Action_2  ;; 0x3a2
   \   0000005A   1300               MOVS     R3,R2
   \   0000005C   EB56               LDRSB    R3,[R5, R3]
   \   0000005E   1627               MOVS     R7,#+22
   \   00000060   7B43               MULS     R3,R7,R3
   \   00000062   F318               ADDS     R3,R6,R3
   \   00000064   1818               ADDS     R0,R3,R0
   \   00000066   ........           BL       PortStageSet
    520                     }
    521                   
    522                     if (TransQuality.Mensur[Proc->Nr-1]>0)   
   \                     ??ProcWOUTC_Action_4:
   \   0000006A   0120               MOVS     R0,#+1
   \   0000006C   2856               LDRSB    R0,[R5, R0]
   \   0000006E   8000               LSLS     R0,R0,#+2
   \   00000070   2149               LDR      R1,??ProcWOUTC_Action_2+0x4  ;; TransQuality
   \   00000072   0818               ADDS     R0,R1,R0
   \   00000074   806C               LDR      R0,[R0, #+72]
   \   00000076   0028               CMP      R0,#+0
   \   00000078   36D0               BEQ      ??ProcWOUTC_Action_0
    523                     MainStg->SendStageChange[Proc->Nr]=ChangeStageFlag;
   \   0000007A   2048               LDR      R0,??ProcWOUTC_Action_2+0x8  ;; 0x6eb
   \   0000007C   0121               MOVS     R1,#+1
   \   0000007E   6956               LDRSB    R1,[R5, R1]
   \   00000080   7118               ADDS     R1,R6,R1
   \   00000082   0A22               MOVS     R2,#+10
   \   00000084   0A54               STRB     R2,[R1, R0]
   \   00000086   2FE0               B        ??ProcWOUTC_Action_0
    524                  
    525                     #ifdef _LIVE_RJESTR 
    526                      LIVE_TAB[LIVE_TAB_IDX]=0xF000 | (Proc->Nr&0xF)<<1 | (MainStg->StageQ[Proc->Nr].Port)&0xFF;
    527                      if (LIVE_TAB_IDX<LIVE_TAB_SIZE) LIVE_TAB_IDX++; else LIVE_TAB_IDX=0;
    528                     #endif
    529                   
    530                 
    531                 //je¿eli zmienna dwustanowa  
    532                }else{
    533                      if (Variables[Proc->Tag.Port/8] && (1<<(Proc->Tag.Port%8)))
   \                     ??ProcWOUTC_Action_1:
   \   00000088   1D48               LDR      R0,??ProcWOUTC_Action_2+0xC  ;; Trap
   \   0000008A   297A               LDRB     R1,[R5, #+8]
   \   0000008C   C910               ASRS     R1,R1,#+3
   \   0000008E   4118               ADDS     R1,R0,R1
   \   00000090   097C               LDRB     R1,[R1, #+16]
   \   00000092   0029               CMP      R1,#+0
   \   00000094   18D0               BEQ      ??ProcWOUTC_Action_5
   \   00000096   0121               MOVS     R1,#+1
   \   00000098   2A7A               LDRB     R2,[R5, #+8]
   \   0000009A   1300               MOVS     R3,R2
   \   0000009C   DB08               LSRS     R3,R3,#+3
   \   0000009E   DB00               LSLS     R3,R3,#+3
   \   000000A0   D21A               SUBS     R2,R2,R3
   \   000000A2   9140               LSLS     R1,R1,R2
   \   000000A4   10D0               BEQ      ??ProcWOUTC_Action_5
    534                      {
    535                         Variables[Proc->Tag.Port/8] &= ~(1<<(Proc->Tag.Port%8));
   \   000000A6   297A               LDRB     R1,[R5, #+8]
   \   000000A8   C910               ASRS     R1,R1,#+3
   \   000000AA   4118               ADDS     R1,R0,R1
   \   000000AC   2A7A               LDRB     R2,[R5, #+8]
   \   000000AE   D210               ASRS     R2,R2,#+3
   \   000000B0   8018               ADDS     R0,R0,R2
   \   000000B2   027C               LDRB     R2,[R0, #+16]
   \   000000B4   0123               MOVS     R3,#+1
   \   000000B6   287A               LDRB     R0,[R5, #+8]
   \   000000B8   0600               MOVS     R6,R0
   \   000000BA   F608               LSRS     R6,R6,#+3
   \   000000BC   F600               LSLS     R6,R6,#+3
   \   000000BE   801B               SUBS     R0,R0,R6
   \   000000C0   8340               LSLS     R3,R3,R0
   \   000000C2   9A43               BICS     R2,R2,R3
   \   000000C4   0A74               STRB     R2,[R1, #+16]
   \   000000C6   0FE0               B        ??ProcWOUTC_Action_0
    536                      }else{
    537                         Variables[Proc->Tag.Port/8] |= (1<<(Proc->Tag.Port%8));
   \                     ??ProcWOUTC_Action_5:
   \   000000C8   297A               LDRB     R1,[R5, #+8]
   \   000000CA   C910               ASRS     R1,R1,#+3
   \   000000CC   4118               ADDS     R1,R0,R1
   \   000000CE   2A7A               LDRB     R2,[R5, #+8]
   \   000000D0   D210               ASRS     R2,R2,#+3
   \   000000D2   8018               ADDS     R0,R0,R2
   \   000000D4   027C               LDRB     R2,[R0, #+16]
   \   000000D6   0123               MOVS     R3,#+1
   \   000000D8   287A               LDRB     R0,[R5, #+8]
   \   000000DA   0600               MOVS     R6,R0
   \   000000DC   F608               LSRS     R6,R6,#+3
   \   000000DE   F600               LSLS     R6,R6,#+3
   \   000000E0   801B               SUBS     R0,R0,R6
   \   000000E2   8340               LSLS     R3,R3,R0
   \   000000E4   1343               ORRS     R3,R3,R2
   \   000000E6   0B74               STRB     R3,[R1, #+16]
    538                      }
    539                }
    540               }
    541               Proc->Out=*PrvOut;
   \                     ??ProcWOUTC_Action_0:
   \   000000E8   2088               LDRH     R0,[R4, #+0]
   \   000000EA   6882               STRH     R0,[R5, #+18]
    542            
    543          }//_______________________ Koniec funkcji  ____________________________
   \   000000EC   F8BC               POP      {R3-R7}
   \   000000EE   01BC               POP      {R0}
   \   000000F0   0047               BX       R0               ;; return
   \   000000F2   C046               Nop      
   \                     ??ProcWOUTC_Action_2:
   \   000000F4   A2030000           DC32     0x3a2
   \   000000F8   ........           DC32     TransQuality
   \   000000FC   EB060000           DC32     0x6eb
   \   00000100   ........           DC32     Trap
    544          
    545          
    546          
    547          
    548          
    549          /*
    550          //-----------------------------------------------------------------------------
    551          // Nazwa funkcji :    ProcSetT_Action
    552          // Funkcja procedury "Forsuj stan timera"
    553          //-----------------------------------------------------------------------------
    554          
    555          void ProcRstT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    556          {  
    557               if ((*PrvOut==1) && (Proc->Out==0))
    558               {
    559                  MainStg->StageTimer[Proc->Nr].Curent=0;
    560                  MainObiect.Timer[Proc->Nr]=0;
    561               }
    562               Proc->Out=*PrvOut;
    563            
    564          }//_______________________ Koniec funkcji  ____________________________
    565          */
    566          
    567          
    568          
    569          //*-----------------------------------------------------------------------------
    570          //* Nazwa funkcji :    ProcNOT_Action
    571          //* Funkcja procedury "Negacja
    572          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    573          void ProcNOT_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    574          {  
    575             if (*PrvOut)
   \                     ProcNOT_Action:
   \   00000000   0022               MOVS     R2,#+0
   \   00000002   805E               LDRSH    R0,[R0, R2]
   \   00000004   421E               SUBS     R2,R0,#+1
   \   00000006   9241               SBCS     R2,R2,R2
   \   00000008   D20F               LSRS     R2,R2,#+31
   \   0000000A   4A82               STRH     R2,[R1, #+18]
    576             {
    577                Proc->Out=0;  
    578             }else{
    579                Proc->Out=1;
    580             }
    581          }//_______________________ Koniec funkcji__ ____________________________
   \   0000000C   7047               BX       LR               ;; return
    582          
    583          
    584          
    585          
    586          //*-----------------------------------------------------------------------------
    587          //* Nazwa funkcji :    ProcToggleT_Action
    588          //* Funkcja procedury "Przerzutnik typu T"
    589          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    590          void ProcToggleRS_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    591          {  
   \                     ProcToggleRS_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    592             if ((*PrvOut))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C05E               LDRSH    R0,[R0, R3]
   \   00000006   0028               CMP      R0,#+0
   \   00000008   02D0               BEQ      ??ProcToggleRS_Action_0
    593             {
    594               Proc->Out=1;
   \   0000000A   0120               MOVS     R0,#+1
   \   0000000C   5082               STRH     R0,[R2, #+18]
   \   0000000E   04E0               B        ??ProcToggleRS_Action_1
    595             }
    596             else if (*UpOut)
   \                     ??ProcToggleRS_Action_0:
   \   00000010   085E               LDRSH    R0,[R1, R0]
   \   00000012   0028               CMP      R0,#+0
   \   00000014   01D0               BEQ      ??ProcToggleRS_Action_1
    597             {
    598               Proc->Out=0;
   \   00000016   1800               MOVS     R0,R3
   \   00000018   5082               STRH     R0,[R2, #+18]
    599             }
    600             
    601          
    602               
    603          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcToggleRS_Action_1:
   \   0000001A   08BC               POP      {R3}
   \   0000001C   01BC               POP      {R0}
   \   0000001E   0047               BX       R0               ;; return
    604          
    605          
    606          
    607          
    608          //*-----------------------------------------------------------------------------
    609          //* Nazwa funkcji :    ProcToggleT_Action
    610          //* Funkcja procedury "Przerzutnik typu T"
    611          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    612          void ProcToggleT_Action(short int *PrvOut, _Procedure *Proc) 
    613          {  
   \                     ProcToggleT_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    614             if ((*PrvOut) && (Proc->LastIn==0) && (Proc->Out==0))
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   825E               LDRSH    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   09D0               BEQ      ??ProcToggleT_Action_0
   \   0000000A   0A7C               LDRB     R2,[R1, #+16]
   \   0000000C   002A               CMP      R2,#+0
   \   0000000E   06D1               BNE      ??ProcToggleT_Action_0
   \   00000010   1222               MOVS     R2,#+18
   \   00000012   8A5E               LDRSH    R2,[R1, R2]
   \   00000014   002A               CMP      R2,#+0
   \   00000016   02D1               BNE      ??ProcToggleT_Action_0
    615             {
    616               Proc->Out=1;
   \   00000018   0122               MOVS     R2,#+1
   \   0000001A   4A82               STRH     R2,[R1, #+18]
   \   0000001C   0CE0               B        ??ProcToggleT_Action_1
    617             }
    618             else if ((*PrvOut) && (Proc->LastIn==0) && (Proc->Out==1))
   \                     ??ProcToggleT_Action_0:
   \   0000001E   0022               MOVS     R2,#+0
   \   00000020   825E               LDRSH    R2,[R0, R2]
   \   00000022   002A               CMP      R2,#+0
   \   00000024   08D0               BEQ      ??ProcToggleT_Action_1
   \   00000026   0A7C               LDRB     R2,[R1, #+16]
   \   00000028   002A               CMP      R2,#+0
   \   0000002A   05D1               BNE      ??ProcToggleT_Action_1
   \   0000002C   1222               MOVS     R2,#+18
   \   0000002E   8A5E               LDRSH    R2,[R1, R2]
   \   00000030   012A               CMP      R2,#+1
   \   00000032   01D1               BNE      ??ProcToggleT_Action_1
    619             {
    620               Proc->Out=0;
   \   00000034   0022               MOVS     R2,#+0
   \   00000036   4A82               STRH     R2,[R1, #+18]
    621             }
    622             
    623             Proc->LastIn=*PrvOut;
   \                     ??ProcToggleT_Action_1:
   \   00000038   0088               LDRH     R0,[R0, #+0]
   \   0000003A   0874               STRB     R0,[R1, #+16]
    624                 
    625          
    626          
    627          }//_______________________ Koniec funkcji__ ____________________________
   \   0000003C   08BC               POP      {R3}
   \   0000003E   01BC               POP      {R0}
   \   00000040   0047               BX       R0               ;; return
    628          
    629          
    630          //*-----------------------------------------------------------------------------
    631          //* Nazwa funkcji :    ProcTLI1_Action
    632          //* Funkcja procedury "Procedura impulsu jednocyklowego
    633          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    634          void ProcTLI1_Action(short int *PrvOut, _Procedure *Proc) 
    635          {  
   \                     ProcTLI1_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    636             if ((*PrvOut) && (Proc->LastIn==0))
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   825E               LDRSH    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   05D0               BEQ      ??ProcTLI1_Action_0
   \   0000000A   0A7C               LDRB     R2,[R1, #+16]
   \   0000000C   531E               SUBS     R3,R2,#+1
   \   0000000E   9B41               SBCS     R3,R3,R3
   \   00000010   DB0F               LSRS     R3,R3,#+31
   \   00000012   4B82               STRH     R3,[R1, #+18]
   \   00000014   00E0               B        ??ProcTLI1_Action_1
    637             {
    638               Proc->Out=1;
    639             }
    640             else
    641             {
    642               Proc->Out=0;
   \                     ??ProcTLI1_Action_0:
   \   00000016   4A82               STRH     R2,[R1, #+18]
    643             }
    644             
    645             Proc->LastIn=*PrvOut;
   \                     ??ProcTLI1_Action_1:
   \   00000018   0088               LDRH     R0,[R0, #+0]
   \   0000001A   0874               STRB     R0,[R1, #+16]
    646                 
    647          
    648          
    649          }//_______________________ Koniec funkcji__ ____________________________
   \   0000001C   08BC               POP      {R3}
   \   0000001E   01BC               POP      {R0}
   \   00000020   0047               BX       R0               ;; return
    650          
    651          
    652          
    653          
    654          //*-----------------------------------------------------------------------------
    655          //* Nazwa funkcji :    ProcLim_Action
    656          //* Funkcja procedury "Porównanie wartoœci. Je¿eli 1>2 q=1"
    657          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    658          void ProcLim_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    659          {  
   \                     ProcLim_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    660             if ((*PrvOut)>(*UpOut))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C95E               LDRSH    R1,[R1, R3]
   \   00000006   C05E               LDRSH    R0,[R0, R3]
   \   00000008   8142               CMP      R1,R0
   \   0000000A   02DA               BGE      ??ProcLim_Action_0
    661             {
    662               Proc->Out=1;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   5082               STRH     R0,[R2, #+18]
   \   00000010   01E0               B        ??ProcLim_Action_1
    663             }
    664             else
    665             {
    666               Proc->Out=0;
   \                     ??ProcLim_Action_0:
   \   00000012   1800               MOVS     R0,R3
   \   00000014   5082               STRH     R0,[R2, #+18]
    667             }
    668               
    669          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcLim_Action_1:
   \   00000016   08BC               POP      {R3}
   \   00000018   01BC               POP      {R0}
   \   0000001A   0047               BX       R0               ;; return
    670          
    671          
    672          
    673          
    674          //*-----------------------------------------------------------------------------
    675          //* Nazwa funkcji :    ProcEven_Action
    676          //* Funkcja procedury "Porównanie wartoœci. Je¿eli 1=2 q=1"
    677          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    678          void ProcEven_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    679          {  
   \                     ProcEven_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    680             if ((*PrvOut)==(*UpOut))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C05E               LDRSH    R0,[R0, R3]
   \   00000006   C95E               LDRSH    R1,[R1, R3]
   \   00000008   8842               CMP      R0,R1
   \   0000000A   02D1               BNE      ??ProcEven_Action_0
    681             {
    682               Proc->Out=1;
   \   0000000C   0120               MOVS     R0,#+1
   \   0000000E   5082               STRH     R0,[R2, #+18]
   \   00000010   01E0               B        ??ProcEven_Action_1
    683             }
    684             else
    685             {
    686               Proc->Out=0;
   \                     ??ProcEven_Action_0:
   \   00000012   1800               MOVS     R0,R3
   \   00000014   5082               STRH     R0,[R2, #+18]
    687             }
    688             
    689          
    690               
    691          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcEven_Action_1:
   \   00000016   08BC               POP      {R3}
   \   00000018   01BC               POP      {R0}
   \   0000001A   0047               BX       R0               ;; return
    692          
    693          
    694          
    695          
    696          //*-----------------------------------------------------------------------------
    697          //* Nazwa funkcji :    ProcPlus_Action
    698          //* Funkcja procedury "Plus"
    699          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    700          void ProcPlus_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    701          {  
    702               Proc->Out=(*PrvOut)+(*UpOut);  
   \                     ProcPlus_Action:
   \   00000000   0023               MOVS     R3,#+0
   \   00000002   C05E               LDRSH    R0,[R0, R3]
   \   00000004   C95E               LDRSH    R1,[R1, R3]
   \   00000006   4018               ADDS     R0,R0,R1
   \   00000008   5082               STRH     R0,[R2, #+18]
    703          }//_______________________ Koniec funkcji__ ____________________________
   \   0000000A   7047               BX       LR               ;; return
    704          
    705          
    706          
    707          //*-----------------------------------------------------------------------------
    708          //* Nazwa funkcji :    ProcPlus_Action
    709          //* Funkcja procedury "Plus"
    710          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    711          void ProcMinus_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    712          {  
    713               Proc->Out=(*PrvOut)-(*UpOut);  
   \                     ProcMinus_Action:
   \   00000000   0023               MOVS     R3,#+0
   \   00000002   C05E               LDRSH    R0,[R0, R3]
   \   00000004   C95E               LDRSH    R1,[R1, R3]
   \   00000006   401A               SUBS     R0,R0,R1
   \   00000008   5082               STRH     R0,[R2, #+18]
    714          }//_______________________ Koniec funkcji__ ____________________________
   \   0000000A   7047               BX       LR               ;; return
    715          
    716          
    717          //*-----------------------------------------------------------------------------
    718          //* Nazwa funkcji :    ProcPlus_Action
    719          //* Funkcja procedury "Plus"
    720          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    721          void ProcMul_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    722          {    
   \                     ProcMul_Action:
   \   00000000   10B5               PUSH     {R4,LR}
   \   00000002   1400               MOVS     R4,R2
    723               int odp;
    724               odp=(*PrvOut)*(*UpOut)/10; 
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   805E               LDRSH    R0,[R0, R2]
   \   00000008   895E               LDRSH    R1,[R1, R2]
   \   0000000A   4843               MULS     R0,R1,R0
   \   0000000C   0A21               MOVS     R1,#+10
   \   0000000E   ........           BL       __aeabi_idivmod
    725               if (odp>30000)
   \   00000012   0749               LDR      R1,??ProcMul_Action_0  ;; 0x7531
   \   00000014   8842               CMP      R0,R1
   \   00000016   07DB               BLT      ??ProcMul_Action_1
    726               {
    727                  if (odp>0) Proc->Out=30000; else Proc->Out=-30000;
   \   00000018   0128               CMP      R0,#+1
   \   0000001A   02DB               BLT      ??ProcMul_Action_2
   \   0000001C   481E               SUBS     R0,R1,#+1
   \   0000001E   6082               STRH     R0,[R4, #+18]
   \   00000020   03E0               B        ??ProcMul_Action_3
   \                     ??ProcMul_Action_2:
   \   00000022   0448               LDR      R0,??ProcMul_Action_0+0x4  ;; 0xffff8ad0
   \   00000024   6082               STRH     R0,[R4, #+18]
   \   00000026   00E0               B        ??ProcMul_Action_3
    728               }else{
    729                  Proc->Out=odp; 
   \                     ??ProcMul_Action_1:
   \   00000028   6082               STRH     R0,[R4, #+18]
    730               }
    731          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcMul_Action_3:
   \   0000002A   10BC               POP      {R4}
   \   0000002C   01BC               POP      {R0}
   \   0000002E   0047               BX       R0               ;; return
   \                     ??ProcMul_Action_0:
   \   00000030   31750000           DC32     0x7531
   \   00000034   D08AFFFF           DC32     0xffff8ad0
    732          
    733          
    734          //*-----------------------------------------------------------------------------
    735          //* Nazwa funkcji :    ProcPlus_Action
    736          //* Funkcja procedury "Plus"
    737          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    738          void ProcDiv_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    739          {  
   \                     ProcDiv_Action:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0500               MOVS     R5,R0
   \   00000004   0E00               MOVS     R6,R1
   \   00000006   1700               MOVS     R7,R2
    740               if ((*UpOut)==0)
   \   00000008   0020               MOVS     R0,#+0
   \   0000000A   305E               LDRSH    R0,[R6, R0]
   \   0000000C   0028               CMP      R0,#+0
   \   0000000E   08D1               BNE      ??ProcDiv_Action_0
    741               {
    742                 if ((*PrvOut)>0) Proc->Out=30000; else Proc->Out=-30000;
   \   00000010   285E               LDRSH    R0,[R5, R0]
   \   00000012   0128               CMP      R0,#+1
   \   00000014   02DB               BLT      ??ProcDiv_Action_1
   \   00000016   1748               LDR      R0,??ProcDiv_Action_2  ;; 0x7530
   \   00000018   7882               STRH     R0,[R7, #+18]
   \   0000001A   27E0               B        ??ProcDiv_Action_3
   \                     ??ProcDiv_Action_1:
   \   0000001C   1648               LDR      R0,??ProcDiv_Action_2+0x4  ;; 0xffff8ad0
   \   0000001E   7882               STRH     R0,[R7, #+18]
   \   00000020   24E0               B        ??ProcDiv_Action_3
    743               }else{
    744                
    745                Proc->Out=((*PrvOut)*10)/(*UpOut); 
   \                     ??ProcDiv_Action_0:
   \   00000022   0020               MOVS     R0,#+0
   \   00000024   285E               LDRSH    R0,[R5, R0]
   \   00000026   0A21               MOVS     R1,#+10
   \   00000028   4843               MULS     R0,R1,R0
   \   0000002A   0021               MOVS     R1,#+0
   \   0000002C   715E               LDRSH    R1,[R6, R1]
   \   0000002E   ........           BL       __aeabi_idivmod
   \   00000032   7882               STRH     R0,[R7, #+18]
    746                if ( (((*PrvOut)*100)/(*UpOut))>((((*PrvOut)*10)/(*UpOut))*10)+5) Proc->Out++;
   \   00000034   0020               MOVS     R0,#+0
   \   00000036   285E               LDRSH    R0,[R5, R0]
   \   00000038   6421               MOVS     R1,#+100
   \   0000003A   4843               MULS     R0,R1,R0
   \   0000003C   0021               MOVS     R1,#+0
   \   0000003E   715E               LDRSH    R1,[R6, R1]
   \   00000040   ........           BL       __aeabi_idivmod
   \   00000044   0400               MOVS     R4,R0
   \   00000046   0020               MOVS     R0,#+0
   \   00000048   285E               LDRSH    R0,[R5, R0]
   \   0000004A   0A21               MOVS     R1,#+10
   \   0000004C   4843               MULS     R0,R1,R0
   \   0000004E   0021               MOVS     R1,#+0
   \   00000050   715E               LDRSH    R1,[R6, R1]
   \   00000052   ........           BL       __aeabi_idivmod
   \   00000056   0100               MOVS     R1,R0
   \   00000058   0A20               MOVS     R0,#+10
   \   0000005A   4143               MULS     R1,R0,R1
   \   0000005C   491D               ADDS     R1,R1,#+5
   \   0000005E   2000               MOVS     R0,R4
   \   00000060   8142               CMP      R1,R0
   \   00000062   03DA               BGE      ??ProcDiv_Action_3
   \   00000064   1220               MOVS     R0,#+18
   \   00000066   385E               LDRSH    R0,[R7, R0]
   \   00000068   401C               ADDS     R0,R0,#+1
   \   0000006A   7882               STRH     R0,[R7, #+18]
    747               }
    748          }//_______________________ Koniec funkcji__ ____________________________
   \                     ??ProcDiv_Action_3:
   \   0000006C   F8BC               POP      {R3-R7}
   \   0000006E   01BC               POP      {R0}
   \   00000070   0047               BX       R0               ;; return
   \   00000072   C046               Nop      
   \                     ??ProcDiv_Action_2:
   \   00000074   30750000           DC32     0x7530
   \   00000078   D08AFFFF           DC32     0xffff8ad0
    749          
    750          
    751          
    752          
    753          
    754          //*-----------------------------------------------------------------------------
    755          //* Nazwa funkcji :    ProcConect_Action
    756          //* Funkcja procedury "Przeniesienie stanu w prawo"
    757          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    758          void ProcConect_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    759          {  
    760                Proc->Out=*PrvOut;  
   \                     ProcConect_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    761            
    762          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    763          
    764          
    765          
    766          //*-----------------------------------------------------------------------------
    767          //* Nazwa funkcji :    ProcDown_Action
    768          //* Funkcja procedury "Przeniesienie stanu w dó³"
    769          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    770          void ProcDown_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    771          {  
    772                Proc->Out=*PrvOut;  
   \                     ProcDown_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    773          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    774          
    775          
    776          
    777          //*-----------------------------------------------------------------------------
    778          //* Nazwa funkcji :    ProcDownRight_Action
    779          //* Funkcja procedury "Przeniesienie stanu w dó³ i prawo"
    780          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    781          void ProcDownRight_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    782          {  
    783                Proc->Out=*PrvOut;
   \                     ProcDownRight_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    784          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    785          
    786          
    787          
    788          
    789          
    790          //*-----------------------------------------------------------------------------
    791          //* Nazwa funkcji :    ProcUpToRight_Action
    792          //* Funkcja procedury "Przeniesienie stanu z góry w prawo"
    793          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    794          void ProcUpToRight_Action(short int *PrvUpOut, _Procedure *Proc) 
    795          {  
    796                Proc->Out=*PrvUpOut;
   \                     ProcUpToRight_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    797          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    798          
    799          
    800          
    801          //*-----------------------------------------------------------------------------
    802          //* Nazwa funkcji :    ProcUpToRightDown_Action
    803          //* Funkcja procedury "Przeniesienie stanu z góry w prawo i dó³"
    804          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    805          void ProcUpToRightDown_Action(short int *PrvUpOut, _Procedure *Proc) 
    806          {  
    807                Proc->Out=*PrvUpOut;
   \                     ProcUpToRightDown_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   4882               STRH     R0,[R1, #+18]
    808          }//_______________________ Koniec funkcji__ ____________________________
   \   00000004   7047               BX       LR               ;; return
    809          
    810          
    811          //*-----------------------------------------------------------------------------
    812          //* Nazwa funkcji :    ProcSetScn
    813          //* Funkcja procedury "Ustaw scenê"
    814          //*-----------------------------------------------------------------------------
    815          char LastScene=0;

   \                                 In section Debug.txt, align 4, keep-with-next
    816          void ProcSetScn_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    817          {  
   \                     ProcSetScn_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    818               
    819            
    820               if ((*PrvOut==1) && (Proc->Out==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   012B               CMP      R3,#+1
   \   00000008   1AD1               BNE      ??ProcSetScn_Action_0
   \   0000000A   1223               MOVS     R3,#+18
   \   0000000C   CB5E               LDRSH    R3,[R1, R3]
   \   0000000E   002B               CMP      R3,#+0
   \   00000010   16D1               BNE      ??ProcSetScn_Action_0
    821               {  
    822                  //if (Proc->Tag.NrScene>NumberScene) Proc->Tag.NrScene=NumberScene;
    823                 if (Proc->Nr==0)  //je¿eli on/off scen
   \   00000012   0123               MOVS     R3,#+1
   \   00000014   CB56               LDRSB    R3,[R1, R3]
   \   00000016   002B               CMP      R3,#+0
   \   00000018   0FD1               BNE      ??ProcSetScn_Action_1
    824                 {
    825                   if (LastScene)
   \   0000001A   0C4B               LDR      R3,??ProcSetScn_Action_2  ;; Trap
   \   0000001C   5C7A               LDRB     R4,[R3, #+9]
   \   0000001E   002C               CMP      R4,#+0
   \   00000020   04D0               BEQ      ??ProcSetScn_Action_3
    826                   {
    827                      MainStg->SceneNr=LastScene;
   \   00000022   0B4D               LDR      R5,??ProcSetScn_Action_2+0x4  ;; 0x6ea
   \   00000024   5455               STRB     R4,[R2, R5]
    828                      LastScene=0;
   \   00000026   0022               MOVS     R2,#+0
   \   00000028   5A72               STRB     R2,[R3, #+9]
   \   0000002A   09E0               B        ??ProcSetScn_Action_0
    829                   }else{ 
    830                      LastScene=MainStg->SceneNr;
   \                     ??ProcSetScn_Action_3:
   \   0000002C   084C               LDR      R4,??ProcSetScn_Action_2+0x4  ;; 0x6ea
   \   0000002E   1219               ADDS     R2,R2,R4
   \   00000030   1478               LDRB     R4,[R2, #+0]
   \   00000032   5C72               STRB     R4,[R3, #+9]
    831                      MainStg->SceneNr=0;
   \   00000034   0023               MOVS     R3,#+0
   \   00000036   1370               STRB     R3,[R2, #+0]
   \   00000038   02E0               B        ??ProcSetScn_Action_0
    832                   }
    833                   
    834                 }else{
    835                  MainStg->SceneNr=Proc->Nr;
   \                     ??ProcSetScn_Action_1:
   \   0000003A   054B               LDR      R3,??ProcSetScn_Action_2+0x4  ;; 0x6ea
   \   0000003C   4C78               LDRB     R4,[R1, #+1]
   \   0000003E   D454               STRB     R4,[R2, R3]
    836                 }
    837               }
    838          
    839               
    840               Proc->Out=*PrvOut;
   \                     ??ProcSetScn_Action_0:
   \   00000040   0088               LDRH     R0,[R0, #+0]
   \   00000042   4882               STRH     R0,[R1, #+18]
    841          
    842          }//_______________________ Koniec funkcji__ ____________________________
   \   00000044   38BC               POP      {R3-R5}
   \   00000046   01BC               POP      {R0}
   \   00000048   0047               BX       R0               ;; return
   \   0000004A   C046               Nop      
   \                     ??ProcSetScn_Action_2:
   \   0000004C   ........           DC32     Trap
   \   00000050   EA060000           DC32     0x6ea
    843          
    844          
    845          
    846          
    847          //*-----------------------------------------------------------------------------
    848          //* Nazwa funkcji :    ProcInc_Action
    849          //* Funkcja procedury "Inkrementuj scenê"
    850          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    851          void ProcInc_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    852          {  
   \                     ProcInc_Action:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
    853               if ((*PrvOut) && (Proc->LastIn==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   002B               CMP      R3,#+0
   \   00000008   0DD0               BEQ      ??ProcInc_Action_0
   \   0000000A   0B7C               LDRB     R3,[R1, #+16]
   \   0000000C   002B               CMP      R3,#+0
   \   0000000E   0AD1               BNE      ??ProcInc_Action_0
    854               {  
    855                  
    856                    if (MainStg->SceneNr<NumberScene) MainStg->SceneNr++;
   \   00000010   084B               LDR      R3,??ProcInc_Action_1  ;; 0x6ea
   \   00000012   D218               ADDS     R2,R2,R3
   \   00000014   084B               LDR      R3,??ProcInc_Action_1+0x4  ;; Trap
   \   00000016   1478               LDRB     R4,[R2, #+0]
   \   00000018   1D7A               LDRB     R5,[R3, #+8]
   \   0000001A   AC42               CMP      R4,R5
   \   0000001C   01D2               BCS      ??ProcInc_Action_2
   \   0000001E   641C               ADDS     R4,R4,#+1
   \   00000020   1470               STRB     R4,[R2, #+0]
    857                    LastScene=0;
   \                     ??ProcInc_Action_2:
   \   00000022   0022               MOVS     R2,#+0
   \   00000024   5A72               STRB     R2,[R3, #+9]
    858               }
    859               
    860          
    861               Proc->LastIn=*PrvOut;
   \                     ??ProcInc_Action_0:
   \   00000026   0288               LDRH     R2,[R0, #+0]
   \   00000028   0A74               STRB     R2,[R1, #+16]
    862               Proc->Out=*PrvOut;
   \   0000002A   0088               LDRH     R0,[R0, #+0]
   \   0000002C   4882               STRH     R0,[R1, #+18]
    863           
    864          }//_______________________ Koniec funkcji__ ____________________________
   \   0000002E   38BC               POP      {R3-R5}
   \   00000030   01BC               POP      {R0}
   \   00000032   0047               BX       R0               ;; return
   \                     ??ProcInc_Action_1:
   \   00000034   EA060000           DC32     0x6ea
   \   00000038   ........           DC32     Trap
    865          
    866          
    867          //*-----------------------------------------------------------------------------
    868          //* Nazwa funkcji :    ProcIncDec_Action
    869          //* Funkcja procedury "Dekrementuj scenê"
    870          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    871          void ProcDec_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    872          {  
   \                     ProcDec_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    873               if ((*PrvOut) && (Proc->LastIn==0))
   \   00000002   0023               MOVS     R3,#+0
   \   00000004   C35E               LDRSH    R3,[R0, R3]
   \   00000006   002B               CMP      R3,#+0
   \   00000008   0CD0               BEQ      ??ProcDec_Action_0
   \   0000000A   0B7C               LDRB     R3,[R1, #+16]
   \   0000000C   002B               CMP      R3,#+0
   \   0000000E   09D1               BNE      ??ProcDec_Action_0
    874               {  
    875                  
    876                  if (MainStg->SceneNr>0) MainStg->SceneNr--;
   \   00000010   084B               LDR      R3,??ProcDec_Action_1  ;; 0x6ea
   \   00000012   D218               ADDS     R2,R2,R3
   \   00000014   1378               LDRB     R3,[R2, #+0]
   \   00000016   002B               CMP      R3,#+0
   \   00000018   01D0               BEQ      ??ProcDec_Action_2
   \   0000001A   5B1E               SUBS     R3,R3,#+1
   \   0000001C   1370               STRB     R3,[R2, #+0]
    877                  LastScene=0;
   \                     ??ProcDec_Action_2:
   \   0000001E   064A               LDR      R2,??ProcDec_Action_1+0x4  ;; Trap + 9
   \   00000020   0023               MOVS     R3,#+0
   \   00000022   1370               STRB     R3,[R2, #+0]
    878               }
    879               
    880          
    881               Proc->LastIn=*PrvOut;
   \                     ??ProcDec_Action_0:
   \   00000024   0288               LDRH     R2,[R0, #+0]
   \   00000026   0A74               STRB     R2,[R1, #+16]
    882               Proc->Out=*PrvOut;
   \   00000028   0088               LDRH     R0,[R0, #+0]
   \   0000002A   4882               STRH     R0,[R1, #+18]
    883          
    884          }//_______________________ Koniec funkcji__ ____________________________
   \   0000002C   08BC               POP      {R3}
   \   0000002E   01BC               POP      {R0}
   \   00000030   0047               BX       R0               ;; return
   \   00000032   C046               Nop      
   \                     ??ProcDec_Action_1:
   \   00000034   EA060000           DC32     0x6ea
   \   00000038   ........           DC32     Trap + 9
    885          
    886          
    887          
    888          //*-----------------------------------------------------------------------------
    889          //* Nazwa funkcji :    ProcSPK_Action
    890          //* Funkcja procedury "Dekrementuj scenê"
    891          //*-----------------------------------------------------------------------------
    892          extern     char Speaker[SPK_Amount];                                                   //sygna³ dŸwiêkowy

   \                                 In section Debug.txt, align 4, keep-with-next
    893          void ProcSPK_Action(short int *PrvOut, _Procedure *Proc) 
    894          {  
   \                     ProcSPK_Action:
   \   00000000   70B5               PUSH     {R4-R6,LR}
   \   00000002   0200               MOVS     R2,R0
   \   00000004   0B00               MOVS     R3,R1
    895               if ((*PrvOut) && (Proc->Out==0))
   \   00000006   0020               MOVS     R0,#+0
   \   00000008   105E               LDRSH    R0,[R2, R0]
   \   0000000A   0028               CMP      R0,#+0
   \   0000000C   21D0               BEQ      ??ProcSPK_Action_0
   \   0000000E   1220               MOVS     R0,#+18
   \   00000010   185E               LDRSH    R0,[R3, R0]
   \   00000012   0028               CMP      R0,#+0
   \   00000014   1DD1               BNE      ??ProcSPK_Action_0
    896               {  
    897                  for (char i=0; i<SPK_Amount; i++) Speaker[i]=0;
   \   00000016   0100               MOVS     R1,R0
   \   00000018   1E4D               LDR      R5,??ProcSPK_Action_1  ;; Speaker
   \   0000001A   0600               MOVS     R6,R0
   \   0000001C   03E0               B        ??ProcSPK_Action_2
   \                     ??ProcSPK_Action_3:
   \   0000001E   2E55               STRB     R6,[R5, R4]
   \   00000020   491C               ADDS     R1,R1,#+1
   \   00000022   0906               LSLS     R1,R1,#+24
   \   00000024   090E               LSRS     R1,R1,#+24
   \                     ??ProcSPK_Action_2:
   \   00000026   0C00               MOVS     R4,R1
   \   00000028   042C               CMP      R4,#+4
   \   0000002A   F8D3               BCC      ??ProcSPK_Action_3
    898                  Speaker[Proc->Tag.SpeakerType]=1;
   \   0000002C   187A               LDRB     R0,[R3, #+8]
   \   0000002E   1949               LDR      R1,??ProcSPK_Action_1  ;; Speaker
   \   00000030   0124               MOVS     R4,#+1
   \   00000032   0C54               STRB     R4,[R1, R0]
    899                  if (Proc->Tag.SpeakerType==0) 
   \   00000034   187A               LDRB     R0,[R3, #+8]
   \   00000036   0028               CMP      R0,#+0
   \   00000038   1AD1               BNE      ??ProcSPK_Action_4
    900                  {
    901                         ButtonBipCounter=g_counter+300000;
   \   0000003A   174C               LDR      R4,??ProcSPK_Action_1+0x4  ;; ButtonBipCounter
   \   0000003C   1748               LDR      R0,??ProcSPK_Action_1+0x8  ;; g_counter
   \   0000003E   0068               LDR      R0,[R0, #+0]
   \   00000040   1749               LDR      R1,??ProcSPK_Action_1+0xC  ;; 0x493e0
   \   00000042   4018               ADDS     R0,R0,R1
   \   00000044   C117               ASRS     R1,R0,#+31
   \   00000046   03C4               STM      R4!,{R0,R1}
    902                         AT91C_BASE_PIOA->PIO_SODR =SpeakerPin;  
                                                           ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   00000048   1648               LDR      R0,??ProcSPK_Action_1+0x10  ;; 0xfffff430
   \   0000004A   8021               MOVS     R1,#+128
   \   0000004C   0906               LSLS     R1,R1,#+24       ;; #-2147483648
   \   0000004E   0160               STR      R1,[R0, #+0]
   \   00000050   0EE0               B        ??ProcSPK_Action_4
    903                  }
    904               }else if (*PrvOut==0) {
   \                     ??ProcSPK_Action_0:
   \   00000052   0020               MOVS     R0,#+0
   \   00000054   105E               LDRSH    R0,[R2, R0]
   \   00000056   0028               CMP      R0,#+0
   \   00000058   0AD1               BNE      ??ProcSPK_Action_4
    905                 for (char i=0; i<SPK_Amount; i++) Speaker[i]=0;
   \   0000005A   0100               MOVS     R1,R0
   \   0000005C   0D4D               LDR      R5,??ProcSPK_Action_1  ;; Speaker
   \   0000005E   0600               MOVS     R6,R0
   \   00000060   03E0               B        ??ProcSPK_Action_5
   \                     ??ProcSPK_Action_6:
   \   00000062   2E55               STRB     R6,[R5, R4]
   \   00000064   491C               ADDS     R1,R1,#+1
   \   00000066   0906               LSLS     R1,R1,#+24
   \   00000068   090E               LSRS     R1,R1,#+24
   \                     ??ProcSPK_Action_5:
   \   0000006A   0C00               MOVS     R4,R1
   \   0000006C   042C               CMP      R4,#+4
   \   0000006E   F8D3               BCC      ??ProcSPK_Action_6
    906               }
    907               if ((*PrvOut==0) && (Proc->Out==1))
   \                     ??ProcSPK_Action_4:
   \   00000070   0020               MOVS     R0,#+0
   \   00000072   105E               LDRSH    R0,[R2, R0]
   \   00000074   0028               CMP      R0,#+0
   \   00000076   07D1               BNE      ??ProcSPK_Action_7
   \   00000078   1220               MOVS     R0,#+18
   \   0000007A   185E               LDRSH    R0,[R3, R0]
   \   0000007C   0128               CMP      R0,#+1
   \   0000007E   03D1               BNE      ??ProcSPK_Action_7
    908               {  
    909                  AT91C_BASE_PIOA->PIO_CODR =SpeakerPin;  
                                                    ^
Warning[Pe068]: integer conversion resulted in a change of sign
   \   00000080   0948               LDR      R0,??ProcSPK_Action_1+0x14  ;; 0xfffff434
   \   00000082   8021               MOVS     R1,#+128
   \   00000084   0906               LSLS     R1,R1,#+24       ;; #-2147483648
   \   00000086   0160               STR      R1,[R0, #+0]
    910               }
    911               Proc->Out=*PrvOut;
   \                     ??ProcSPK_Action_7:
   \   00000088   1088               LDRH     R0,[R2, #+0]
   \   0000008A   5882               STRH     R0,[R3, #+18]
    912          }//_______________________ Koniec funkcji__ ____________________________
   \   0000008C   70BC               POP      {R4-R6}
   \   0000008E   01BC               POP      {R0}
   \   00000090   0047               BX       R0               ;; return
   \   00000092   C046               Nop      
   \                     ??ProcSPK_Action_1:
   \   00000094   ........           DC32     Speaker
   \   00000098   ........           DC32     ButtonBipCounter
   \   0000009C   ........           DC32     g_counter
   \   000000A0   E0930400           DC32     0x493e0
   \   000000A4   30F4FFFF           DC32     0xfffff430
   \   000000A8   34F4FFFF           DC32     0xfffff434
    913          
    914          
    915          
    916          
    917          
    918          //*-----------------------------------------------------------------------------
    919          //* Nazwa funkcji :    ProcSumL_Action
    920          //* Funkcja procedury "Sumy logicznej"
    921          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    922          void ProcSumL_Action(short int *PrvOut, short int *UpOut, _Procedure *Proc) 
    923          {  
    924            Proc->Out=*PrvOut | *UpOut;   
   \                     ProcSumL_Action:
   \   00000000   0088               LDRH     R0,[R0, #+0]
   \   00000002   0988               LDRH     R1,[R1, #+0]
   \   00000004   0143               ORRS     R1,R1,R0
   \   00000006   5182               STRH     R1,[R2, #+18]
    925          }//_______________________ Koniec funkcji__ ____________________________
   \   00000008   7047               BX       LR               ;; return
    926          
    927          
    928          
    929          //*-----------------------------------------------------------------------------
    930          //* Nazwa funkcji :    ProcIncDec_Action
    931          //* Funkcja procedury "Inkrementuj scenê"
    932          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
    933          void ProcTimerSet_Action(short int *PrvOut, _Procedure *Proc, _MainStage *MainStg) 
    934          {  
   \                     ProcTimerSet_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    935             if ((*PrvOut)==0)
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   825E               LDRSH    R2,[R0, R2]
   \   00000006   002A               CMP      R2,#+0
   \   00000008   01D1               BNE      ??ProcTimerSet_Action_0
    936             {
    937               Proc->Out=0;
   \   0000000A   4A82               STRH     R2,[R1, #+18]
   \   0000000C   14E0               B        ??ProcTimerSet_Action_1
    938             }else{
    939               if ((*PrvOut) && (Proc->LastIn==0))
   \                     ??ProcTimerSet_Action_0:
   \   0000000E   0022               MOVS     R2,#+0
   \   00000010   825E               LDRSH    R2,[R0, R2]
   \   00000012   002A               CMP      R2,#+0
   \   00000014   07D0               BEQ      ??ProcTimerSet_Action_2
   \   00000016   0A7C               LDRB     R2,[R1, #+16]
   \   00000018   002A               CMP      R2,#+0
   \   0000001A   04D1               BNE      ??ProcTimerSet_Action_2
    940               {  
    941                 Proc->Tag.CounterStartTime=g_seconds_counter; 
   \   0000001C   094A               LDR      R2,??ProcTimerSet_Action_3  ;; g_seconds_counter
   \   0000001E   1268               LDR      R2,[R2, #+0]
   \   00000020   CA60               STR      R2,[R1, #+12]
    942                 Proc->Out=0;
   \   00000022   0022               MOVS     R2,#+0
   \   00000024   4A82               STRH     R2,[R1, #+18]
    943               }
    944               
    945               if ((Proc->Tag.CounterStartTime+Proc->Tag.SetCounter)<g_seconds_counter)
   \                     ??ProcTimerSet_Action_2:
   \   00000026   CA68               LDR      R2,[R1, #+12]
   \   00000028   8B68               LDR      R3,[R1, #+8]
   \   0000002A   D218               ADDS     R2,R2,R3
   \   0000002C   054B               LDR      R3,??ProcTimerSet_Action_3  ;; g_seconds_counter
   \   0000002E   1B68               LDR      R3,[R3, #+0]
   \   00000030   9A42               CMP      R2,R3
   \   00000032   9241               SBCS     R2,R2,R2
   \   00000034   D20F               LSRS     R2,R2,#+31
   \   00000036   4A82               STRH     R2,[R1, #+18]
    946               {
    947                 Proc->Out=1;
    948               }else{
    949                 Proc->Out=0;
    950               }
    951             }   
    952             
    953             Proc->LastIn=*PrvOut;
   \                     ??ProcTimerSet_Action_1:
   \   00000038   0088               LDRH     R0,[R0, #+0]
   \   0000003A   0874               STRB     R0,[R1, #+16]
    954          }//_______________________ Koniec funkcji__ ____________________________
   \   0000003C   08BC               POP      {R3}
   \   0000003E   01BC               POP      {R0}
   \   00000040   0047               BX       R0               ;; return
   \   00000042   C046               Nop      
   \                     ??ProcTimerSet_Action_3:
   \   00000044   ........           DC32     g_seconds_counter
    955          
    956          
    957          
    958          
    959          
    960          
    961          //*-----------------------------------------------------------------------------
    962          //* Nazwa funkcji :    ProcClock_Action
    963          //* Funkcja procedury "Zegar"
    964          //*-----------------------------------------------------------------------------
    965          

   \                                 In section Debug.txt, align 4, keep-with-next
    966          void ProcClock_Action(short int *PrvOut, _Procedure *Proc) 
    967          {  
   \                     ProcClock_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    968             Proc->Out=0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   4A82               STRH     R2,[R1, #+18]
    969             if (*PrvOut)
   \   00000006   805E               LDRSH    R0,[R0, R2]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   31D0               BEQ      ??ProcClock_Action_0
    970             {
    971                if ((Proc->Tag.ClkPrcType==PrcMounth) && (Proc->Tag.ClkPrcVal==DateTime.Mounth))  Proc->Out=1; 
   \   0000000C   087A               LDRB     R0,[R1, #+8]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   06D1               BNE      ??ProcClock_Action_1
   \   00000012   487A               LDRB     R0,[R1, #+9]
   \   00000014   184A               LDR      R2,??ProcClock_Action_2  ;; DateTime + 1
   \   00000016   1278               LDRB     R2,[R2, #+0]
   \   00000018   9042               CMP      R0,R2
   \   0000001A   01D1               BNE      ??ProcClock_Action_1
   \   0000001C   0120               MOVS     R0,#+1
   \   0000001E   4882               STRH     R0,[R1, #+18]
    972                if ((Proc->Tag.ClkPrcType==PrcDay)    && (Proc->Tag.ClkPrcVal==DateTime.Day))     Proc->Out=1; 
   \                     ??ProcClock_Action_1:
   \   00000020   087A               LDRB     R0,[R1, #+8]
   \   00000022   0128               CMP      R0,#+1
   \   00000024   06D1               BNE      ??ProcClock_Action_3
   \   00000026   487A               LDRB     R0,[R1, #+9]
   \   00000028   144A               LDR      R2,??ProcClock_Action_2+0x4  ;; DateTime + 2
   \   0000002A   1278               LDRB     R2,[R2, #+0]
   \   0000002C   9042               CMP      R0,R2
   \   0000002E   01D1               BNE      ??ProcClock_Action_3
   \   00000030   0120               MOVS     R0,#+1
   \   00000032   4882               STRH     R0,[R1, #+18]
    973                if ((Proc->Tag.ClkPrcType==PrcHour)   && (Proc->Tag.ClkPrcVal==DateTime.Hour))    Proc->Out=1; 
   \                     ??ProcClock_Action_3:
   \   00000034   087A               LDRB     R0,[R1, #+8]
   \   00000036   0228               CMP      R0,#+2
   \   00000038   06D1               BNE      ??ProcClock_Action_4
   \   0000003A   487A               LDRB     R0,[R1, #+9]
   \   0000003C   104A               LDR      R2,??ProcClock_Action_2+0x8  ;; DateTime + 3
   \   0000003E   1278               LDRB     R2,[R2, #+0]
   \   00000040   9042               CMP      R0,R2
   \   00000042   01D1               BNE      ??ProcClock_Action_4
   \   00000044   0120               MOVS     R0,#+1
   \   00000046   4882               STRH     R0,[R1, #+18]
    974                if ((Proc->Tag.ClkPrcType==PrcMinute) && (Proc->Tag.ClkPrcVal==DateTime.Minute))  Proc->Out=1;  
   \                     ??ProcClock_Action_4:
   \   00000048   087A               LDRB     R0,[R1, #+8]
   \   0000004A   0328               CMP      R0,#+3
   \   0000004C   06D1               BNE      ??ProcClock_Action_5
   \   0000004E   487A               LDRB     R0,[R1, #+9]
   \   00000050   0C4A               LDR      R2,??ProcClock_Action_2+0xC  ;; DateTime + 4
   \   00000052   1278               LDRB     R2,[R2, #+0]
   \   00000054   9042               CMP      R0,R2
   \   00000056   01D1               BNE      ??ProcClock_Action_5
   \   00000058   0120               MOVS     R0,#+1
   \   0000005A   4882               STRH     R0,[R1, #+18]
    975                if ((Proc->Tag.ClkPrcType==PrcSecond) && (Proc->Tag.ClkPrcVal==DateTime.Second))  Proc->Out=1; 
   \                     ??ProcClock_Action_5:
   \   0000005C   087A               LDRB     R0,[R1, #+8]
   \   0000005E   0428               CMP      R0,#+4
   \   00000060   06D1               BNE      ??ProcClock_Action_0
   \   00000062   487A               LDRB     R0,[R1, #+9]
   \   00000064   084A               LDR      R2,??ProcClock_Action_2+0x10  ;; DateTime + 5
   \   00000066   1278               LDRB     R2,[R2, #+0]
   \   00000068   9042               CMP      R0,R2
   \   0000006A   01D1               BNE      ??ProcClock_Action_0
   \   0000006C   0120               MOVS     R0,#+1
   \   0000006E   4882               STRH     R0,[R1, #+18]
    976                        
    977          
    978             }
    979          
    980          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcClock_Action_0:
   \   00000070   08BC               POP      {R3}
   \   00000072   01BC               POP      {R0}
   \   00000074   0047               BX       R0               ;; return
   \   00000076   C046               Nop      
   \                     ??ProcClock_Action_2:
   \   00000078   ........           DC32     DateTime + 1
   \   0000007C   ........           DC32     DateTime + 2
   \   00000080   ........           DC32     DateTime + 3
   \   00000084   ........           DC32     DateTime + 4
   \   00000088   ........           DC32     DateTime + 5
    981          
    982          
    983          
    984          //*-----------------------------------------------------------------------------
    985          //* Nazwa funkcji :    ProcDay_Action
    986          //* Funkcja procedury "Dnia tygodnia"
    987          //*-----------------------------------------------------------------------------
    988          

   \                                 In section Debug.txt, align 4, keep-with-next
    989          void ProcDay_Action(short int *PrvOut, _Procedure *Proc) 
    990          {  
   \                     ProcDay_Action:
   \   00000000   01B5               PUSH     {R0,LR}
    991             Proc->Out=0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   4A82               STRH     R2,[R1, #+18]
    992             if (*PrvOut)
   \   00000006   805E               LDRSH    R0,[R0, R2]
   \   00000008   0028               CMP      R0,#+0
   \   0000000A   06D0               BEQ      ??ProcDay_Action_0
    993             {
    994                if (Proc->Tag.DayOfWeek==DateTime.DayOfWeek)  Proc->Out=1; 
   \   0000000C   087A               LDRB     R0,[R1, #+8]
   \   0000000E   044A               LDR      R2,??ProcDay_Action_1  ;; DateTime + 6
   \   00000010   1278               LDRB     R2,[R2, #+0]
   \   00000012   9042               CMP      R0,R2
   \   00000014   01D1               BNE      ??ProcDay_Action_0
   \   00000016   0120               MOVS     R0,#+1
   \   00000018   4882               STRH     R0,[R1, #+18]
    995          
    996             }
    997          }//_______________________ Koniec funkcji  ____________________________
   \                     ??ProcDay_Action_0:
   \   0000001A   08BC               POP      {R3}
   \   0000001C   01BC               POP      {R0}
   \   0000001E   0047               BX       R0               ;; return
   \                     ??ProcDay_Action_1:
   \   00000020   ........           DC32     DateTime + 6
    998          
    999          
   1000          
   1001          
   1002          
   1003          
   1004          
   1005          //*-----------------------------------------------------------------------------
   1006          //* Nazwa funkcji :    Program
   1007          //* Funkcja opóŸnienia
   1008          //*-----------------------------------------------------------------------------
   1009          volatile char Busy_program=0;
   1010          
   1011          char SceneNrLast=0;
   1012          char RealPrcLines=MaxPrcLines;
   1013          
   1014          int PtogTime=0;
   1015          unsigned long last_time;
   1016          

   \                                 In section Debug.txt, align 4, keep-with-next
   1017          void Program (_ProgramTab *ProgTab) 
   1018          { 
   \                     Program:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   82B0               SUB      SP,SP,#+8
   1019              static int MemCol=0;
   1020              static int MemRow=0;
   1021              int StartLineNr=0;
   \   00000004   0024               MOVS     R4,#+0
   \   00000006   2600               MOVS     R6,R4
   1022              int StartPrcInLine=0;
   \   00000008   0194               STR      R4,[SP, #+4]
   \   0000000A   CD4D               LDR      R5,??Program_1   ;; Trap
   \   0000000C   A87A               LDRB     R0,[R5, #+10]
   \   0000000E   0028               CMP      R0,#+0
   \   00000010   00D0               BEQ      .+4
   \   00000012   47E2               B        ??Program_2
   \   00000014   0120               MOVS     R0,#+1
   \   00000016   A872               STRB     R0,[R5, #+10]
   1023              
   1024              if (Busy_program==0)
   1025              {
   1026                Busy_program=1;
   1027              
   1028          
   1029             last_time=g_counter;
   \   00000018   CA48               LDR      R0,??Program_1+0x4  ;; g_counter
   \   0000001A   0068               LDR      R0,[R0, #+0]
   \   0000001C   A863               STR      R0,[R5, #+56]
   1030            
   1031          
   1032            
   1033            short int StPrvPrc; //stan poprzedniej procedury
   1034            short int StUpPrc; //stan procedury z linii wy¿ej, z tej samej kolumny dla sumy logicznej
   1035            
   1036            if ((Trap.Enable) && (Trap.Change))
   \   0000001E   2878               LDRB     R0,[R5, #+0]
   \   00000020   0028               CMP      R0,#+0
   \   00000022   07D0               BEQ      ??Program_3
   \   00000024   2879               LDRB     R0,[R5, #+4]
   \   00000026   0028               CMP      R0,#+0
   \   00000028   04D0               BEQ      ??Program_3
   1037                  {
   1038                    StartPrcInLine=MemCol;
   \   0000002A   E86B               LDR      R0,[R5, #+60]
   \   0000002C   0190               STR      R0,[SP, #+4]
   1039                    StartLineNr=MemRow;
   \   0000002E   2E6C               LDR      R6,[R5, #+64]
   1040                    Trap.Change=0;
   \   00000030   2000               MOVS     R0,R4
   \   00000032   2871               STRB     R0,[R5, #+4]
   1041                  }
   1042            
   1043             
   1044                
   1045                          
   1046                 
   1047                   
   1048            
   1049                 for (char NB=0; NB<NumberButton; NB++)
   \                     ??Program_3:
   \   00000034   2100               MOVS     R1,R4
   \   00000036   08E0               B        ??Program_4
   1050                 {
   1051                      MainStage.StageButtonExe[NB]=MainStage.StageButton[NB];  
   \                     ??Program_5:
   \   00000038   0A00               MOVS     R2,R1
   \   0000003A   C348               LDR      R0,??Program_1+0x8  ;; MainStage
   \   0000003C   8318               ADDS     R3,R0,R2
   \   0000003E   5033               ADDS     R3,R3,#+80
   \   00000040   805C               LDRB     R0,[R0, R2]
   \   00000042   1870               STRB     R0,[R3, #+0]
   1052                 }
   \   00000044   491C               ADDS     R1,R1,#+1
   \   00000046   0906               LSLS     R1,R1,#+24
   \   00000048   090E               LSRS     R1,R1,#+24
   \                     ??Program_4:
   \   0000004A   0800               MOVS     R0,R1
   \   0000004C   5028               CMP      R0,#+80
   \   0000004E   F3D3               BCC      ??Program_5
   1053            
   1054            
   1055            
   1056                for (int LineNr=StartLineNr; LineNr<RealPrcLines; LineNr++)
   \   00000050   00E0               B        ??Program_6
   \                     ??Program_7:
   \   00000052   761C               ADDS     R6,R6,#+1
   \                     ??Program_6:
   \   00000054   287B               LDRB     R0,[R5, #+12]
   \   00000056   8642               CMP      R6,R0
   \   00000058   00DB               BLT      .+4
   \   0000005A   E9E1               B        ??Program_8
   1057                {
   1058                  for (int PrcInLine=StartPrcInLine; PrcInLine<MaxPrcInLine; PrcInLine++)
   \   0000005C   019F               LDR      R7,[SP, #+4]
   \   0000005E   16E0               B        ??Program_9
   1059                  {
   1060                   
   1061                    
   1062          
   1063                    
   1064                    
   1065                    
   1066                   if ((Trap.Enable) &&  (Trap.Row==LineNr) && (Trap.Col==PrcInLine)) 
   1067                   {
   1068                     Trap.Activ=1; 
   1069                     MemCol=PrcInLine;
   1070                     MemRow=LineNr;
   1071                      
   1072                   }
   1073                   if ((Trap.Enable==0) || (Trap.Activ==0) )
   1074                   {
   1075          
   1076                     
   1077                   if (Trap.Enable==0)
   1078                   {
   1079                    MemCol=PrcInLine;
   1080                    MemRow=LineNr;
   1081                   }  
   1082                     
   1083                     
   1084                     if (ProgTab->Line[LineNr].Proc[PrcInLine].Type!=None)
   1085                     {
   1086                        if (PrcInLine==0)
   1087                        {
   1088                          StPrvPrc= 1;
   1089                        }else{
   1090                          StPrvPrc= (ProgTab->Line[LineNr].Proc[PrcInLine-1].Out);
   1091                        }
   1092                        
   1093                        
   1094          
   1095                        switch (ProgTab->Line[LineNr].Proc[PrcInLine].Type)
   1096                        {    
   1097                            case ProcConect     : ProcConect_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1098                            case ProcDown       : ProcDown_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1099                            case ProcDownRight  : ProcDownRight_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1100                            case ProcSumLogRight     : 
   1101                                                StUpPrc= 0;
   1102                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1103                                                ProcSumL_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1104                                                break;
   1105                            case ProcSumLogDown     : 
   1106                                                StUpPrc= 0;
   1107                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1108                                                ProcSumL_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1109                                                break;
   1110                            case ProcUpToRight     : 
   1111                                                StUpPrc= 0;
   1112                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1113                                                ProcUpToRight_Action(&StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1114                                                break;
   1115                                                
   1116                            case ProcUpToRightDown    : 
   1117                                                StUpPrc= 0;
   1118                                                if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1119                                                ProcUpToRightDown_Action(&StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); 
   1120                                                break;                    
   1121                                             
   1122                           
   1123                            
   1124                            case ProcNOT        : ProcNOT_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;         
   1125                            case ProcToggleRS   : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1126                                                  ProcToggleRS_Action(&StPrvPrc, &StUpPrc,  &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;    
   1127                            case ProcToggleT    : ProcToggleT_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;         
   1128                            case ProcTLI1       : ProcTLI1_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;         
   1129                            case ProcStI        : ProcStI_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1130                            case ProcStNI       : ProcStNI_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1131                            case ProcStQ        : ProcStQ_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1132                            case ProcStB        : ProcStB_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1133                            case ProcStS        : ProcStS_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1134                            case ProcWOUT       : ProcWOUT_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1135                            case ProcWOUTS      : ProcWOUTS_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]),&MainStage); break;
   1136                            case ProcWOUTR      : ProcWOUTR_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]),&MainStage); break;
   1137                            case ProcWOUTC      : ProcWOUTC_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]),&MainStage); break;
   1138                            case ProcSetScn     : ProcSetScn_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1139                            case ProcInc        : ProcInc_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;             
   1140                            case ProcDec        : ProcDec_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;             
   1141                            case ProcSPK        : ProcSPK_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break; 
   1142                            case ProcTimerSet   : ProcTimerSet_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1143                            case ProcClock      : ProcClock_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1144                            case ProcDay        : ProcDay_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1145                            case ProcGetReg     : ProcGetReg_Action(&(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1146                            case ProcSetReg     : ProcSetAnal_Action(&StPrvPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine]), &MainStage); break;
   1147                            case ProcConstAnal  : ProcConstAnal_Action(&(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1148                            case ProcLim        : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1149                                                  ProcLim_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1150                            case ProcEven       : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1151                                                  ProcEven_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1152                            case ProcPlus       : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1153                                                  ProcPlus_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1154                            case ProcMinus      : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1155                                                  ProcMinus_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1156                            case ProcMul        : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1157                                                  ProcMul_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1158                            case ProcDiv        : if (LineNr!=0) StUpPrc=(ProgTab->Line[LineNr-1].Proc[PrcInLine].Out);
   1159                                                  ProcDiv_Action(&StPrvPrc, &StUpPrc, &(ProgTab->Line[LineNr].Proc[PrcInLine])); break;
   1160          
   1161                            
   1162                        }
   1163                        
   1164                     }  
   1165                    
   1166                   
   1167                   
   1168                   
   1169                   
   1170                   
   1171                   if ((LineNr==RealPrcLines-1) && (PrcInLine==MaxPrcInLine-1))
   1172                    { 
   1173                    
   1174                        //ThermostatsExecute();
   1175          
   1176                          /* 
   1177                          for (char iNrQ=0; iNrQ<NumberNeurons; iNrQ++)
   1178                          {  
   1179                            for (char iNrReg=0; iNrReg<NumberReg; iNrReg++)
   1180                          {
   1181                            MainStage.StageQ[iNrQ].Value[iNrReg]=MainStage.StageQ_TMP[iNrQ].Value[iNrReg]; 
   1182                          }
   1183                          
   1184                          }
   1185                          */
   1186          
   1187                      for (char iNrReg=0; iNrReg<NumberReg; iNrReg++)
   1188                      {
   1189                        MainStage.StageI[0].Value[iNrReg]=MainStage.StageQ[0].Value[iNrReg]; 
   \                     ??Program_10:
   \   00000060   0A00               MOVS     R2,R1
   \   00000062   5200               LSLS     R2,R2,#+1
   \   00000064   8018               ADDS     R0,R0,R2
   \   00000066   A022               MOVS     R2,#+160
   \   00000068   B84B               LDR      R3,??Program_1+0xC  ;; 0x3a2
   \   0000006A   C35A               LDRH     R3,[R0, R3]
   \   0000006C   8352               STRH     R3,[R0, R2]
   1190                      }
   \   0000006E   491C               ADDS     R1,R1,#+1
   \   00000070   0906               LSLS     R1,R1,#+24
   \   00000072   090E               LSRS     R1,R1,#+24
   \                     ??Program_11:
   \   00000074   0800               MOVS     R0,R1
   \   00000076   0B28               CMP      R0,#+11
   \   00000078   B348               LDR      R0,??Program_1+0x8  ;; MainStage
   \   0000007A   F1D3               BCC      ??Program_10
   1191            
   1192           
   1193            
   1194                      if (MainStage.SceneNr!=SceneNrLast)
   \   0000007C   B449               LDR      R1,??Program_1+0x10  ;; 0x6ea
   \   0000007E   405C               LDRB     R0,[R0, R1]
   \   00000080   E97A               LDRB     R1,[R5, #+11]
   \   00000082   8842               CMP      R0,R1
   \   00000084   02D0               BEQ      ??Program_12
   1195                      {
   1196                        SceneNrLast=MainStage.SceneNr;
   \   00000086   E872               STRB     R0,[R5, #+11]
   1197                        MenuPaint();
   \   00000088   ........           BL       MenuPaint
   1198                      }
   \                     ??Program_12:
   \   0000008C   7F1C               ADDS     R7,R7,#+1
   \                     ??Program_9:
   \   0000008E   0A2F               CMP      R7,#+10
   \   00000090   DFDA               BGE      ??Program_7
   \   00000092   2878               LDRB     R0,[R5, #+0]
   \   00000094   0028               CMP      R0,#+0
   \   00000096   09D0               BEQ      ??Program_13
   \   00000098   6878               LDRB     R0,[R5, #+1]
   \   0000009A   B042               CMP      R0,R6
   \   0000009C   06D1               BNE      ??Program_13
   \   0000009E   A878               LDRB     R0,[R5, #+2]
   \   000000A0   B842               CMP      R0,R7
   \   000000A2   03D1               BNE      ??Program_13
   \   000000A4   0120               MOVS     R0,#+1
   \   000000A6   E870               STRB     R0,[R5, #+3]
   \   000000A8   EF63               STR      R7,[R5, #+60]
   \   000000AA   2E64               STR      R6,[R5, #+64]
   \                     ??Program_13:
   \   000000AC   2878               LDRB     R0,[R5, #+0]
   \   000000AE   0028               CMP      R0,#+0
   \   000000B0   02D0               BEQ      ??Program_14
   \   000000B2   E978               LDRB     R1,[R5, #+3]
   \   000000B4   0029               CMP      R1,#+0
   \   000000B6   E9D1               BNE      ??Program_12
   \                     ??Program_14:
   \   000000B8   0028               CMP      R0,#+0
   \   000000BA   01D1               BNE      ??Program_15
   \   000000BC   EF63               STR      R7,[R5, #+60]
   \   000000BE   2E64               STR      R6,[R5, #+64]
   \                     ??Program_15:
   \   000000C0   1820               MOVS     R0,#+24
   \   000000C2   7843               MULS     R0,R7,R0
   \   000000C4   F021               MOVS     R1,#+240
   \   000000C6   7143               MULS     R1,R6,R1
   \   000000C8   029A               LDR      R2,[SP, #+8]
   \   000000CA   5118               ADDS     R1,R2,R1
   \   000000CC   0818               ADDS     R0,R1,R0
   \   000000CE   0100               MOVS     R1,R0
   \   000000D0   1231               ADDS     R1,R1,#+18
   \   000000D2   8A79               LDRB     R2,[R1, #+6]
   \   000000D4   002A               CMP      R2,#+0
   \   000000D6   00D1               BNE      .+4
   \   000000D8   A0E1               B        ??Program_16
   \   000000DA   002F               CMP      R7,#+0
   \   000000DC   6A46               MOV      R2,SP
   \   000000DE   02D1               BNE      ??Program_17
   \   000000E0   0123               MOVS     R3,#+1
   \   000000E2   1380               STRH     R3,[R2, #+0]
   \   000000E4   01E0               B        ??Program_18
   \                     ??Program_17:
   \   000000E6   0B88               LDRH     R3,[R1, #+0]
   \   000000E8   1380               STRH     R3,[R2, #+0]
   \                     ??Program_18:
   \   000000EA   8979               LDRB     R1,[R1, #+6]
   \   000000EC   891E               SUBS     R1,R1,#+2
   \   000000EE   3D29               CMP      R1,#+61
   \   000000F0   00D9               BLS      .+4
   \   000000F2   93E1               B        ??Program_16
   \   000000F4   01A2               ADR      R2,??Program_0
   \   000000F6   4900               LSLS     R1,R1,#+1
   \   000000F8   525A               LDRH     R2,[R2, R1]
   \   000000FA   9744               ADD      PC,PC,R2
   \                     ??Program_0:
   \   000000FC   7A0088009600       DC16     +122,+136,+150,+196
   \              C400        
   \   00000104   A400D800F800       DC16     +164,+216,+248,+280
   \              1801        
   \   0000010C   260144015001       DC16     +294,+324,+336,+798
   \              1E03        
   \   00000114   1E031E031E03       DC16     +798,+798,+798,+798
   \              1E03        
   \   0000011C   1E031E035C01       DC16     +798,+798,+348,+362
   \              6A01        
   \   00000124   780186019401       DC16     +376,+390,+404,+798
   \              1E03        
   \   0000012C   1E031E031E03       DC16     +798,+798,+798,+798
   \              1E03        
   \   00000134   1E031E03A201       DC16     +798,+798,+418,+432
   \              B001        
   \   0000013C   BE01CC01DA01       DC16     +446,+460,+474,+488
   \              E801        
   \   00000144   F60104021E03       DC16     +502,+516,+798,+798
   \              1E03        
   \   0000014C   1E031E031E03       DC16     +798,+798,+798,+528
   \              1002        
   \   00000154   1E022A021E03       DC16     +542,+554,+798,+798
   \              1E03        
   \   0000015C   1E031E031E03       DC16     +798,+798,+798,+798
   \              1E03        
   \   00000164   1E0364023602       DC16     +798,+612,+566,+598
   \              5602        
   \   0000016C   6C028A02A802       DC16     +620,+650,+680,+710
   \              C602        
   \   00000174   E4020203           DC16     +740,+770
   \                     ??Program_19:
   \   00000178   734A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   0000017A   1830               ADDS     R0,R0,#+24
   \   0000017C   0100               MOVS     R1,R0
   \   0000017E   6846               MOV      R0,SP
   \   00000180   ........           BL       ProcConect_Action
   \   00000184   4AE1               B        ??Program_16
   \                     ??Program_20:
   \   00000186   704A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000188   1830               ADDS     R0,R0,#+24
   \   0000018A   0100               MOVS     R1,R0
   \   0000018C   6846               MOV      R0,SP
   \   0000018E   ........           BL       ProcDown_Action
   \   00000192   43E1               B        ??Program_16
   \                     ??Program_21:
   \   00000194   6C4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000196   1830               ADDS     R0,R0,#+24
   \   00000198   0100               MOVS     R1,R0
   \   0000019A   6846               MOV      R0,SP
   \   0000019C   ........           BL       ProcDownRight_Action
   \   000001A0   3CE1               B        ??Program_16
   \                     ??Program_22:
   \   000001A2   6946               MOV      R1,SP
   \   000001A4   2200               MOVS     R2,R4
   \   000001A6   4A80               STRH     R2,[R1, #+2]
   \   000001A8   002E               CMP      R6,#+0
   \   000001AA   03D0               BEQ      ??Program_23
   \   000001AC   0200               MOVS     R2,R0
   \   000001AE   C63A               SUBS     R2,R2,#+198
   \   000001B0   1288               LDRH     R2,[R2, #+0]
   \   000001B2   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_23:
   \   000001B4   1830               ADDS     R0,R0,#+24
   \   000001B6   0200               MOVS     R2,R0
   \   000001B8   891C               ADDS     R1,R1,#+2
   \   000001BA   6846               MOV      R0,SP
   \   000001BC   ........           BL       ProcSumL_Action
   \   000001C0   2CE1               B        ??Program_16
   \                     ??Program_24:
   \   000001C2   6946               MOV      R1,SP
   \   000001C4   2200               MOVS     R2,R4
   \   000001C6   4A80               STRH     R2,[R1, #+2]
   \   000001C8   002E               CMP      R6,#+0
   \   000001CA   F3D0               BEQ      ??Program_23
   \   000001CC   0200               MOVS     R2,R0
   \   000001CE   C63A               SUBS     R2,R2,#+198
   \   000001D0   1288               LDRH     R2,[R2, #+0]
   \   000001D2   4A80               STRH     R2,[R1, #+2]
   \   000001D4   EEE7               B        ??Program_23
   \                     ??Program_25:
   \   000001D6   6946               MOV      R1,SP
   \   000001D8   2200               MOVS     R2,R4
   \   000001DA   4A80               STRH     R2,[R1, #+2]
   \   000001DC   002E               CMP      R6,#+0
   \   000001DE   03D0               BEQ      ??Program_26
   \   000001E0   0200               MOVS     R2,R0
   \   000001E2   C63A               SUBS     R2,R2,#+198
   \   000001E4   1288               LDRH     R2,[R2, #+0]
   \   000001E6   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_26:
   \   000001E8   1830               ADDS     R0,R0,#+24
   \   000001EA   0100               MOVS     R1,R0
   \   000001EC   00A8               ADD      R0,SP,#+0
   \   000001EE   801C               ADDS     R0,R0,#+2
   \   000001F0   ........           BL       ProcUpToRight_Action
   \   000001F4   12E1               B        ??Program_16
   \                     ??Program_27:
   \   000001F6   6946               MOV      R1,SP
   \   000001F8   2200               MOVS     R2,R4
   \   000001FA   4A80               STRH     R2,[R1, #+2]
   \   000001FC   002E               CMP      R6,#+0
   \   000001FE   03D0               BEQ      ??Program_28
   \   00000200   0200               MOVS     R2,R0
   \   00000202   C63A               SUBS     R2,R2,#+198
   \   00000204   1288               LDRH     R2,[R2, #+0]
   \   00000206   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_28:
   \   00000208   1830               ADDS     R0,R0,#+24
   \   0000020A   0100               MOVS     R1,R0
   \   0000020C   00A8               ADD      R0,SP,#+0
   \   0000020E   801C               ADDS     R0,R0,#+2
   \   00000210   ........           BL       ProcUpToRightDown_Action
   \   00000214   02E1               B        ??Program_16
   \                     ??Program_29:
   \   00000216   4C4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000218   1830               ADDS     R0,R0,#+24
   \   0000021A   0100               MOVS     R1,R0
   \   0000021C   6846               MOV      R0,SP
   \   0000021E   ........           BL       ProcNOT_Action
   \   00000222   FBE0               B        ??Program_16
   \                     ??Program_30:
   \   00000224   002E               CMP      R6,#+0
   \   00000226   04D0               BEQ      ??Program_31
   \   00000228   6946               MOV      R1,SP
   \   0000022A   0200               MOVS     R2,R0
   \   0000022C   C63A               SUBS     R2,R2,#+198
   \   0000022E   1288               LDRH     R2,[R2, #+0]
   \   00000230   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_31:
   \   00000232   1830               ADDS     R0,R0,#+24
   \   00000234   0200               MOVS     R2,R0
   \   00000236   00A9               ADD      R1,SP,#+0
   \   00000238   891C               ADDS     R1,R1,#+2
   \   0000023A   6846               MOV      R0,SP
   \   0000023C   ........           BL       ProcToggleRS_Action
   \   00000240   ECE0               B        ??Program_16
   \                     ??Program_32:
   \   00000242   1830               ADDS     R0,R0,#+24
   \   00000244   0100               MOVS     R1,R0
   \   00000246   6846               MOV      R0,SP
   \   00000248   ........           BL       ProcToggleT_Action
   \   0000024C   E6E0               B        ??Program_16
   \                     ??Program_33:
   \   0000024E   1830               ADDS     R0,R0,#+24
   \   00000250   0100               MOVS     R1,R0
   \   00000252   6846               MOV      R0,SP
   \   00000254   ........           BL       ProcTLI1_Action
   \   00000258   E0E0               B        ??Program_16
   \                     ??Program_34:
   \   0000025A   3B4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   0000025C   1830               ADDS     R0,R0,#+24
   \   0000025E   0100               MOVS     R1,R0
   \   00000260   6846               MOV      R0,SP
   \   00000262   ........           BL       ProcStI_Action
   \   00000266   D9E0               B        ??Program_16
   \                     ??Program_35:
   \   00000268   374A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   0000026A   1830               ADDS     R0,R0,#+24
   \   0000026C   0100               MOVS     R1,R0
   \   0000026E   6846               MOV      R0,SP
   \   00000270   ........           BL       ProcStNI_Action
   \   00000274   D2E0               B        ??Program_16
   \                     ??Program_36:
   \   00000276   344A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000278   1830               ADDS     R0,R0,#+24
   \   0000027A   0100               MOVS     R1,R0
   \   0000027C   6846               MOV      R0,SP
   \   0000027E   ........           BL       ProcStQ_Action
   \   00000282   CBE0               B        ??Program_16
   \                     ??Program_37:
   \   00000284   304A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000286   1830               ADDS     R0,R0,#+24
   \   00000288   0100               MOVS     R1,R0
   \   0000028A   6846               MOV      R0,SP
   \   0000028C   ........           BL       ProcStB_Action
   \   00000290   C4E0               B        ??Program_16
   \                     ??Program_38:
   \   00000292   2D4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000294   1830               ADDS     R0,R0,#+24
   \   00000296   0100               MOVS     R1,R0
   \   00000298   6846               MOV      R0,SP
   \   0000029A   ........           BL       ProcStS_Action
   \   0000029E   BDE0               B        ??Program_16
   \                     ??Program_39:
   \   000002A0   294A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002A2   1830               ADDS     R0,R0,#+24
   \   000002A4   0100               MOVS     R1,R0
   \   000002A6   6846               MOV      R0,SP
   \   000002A8   ........           BL       ProcWOUT_Action
   \   000002AC   B6E0               B        ??Program_16
   \                     ??Program_40:
   \   000002AE   264A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002B0   1830               ADDS     R0,R0,#+24
   \   000002B2   0100               MOVS     R1,R0
   \   000002B4   6846               MOV      R0,SP
   \   000002B6   ........           BL       ProcWOUTS_Action
   \   000002BA   AFE0               B        ??Program_16
   \                     ??Program_41:
   \   000002BC   224A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002BE   1830               ADDS     R0,R0,#+24
   \   000002C0   0100               MOVS     R1,R0
   \   000002C2   6846               MOV      R0,SP
   \   000002C4   ........           BL       ProcWOUTR_Action
   \   000002C8   A8E0               B        ??Program_16
   \                     ??Program_42:
   \   000002CA   1F4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002CC   1830               ADDS     R0,R0,#+24
   \   000002CE   0100               MOVS     R1,R0
   \   000002D0   6846               MOV      R0,SP
   \   000002D2   ........           BL       ProcWOUTC_Action
   \   000002D6   A1E0               B        ??Program_16
   \                     ??Program_43:
   \   000002D8   1B4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002DA   1830               ADDS     R0,R0,#+24
   \   000002DC   0100               MOVS     R1,R0
   \   000002DE   6846               MOV      R0,SP
   \   000002E0   ........           BL       ProcSetScn_Action
   \   000002E4   9AE0               B        ??Program_16
   \                     ??Program_44:
   \   000002E6   184A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002E8   1830               ADDS     R0,R0,#+24
   \   000002EA   0100               MOVS     R1,R0
   \   000002EC   6846               MOV      R0,SP
   \   000002EE   ........           BL       ProcInc_Action
   \   000002F2   93E0               B        ??Program_16
   \                     ??Program_45:
   \   000002F4   144A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   000002F6   1830               ADDS     R0,R0,#+24
   \   000002F8   0100               MOVS     R1,R0
   \   000002FA   6846               MOV      R0,SP
   \   000002FC   ........           BL       ProcDec_Action
   \   00000300   8CE0               B        ??Program_16
   \                     ??Program_46:
   \   00000302   1830               ADDS     R0,R0,#+24
   \   00000304   0100               MOVS     R1,R0
   \   00000306   6846               MOV      R0,SP
   \   00000308   ........           BL       ProcSPK_Action
   \   0000030C   86E0               B        ??Program_16
   \                     ??Program_47:
   \   0000030E   0E4A               LDR      R2,??Program_1+0x8  ;; MainStage
   \   00000310   1830               ADDS     R0,R0,#+24
   \   00000312   0100               MOVS     R1,R0
   \   00000314   6846               MOV      R0,SP
   \   00000316   ........           BL       ProcTimerSet_Action
   \   0000031A   7FE0               B        ??Program_16
   \                     ??Program_48:
   \   0000031C   1830               ADDS     R0,R0,#+24
   \   0000031E   0100               MOVS     R1,R0
   \   00000320   6846               MOV      R0,SP
   \   00000322   ........           BL       ProcClock_Action
   \   00000326   79E0               B        ??Program_16
   \                     ??Program_49:
   \   00000328   1830               ADDS     R0,R0,#+24
   \   0000032A   0100               MOVS     R1,R0
   \   0000032C   6846               MOV      R0,SP
   \   0000032E   ........           BL       ProcDay_Action
   \   00000332   73E0               B        ??Program_16
   \                     ??Program_50:
   \   00000334   0449               LDR      R1,??Program_1+0x8  ;; MainStage
   \   00000336   1830               ADDS     R0,R0,#+24
   \   00000338   ........           BL       ProcGetReg_Action
   \   0000033C   6EE0               B        ??Program_16
   \   0000033E   C046               Nop      
   \                     ??Program_1:
   \   00000340   ........           DC32     Trap
   \   00000344   ........           DC32     g_counter
   \   00000348   ........           DC32     MainStage
   \   0000034C   A2030000           DC32     0x3a2
   \   00000350   EA060000           DC32     0x6ea
   \                     ??Program_51:
   \   00000354   574A               LDR      R2,??Program_52  ;; MainStage
   \   00000356   1830               ADDS     R0,R0,#+24
   \   00000358   0100               MOVS     R1,R0
   \   0000035A   6846               MOV      R0,SP
   \   0000035C   ........           BL       ProcSetAnal_Action
   \   00000360   5CE0               B        ??Program_16
   \                     ??Program_53:
   \   00000362   1830               ADDS     R0,R0,#+24
   \   00000364   ........           BL       ProcConstAnal_Action
   \   00000368   58E0               B        ??Program_16
   \                     ??Program_54:
   \   0000036A   002E               CMP      R6,#+0
   \   0000036C   04D0               BEQ      ??Program_55
   \   0000036E   6946               MOV      R1,SP
   \   00000370   0200               MOVS     R2,R0
   \   00000372   C63A               SUBS     R2,R2,#+198
   \   00000374   1288               LDRH     R2,[R2, #+0]
   \   00000376   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_55:
   \   00000378   1830               ADDS     R0,R0,#+24
   \   0000037A   0200               MOVS     R2,R0
   \   0000037C   00A9               ADD      R1,SP,#+0
   \   0000037E   891C               ADDS     R1,R1,#+2
   \   00000380   6846               MOV      R0,SP
   \   00000382   ........           BL       ProcLim_Action
   \   00000386   49E0               B        ??Program_16
   \                     ??Program_56:
   \   00000388   002E               CMP      R6,#+0
   \   0000038A   04D0               BEQ      ??Program_57
   \   0000038C   6946               MOV      R1,SP
   \   0000038E   0200               MOVS     R2,R0
   \   00000390   C63A               SUBS     R2,R2,#+198
   \   00000392   1288               LDRH     R2,[R2, #+0]
   \   00000394   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_57:
   \   00000396   1830               ADDS     R0,R0,#+24
   \   00000398   0200               MOVS     R2,R0
   \   0000039A   00A9               ADD      R1,SP,#+0
   \   0000039C   891C               ADDS     R1,R1,#+2
   \   0000039E   6846               MOV      R0,SP
   \   000003A0   ........           BL       ProcEven_Action
   \   000003A4   3AE0               B        ??Program_16
   \                     ??Program_58:
   \   000003A6   002E               CMP      R6,#+0
   \   000003A8   04D0               BEQ      ??Program_59
   \   000003AA   6946               MOV      R1,SP
   \   000003AC   0200               MOVS     R2,R0
   \   000003AE   C63A               SUBS     R2,R2,#+198
   \   000003B0   1288               LDRH     R2,[R2, #+0]
   \   000003B2   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_59:
   \   000003B4   1830               ADDS     R0,R0,#+24
   \   000003B6   0200               MOVS     R2,R0
   \   000003B8   00A9               ADD      R1,SP,#+0
   \   000003BA   891C               ADDS     R1,R1,#+2
   \   000003BC   6846               MOV      R0,SP
   \   000003BE   ........           BL       ProcPlus_Action
   \   000003C2   2BE0               B        ??Program_16
   \                     ??Program_60:
   \   000003C4   002E               CMP      R6,#+0
   \   000003C6   04D0               BEQ      ??Program_61
   \   000003C8   6946               MOV      R1,SP
   \   000003CA   0200               MOVS     R2,R0
   \   000003CC   C63A               SUBS     R2,R2,#+198
   \   000003CE   1288               LDRH     R2,[R2, #+0]
   \   000003D0   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_61:
   \   000003D2   1830               ADDS     R0,R0,#+24
   \   000003D4   0200               MOVS     R2,R0
   \   000003D6   00A9               ADD      R1,SP,#+0
   \   000003D8   891C               ADDS     R1,R1,#+2
   \   000003DA   6846               MOV      R0,SP
   \   000003DC   ........           BL       ProcMinus_Action
   \   000003E0   1CE0               B        ??Program_16
   \                     ??Program_62:
   \   000003E2   002E               CMP      R6,#+0
   \   000003E4   04D0               BEQ      ??Program_63
   \   000003E6   6946               MOV      R1,SP
   \   000003E8   0200               MOVS     R2,R0
   \   000003EA   C63A               SUBS     R2,R2,#+198
   \   000003EC   1288               LDRH     R2,[R2, #+0]
   \   000003EE   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_63:
   \   000003F0   1830               ADDS     R0,R0,#+24
   \   000003F2   0200               MOVS     R2,R0
   \   000003F4   00A9               ADD      R1,SP,#+0
   \   000003F6   891C               ADDS     R1,R1,#+2
   \   000003F8   6846               MOV      R0,SP
   \   000003FA   ........           BL       ProcMul_Action
   \   000003FE   0DE0               B        ??Program_16
   \                     ??Program_64:
   \   00000400   002E               CMP      R6,#+0
   \   00000402   04D0               BEQ      ??Program_65
   \   00000404   6946               MOV      R1,SP
   \   00000406   0200               MOVS     R2,R0
   \   00000408   C63A               SUBS     R2,R2,#+198
   \   0000040A   1288               LDRH     R2,[R2, #+0]
   \   0000040C   4A80               STRH     R2,[R1, #+2]
   \                     ??Program_65:
   \   0000040E   1830               ADDS     R0,R0,#+24
   \   00000410   0200               MOVS     R2,R0
   \   00000412   00A9               ADD      R1,SP,#+0
   \   00000414   891C               ADDS     R1,R1,#+2
   \   00000416   6846               MOV      R0,SP
   \   00000418   ........           BL       ProcDiv_Action
   \                     ??Program_16:
   \   0000041C   287B               LDRB     R0,[R5, #+12]
   \   0000041E   401E               SUBS     R0,R0,#+1
   \   00000420   8642               CMP      R6,R0
   \   00000422   00D0               BEQ      .+4
   \   00000424   32E6               B        ??Program_12
   \   00000426   092F               CMP      R7,#+9
   \   00000428   00D0               BEQ      .+4
   \   0000042A   2FE6               B        ??Program_12
   \   0000042C   2100               MOVS     R1,R4
   \   0000042E   21E6               B        ??Program_11
   1199           
   1200                   
   1201          
   1202                   }
   1203                   
   1204                   
   1205                  }
   1206                  
   1207                  
   1208                }
   1209              }
   1210            
   1211            
   1212            
   1213            //zerowanie wyjœæ  z flagami impulsu      
   1214                 for (char iNrQ=0; iNrQ<NumberNeurons; iNrQ++)
   \                     ??Program_8:
   \   00000430   2100               MOVS     R1,R4
   \   00000432   20E0               B        ??Program_66
   1215                 {
   1216                    if ((MainStage.StageQImpulse[iNrQ]) && (MainStage.SendStageChange[iNrQ]==0))
   \                     ??Program_67:
   \   00000434   0F00               MOVS     R7,R1
   \   00000436   1F48               LDR      R0,??Program_52  ;; MainStage
   \   00000438   1F4A               LDR      R2,??Program_52+0x4  ;; 0x6a4
   \   0000043A   7B00               LSLS     R3,R7,#+1
   \   0000043C   C318               ADDS     R3,R0,R3
   \   0000043E   9A18               ADDS     R2,R3,R2
   \   00000440   1388               LDRH     R3,[R2, #+0]
   \   00000442   002B               CMP      R3,#+0
   \   00000444   14D0               BEQ      ??Program_68
   \   00000446   1D4B               LDR      R3,??Program_52+0x8  ;; 0x6eb
   \   00000448   C619               ADDS     R6,R0,R7
   \   0000044A   F318               ADDS     R3,R6,R3
   \   0000044C   1E78               LDRB     R6,[R3, #+0]
   \   0000044E   002E               CMP      R6,#+0
   \   00000450   0ED1               BNE      ??Program_68
   1217                    {
   1218                      MainStage.StageQ[iNrQ].Port &=~(MainStage.StageQImpulse[iNrQ]); 
   \   00000452   1B4E               LDR      R6,??Program_52+0xC  ;; 0x3a2
   \   00000454   B446               MOV      R12,R6
   \   00000456   1626               MOVS     R6,#+22
   \   00000458   7743               MULS     R7,R6,R7
   \   0000045A   C019               ADDS     R0,R0,R7
   \   0000045C   6646               MOV      R6,R12
   \   0000045E   8019               ADDS     R0,R0,R6
   \   00000460   0688               LDRH     R6,[R0, #+0]
   \   00000462   1788               LDRH     R7,[R2, #+0]
   \   00000464   BE43               BICS     R6,R6,R7
   \   00000466   0680               STRH     R6,[R0, #+0]
   1219                      MainStage.StageQImpulse[iNrQ]=0;
   \   00000468   2000               MOVS     R0,R4
   \   0000046A   1080               STRH     R0,[R2, #+0]
   1220                      MainStage.SendStageChange[iNrQ]=ChangeStageFlag;
   \   0000046C   0A20               MOVS     R0,#+10
   \   0000046E   1870               STRB     R0,[R3, #+0]
   1221                    } 
   1222                 }
   \                     ??Program_68:
   \   00000470   491C               ADDS     R1,R1,#+1
   \   00000472   0906               LSLS     R1,R1,#+24
   \   00000474   090E               LSRS     R1,R1,#+24
   \                     ??Program_66:
   \   00000476   0800               MOVS     R0,R1
   \   00000478   2328               CMP      R0,#+35
   \   0000047A   DBD3               BCC      ??Program_67
   1223            
   1224            //zerowanie zmiennych  z flagami impulsu  
   1225            for (char i=0; i<sizeof(VariablesImpulse); i++)
   \   0000047C   2000               MOVS     R0,R4
   \   0000047E   0EE0               B        ??Program_69
   1226            {
   1227              if (VariablesImpulse[i]>0)
   \                     ??Program_70:
   \   00000480   0100               MOVS     R1,R0
   \   00000482   6918               ADDS     R1,R5,R1
   \   00000484   2022               MOVS     R2,#+32
   \   00000486   8A5C               LDRB     R2,[R1, R2]
   \   00000488   002A               CMP      R2,#+0
   \   0000048A   05D0               BEQ      ??Program_71
   1228              {
   1229                Variables[i]&=~(VariablesImpulse[i]);
   \   0000048C   0B7C               LDRB     R3,[R1, #+16]
   \   0000048E   9343               BICS     R3,R3,R2
   \   00000490   0B74               STRB     R3,[R1, #+16]
   1230                VariablesImpulse[i]=0;
   \   00000492   2031               ADDS     R1,R1,#+32
   \   00000494   2200               MOVS     R2,R4
   \   00000496   0A70               STRB     R2,[R1, #+0]
   1231              }
   1232            }
   \                     ??Program_71:
   \   00000498   401C               ADDS     R0,R0,#+1
   \   0000049A   0006               LSLS     R0,R0,#+24
   \   0000049C   000E               LSRS     R0,R0,#+24
   \                     ??Program_69:
   \   0000049E   0D28               CMP      R0,#+13
   \   000004A0   EED3               BCC      ??Program_70
   1233            
   1234            
   1235            
   1236            Busy_program=0;
   \   000004A2   AC72               STRB     R4,[R5, #+10]
   1237            
   1238              }
   1239             
   1240              
   1241              PtogTime=g_counter-last_time;
   \                     ??Program_2:
   \   000004A4   0748               LDR      R0,??Program_52+0x10  ;; g_counter
   \   000004A6   0068               LDR      R0,[R0, #+0]
   \   000004A8   A96B               LDR      R1,[R5, #+56]
   \   000004AA   401A               SUBS     R0,R0,R1
   \   000004AC   6863               STR      R0,[R5, #+52]
   1242          
   1243          }//_______________________ Koniec funkcji program__ ____________________________
   \   000004AE   FEBC               POP      {R1-R7}
   \   000004B0   01BC               POP      {R0}
   \   000004B2   0047               BX       R0               ;; return
   \                     ??Program_52:
   \   000004B4   ........           DC32     MainStage
   \   000004B8   A4060000           DC32     0x6a4
   \   000004BC   EB060000           DC32     0x6eb
   \   000004C0   A2030000           DC32     0x3a2
   \   000004C4   ........           DC32     g_counter

   \                                 In section .data, align 4
   \                     Trap:
   \   00000000   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0
   \              0000        
   \                     NumberScene:
   \   00000008   0A                 DC8 10
   \                     LastScene:
   \   00000009   00                 DC8 0
   \                     Busy_program:
   \   0000000A   00                 DC8 0
   \                     SceneNrLast:
   \   0000000B   00                 DC8 0
   \                     RealPrcLines:
   \   0000000C   C8                 DC8 200
   \   0000000D   000000             DC8 0, 0, 0
   \                     Variables:
   \   00000010   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     VariablesImpulse:
   \   00000020   000000000000       DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              000000000000
   \              00000000    
   \                     ScreenUse:
   \   00000030   0000               DC8 0, 0
   \   00000032   0000               DC8 0, 0
   \                     PtogTime:
   \   00000034   00000000           DC32 0
   \                     last_time:
   \   00000038   00000000           DC8 0, 0, 0, 0
   \   0000003C   00000000           DC32 0
   \   00000040   00000000           DC32 0

   \                                 In section .data, align 4
   \                     pProg:
   \   00000000   ........           DC32 gProg
   1244          
   1245          
   1246          
   1247          //-----------------------------------------------------------------------------
   1248          // Nazwa funkcji :    SceneNrCount
   1249          // Funkcja zlicza u¿ywane w programie u¿ytkowym sceny. Odpowiedzi¹ jest iloœæ scen
   1250          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1251          char SceneNrCount(_ProgramTab *ProgTab)
   1252          {
   \                     SceneNrCount:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0100               MOVS     R1,R0
   1253                char MaxScnNr=0;
   \   00000004   0022               MOVS     R2,#+0
   \   00000006   1000               MOVS     R0,R2
   1254                for (int LineNr=0; LineNr<MaxPrcLines; LineNr++)
   \   00000008   1300               MOVS     R3,R2
   \   0000000A   14E0               B        ??SceneNrCount_0
   1255                {
   1256                  for (int PrcInLine=0; PrcInLine<MaxPrcInLine; PrcInLine++)
   1257                  {
   1258                     if ((ProgTab->Line[LineNr].Proc[PrcInLine].Type==ProcStS) && (ProgTab->Line[LineNr].Proc[PrcInLine].Nr>MaxScnNr))
   \                     ??SceneNrCount_1:
   \   0000000C   1825               MOVS     R5,#+24
   \   0000000E   6543               MULS     R5,R4,R5
   \   00000010   F026               MOVS     R6,#+240
   \   00000012   5E43               MULS     R6,R3,R6
   \   00000014   8E19               ADDS     R6,R1,R6
   \   00000016   7519               ADDS     R5,R6,R5
   \   00000018   2E7E               LDRB     R6,[R5, #+24]
   \   0000001A   182E               CMP      R6,#+24
   \   0000001C   07D1               BNE      ??SceneNrCount_2
   \   0000001E   0600               MOVS     R6,R0
   \   00000020   1927               MOVS     R7,#+25
   \   00000022   EF57               LDRSB    R7,[R5, R7]
   \   00000024   BE42               CMP      R6,R7
   \   00000026   02DA               BGE      ??SceneNrCount_2
   1259                     {
   1260                       MaxScnNr=ProgTab->Line[LineNr].Proc[PrcInLine].Nr;
   \   00000028   3800               MOVS     R0,R7
   \   0000002A   0006               LSLS     R0,R0,#+24
   \   0000002C   000E               LSRS     R0,R0,#+24
   1261                     }
   1262                  }
   \                     ??SceneNrCount_2:
   \   0000002E   641C               ADDS     R4,R4,#+1
   \                     ??SceneNrCount_3:
   \   00000030   0A2C               CMP      R4,#+10
   \   00000032   EBDB               BLT      ??SceneNrCount_1
   \   00000034   5B1C               ADDS     R3,R3,#+1
   \                     ??SceneNrCount_0:
   \   00000036   C82B               CMP      R3,#+200
   \   00000038   01DA               BGE      ??SceneNrCount_4
   \   0000003A   1400               MOVS     R4,R2
   \   0000003C   F8E7               B        ??SceneNrCount_3
   1263                  
   1264                }
   1265            
   1266                return MaxScnNr;
   \                     ??SceneNrCount_4:
   \   0000003E   F8BC               POP      {R3-R7}
   \   00000040   02BC               POP      {R1}
   \   00000042   0847               BX       R1               ;; return
   1267          }//_______________________ Koniec funkcji_______________________________________
   1268          
   1269          
   1270          
   1271          
   1272             
   1273          //-----------------------------------------------------------------------------
   1274          // Nazwa funkcji :    ScreenNrCount
   1275          // Funkcja zlicza u¿ywane ekrany. Odpowiedzi¹ jest suma logiczna u¿ywanych ekranów
   1276          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1277          short CheckScreenUse(_ProgramTab *ProgTab)
   1278          {
   \                     CheckScreenUse:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0120               MOVS     R0,#+1
   1279            
   1280                short ScreenUse=1; 
   1281               
   1282                char f=1;  
   \   00000004   0100               MOVS     R1,R0
   \   00000006   0022               MOVS     R2,#+0
   \   00000008   28E0               B        ??CheckScreenUse_0
   1283            
   1284                char sc=0;
   1285                _ScreenPaternDesign *ScreenPaternDesign; 
   1286                while ((f)&&(sc<ScreenNr))
   1287                {
   1288                  f=0;
   1289                  
   1290                       if (sc==0) 
   1291                      {
   1292                        ScreenPaternDesign=ScreenSetTab_0;
   1293                      }else{
   1294                        ScreenPaternDesign=ScreenSetTab_1; 
   1295                      }  
   1296          
   1297                  for (int bt=0; bt<ScrenButtonNr; bt++)
   1298                  {
   1299                    if ((ScreenPaternDesign[ProgTab->Screen[sc].PaternDesign].Button[bt].Width>0) && (ProgTab->Screen[sc].Button[bt].OpenPage>0) )
   \                     ??CheckScreenUse_1:
   \   0000000A   1500               MOVS     R5,R2
   \   0000000C   A026               MOVS     R6,#+160
   \   0000000E   7543               MULS     R5,R6,R5
   \   00000010   009E               LDR      R6,[SP, #+0]
   \   00000012   7519               ADDS     R5,R6,R5
   \   00000014   A700               LSLS     R7,R4,#+2
   \   00000016   BC46               MOV      R12,R7
   \   00000018   184E               LDR      R6,??CheckScreenUse_2  ;; 0xbb98
   \   0000001A   AF5D               LDRB     R7,[R5, R6]
   \   0000001C   5826               MOVS     R6,#+88
   \   0000001E   7743               MULS     R7,R6,R7
   \   00000020   DE19               ADDS     R6,R3,R7
   \   00000022   6746               MOV      R7,R12
   \   00000024   F619               ADDS     R6,R6,R7
   \   00000026   B678               LDRB     R6,[R6, #+2]
   \   00000028   002E               CMP      R6,#+0
   \   0000002A   11D0               BEQ      ??CheckScreenUse_3
   \   0000002C   144E               LDR      R6,??CheckScreenUse_2+0x4  ;; 0xbbaa
   \   0000002E   E700               LSLS     R7,R4,#+3
   \   00000030   ED19               ADDS     R5,R5,R7
   \   00000032   AD19               ADDS     R5,R5,R6
   \   00000034   0F26               MOVS     R6,#+15
   \   00000036   2F78               LDRB     R7,[R5, #+0]
   \   00000038   3742               TST      R7,R6
   \   0000003A   09D0               BEQ      ??CheckScreenUse_3
   1300                    {
   1301                      ScreenUse |=1<<(ProgTab->Screen[sc].Button[bt].OpenPage-1);
   \   0000003C   0121               MOVS     R1,#+1
   \   0000003E   3D00               MOVS     R5,R7
   \   00000040   2E40               ANDS     R6,R6,R5
   \   00000042   751E               SUBS     R5,R6,#+1
   \   00000044   A940               LSLS     R1,R1,R5
   \   00000046   0143               ORRS     R1,R1,R0
   \   00000048   0904               LSLS     R1,R1,#+16
   \   0000004A   0914               ASRS     R1,R1,#+16
   \   0000004C   0800               MOVS     R0,R1
   1302                      f=1;
   \   0000004E   0121               MOVS     R1,#+1
   1303                    }
   1304                  }
   \                     ??CheckScreenUse_3:
   \   00000050   641C               ADDS     R4,R4,#+1
   \                     ??CheckScreenUse_4:
   \   00000052   092C               CMP      R4,#+9
   \   00000054   D9DB               BLT      ??CheckScreenUse_1
   1305                  sc++;
   \   00000056   521C               ADDS     R2,R2,#+1
   \   00000058   1206               LSLS     R2,R2,#+24
   \   0000005A   120E               LSRS     R2,R2,#+24
   \                     ??CheckScreenUse_0:
   \   0000005C   0029               CMP      R1,#+0
   \   0000005E   0AD0               BEQ      ??CheckScreenUse_5
   \   00000060   1100               MOVS     R1,R2
   \   00000062   0829               CMP      R1,#+8
   \   00000064   07D2               BCS      ??CheckScreenUse_5
   \   00000066   0021               MOVS     R1,#+0
   \   00000068   1300               MOVS     R3,R2
   \   0000006A   01D1               BNE      ??CheckScreenUse_6
   \   0000006C   054B               LDR      R3,??CheckScreenUse_2+0x8  ;; ScreenSetTab_0
   \   0000006E   00E0               B        ??CheckScreenUse_7
   \                     ??CheckScreenUse_6:
   \   00000070   054B               LDR      R3,??CheckScreenUse_2+0xC  ;; ScreenSetTab_1
   \                     ??CheckScreenUse_7:
   \   00000072   0C00               MOVS     R4,R1
   \   00000074   EDE7               B        ??CheckScreenUse_4
   1306                  
   1307                }
   1308                
   1309           
   1310            
   1311                return ScreenUse;
   \                     ??CheckScreenUse_5:
   \   00000076   F8BC               POP      {R3-R7}
   \   00000078   02BC               POP      {R1}
   \   0000007A   0847               BX       R1               ;; return
   \                     ??CheckScreenUse_2:
   \   0000007C   98BB0000           DC32     0xbb98
   \   00000080   AABB0000           DC32     0xbbaa
   \   00000084   ........           DC32     ScreenSetTab_0
   \   00000088   ........           DC32     ScreenSetTab_1
   1312            
   1313          }//_______________________ Koniec funkcji_______________________________________
   1314          
   1315          
   1316               
   1317               
   1318               

   \                                 In section Debug.txt, align 4, keep-with-next
   1319          void CountLines(_ProgramTab *ProgTab)
   1320          {
   \                     CountLines:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   1321               char UseLine=0;
   \   00000002   0021               MOVS     R1,#+0
   \   00000004   0A00               MOVS     R2,R1
   1322                  for (char j=0; j<MaxPrcLines; j++)
   \   00000006   0B00               MOVS     R3,R1
   \   00000008   13E0               B        ??CountLines_0
   1323                    for (char i=0; i<MaxPrcInLine; i++) 
   1324                      if (ProgTab->Line[j].Proc[i].Type>0) UseLine=j;
   \                     ??CountLines_1:
   \   0000000A   1826               MOVS     R6,#+24
   \   0000000C   7543               MULS     R5,R6,R5
   \   0000000E   1E00               MOVS     R6,R3
   \   00000010   F027               MOVS     R7,#+240
   \   00000012   7E43               MULS     R6,R7,R6
   \   00000014   8619               ADDS     R6,R0,R6
   \   00000016   7519               ADDS     R5,R6,R5
   \   00000018   2D7E               LDRB     R5,[R5, #+24]
   \   0000001A   002D               CMP      R5,#+0
   \   0000001C   00D0               BEQ      ??CountLines_2
   \   0000001E   1A00               MOVS     R2,R3
   \                     ??CountLines_2:
   \   00000020   641C               ADDS     R4,R4,#+1
   \   00000022   2406               LSLS     R4,R4,#+24
   \   00000024   240E               LSRS     R4,R4,#+24
   \                     ??CountLines_3:
   \   00000026   2500               MOVS     R5,R4
   \   00000028   0A2D               CMP      R5,#+10
   \   0000002A   EED3               BCC      ??CountLines_1
   \   0000002C   5B1C               ADDS     R3,R3,#+1
   \   0000002E   1B06               LSLS     R3,R3,#+24
   \   00000030   1B0E               LSRS     R3,R3,#+24
   \                     ??CountLines_0:
   \   00000032   1C00               MOVS     R4,R3
   \   00000034   C82C               CMP      R4,#+200
   \   00000036   01D2               BCS      ??CountLines_4
   \   00000038   0C00               MOVS     R4,R1
   \   0000003A   F4E7               B        ??CountLines_3
   1325              RealPrcLines=UseLine+1; 
   \                     ??CountLines_4:
   \   0000003C   0248               LDR      R0,??CountLines_5  ;; Trap + 12
   \   0000003E   521C               ADDS     R2,R2,#+1
   \   00000040   0270               STRB     R2,[R0, #+0]
   1326          }
   \   00000042   F8BC               POP      {R3-R7}
   \   00000044   01BC               POP      {R0}
   \   00000046   0047               BX       R0               ;; return
   \                     ??CountLines_5:
   \   00000048   ........           DC32     Trap + 12
   1327          
   1328          
   1329          

   \                                 In section Debug.txt, align 4, keep-with-next
   1330          void RefreshNeuronsList(_ProgramTab *ProgTab)
   1331          {
   \                     RefreshNeuronsList:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   0024               MOVS     R4,#+0
   \   00000004   09E0               B        ??RefreshNeuronsList_0
   1332            for (char i=0; i<NumberNeurons; i++)
   1333            {
   1334             if (ProgTab->NeuronsIdTab[i]>0)
   1335             {
   1336                 NeuronsList[i].NeuronType=(_NeuronType)((ProgTab->NeuronsIdTab[i])/1000000);
   1337                 NeuronsList[i].NeuronID=(ProgTab->NeuronsIdTab[i])-(NeuronsList[i].NeuronType*1000000);
   1338             }else{
   1339                 NeuronsList[i].NeuronType=(_NeuronType)0;
   \                     ??RefreshNeuronsList_1:
   \   00000006   0C21               MOVS     R1,#+12
   \   00000008   4843               MULS     R0,R1,R0
   \   0000000A   1349               LDR      R1,??RefreshNeuronsList_2  ;; NeuronsList
   \   0000000C   0E18               ADDS     R6,R1,R0
   \   0000000E   0020               MOVS     R0,#+0
   \   00000010   3070               STRB     R0,[R6, #+0]
   1340                 NeuronsList[i].NeuronID=0;
   \   00000012   7060               STR      R0,[R6, #+4]
   1341             }
   \                     ??RefreshNeuronsList_3:
   \   00000014   641C               ADDS     R4,R4,#+1
   \   00000016   2406               LSLS     R4,R4,#+24
   \   00000018   240E               LSRS     R4,R4,#+24
   \                     ??RefreshNeuronsList_0:
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   2328               CMP      R0,#+35
   \   0000001E   17D2               BCS      ??RefreshNeuronsList_4
   \   00000020   0E49               LDR      R1,??RefreshNeuronsList_2+0x4  ;; 0xc098
   \   00000022   8200               LSLS     R2,R0,#+2
   \   00000024   009B               LDR      R3,[SP, #+0]
   \   00000026   9A18               ADDS     R2,R3,R2
   \   00000028   5518               ADDS     R5,R2,R1
   \   0000002A   2968               LDR      R1,[R5, #+0]
   \   0000002C   0129               CMP      R1,#+1
   \   0000002E   EADB               BLT      ??RefreshNeuronsList_1
   \   00000030   0C21               MOVS     R1,#+12
   \   00000032   4843               MULS     R0,R1,R0
   \   00000034   0849               LDR      R1,??RefreshNeuronsList_2  ;; NeuronsList
   \   00000036   0E18               ADDS     R6,R1,R0
   \   00000038   094F               LDR      R7,??RefreshNeuronsList_2+0x8  ;; 0xf4240
   \   0000003A   2868               LDR      R0,[R5, #+0]
   \   0000003C   3900               MOVS     R1,R7
   \   0000003E   ........           BL       __aeabi_idivmod
   \   00000042   3070               STRB     R0,[R6, #+0]
   \   00000044   2868               LDR      R0,[R5, #+0]
   \   00000046   3178               LDRB     R1,[R6, #+0]
   \   00000048   7943               MULS     R1,R7,R1
   \   0000004A   401A               SUBS     R0,R0,R1
   \   0000004C   7060               STR      R0,[R6, #+4]
   \   0000004E   E1E7               B        ??RefreshNeuronsList_3
   1342            }
   1343          }
   \                     ??RefreshNeuronsList_4:
   \   00000050   F8BC               POP      {R3-R7}
   \   00000052   01BC               POP      {R0}
   \   00000054   0047               BX       R0               ;; return
   \   00000056   C046               Nop      
   \                     ??RefreshNeuronsList_2:
   \   00000058   ........           DC32     NeuronsList
   \   0000005C   98C00000           DC32     0xc098
   \   00000060   40420F00           DC32     0xf4240
   1344          
   1345          
   1346          
   1347          //-----------------------------------------------------------------------------
   1348          // Nazwa funkcji :    AddRsTask
   1349          // Funkcja ustawia dodanie zadania dla transmisji Rs
   1350          // Ord - typ rozkazu : odczyt wejœæ, zapis
   1351          // Node - nr wêz³a/urz¹dzenia
   1352          // Reg  - nr rejestru w wêŸle 
   1353          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1354          void AddRsTask(_OrderType Ord, char Node, char Reg)
   1355          { 
   \                     AddRsTask:
   \   00000000   F4B5               PUSH     {R2,R4-R7,LR}
   1356               ptr_ZD_MODBUS ZD_MODBUS;
   1357               ZD_MODBUS         =   ZD_MODBUS_0;
   1358               
   1359              char OrdExist=0;
   \   00000002   0022               MOVS     R2,#+0
   \   00000004   1400               MOVS     R4,R2
   1360              char RfOrd=0;
   \   00000006   1300               MOVS     R3,R2
   1361              char FreePlace=0;
   1362              
   1363              
   1364              //przepisanie rozkazu na zrozumia³y dla tablicy zadañ Rs
   1365              if (Ord==SI) RfOrd=0x4; 
   \   00000008   0128               CMP      R0,#+1
   \   0000000A   00D1               BNE      ??AddRsTask_0
   \   0000000C   0423               MOVS     R3,#+4
   1366              if (Ord==SQ) RfOrd=0xF; 
   \                     ??AddRsTask_0:
   \   0000000E   0228               CMP      R0,#+2
   \   00000010   00D1               BNE      ??AddRsTask_1
   \   00000012   0F23               MOVS     R3,#+15
   1367          
   1368                
   1369          
   1370                    
   1371              //Sprawdzenie czy taki rozkaz nie istnieje w tablicy
   1372              char i=0;
   \                     ??AddRsTask_1:
   \   00000014   1000               MOVS     R0,R2
   \   00000016   1FE0               B        ??AddRsTask_2
   1373              while ((i<ZD_MODBUS_Tab_Max) && (OrdExist==0))
   1374              {
   1375                 if ((ZD_MODBUS[i].Adress==Node) && 
   1376                     (ZD_MODBUS[i].Function==RfOrd) &&
   1377                     (ZD_MODBUS[i].Target==Reg) &&
   1378                     (ZD_MODBUS[i].StartAdr==Node-0))
   \                     ??AddRsTask_3:
   \   00000018   264D               LDR      R5,??AddRsTask_4  ;; ZD_MODBUS_0
   \   0000001A   0600               MOVS     R6,R0
   \   0000001C   0D27               MOVS     R7,#+13
   \   0000001E   7E43               MULS     R6,R7,R6
   \   00000020   AD19               ADDS     R5,R5,R6
   \   00000022   2E78               LDRB     R6,[R5, #+0]
   \   00000024   8E42               CMP      R6,R1
   \   00000026   14D1               BNE      ??AddRsTask_5
   \   00000028   6E78               LDRB     R6,[R5, #+1]
   \   0000002A   9E42               CMP      R6,R3
   \   0000002C   11D1               BNE      ??AddRsTask_5
   \   0000002E   AE78               LDRB     R6,[R5, #+2]
   \   00000030   EF78               LDRB     R7,[R5, #+3]
   \   00000032   3F06               LSLS     R7,R7,#+24
   \   00000034   3F0C               LSRS     R7,R7,#+16
   \   00000036   3E43               ORRS     R6,R6,R7
   \   00000038   6F46               MOV      R7,SP
   \   0000003A   3F78               LDRB     R7,[R7, #+0]
   \   0000003C   BE42               CMP      R6,R7
   \   0000003E   08D1               BNE      ??AddRsTask_5
   \   00000040   2E79               LDRB     R6,[R5, #+4]
   \   00000042   6F79               LDRB     R7,[R5, #+5]
   \   00000044   3F06               LSLS     R7,R7,#+24
   \   00000046   3F0C               LSRS     R7,R7,#+16
   \   00000048   3E43               ORRS     R6,R6,R7
   \   0000004A   0D00               MOVS     R5,R1
   \   0000004C   AE42               CMP      R6,R5
   \   0000004E   00D1               BNE      ??AddRsTask_5
   1379                    {
   1380                      OrdExist=1;
   \   00000050   0124               MOVS     R4,#+1
   1381                    }
   1382                 i++;
   \                     ??AddRsTask_5:
   \   00000052   401C               ADDS     R0,R0,#+1
   \   00000054   0006               LSLS     R0,R0,#+24
   \   00000056   000E               LSRS     R0,R0,#+24
   1383              }
   \                     ??AddRsTask_2:
   \   00000058   0500               MOVS     R5,R0
   \   0000005A   142D               CMP      R5,#+20
   \   0000005C   01D2               BCS      ??AddRsTask_6
   \   0000005E   2500               MOVS     R5,R4
   \   00000060   DAD0               BEQ      ??AddRsTask_3
   1384              
   1385              //je¿eli rozkaz nie istnieje to dodaj
   1386              if (OrdExist==0)
   \                     ??AddRsTask_6:
   \   00000062   002C               CMP      R4,#+0
   \   00000064   23D1               BNE      ??AddRsTask_7
   1387              {
   1388                //znajdŸ wolne miejsce w tablicy zadañ 
   1389                FreePlace=0;
   \   00000066   02E0               B        ??AddRsTask_8
   1390                while ((FreePlace<ZD_MODBUS_Tab_Max) && (ZD_MODBUS[FreePlace].Adress!=0)) FreePlace++;
   \                     ??AddRsTask_9:
   \   00000068   521C               ADDS     R2,R2,#+1
   \   0000006A   1206               LSLS     R2,R2,#+24
   \   0000006C   120E               LSRS     R2,R2,#+24
   \                     ??AddRsTask_8:
   \   0000006E   1000               MOVS     R0,R2
   \   00000070   1428               CMP      R0,#+20
   \   00000072   05D2               BCS      ??AddRsTask_10
   \   00000074   0D24               MOVS     R4,#+13
   \   00000076   6043               MULS     R0,R4,R0
   \   00000078   0E4C               LDR      R4,??AddRsTask_4  ;; ZD_MODBUS_0
   \   0000007A   205C               LDRB     R0,[R4, R0]
   \   0000007C   0028               CMP      R0,#+0
   \   0000007E   F3D1               BNE      ??AddRsTask_9
   1391                
   1392                
   1393                if (FreePlace<ZD_MODBUS_Tab_Max)     //jezeli jest miejsce w tablicy to dodaj
   \                     ??AddRsTask_10:
   \   00000080   1000               MOVS     R0,R2
   \   00000082   1428               CMP      R0,#+20
   \   00000084   13D2               BCS      ??AddRsTask_7
   1394                { 
   1395                  ZD_MODBUS[FreePlace].Adress=Node;
   \   00000086   0B4D               LDR      R5,??AddRsTask_4  ;; ZD_MODBUS_0
   \   00000088   0D20               MOVS     R0,#+13
   \   0000008A   4243               MULS     R2,R0,R2
   \   0000008C   A818               ADDS     R0,R5,R2
   \   0000008E   0170               STRB     R1,[R0, #+0]
   1396                  ZD_MODBUS[FreePlace].Function=RfOrd;
   \   00000090   4370               STRB     R3,[R0, #+1]
   1397                  ZD_MODBUS[FreePlace].Target=Reg;
   \   00000092   6A46               MOV      R2,SP
   \   00000094   1278               LDRB     R2,[R2, #+0]
   \   00000096   8270               STRB     R2,[R0, #+2]
   \   00000098   120A               LSRS     R2,R2,#+8
   \   0000009A   C270               STRB     R2,[R0, #+3]
   1398                  ZD_MODBUS[FreePlace].StartAdr=Node-0;   //miejsce w pamiêci do pobrania danych (odpowiada nodowi)
   \   0000009C   0171               STRB     R1,[R0, #+4]
   \   0000009E   090A               LSRS     R1,R1,#+8
   \   000000A0   4171               STRB     R1,[R0, #+5]
   1399                  ZD_MODBUS[FreePlace].Coil=16;
   \   000000A2   1021               MOVS     R1,#+16
   \   000000A4   8171               STRB     R1,[R0, #+6]
   \   000000A6   090A               LSRS     R1,R1,#+8
   \   000000A8   C171               STRB     R1,[R0, #+7]
   1400                  ZD_MODBUS[FreePlace].Error=0x0; 
   \   000000AA   C172               STRB     R1,[R0, #+11]
   \   000000AC   0173               STRB     R1,[R0, #+12]
   1401                }
   1402                
   1403                
   1404              }
   1405              
   1406                
   1407          
   1408                
   1409                          
   1410          }//_______________________ Koniec funkcji  AddRsTask _________________
   \                     ??AddRsTask_7:
   \   000000AE   F8BC               POP      {R3-R7}
   \   000000B0   01BC               POP      {R0}
   \   000000B2   0047               BX       R0               ;; return
   \                     ??AddRsTask_4:
   \   000000B4   ........           DC32     ZD_MODBUS_0
   1411          
   1412          
   1413          
   1414          
   1415          //-----------------------------------------------------------------------------
   1416          // Nazwa funkcji :    AddRfTask
   1417          // Funkcja ustawia dodanie zadania dla transmisji Rs
   1418          // Ord - typ rozkazu : odczyt wejœæ, zapis
   1419          // Node - nr wêz³a/urz¹dzeia
   1420          // Reg  - nr rejestru w wêŸle 
   1421          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1422          void AddRfTask(_OrderType Ord, char Node, char Reg)
   1423          { 
   \                     AddRfTask:
   \   00000000   F7B5               PUSH     {R0-R2,R4-R7,LR}
   \   00000002   0400               MOVS     R4,R0
   \   00000004   0020               MOVS     R0,#+0
   1424              char OrdExist=0;
   1425              char RfOrd;
   1426              char FreePlace=0;
   1427              char FirstOccureNode=0xFF;        //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   \   00000006   FF22               MOVS     R2,#+255
   1428              char LastOccureNode=0xFF;        //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   \   00000008   0092               STR      R2,[SP, #+0]
   1429             
   1430              //zabezpieczenie przed przekroczeniami
   1431              if (Node>NumberNeurons) return;
   \   0000000A   2429               CMP      R1,#+36
   \   0000000C   00D3               BCC      .+4
   \   0000000E   D0E0               B        ??AddRfTask_0
   1432              if (Reg>99) return;
   \   00000010   6D46               MOV      R5,SP
   \   00000012   2D7A               LDRB     R5,[R5, #+8]
   \   00000014   642D               CMP      R5,#+100
   \   00000016   00D3               BCC      .+4
   \   00000018   CBE0               B        ??AddRfTask_0
   1433              
   1434              
   1435              //przepisanie rozkazu na zrozumia³y dla tablicy zadañ RF
   1436              switch (Ord)
   \   0000001A   012C               CMP      R4,#+1
   \   0000001C   04D0               BEQ      ??AddRfTask_1
   \   0000001E   022C               CMP      R4,#+2
   \   00000020   04D0               BEQ      ??AddRfTask_2
   \   00000022   042C               CMP      R4,#+4
   \   00000024   04D0               BEQ      ??AddRfTask_3
   \   00000026   04E0               B        ??AddRfTask_4
   1437              {
   1438                  case SI:      RfOrd=R_RegOrd; break; 
   \                     ??AddRfTask_1:
   \   00000028   0123               MOVS     R3,#+1
   \   0000002A   02E0               B        ??AddRfTask_4
   1439                  case SQ:      RfOrd=W_RegOrd; break; 
   \                     ??AddRfTask_2:
   \   0000002C   0223               MOVS     R3,#+2
   \   0000002E   00E0               B        ??AddRfTask_4
   1440                  case SNewId:  RfOrd=W_NewIdOrd; break; 
   \                     ??AddRfTask_3:
   \   00000030   0523               MOVS     R3,#+5
   1441              }  
   1442           
   1443          
   1444                
   1445              //Sprawdzenie czy taki rozkaz nie istnieje w tablicy
   1446              char i=0;
   \                     ??AddRfTask_4:
   \   00000032   0400               MOVS     R4,R0
   \   00000034   22E0               B        ??AddRfTask_5
   1447              while ((i<RF_Tasks) && (OrdExist==0))
   1448              {
   1449                 if ((RF_TaskTab[i].Node==Node) && 
   1450                     (RF_TaskTab[i].Command.ID==NeuronsList[Node-1].NeuronID) &&
   1451                     (RF_TaskTab[i].Command.Order==RfOrd) &&
   1452                     (RF_TaskTab[i].Command.Auxi==Reg))
   \                     ??AddRfTask_6:
   \   00000036   604D               LDR      R5,??AddRfTask_7  ;; RF_TaskTab
   \   00000038   2600               MOVS     R6,R4
   \   0000003A   F600               LSLS     R6,R6,#+3
   \   0000003C   AD19               ADDS     R5,R5,R6
   \   0000003E   2E78               LDRB     R6,[R5, #+0]
   \   00000040   8E42               CMP      R6,R1
   \   00000042   18D1               BNE      ??AddRfTask_8
   \   00000044   6D68               LDR      R5,[R5, #+4]
   \   00000046   2F03               LSLS     R7,R5,#+12
   \   00000048   3F0B               LSRS     R7,R7,#+12
   \   0000004A   BC46               MOV      R12,R7
   \   0000004C   0C27               MOVS     R7,#+12
   \   0000004E   4F43               MULS     R7,R1,R7
   \   00000050   5A4E               LDR      R6,??AddRfTask_7+0x4  ;; NeuronsList
   \   00000052   F619               ADDS     R6,R6,R7
   \   00000054   083E               SUBS     R6,R6,#+8
   \   00000056   3668               LDR      R6,[R6, #+0]
   \   00000058   6746               MOV      R7,R12
   \   0000005A   B742               CMP      R7,R6
   \   0000005C   0BD1               BNE      ??AddRfTask_8
   \   0000005E   F026               MOVS     R6,#+240
   \   00000060   3604               LSLS     R6,R6,#+16       ;; #+15728640
   \   00000062   2E40               ANDS     R6,R6,R5
   \   00000064   360D               LSRS     R6,R6,#+20
   \   00000066   9E42               CMP      R6,R3
   \   00000068   05D1               BNE      ??AddRfTask_8
   \   0000006A   2D0E               LSRS     R5,R5,#+24
   \   0000006C   6E46               MOV      R6,SP
   \   0000006E   367A               LDRB     R6,[R6, #+8]
   \   00000070   B542               CMP      R5,R6
   \   00000072   00D1               BNE      ??AddRfTask_8
   1453                    {
   1454                      OrdExist=1;
   \   00000074   0120               MOVS     R0,#+1
   1455                    }
   1456                
   1457                 i++;
   \                     ??AddRfTask_8:
   \   00000076   641C               ADDS     R4,R4,#+1
   \   00000078   2406               LSLS     R4,R4,#+24
   \   0000007A   240E               LSRS     R4,R4,#+24
   1458              }
   \                     ??AddRfTask_5:
   \   0000007C   2500               MOVS     R5,R4
   \   0000007E   462D               CMP      R5,#+70
   \   00000080   01D2               BCS      ??AddRfTask_9
   \   00000082   0500               MOVS     R5,R0
   \   00000084   D7D0               BEQ      ??AddRfTask_6
   1459              
   1460              i=0;
   \                     ??AddRfTask_9:
   \   00000086   0026               MOVS     R6,#+0
   1461              char Rf_Zad=0; //iloœæ zadañ.  
   \   00000088   3400               MOVS     R4,R6
   \   0000008A   1DE0               B        ??AddRfTask_10
   1462              //Odszukanie ostatniego i ewentualnie pierwszego zadania z tym wêz³em - ma to na cenu u³o¿enie zadañ wêz³ów po kolei co jest konieczne do prawid³owego odpytywania sterowników w trybie slave. Sterowniki takie czekaj¹ na wszystkie swoje odpytania a je¿eli wyst¹pi odpytanie innego wêz³a lub ponowne odpytanie rejestru 0 odpytywanego sterownika to prze³¹czaj¹ sie na tryb master, wykonuj¹ w³asne odpytania a nastêpnie prze³¹czaj¹ siê ponownie w trym slave. Pierwszym zadaniem w kolejce zawsze musi byæ odpytanie rejestru 0
   1463              //Obliczenie iloœci zadañ
   1464              while (i<RF_Tasks)
   1465              {
   1466                   if (RF_TaskTab[i].Node==Node)
   \                     ??AddRfTask_11:
   \   0000008C   4A4D               LDR      R5,??AddRfTask_7  ;; RF_TaskTab
   \   0000008E   3700               MOVS     R7,R6
   \   00000090   FF00               LSLS     R7,R7,#+3
   \   00000092   ED5D               LDRB     R5,[R5, R7]
   \   00000094   8D42               CMP      R5,R1
   \   00000096   0FD1               BNE      ??AddRfTask_12
   1467                   {
   1468                     if ((RfOrd==R_RegOrd) && (Reg==0) &&  (FirstOccureNode==0xFF))  FirstOccureNode=Rf_Zad; //pierwsze wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   \   00000098   1F00               MOVS     R7,R3
   \   0000009A   3F06               LSLS     R7,R7,#+24
   \   0000009C   3F0E               LSRS     R7,R7,#+24
   \   0000009E   012F               CMP      R7,#+1
   \   000000A0   09D1               BNE      ??AddRfTask_13
   \   000000A2   6F46               MOV      R7,SP
   \   000000A4   3F7A               LDRB     R7,[R7, #+8]
   \   000000A6   002F               CMP      R7,#+0
   \   000000A8   05D1               BNE      ??AddRfTask_13
   \   000000AA   1700               MOVS     R7,R2
   \   000000AC   3F06               LSLS     R7,R7,#+24
   \   000000AE   3F0E               LSRS     R7,R7,#+24
   \   000000B0   FF2F               CMP      R7,#+255
   \   000000B2   00D1               BNE      ??AddRfTask_13
   \   000000B4   2200               MOVS     R2,R4
   1469                     LastOccureNode=Rf_Zad;                                               //ostatnie wyst¹pienie zadania tego wêz³a. 0xFF oznacza ¿e nie znaleziono ¿adnego inneo zadania z tym wêz³em
   \                     ??AddRfTask_13:
   \   000000B6   0094               STR      R4,[SP, #+0]
   1470                   }
   1471                   
   1472                   if (RF_TaskTab[i].Node!=0) Rf_Zad++;
   \                     ??AddRfTask_12:
   \   000000B8   002D               CMP      R5,#+0
   \   000000BA   02D0               BEQ      ??AddRfTask_14
   \   000000BC   641C               ADDS     R4,R4,#+1
   \   000000BE   2406               LSLS     R4,R4,#+24
   \   000000C0   240E               LSRS     R4,R4,#+24
   1473                   i++;    
   \                     ??AddRfTask_14:
   \   000000C2   761C               ADDS     R6,R6,#+1
   \   000000C4   3606               LSLS     R6,R6,#+24
   \   000000C6   360E               LSRS     R6,R6,#+24
   1474              }
   \                     ??AddRfTask_10:
   \   000000C8   3500               MOVS     R5,R6
   \   000000CA   462D               CMP      R5,#+70
   \   000000CC   DED3               BCC      ??AddRfTask_11
   1475              if(Rf_Zad>=RF_Tasks) return;    //je¿eli nie ma ju¿ miejsca na nowe zadania to wyjdŸ z funkcji
   \   000000CE   2500               MOVS     R5,R4
   \   000000D0   462D               CMP      R5,#+70
   \   000000D2   6ED2               BCS      ??AddRfTask_0
   1476              
   1477              
   1478              
   1479              //je¿eli rozkaz nie istnieje to dodaj. Je¿eli na liœcie s¹ ju¿ 
   1480              if (OrdExist==0)
   \   000000D4   0028               CMP      R0,#+0
   \   000000D6   6CD1               BNE      ??AddRfTask_0
   1481              {
   1482                if (FirstOccureNode!=0xFF)                                                //znajdŸ miejsce w tablicy zadañ dla nowego zadania
   \   000000D8   1000               MOVS     R0,R2
   \   000000DA   0006               LSLS     R0,R0,#+24
   \   000000DC   000E               LSRS     R0,R0,#+24
   \   000000DE   FF28               CMP      R0,#+255
   \   000000E0   01D0               BEQ      ??AddRfTask_15
   1483                {
   1484                   FreePlace=FirstOccureNode;                                              //miejsce w tablicy na nowe zadanie przed dotychczasowymi zadaniami
   \   000000E2   1000               MOVS     R0,R2
   \   000000E4   0AE0               B        ??AddRfTask_16
   1485                }
   1486                else if (LastOccureNode!=0xFF)  
   \                     ??AddRfTask_15:
   \   000000E6   0098               LDR      R0,[SP, #+0]
   \   000000E8   0006               LSLS     R0,R0,#+24
   \   000000EA   000E               LSRS     R0,R0,#+24
   \   000000EC   FF28               CMP      R0,#+255
   \   000000EE   04D0               BEQ      ??AddRfTask_17
   1487                {
   1488                   FreePlace=LastOccureNode+1;                                             //miejsce w tablicy na nowe zadanie za dotychczasowymi zadaniami
   \   000000F0   0098               LDR      R0,[SP, #+0]
   \   000000F2   401C               ADDS     R0,R0,#+1
   \   000000F4   0006               LSLS     R0,R0,#+24
   \   000000F6   000E               LSRS     R0,R0,#+24
   \   000000F8   00E0               B        ??AddRfTask_16
   1489                }else{
   1490                   FreePlace=Rf_Zad;                                                          //miejsce w tablicy na nowe zadanie
   \                     ??AddRfTask_17:
   \   000000FA   2000               MOVS     R0,R4
   1491                }
   1492                
   1493                //je¿eli zadanie ma byæ wprowadzone pomiêdzy inne zadania
   1494                if (((FirstOccureNode!=0xFF) && (FirstOccureNode+1>Rf_Zad)) || 
   1495                    ((LastOccureNode!=0xFF)  && (LastOccureNode<Rf_Zad)))
   \                     ??AddRfTask_16:
   \   000000FC   1500               MOVS     R5,R2
   \   000000FE   2D06               LSLS     R5,R5,#+24
   \   00000100   2D0E               LSRS     R5,R5,#+24
   \   00000102   FF2D               CMP      R5,#+255
   \   00000104   03D0               BEQ      ??AddRfTask_18
   \   00000106   2500               MOVS     R5,R4
   \   00000108   521C               ADDS     R2,R2,#+1
   \   0000010A   9542               CMP      R5,R2
   \   0000010C   0ADB               BLT      ??AddRfTask_19
   \                     ??AddRfTask_18:
   \   0000010E   009A               LDR      R2,[SP, #+0]
   \   00000110   1206               LSLS     R2,R2,#+24
   \   00000112   120E               LSRS     R2,R2,#+24
   \   00000114   FF2A               CMP      R2,#+255
   \   00000116   30D0               BEQ      ??AddRfTask_20
   \   00000118   009A               LDR      R2,[SP, #+0]
   \   0000011A   2500               MOVS     R5,R4
   \   0000011C   1206               LSLS     R2,R2,#+24
   \   0000011E   120E               LSRS     R2,R2,#+24
   \   00000120   AA42               CMP      R2,R5
   \   00000122   2AD2               BCS      ??AddRfTask_20
   1496                {
   1497                  //rozsuniêcie zadañ
   1498                  unsigned char  Pz=Rf_Zad-1;
   \                     ??AddRfTask_19:
   \   00000124   621E               SUBS     R2,R4,#+1
   \   00000126   1206               LSLS     R2,R2,#+24
   \   00000128   120E               LSRS     R2,R2,#+24
   \   0000012A   20E0               B        ??AddRfTask_21
   1499                  while (Pz>=FreePlace)
   1500                  {
   1501                     RF_TaskTab[Pz+1].Node=RF_TaskTab[Pz].Node;
   \                     ??AddRfTask_22:
   \   0000012C   224D               LDR      R5,??AddRfTask_7  ;; RF_TaskTab
   \   0000012E   E400               LSLS     R4,R4,#+3
   \   00000130   2C19               ADDS     R4,R5,R4
   \   00000132   2578               LDRB     R5,[R4, #+0]
   \   00000134   2572               STRB     R5,[R4, #+8]
   \   00000136   E568               LDR      R5,[R4, #+12]
   \   00000138   2D0D               LSRS     R5,R5,#+20
   \   0000013A   2D05               LSLS     R5,R5,#+20
   \   0000013C   6668               LDR      R6,[R4, #+4]
   \   0000013E   3603               LSLS     R6,R6,#+12
   \   00000140   360B               LSRS     R6,R6,#+12
   \   00000142   2E43               ORRS     R6,R6,R5
   \   00000144   E660               STR      R6,[R4, #+12]
   \   00000146   1E4D               LDR      R5,??AddRfTask_7+0x8  ;; 0xff0fffff
   \   00000148   3540               ANDS     R5,R5,R6
   \   0000014A   6668               LDR      R6,[R4, #+4]
   \   0000014C   360D               LSRS     R6,R6,#+20
   \   0000014E   3705               LSLS     R7,R6,#+20
   \   00000150   F026               MOVS     R6,#+240
   \   00000152   3604               LSLS     R6,R6,#+16       ;; #+15728640
   \   00000154   3E40               ANDS     R6,R6,R7
   \   00000156   2E43               ORRS     R6,R6,R5
   \   00000158   E660               STR      R6,[R4, #+12]
   1502                     RF_TaskTab[Pz+1].Command.ID=RF_TaskTab[Pz].Command.ID;
   1503                     RF_TaskTab[Pz+1].Command.Order=RF_TaskTab[Pz].Command.Order;
   1504                     RF_TaskTab[Pz+1].Command.Auxi=RF_TaskTab[Pz].Command.Auxi;
   \   0000015A   3502               LSLS     R5,R6,#+8
   \   0000015C   2D0A               LSRS     R5,R5,#+8
   \   0000015E   6668               LDR      R6,[R4, #+4]
   \   00000160   360E               LSRS     R6,R6,#+24
   \   00000162   3606               LSLS     R6,R6,#+24
   \   00000164   2E43               ORRS     R6,R6,R5
   \   00000166   E660               STR      R6,[R4, #+12]
   1505                     Pz--;
   \   00000168   521E               SUBS     R2,R2,#+1
   \   0000016A   1206               LSLS     R2,R2,#+24
   \   0000016C   120E               LSRS     R2,R2,#+24
   1506                  }
   \                     ??AddRfTask_21:
   \   0000016E   1400               MOVS     R4,R2
   \   00000170   0500               MOVS     R5,R0
   \   00000172   2D06               LSLS     R5,R5,#+24
   \   00000174   2D0E               LSRS     R5,R5,#+24
   \   00000176   AC42               CMP      R4,R5
   \   00000178   D8D2               BCS      ??AddRfTask_22
   1507                }
   1508                
   1509                 //while ((FreePlace<RF_Tasks) && (RF_TaskTab[FreePlace].Node!=0)) FreePlace++;   //tak by³o do wersji 1.2 w³acznie
   1510                if (FreePlace<RF_Tasks)     //jezeli jest miejsce w tablicy to dodaj
   \                     ??AddRfTask_20:
   \   0000017A   0200               MOVS     R2,R0
   \   0000017C   1206               LSLS     R2,R2,#+24
   \   0000017E   120E               LSRS     R2,R2,#+24
   \   00000180   462A               CMP      R2,#+70
   \   00000182   16D2               BCS      ??AddRfTask_0
   1511                {
   1512                  RF_TaskTab[FreePlace].Node=Node;
   \   00000184   0C4D               LDR      R5,??AddRfTask_7  ;; RF_TaskTab
   \   00000186   0006               LSLS     R0,R0,#+24
   \   00000188   000E               LSRS     R0,R0,#+24
   \   0000018A   C000               LSLS     R0,R0,#+3
   \   0000018C   2818               ADDS     R0,R5,R0
   \   0000018E   0170               STRB     R1,[R0, #+0]
   1513                  RF_TaskTab[FreePlace].Command.ID=NeuronsList[Node-1].NeuronID;
   1514                  RF_TaskTab[FreePlace].Command.Order=RfOrd;
   1515                  RF_TaskTab[FreePlace].Command.Auxi=Reg;
   \   00000190   0C22               MOVS     R2,#+12
   \   00000192   5143               MULS     R1,R2,R1
   \   00000194   094A               LDR      R2,??AddRfTask_7+0x4  ;; NeuronsList
   \   00000196   5118               ADDS     R1,R2,R1
   \   00000198   0839               SUBS     R1,R1,#+8
   \   0000019A   0968               LDR      R1,[R1, #+0]
   \   0000019C   084A               LDR      R2,??AddRfTask_7+0x8  ;; 0xff0fffff
   \   0000019E   0A40               ANDS     R2,R2,R1
   \   000001A0   1905               LSLS     R1,R3,#+20
   \   000001A2   1143               ORRS     R1,R1,R2
   \   000001A4   0902               LSLS     R1,R1,#+8
   \   000001A6   090A               LSRS     R1,R1,#+8
   \   000001A8   6A46               MOV      R2,SP
   \   000001AA   127A               LDRB     R2,[R2, #+8]
   \   000001AC   1206               LSLS     R2,R2,#+24
   \   000001AE   0A43               ORRS     R2,R2,R1
   \   000001B0   4260               STR      R2,[R0, #+4]
   \                     ??AddRfTask_0:
   \   000001B2   FEBC               POP      {R1-R7}
   \   000001B4   01BC               POP      {R0}
   \   000001B6   0047               BX       R0               ;; return
   \                     ??AddRfTask_7:
   \   000001B8   ........           DC32     RF_TaskTab
   \   000001BC   ........           DC32     NeuronsList
   \   000001C0   FFFF0FFF           DC32     0xff0fffff
   1516                  
   1517                }
   1518                
   1519                
   1520              }
   1521              
   1522              
   1523          
   1524          }//_______________________ Koniec funkcji  AddRfTask _________________
   1525          
   1526          
   1527          
   1528          
   1529          
   1530          
   1531          //-----------------------------------------------------------------------------
   1532          // Nazwa funkcji :    SetTask
   1533          // Funkcja ustawia zadania transmisji RS oraz RF
   1534          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1535          void SetTask(_ProgramTab *ProgTab)
   1536          { 
   \                     SetTask:
   \   00000000   F1B5               PUSH     {R0,R4-R7,LR}
   \   00000002   8AB0               SUB      SP,SP,#+40
   1537                _Procedure Proc; 
   1538                _OrderType SetOrd=NonOrd;
   1539                char       RegOrd=0;
   1540            
   1541                
   1542                //wyczyszczenie tablicy zadañ
   1543                for (char i=0; i<RF_Tasks; i++) 
   \   00000004   0025               MOVS     R5,#+0
   \   00000006   2800               MOVS     R0,R5
   \   00000008   08E0               B        ??SetTask_0
   1544                {
   1545                  RF_TaskTab[i].Node=0;
   \                     ??SetTask_1:
   \   0000000A   C900               LSLS     R1,R1,#+3
   \   0000000C   8D4A               LDR      R2,??SetTask_2   ;; RF_TaskTab
   \   0000000E   5118               ADDS     R1,R2,R1
   \   00000010   2A00               MOVS     R2,R5
   \   00000012   0A70               STRB     R2,[R1, #+0]
   1546                  RF_TaskTab[i].Command.ID=0;
   1547                  RF_TaskTab[i].Command.Order=0;
   1548                  RF_TaskTab[i].Command.Auxi=0;
   \   00000014   4D60               STR      R5,[R1, #+4]
   1549                }
   \   00000016   401C               ADDS     R0,R0,#+1
   \   00000018   0006               LSLS     R0,R0,#+24
   \   0000001A   000E               LSRS     R0,R0,#+24
   \                     ??SetTask_0:
   \   0000001C   0100               MOVS     R1,R0
   \   0000001E   4629               CMP      R1,#+70
   \   00000020   F3D3               BCC      ??SetTask_1
   1550                
   1551                for (char node=0; node<NumberNeurons; node++)
   \   00000022   2C00               MOVS     R4,R5
   \   00000024   15E0               B        ??SetTask_3
   1552                {
   1553                   if((NeuronsList[node].NeuronType!=NoneNodeType) && (NeuronsList[node].NeuronType>=BeginRF) && (NeuronsList[node].NeuronType<=EndRF))  AddRfTask(SI, node+1, 0);
   \                     ??SetTask_4:
   \   00000026   8848               LDR      R0,??SetTask_2+0x4  ;; NeuronsList
   \   00000028   2100               MOVS     R1,R4
   \   0000002A   0C22               MOVS     R2,#+12
   \   0000002C   5143               MULS     R1,R2,R1
   \   0000002E   405C               LDRB     R0,[R0, R1]
   \   00000030   0028               CMP      R0,#+0
   \   00000032   0BD0               BEQ      ??SetTask_5
   \   00000034   0228               CMP      R0,#+2
   \   00000036   09D3               BCC      ??SetTask_5
   \   00000038   0628               CMP      R0,#+6
   \   0000003A   07D2               BCS      ??SetTask_5
   \   0000003C   2A00               MOVS     R2,R5
   \   0000003E   2100               MOVS     R1,R4
   \   00000040   491C               ADDS     R1,R1,#+1
   \   00000042   0906               LSLS     R1,R1,#+24
   \   00000044   090E               LSRS     R1,R1,#+24
   \   00000046   0120               MOVS     R0,#+1
   \   00000048   ........           BL       AddRfTask
   1554                }
   \                     ??SetTask_5:
   \   0000004C   641C               ADDS     R4,R4,#+1
   \   0000004E   2406               LSLS     R4,R4,#+24
   \   00000050   240E               LSRS     R4,R4,#+24
   \                     ??SetTask_3:
   \   00000052   2000               MOVS     R0,R4
   \   00000054   2328               CMP      R0,#+35
   \   00000056   E6D3               BCC      ??SetTask_4
   1555                
   1556                
   1557                for (int LineNr=0; LineNr<RealPrcLines; LineNr++)
   \   00000058   0095               STR      R5,[SP, #+0]
   \   0000005A   02E0               B        ??SetTask_6
   \                     ??SetTask_7:
   \   0000005C   0098               LDR      R0,[SP, #+0]
   \   0000005E   401C               ADDS     R0,R0,#+1
   \   00000060   0090               STR      R0,[SP, #+0]
   \                     ??SetTask_6:
   \   00000062   0098               LDR      R0,[SP, #+0]
   \   00000064   7949               LDR      R1,??SetTask_2+0x8  ;; Trap + 12
   \   00000066   0978               LDRB     R1,[R1, #+0]
   \   00000068   8842               CMP      R0,R1
   \   0000006A   58DA               BGE      ??SetTask_8
   1558                {
   1559                  for (int PrcInLine=0; PrcInLine<MaxPrcInLine; PrcInLine++)
   \   0000006C   2C00               MOVS     R4,R5
   \   0000006E   2FE0               B        ??SetTask_9
   1560                  {
   1561          
   1562                        Proc=ProgTab->Line[LineNr].Proc[PrcInLine];
   1563                        
   1564                        RegOrd=Proc.Tag.RegNr;
   1565                        SetOrd=NonOrd;
   1566                        //wybór typu rozkazu
   1567                        switch (Proc.Type)
   1568                        {
   1569                           case ProcWOUT:       SetOrd=SQ;  RegOrd=0; break;
   1570                           case ProcWOUTS:      SetOrd=SQ;  RegOrd=0; break;
   1571                           case ProcWOUTR:      SetOrd=SQ;  RegOrd=0; break;
   1572                           case ProcWOUTC:      SetOrd=SQ;  RegOrd=0; break;
   1573                           case ProcStI:        SetOrd=SI;  RegOrd=0; break;
   1574                           case ProcStNI:       SetOrd=SI;  RegOrd=0; break;
   1575                           case ProcSetReg:     SetOrd=SQ;  RegOrd=Proc.Tag.RegNr; break;
   1576                           case ProcGetReg:     SetOrd=SI;  RegOrd=Proc.Tag.RegNr; break;
   \                     ??SetTask_10:
   \   00000070   0127               MOVS     R7,#+1
   1577                        }     
   1578                         
   1579                        
   1580                        //je¿eli rozkaz
   1581                        if (SetOrd!=NonOrd)
   \                     ??SetTask_11:
   \   00000072   002F               CMP      R7,#+0
   \   00000074   2BD0               BEQ      ??SetTask_12
   1582                        {
   1583                              
   1584                                //Je¿eli nody z transmisj¹ RS
   1585                                if (((NeuronsList[Proc.Nr-1].NeuronType>=BeginRS) && (NeuronsList[Proc.Nr-1].NeuronType<=EndRS)) || (NeuronsList[Proc.Nr-1].NeuronType==0))
   \   00000076   6846               MOV      R0,SP
   \   00000078   04A9               ADD      R1,SP,#+16
   \   0000007A   4978               LDRB     R1,[R1, #+1]
   \   0000007C   0172               STRB     R1,[R0, #+8]
   \   0000007E   7248               LDR      R0,??SetTask_2+0x4  ;; NeuronsList
   \   00000080   6A46               MOV      R2,SP
   \   00000082   0821               MOVS     R1,#+8
   \   00000084   5156               LDRSB    R1,[R2, R1]
   \   00000086   0C22               MOVS     R2,#+12
   \   00000088   5143               MULS     R1,R2,R1
   \   0000008A   4018               ADDS     R0,R0,R1
   \   0000008C   0C38               SUBS     R0,R0,#+12
   \   0000008E   0190               STR      R0,[SP, #+4]
   \   00000090   0078               LDRB     R0,[R0, #+0]
   \   00000092   0028               CMP      R0,#+0
   \   00000094   01D0               BEQ      ??SetTask_13
   \   00000096   0328               CMP      R0,#+3
   \   00000098   01D3               BCC      ??SetTask_14
   \                     ??SetTask_13:
   \   0000009A   0028               CMP      R0,#+0
   \   0000009C   08D1               BNE      ??SetTask_15
   1586                                {
   1587                                  AddRsTask(SetOrd, Proc.Nr, RegOrd);                //Dodaj rozkaz do tablicy zadañ Modbus
   \                     ??SetTask_14:
   \   0000009E   3200               MOVS     R2,R6
   \   000000A0   6946               MOV      R1,SP
   \   000000A2   0820               MOVS     R0,#+8
   \   000000A4   0956               LDRSB    R1,[R1, R0]
   \   000000A6   0906               LSLS     R1,R1,#+24
   \   000000A8   090E               LSRS     R1,R1,#+24
   \   000000AA   3800               MOVS     R0,R7
   \   000000AC   ........           BL       AddRsTask
   1588                                }
   1589                                //Je¿eli nody z transmisj¹ RF
   1590                                if ((NeuronsList[Proc.Nr-1].NeuronType>=BeginRF) && (NeuronsList[Proc.Nr-1].NeuronType<=EndRF))
   \                     ??SetTask_15:
   \   000000B0   0198               LDR      R0,[SP, #+4]
   \   000000B2   0078               LDRB     R0,[R0, #+0]
   \   000000B4   0228               CMP      R0,#+2
   \   000000B6   0AD3               BCC      ??SetTask_12
   \   000000B8   0628               CMP      R0,#+6
   \   000000BA   08D2               BCS      ??SetTask_12
   1591                                {
   1592                                   AddRfTask(SetOrd, Proc.Nr, RegOrd);                //Dodaj rozkaz do tablicy zadañ RF
   \   000000BC   3200               MOVS     R2,R6
   \   000000BE   6946               MOV      R1,SP
   \   000000C0   0820               MOVS     R0,#+8
   \   000000C2   0956               LDRSB    R1,[R1, R0]
   \   000000C4   0906               LSLS     R1,R1,#+24
   \   000000C6   090E               LSRS     R1,R1,#+24
   \   000000C8   3800               MOVS     R0,R7
   \   000000CA   ........           BL       AddRfTask
   1593                                }
   1594                        }  
   \                     ??SetTask_12:
   \   000000CE   641C               ADDS     R4,R4,#+1
   \                     ??SetTask_9:
   \   000000D0   0A2C               CMP      R4,#+10
   \   000000D2   C3DA               BGE      ??SetTask_7
   \   000000D4   04A8               ADD      R0,SP,#+16
   \   000000D6   1821               MOVS     R1,#+24
   \   000000D8   6143               MULS     R1,R4,R1
   \   000000DA   009A               LDR      R2,[SP, #+0]
   \   000000DC   F023               MOVS     R3,#+240
   \   000000DE   5A43               MULS     R2,R3,R2
   \   000000E0   0A9B               LDR      R3,[SP, #+40]
   \   000000E2   9A18               ADDS     R2,R3,R2
   \   000000E4   5118               ADDS     R1,R2,R1
   \   000000E6   1831               ADDS     R1,R1,#+24
   \   000000E8   1822               MOVS     R2,#+24
   \   000000EA   ........           BL       __aeabi_memcpy4
   \   000000EE   04A8               ADD      R0,SP,#+16
   \   000000F0   067A               LDRB     R6,[R0, #+8]
   \   000000F2   2F00               MOVS     R7,R5
   \   000000F4   6846               MOV      R0,SP
   \   000000F6   007C               LDRB     R0,[R0, #+16]
   \   000000F8   1438               SUBS     R0,R0,#+20
   \   000000FA   0128               CMP      R0,#+1
   \   000000FC   0AD9               BLS      ??SetTask_16
   \   000000FE   0C38               SUBS     R0,R0,#+12
   \   00000100   0328               CMP      R0,#+3
   \   00000102   04D9               BLS      ??SetTask_17
   \   00000104   1838               SUBS     R0,R0,#+24
   \   00000106   B3D0               BEQ      ??SetTask_10
   \   00000108   401E               SUBS     R0,R0,#+1
   \   0000010A   06D0               BEQ      ??SetTask_18
   \   0000010C   B1E7               B        ??SetTask_11
   \                     ??SetTask_17:
   \   0000010E   0227               MOVS     R7,#+2
   \   00000110   2E00               MOVS     R6,R5
   \   00000112   AEE7               B        ??SetTask_11
   \                     ??SetTask_16:
   \   00000114   0127               MOVS     R7,#+1
   \   00000116   2E00               MOVS     R6,R5
   \   00000118   ABE7               B        ??SetTask_11
   \                     ??SetTask_18:
   \   0000011A   0227               MOVS     R7,#+2
   \   0000011C   A9E7               B        ??SetTask_11
   1595                        
   1596                  }
   1597                  
   1598                }
   1599                
   1600                
   1601                
   1602                
   1603                
   1604                //Bezpoœrednie zmienne ekranowe
   1605                volatile _Screen* ScreenLokal;
   1606                 _ScreenPaternDesign *ScreenPaternDesign;
   1607          
   1608                
   1609                 for (char Sheet=0; Sheet<ScreenNr; Sheet++)
   \                     ??SetTask_8:
   \   0000011E   2E00               MOVS     R6,R5
   \   00000120   4AE0               B        ??SetTask_19
   1610                 {
   1611                     if (ScreenUse&1<<Sheet)
   1612                     {
   1613                        if (Sheet==0) 
   1614                        {
   1615                          ScreenPaternDesign=ScreenSetTab_0;
   1616                        }else{
   1617                          ScreenPaternDesign=ScreenSetTab_1; 
   1618                        } 
   1619                       
   1620                       ScreenLokal=&gProg.Screen[Sheet];
   1621                       for (char i=0; i<ScrenAnalogNr; i++)
   1622                          {
   1623          
   1624                                if ( (ScreenPaternDesign[ScreenLokal->PaternDesign].Value[i].Width>0) && ((ScreenLokal->Analog[i].Nr>0) || ((ScreenLokal->Analog[i].Nr==0)&&(ScreenLokal->Analog[i].Reg>0))))
   1625                                 {
   1626                                    AddRfTask(SI, ScreenLokal->Analog[i].Nr, ScreenLokal->Analog[i].Reg);
   1627                                 }
   1628                          }
   1629                       for (char i=0; i<ScrenGraphNr; i++)
   1630                          {
   1631                                if ((ScreenPaternDesign[ScreenLokal->PaternDesign].Graph[i].Width>0) && ((ScreenLokal->Graph[i].Type==GraphOnOff) || (ScreenLokal->Graph[i].PlusOnOff==1) || (ScreenLokal->Graph[i].Type==GraphWartosc)))
   \                     ??SetTask_20:
   \   00000122   8100               LSLS     R1,R0,#+2
   \   00000124   2278               LDRB     R2,[R4, #+0]
   \   00000126   5823               MOVS     R3,#+88
   \   00000128   5A43               MULS     R2,R3,R2
   \   0000012A   009B               LDR      R3,[SP, #+0]
   \   0000012C   9A18               ADDS     R2,R3,R2
   \   0000012E   5118               ADDS     R1,R2,R1
   \   00000130   2631               ADDS     R1,R1,#+38
   \   00000132   0978               LDRB     R1,[R1, #+0]
   \   00000134   0029               CMP      R1,#+0
   \   00000136   11D0               BEQ      ??SetTask_21
   \   00000138   0721               MOVS     R1,#+7
   \   0000013A   4843               MULS     R0,R1,R0
   \   0000013C   2018               ADDS     R0,R4,R0
   \   0000013E   5330               ADDS     R0,R0,#+83
   \   00000140   0178               LDRB     R1,[R0, #+0]
   \   00000142   0B29               CMP      R1,#+11
   \   00000144   05D0               BEQ      ??SetTask_22
   \   00000146   8179               LDRB     R1,[R0, #+6]
   \   00000148   C907               LSLS     R1,R1,#+31
   \   0000014A   02D4               BMI      ??SetTask_22
   \   0000014C   0178               LDRB     R1,[R0, #+0]
   \   0000014E   0A29               CMP      R1,#+10
   \   00000150   04D1               BNE      ??SetTask_21
   1632                                 {
   1633                                    AddRfTask(SI, ScreenLokal->Graph[i].Nr, ScreenLokal->Graph[i].Reg);
   \                     ??SetTask_22:
   \   00000152   4279               LDRB     R2,[R0, #+5]
   \   00000154   0179               LDRB     R1,[R0, #+4]
   \   00000156   0120               MOVS     R0,#+1
   \   00000158   ........           BL       AddRfTask
   1634                                 }
   1635                          }
   \                     ??SetTask_21:
   \   0000015C   7F1C               ADDS     R7,R7,#+1
   \   0000015E   3F06               LSLS     R7,R7,#+24
   \   00000160   3F0E               LSRS     R7,R7,#+24
   \                     ??SetTask_23:
   \   00000162   3800               MOVS     R0,R7
   \   00000164   0428               CMP      R0,#+4
   \   00000166   DCD3               BCC      ??SetTask_20
   1636                       
   1637                       //je¿eli na stronie jest termostat
   1638                       if (((Sheet==0) && (gProg.Screen[Sheet].PaternDesign==MainScreenTermo)) || 
   1639                              ((Sheet) && (gProg.Screen[Sheet].PaternDesign==SubScreenTermo)))
   \   00000168   3000               MOVS     R0,R6
   \   0000016A   03D1               BNE      ??SetTask_24
   \   0000016C   0198               LDR      R0,[SP, #+4]
   \   0000016E   0078               LDRB     R0,[R0, #+0]
   \   00000170   0828               CMP      R0,#+8
   \   00000172   05D0               BEQ      ??SetTask_25
   \                     ??SetTask_24:
   \   00000174   3000               MOVS     R0,R6
   \   00000176   1CD0               BEQ      ??SetTask_26
   \   00000178   0198               LDR      R0,[SP, #+4]
   \   0000017A   0078               LDRB     R0,[R0, #+0]
   \   0000017C   0528               CMP      R0,#+5
   \   0000017E   18D1               BNE      ??SetTask_26
   1640                        {
   1641                        
   1642                       if (ScreenLokal->Thermo.ActorNode>0)
   \                     ??SetTask_25:
   \   00000180   8C34               ADDS     R4,R4,#+140
   \   00000182   0020               MOVS     R0,#+0
   \   00000184   2056               LDRSB    R0,[R4, R0]
   \   00000186   0128               CMP      R0,#+1
   \   00000188   07DB               BLT      ??SetTask_27
   1643                                 {
   1644                                    AddRfTask(SQ, ScreenLokal->Thermo.ActorNode, ScreenLokal->Thermo.ActorPort);
   \   0000018A   6278               LDRB     R2,[R4, #+1]
   \   0000018C   0020               MOVS     R0,#+0
   \   0000018E   2156               LDRSB    R1,[R4, R0]
   \   00000190   0906               LSLS     R1,R1,#+24
   \   00000192   090E               LSRS     R1,R1,#+24
   \   00000194   0220               MOVS     R0,#+2
   \   00000196   ........           BL       AddRfTask
   1645                                 }   
   1646                       if (ScreenLokal->Thermo.SensorNode>0)
   \                     ??SetTask_27:
   \   0000019A   0320               MOVS     R0,#+3
   \   0000019C   2056               LDRSB    R0,[R4, R0]
   \   0000019E   0128               CMP      R0,#+1
   \   000001A0   07DB               BLT      ??SetTask_26
   1647                                 {
   1648                                    AddRfTask(SI, ScreenLokal->Thermo.SensorNode, ScreenLokal->Thermo.SensorReg);
   \   000001A2   2279               LDRB     R2,[R4, #+4]
   \   000001A4   0320               MOVS     R0,#+3
   \   000001A6   2156               LDRSB    R1,[R4, R0]
   \   000001A8   0906               LSLS     R1,R1,#+24
   \   000001AA   090E               LSRS     R1,R1,#+24
   \   000001AC   0120               MOVS     R0,#+1
   \   000001AE   ........           BL       AddRfTask
   1649                                 }  
   1650                       
   1651                        }
   \                     ??SetTask_26:
   \   000001B2   761C               ADDS     R6,R6,#+1
   \   000001B4   3606               LSLS     R6,R6,#+24
   \   000001B6   360E               LSRS     R6,R6,#+24
   \                     ??SetTask_19:
   \   000001B8   3000               MOVS     R0,R6
   \   000001BA   0828               CMP      R0,#+8
   \   000001BC   3DD2               BCS      ??SetTask_28
   \   000001BE   3020               MOVS     R0,#+48
   \   000001C0   2349               LDR      R1,??SetTask_2+0xC  ;; Trap
   \   000001C2   085E               LDRSH    R0,[R1, R0]
   \   000001C4   0121               MOVS     R1,#+1
   \   000001C6   B140               LSLS     R1,R1,R6
   \   000001C8   0140               ANDS     R1,R1,R0
   \   000001CA   F2D0               BEQ      ??SetTask_26
   \   000001CC   3000               MOVS     R0,R6
   \   000001CE   02D1               BNE      ??SetTask_29
   \   000001D0   2048               LDR      R0,??SetTask_2+0x10  ;; ScreenSetTab_0
   \   000001D2   0090               STR      R0,[SP, #+0]
   \   000001D4   01E0               B        ??SetTask_30
   \                     ??SetTask_29:
   \   000001D6   2048               LDR      R0,??SetTask_2+0x14  ;; ScreenSetTab_1
   \   000001D8   0090               STR      R0,[SP, #+0]
   \                     ??SetTask_30:
   \   000001DA   2048               LDR      R0,??SetTask_2+0x18  ;; 0xbb98
   \   000001DC   3100               MOVS     R1,R6
   \   000001DE   A022               MOVS     R2,#+160
   \   000001E0   5143               MULS     R1,R2,R1
   \   000001E2   1F4A               LDR      R2,??SetTask_2+0x1C  ;; gProg
   \   000001E4   5118               ADDS     R1,R2,R1
   \   000001E6   0818               ADDS     R0,R1,R0
   \   000001E8   0190               STR      R0,[SP, #+4]
   \   000001EA   0400               MOVS     R4,R0
   \   000001EC   2F00               MOVS     R7,R5
   \   000001EE   1FE0               B        ??SetTask_31
   \                     ??SetTask_32:
   \   000001F0   8100               LSLS     R1,R0,#+2
   \   000001F2   2278               LDRB     R2,[R4, #+0]
   \   000001F4   5823               MOVS     R3,#+88
   \   000001F6   5A43               MULS     R2,R3,R2
   \   000001F8   009B               LDR      R3,[SP, #+0]
   \   000001FA   9A18               ADDS     R2,R3,R2
   \   000001FC   5118               ADDS     R1,R2,R1
   \   000001FE   3631               ADDS     R1,R1,#+54
   \   00000200   0978               LDRB     R1,[R1, #+0]
   \   00000202   0029               CMP      R1,#+0
   \   00000204   11D0               BEQ      ??SetTask_33
   \   00000206   0721               MOVS     R1,#+7
   \   00000208   4843               MULS     R0,R1,R0
   \   0000020A   2018               ADDS     R0,R4,R0
   \   0000020C   7330               ADDS     R0,R0,#+115
   \   0000020E   0178               LDRB     R1,[R0, #+0]
   \   00000210   0029               CMP      R1,#+0
   \   00000212   05D1               BNE      ??SetTask_34
   \   00000214   0178               LDRB     R1,[R0, #+0]
   \   00000216   0029               CMP      R1,#+0
   \   00000218   07D1               BNE      ??SetTask_33
   \   0000021A   4178               LDRB     R1,[R0, #+1]
   \   0000021C   0029               CMP      R1,#+0
   \   0000021E   04D0               BEQ      ??SetTask_33
   \                     ??SetTask_34:
   \   00000220   4278               LDRB     R2,[R0, #+1]
   \   00000222   0178               LDRB     R1,[R0, #+0]
   \   00000224   0120               MOVS     R0,#+1
   \   00000226   ........           BL       AddRfTask
   \                     ??SetTask_33:
   \   0000022A   7F1C               ADDS     R7,R7,#+1
   \   0000022C   3F06               LSLS     R7,R7,#+24
   \   0000022E   3F0E               LSRS     R7,R7,#+24
   \                     ??SetTask_31:
   \   00000230   3800               MOVS     R0,R7
   \   00000232   0428               CMP      R0,#+4
   \   00000234   DCD3               BCC      ??SetTask_32
   \   00000236   2F00               MOVS     R7,R5
   \   00000238   93E7               B        ??SetTask_23
   1652                     
   1653                     }
   1654          
   1655                 }
   1656                //-------------------------------
   1657                
   1658                
   1659                //Dodanie standardowego odpytywania wez³ów nie u¿ywanych w programie
   1660                 /*
   1661                 char ExstF=0;
   1662                
   1663                for (char i=0; i<NumberNeurons; i++)
   1664                {
   1665                  ExstF=0;
   1666                  if (NeuronsList[i].NeuronID!=0)
   1667                  {
   1668                     for (char j=0; j<RF_Tasks; j++)
   1669                     {
   1670                       if (RF_TaskTab[j].Command.ID==0)  //je¿eli brak zadañ to wyjdŸ
   1671                       { 
   1672                         j=RF_Tasks;
   1673                       }else if (RF_TaskTab[j].Command.ID==NeuronsList[i].NeuronID)    //je¿eli zadanie dla tego noda istnieje
   1674                       {
   1675                         ExstF=1;   //ustaw flagê
   1676                       }
   1677                     }
   1678                     
   1679                     //je¿eli nie znaleziono zadania dla wez³a przypisz pytanie standardowe
   1680                     if (ExstF==0)
   1681                     {
   1682                         AddRfTask(SI, i+1, 0);                //Dodaj pytanie standardowe do tablicy zadañ RF
   1683                     }
   1684                  }
   1685                  
   1686                }
   1687                 */
   1688               
   1689                
   1690                
   1691                          
   1692          }//_______________________ Koniec funkcji  SetTask_________________
   \                     ??SetTask_28:
   \   0000023A   0BB0               ADD      SP,SP,#+44
   \   0000023C   F0BC               POP      {R4-R7}
   \   0000023E   01BC               POP      {R0}
   \   00000240   0047               BX       R0               ;; return
   \   00000242   C046               Nop      
   \                     ??SetTask_2:
   \   00000244   ........           DC32     RF_TaskTab
   \   00000248   ........           DC32     NeuronsList
   \   0000024C   ........           DC32     Trap + 12
   \   00000250   ........           DC32     Trap
   \   00000254   ........           DC32     ScreenSetTab_0
   \   00000258   ........           DC32     ScreenSetTab_1
   \   0000025C   98BB0000           DC32     0xbb98
   \   00000260   ........           DC32     gProg
   1693          
   1694          
   1695          
   1696          
   1697          
   1698          
   1699          
   1700          
   1701          //-----------------------------------------------------------------------------
   1702          // Nazwa funkcji :    ProgramChangeSave
   1703          // Funkcja zapisu zmian w programie u¿ytkowym
   1704          //-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1705          void ProgramChangeExecute(_ProgramTab *ProgTab)
   1706          {
   \                     ProgramChangeExecute:
   \   00000000   31B5               PUSH     {R0,R4,R5,LR}
   \   00000002   0400               MOVS     R4,R0
   1707             //obliczenie iloœci u¿ywanych scen
   1708             NumberScene=SceneNrCount(ProgTab);
   \   00000004   094D               LDR      R5,??ProgramChangeExecute_0  ;; Trap
   \   00000006   ........           BL       SceneNrCount
   \   0000000A   2872               STRB     R0,[R5, #+8]
   1709             
   1710             //obliczenie iloœci u¿ywanych linii
   1711             CountLines(ProgTab);
   \   0000000C   2000               MOVS     R0,R4
   \   0000000E   ........           BL       CountLines
   1712             
   1713             //obliczenie iloœci u¿ywanych stron ekranowych
   1714             ScreenUse=CheckScreenUse(ProgTab);
   \   00000012   2000               MOVS     R0,R4
   \   00000014   ........           BL       CheckScreenUse
   \   00000018   2886               STRH     R0,[R5, #+48]
   1715             
   1716          
   1717             
   1718             //odœwierzenie/przepisanie listy neuronów
   1719             RefreshNeuronsList(ProgTab);
   \   0000001A   2000               MOVS     R0,R4
   \   0000001C   ........           BL       RefreshNeuronsList
   1720             
   1721             
   1722             //ustawienie zadañ Rs i RF
   1723             SetTask(ProgTab);
   \   00000020   2000               MOVS     R0,R4
   \   00000022   ........           BL       SetTask
   1724            
   1725          }//_______________________ Koniec funkcji zapisu zmian programu_________________
   \   00000026   38BC               POP      {R3-R5}
   \   00000028   01BC               POP      {R0}
   \   0000002A   0047               BX       R0               ;; return
   \                     ??ProgramChangeExecute_0:
   \   0000002C   ........           DC32     Trap
   1726          
   1727          
   1728          
   1729          
   1730          
   1731          
   1732          //*-----------------------------------------------------------------------------
   1733          //* Nazwa funkcji :    GetBinVarPack
   1734          //* Funkcja zwraca paczkê w tablicy wartoœci zmienncyh dwustanowych z zakresu B000 - B700
   1735          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1736          void GetBinVarPack(WORD adr, WORD Length,unsigned char *Tab )
   1737          {
   1738            /*
   1739                  WORD  RamByte=(adr/8);
   1740                  WORD  RamBit= (adr) % 8;
   1741                  char  CurentByte;
   1742                  char  CurentBit;  
   1743            
   1744              
   1745                for (WORD i=0; i<Length; i++)
   1746                      {
   1747                         Tab[CurentByte] &= ~(1<<CurentBit);
   1748                         Tab[CurentByte] |=  (((ram.BinVarRAM[RamByte]>>RamBit) & 0x1)<< CurentBit);
   1749                                   
   1750                         if (CurentBit<7) {CurentBit++;} else {CurentBit=0; CurentByte++;}
   1751                         if (RamBit<7) {RamBit++;} else {RamBit=0; RamByte++;}
   1752                      }  
   1753            
   1754           */
   1755          }//_______________________ Koniec funkcji GetBinVar ____________________________
   \                     GetBinVarPack:
   \   00000000   7047               BX       LR               ;; return
   1756          
   1757          
   1758          
   1759          
   1760          
   1761          
   1762          
   1763          
   1764          
   1765          //*-----------------------------------------------------------------------------
   1766          //* Nazwa funkcji :    GetBinVar
   1767          //* Funkcja przepisuje paczkê wartoœci zmiennych dwustanowej komunikacyjnej DA00 - DDFF do Tab
   1768          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1769          void GetBinVarPackComm(WORD adr, WORD Length, unsigned char* Tab )
   1770          {
   \                     GetBinVarPackComm:
   \   00000000   F7B5               PUSH     {R0-R2,R4-R7,LR}
   1771                  WORD  RamByte=adr;
   \   00000002   0021               MOVS     R1,#+0
   1772                  WORD  RamBit= 0;
   1773                  char  CurentByte = 0;
   \   00000004   0A00               MOVS     R2,R1
   1774                  char  CurentBit = 0;  
   \   00000006   0B00               MOVS     R3,R1
   1775          
   1776                  for (char i=0; i<16; i++)  {Tab[i]=0;}
   \   00000008   0C00               MOVS     R4,R1
   \   0000000A   0E00               MOVS     R6,R1
   \   0000000C   05E0               B        ??GetBinVarPackComm_0
   \                     ??GetBinVarPackComm_1:
   \   0000000E   2700               MOVS     R7,R4
   \   00000010   029D               LDR      R5,[SP, #+8]
   \   00000012   EE55               STRB     R6,[R5, R7]
   \   00000014   641C               ADDS     R4,R4,#+1
   \   00000016   2406               LSLS     R4,R4,#+24
   \   00000018   240E               LSRS     R4,R4,#+24
   \                     ??GetBinVarPackComm_0:
   \   0000001A   2500               MOVS     R5,R4
   \   0000001C   102D               CMP      R5,#+16
   \   0000001E   F6D3               BCC      ??GetBinVarPackComm_1
   1777               
   1778              
   1779                for (WORD i=0; i<Length; i++)
   \   00000020   0C00               MOVS     R4,R1
   \   00000022   06E0               B        ??GetBinVarPackComm_2
   1780                      {
   1781                         if ((ram.VarCom_Word[RamByte]>>RamBit) & 0x1) { Tab[CurentByte] |= 0x1<<CurentBit;} else {Tab[CurentByte] &= ~(0x1<<CurentBit);}
   1782                        
   1783                         
   1784                         if (CurentBit<7) {CurentBit++;} else {CurentBit=0; CurentByte++; Tab[CurentByte]=0;}
   1785                         if (RamBit<7) {RamBit++;} else {RamBit=0; RamByte++;}
   \                     ??GetBinVarPackComm_3:
   \   00000024   0021               MOVS     R1,#+0
   \   00000026   401C               ADDS     R0,R0,#+1
   \   00000028   0004               LSLS     R0,R0,#+16
   \   0000002A   000C               LSRS     R0,R0,#+16
   \                     ??GetBinVarPackComm_4:
   \   0000002C   641C               ADDS     R4,R4,#+1
   \   0000002E   2404               LSLS     R4,R4,#+16
   \   00000030   240C               LSRS     R4,R4,#+16
   \                     ??GetBinVarPackComm_2:
   \   00000032   2500               MOVS     R5,R4
   \   00000034   6E46               MOV      R6,SP
   \   00000036   B688               LDRH     R6,[R6, #+4]
   \   00000038   B542               CMP      R5,R6
   \   0000003A   2DD2               BCS      ??GetBinVarPackComm_5
   \   0000003C   0500               MOVS     R5,R0
   \   0000003E   6D00               LSLS     R5,R5,#+1
   \   00000040   174E               LDR      R6,??GetBinVarPackComm_6  ;; ram
   \   00000042   755B               LDRH     R5,[R6, R5]
   \   00000044   0D41               ASRS     R5,R5,R1
   \   00000046   ED07               LSLS     R5,R5,#+31
   \   00000048   08D5               BPL      ??GetBinVarPackComm_7
   \   0000004A   1500               MOVS     R5,R2
   \   0000004C   029E               LDR      R6,[SP, #+8]
   \   0000004E   7519               ADDS     R5,R6,R5
   \   00000050   2E78               LDRB     R6,[R5, #+0]
   \   00000052   0127               MOVS     R7,#+1
   \   00000054   9F40               LSLS     R7,R7,R3
   \   00000056   3743               ORRS     R7,R7,R6
   \   00000058   2F70               STRB     R7,[R5, #+0]
   \   0000005A   07E0               B        ??GetBinVarPackComm_8
   \                     ??GetBinVarPackComm_7:
   \   0000005C   1500               MOVS     R5,R2
   \   0000005E   029E               LDR      R6,[SP, #+8]
   \   00000060   7519               ADDS     R5,R6,R5
   \   00000062   2E78               LDRB     R6,[R5, #+0]
   \   00000064   0127               MOVS     R7,#+1
   \   00000066   9F40               LSLS     R7,R7,R3
   \   00000068   BE43               BICS     R6,R6,R7
   \   0000006A   2E70               STRB     R6,[R5, #+0]
   \                     ??GetBinVarPackComm_8:
   \   0000006C   1D00               MOVS     R5,R3
   \   0000006E   072D               CMP      R5,#+7
   \   00000070   03D2               BCS      ??GetBinVarPackComm_9
   \   00000072   5B1C               ADDS     R3,R3,#+1
   \   00000074   1B06               LSLS     R3,R3,#+24
   \   00000076   1B0E               LSRS     R3,R3,#+24
   \   00000078   07E0               B        ??GetBinVarPackComm_10
   \                     ??GetBinVarPackComm_9:
   \   0000007A   0023               MOVS     R3,#+0
   \   0000007C   521C               ADDS     R2,R2,#+1
   \   0000007E   1206               LSLS     R2,R2,#+24
   \   00000080   120E               LSRS     R2,R2,#+24
   \   00000082   1700               MOVS     R7,R2
   \   00000084   029D               LDR      R5,[SP, #+8]
   \   00000086   1E00               MOVS     R6,R3
   \   00000088   EE55               STRB     R6,[R5, R7]
   \                     ??GetBinVarPackComm_10:
   \   0000008A   0D00               MOVS     R5,R1
   \   0000008C   072D               CMP      R5,#+7
   \   0000008E   C9D2               BCS      ??GetBinVarPackComm_3
   \   00000090   491C               ADDS     R1,R1,#+1
   \   00000092   0904               LSLS     R1,R1,#+16
   \   00000094   090C               LSRS     R1,R1,#+16
   \   00000096   C9E7               B        ??GetBinVarPackComm_4
   1786                      }  
   1787          }//_______________________ Koniec funkcji GetBinVarComm ________________________
   \                     ??GetBinVarPackComm_5:
   \   00000098   FEBC               POP      {R1-R7}
   \   0000009A   01BC               POP      {R0}
   \   0000009C   0047               BX       R0               ;; return
   \   0000009E   C046               Nop      
   \                     ??GetBinVarPackComm_6:
   \   000000A0   ........           DC32     ram
   1788          
   1789          
   1790          //*-----------------------------------------------------------------------------
   1791          //* Nazwa funkcji :    GetRegPackComm
   1792          //* Funkcja przepisuje StageQ
   1793          //*   Adr - nr StageQ
   1794          //*   Reg - nr rejestru
   1795          //*   LengthBit - ile bitów do kopiowania je¿eli wiêcej ni¿ 16 to kopiuje z nastêpnego rejestru
   1796          //*-----------------------------------------------------------------------------

   \                                 In section Debug.txt, align 4, keep-with-next
   1797          void GetRegPackComm(short int  Adr, char Reg, char LengthBit, unsigned char* Tab )
   1798          {
   \                     GetRegPackComm:
   \   00000000   FDB5               PUSH     {R0,R2-R7,LR}
   1799                  WORD  RamWord=Reg;
   \   00000002   0C00               MOVS     R4,R1
   \   00000004   0023               MOVS     R3,#+0
   1800                  WORD  RamBitInWord= 0;
   1801                  char  CurentByte = 0;
   \   00000006   1900               MOVS     R1,R3
   1802                  char  CurentBit = 0;  
   \   00000008   0A00               MOVS     R2,R1
   1803           
   1804                  Adr+=1;
   \   0000000A   6D46               MOV      R5,SP
   \   0000000C   401C               ADDS     R0,R0,#+1
   \   0000000E   2880               STRH     R0,[R5, #+0]
   1805                  
   1806                  for (char i=0; i<16; i++)  {Tab[i]=0;}
   \   00000010   0800               MOVS     R0,R1
   \   00000012   0600               MOVS     R6,R0
   \   00000014   05E0               B        ??GetRegPackComm_0
   \                     ??GetRegPackComm_1:
   \   00000016   0700               MOVS     R7,R0
   \   00000018   029D               LDR      R5,[SP, #+8]
   \   0000001A   EE55               STRB     R6,[R5, R7]
   \   0000001C   401C               ADDS     R0,R0,#+1
   \   0000001E   0006               LSLS     R0,R0,#+24
   \   00000020   000E               LSRS     R0,R0,#+24
   \                     ??GetRegPackComm_0:
   \   00000022   0500               MOVS     R5,R0
   \   00000024   102D               CMP      R5,#+16
   \   00000026   F6D3               BCC      ??GetRegPackComm_1
   1807               
   1808              
   1809                for (WORD i=0; i<LengthBit; i++)
   \   00000028   0D00               MOVS     R5,R1
   \   0000002A   06E0               B        ??GetRegPackComm_2
   1810                      {
   1811                         if ((MainStage.StageQ[Adr].Value[RamWord]>>RamBitInWord) & 0x1) { Tab[CurentByte] |= 0x1<<CurentBit;} else {Tab[CurentByte] &= ~(0x1<<CurentBit);}
   1812                        
   1813                         
   1814                         if (CurentBit<7) {CurentBit++;} else {CurentBit=0; CurentByte++; Tab[CurentByte]=0;}
   1815                         if (RamBitInWord<15) {RamBitInWord++;} else {RamBitInWord=0; RamWord++;}
   \                     ??GetRegPackComm_3:
   \   0000002C   0023               MOVS     R3,#+0
   \   0000002E   641C               ADDS     R4,R4,#+1
   \   00000030   2404               LSLS     R4,R4,#+16
   \   00000032   240C               LSRS     R4,R4,#+16
   \                     ??GetRegPackComm_4:
   \   00000034   6D1C               ADDS     R5,R5,#+1
   \   00000036   2D04               LSLS     R5,R5,#+16
   \   00000038   2D0C               LSRS     R5,R5,#+16
   \                     ??GetRegPackComm_2:
   \   0000003A   2800               MOVS     R0,R5
   \   0000003C   6E46               MOV      R6,SP
   \   0000003E   3679               LDRB     R6,[R6, #+4]
   \   00000040   B042               CMP      R0,R6
   \   00000042   37D2               BCS      ??GetRegPackComm_5
   \   00000044   1D48               LDR      R0,??GetRegPackComm_6  ;; 0x3a2
   \   00000046   8446               MOV      R12,R0
   \   00000048   2000               MOVS     R0,R4
   \   0000004A   4600               LSLS     R6,R0,#+1
   \   0000004C   6F46               MOV      R7,SP
   \   0000004E   0020               MOVS     R0,#+0
   \   00000050   385E               LDRSH    R0,[R7, R0]
   \   00000052   1627               MOVS     R7,#+22
   \   00000054   7843               MULS     R0,R7,R0
   \   00000056   1A4F               LDR      R7,??GetRegPackComm_6+0x4  ;; MainStage
   \   00000058   3818               ADDS     R0,R7,R0
   \   0000005A   8619               ADDS     R6,R0,R6
   \   0000005C   6046               MOV      R0,R12
   \   0000005E   305E               LDRSH    R0,[R6, R0]
   \   00000060   1841               ASRS     R0,R0,R3
   \   00000062   C007               LSLS     R0,R0,#+31
   \   00000064   08D5               BPL      ??GetRegPackComm_7
   \   00000066   0800               MOVS     R0,R1
   \   00000068   029E               LDR      R6,[SP, #+8]
   \   0000006A   3018               ADDS     R0,R6,R0
   \   0000006C   0678               LDRB     R6,[R0, #+0]
   \   0000006E   0127               MOVS     R7,#+1
   \   00000070   9740               LSLS     R7,R7,R2
   \   00000072   3743               ORRS     R7,R7,R6
   \   00000074   0770               STRB     R7,[R0, #+0]
   \   00000076   07E0               B        ??GetRegPackComm_8
   \                     ??GetRegPackComm_7:
   \   00000078   0800               MOVS     R0,R1
   \   0000007A   029E               LDR      R6,[SP, #+8]
   \   0000007C   3018               ADDS     R0,R6,R0
   \   0000007E   0678               LDRB     R6,[R0, #+0]
   \   00000080   0127               MOVS     R7,#+1
   \   00000082   9740               LSLS     R7,R7,R2
   \   00000084   BE43               BICS     R6,R6,R7
   \   00000086   0670               STRB     R6,[R0, #+0]
   \                     ??GetRegPackComm_8:
   \   00000088   1000               MOVS     R0,R2
   \   0000008A   0728               CMP      R0,#+7
   \   0000008C   03D2               BCS      ??GetRegPackComm_9
   \   0000008E   521C               ADDS     R2,R2,#+1
   \   00000090   1206               LSLS     R2,R2,#+24
   \   00000092   120E               LSRS     R2,R2,#+24
   \   00000094   07E0               B        ??GetRegPackComm_10
   \                     ??GetRegPackComm_9:
   \   00000096   0022               MOVS     R2,#+0
   \   00000098   491C               ADDS     R1,R1,#+1
   \   0000009A   0906               LSLS     R1,R1,#+24
   \   0000009C   090E               LSRS     R1,R1,#+24
   \   0000009E   0F00               MOVS     R7,R1
   \   000000A0   0298               LDR      R0,[SP, #+8]
   \   000000A2   1600               MOVS     R6,R2
   \   000000A4   C655               STRB     R6,[R0, R7]
   \                     ??GetRegPackComm_10:
   \   000000A6   1800               MOVS     R0,R3
   \   000000A8   0F28               CMP      R0,#+15
   \   000000AA   BFD2               BCS      ??GetRegPackComm_3
   \   000000AC   5B1C               ADDS     R3,R3,#+1
   \   000000AE   1B04               LSLS     R3,R3,#+16
   \   000000B0   1B0C               LSRS     R3,R3,#+16
   \   000000B2   BFE7               B        ??GetRegPackComm_4
   1816                      }  
   1817          }//_______________________ Koniec funkcji GetRegPackComm ________________________
   \                     ??GetRegPackComm_5:
   \   000000B4   FEBC               POP      {R1-R7}
   \   000000B6   01BC               POP      {R0}
   \   000000B8   0047               BX       R0               ;; return
   \   000000BA   C046               Nop      
   \                     ??GetRegPackComm_6:
   \   000000BC   A2030000           DC32     0x3a2
   \   000000C0   ........           DC32     MainStage

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   ........           DC32     ZD_MODBUS_0

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   AA8A0000           DC32     0x8aaa

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable7:
   \   00000000   ........           DC32     VariablesAnal

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   A2030000           DC32     0x3a2

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   EA060000           DC32     0x6ea

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable13:
   \   00000000   ........           DC32     TransQuality

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable14:
   \   00000000   EB060000           DC32     0x6eb

   \                                 In section Debug.txt, align 4, keep-with-next
   \                     ??DataTable15:
   \   00000000   ........           DC32     Trap
   1818          
   1819          
   1820          
   1821          
   1822          
   1823          
   1824          //****************************************************************************//
   1825          //****************************************************************************//
   1826          //*************************** P R O C E D U R Y ******************************//
   1827          //****************************************************************************//
   1828          //****************************************************************************//
   1829          
   1830          
   1831          
   1832          
   1833          
   1834          
   1835          
   1836          
   1837          
   1838          
   1839          

   Maximum stack usage in bytes:

     Function                 .cstack
     --------                 -------
     AddRfTask                    32
     AddRsTask                    24
     CheckScreenUse               24
     CountLines                   24
     GetBinVarPack                 0
     GetBinVarPackComm            32
     GetRegPackComm               32
     PortStageRead                 0
     PortStageSet                  8
     ProcClock_Action              8
     ProcConect_Action             0
     ProcConstAnal_Action          0
     ProcDay_Action                8
     ProcDec_Action                8
     ProcDiv_Action               24
     ProcDownRight_Action          0
     ProcDown_Action               0
     ProcEven_Action               8
     ProcGetReg_Action            16
     ProcInc_Action               16
     ProcLim_Action                8
     ProcMinus_Action              0
     ProcMul_Action                8
     ProcNOT_Action                0
     ProcPlus_Action               0
     ProcSPK_Action               16
     ProcSetAnal_Action           16
     ProcSetScn_Action            16
     ProcStB_Action                8
     ProcStI_Action                8
     ProcStNI_Action               8
     ProcStQ_Action               16
     ProcStS_Action                8
     ProcSumL_Action               0
     ProcTLI1_Action               8
     ProcTimerSet_Action           8
     ProcToggleRS_Action           8
     ProcToggleT_Action            8
     ProcUpToRightDown_Action      0
     ProcUpToRight_Action          0
     ProcWOUTC_Action             24
     ProcWOUTR_Action             24
     ProcWOUTS_Action             24
     ProcWOUT_Action              24
     Program                      32
     ProgramChangeExecute         16
     RefreshNeuronsList           24
     SceneNrCount                 24
     SetModbusTask                 0
     SetTask                      64


   Section sizes:

     Function/Label           Bytes
     --------------           -----
     SceneBefOff                  1
     TransQuality               216
     ProgConvers_DW_F             4
     ButtonExe                  576
     gProg                    50800
     NeuronsList                420
     VariablesAnal               40
     MainStage                 1808
     SetModbusTask              110
     PortStageRead               10
     PortStageSet                24
     ProcStI_Action             106
     ProcStNI_Action            124
     ProcGetReg_Action           80
     ProcSetAnal_Action          54
     ProcConstAnal_Action         6
     ProcStB_Action              32
     ProcStQ_Action              48
     ProcStS_Action              34
     ProcWOUT_Action            248
     ProcWOUTS_Action           144
     ProcWOUTR_Action           144
     ProcWOUTC_Action           260
     ProcNOT_Action              14
     ProcToggleRS_Action         32
     ProcToggleT_Action          66
     ProcTLI1_Action             34
     ProcLim_Action              28
     ProcEven_Action             28
     ProcPlus_Action             12
     ProcMinus_Action            12
     ProcMul_Action              56
     ProcDiv_Action             124
     ProcConect_Action            6
     ProcDown_Action              6
     ProcDownRight_Action         6
     ProcUpToRight_Action         6
     ProcUpToRightDown_Action     6
     ProcSetScn_Action           84
     ProcInc_Action              60
     ProcDec_Action              60
     ProcSPK_Action             172
     ProcSumL_Action             10
     ProcTimerSet_Action         72
     ProcClock_Action           140
     ProcDay_Action              36
     Program                   1224
     Trap                        68
     pProg                        4
     SceneNrCount                68
     CheckScreenUse             140
     CountLines                  76
     RefreshNeuronsList         100
     AddRsTask                  184
     AddRfTask                  452
     SetTask                    612
     ProgramChangeExecute        48
     GetBinVarPack                2
     GetBinVarPackComm          164
     GetRegPackComm             196
     ??DataTable0                 4
     ??DataTable3                 4
     ??DataTable7                 4
     ??DataTable8                 4
     ??DataTable9                 4
     ??DataTable13                4
     ??DataTable14                4
     ??DataTable15                4

 
 53 865 bytes in section .bss
     72 bytes in section .data
  5 792 bytes in section Debug.txt
 
  5 792 bytes of CODE memory
 53 937 bytes of DATA memory

Errors: none
Warnings: 10
