###############################################################################
#                                                                             #
# IAR ARM ANSI C/C++ Compiler V5.10.5.372/W32           21/Jan/2010  09:23:33 #
# Copyright 1999-2007 IAR Systems. All rights reserved.                       #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  L:\Projekty\TP64128\TP64128-program\Framework\ScreenMENU #
#                    .c                                                       #
#    Command line =  L:\Projekty\TP64128\TP64128-program\Framework\ScreenMENU #
#                    .c -D AT91SAM7S256 -D AT91SAM7SEK -D iH -lC              #
#                    L:\Projekty\TP64128\TP64128-program\bin\cdc\AT91SAM7SEK\ #
#                    List\ --diag_suppress Pa082 -o                           #
#                    L:\Projekty\TP64128\TP64128-program\bin\cdc\AT91SAM7SEK\ #
#                    Obj\ --debug --endian little --cpu ARM7TDMI -e --fpu     #
#                    None --dlib_config "C:\Program Files\IAR                 #
#                    Systems\Embedded Workbench 5.0\ARM\INC\DLib_Config_Norma #
#                    l.h" -I L:\Projekty\TP64128\TP64128-program\lib\AT91SAM7 #
#                    S256\ -I L:\Projekty\TP64128\TP64128-program\lib\AT91SAM #
#                    7S64\ -I L:\Projekty\TP64128\TP64128-program\ -I         #
#                    L:\Projekty\TP64128\TP64128-program\cdc\ -I              #
#                    L:\Projekty\TP64128\TP64128-program\core\ -I             #
#                    L:\Projekty\TP64128\TP64128-program\startup\ -I          #
#                    L:\Projekty\TP64128\TP64128-program\Framework\ -I        #
#                    "C:\Program Files\IAR Systems\Embedded Workbench         #
#                    5.0\ARM\INC\" --section .text=Debug.txt --interwork      #
#                    --cpu_mode thumb -Ohs                                    #
#    List file    =  L:\Projekty\TP64128\TP64128-program\bin\cdc\AT91SAM7SEK\ #
#                    List\ScreenMENU.lst                                      #
#    Object file  =  L:\Projekty\TP64128\TP64128-program\bin\cdc\AT91SAM7SEK\ #
#                    Obj\ScreenMENU.o                                         #
#                                                                             #
#                                                                             #
###############################################################################

L:\Projekty\TP64128\TP64128-program\Framework\ScreenMENU.c
      1          //****************************************************************************//
      2          //*--------------------------------------------------------------------------*//
      3          //*                 IASE Microcontroller Software Support                    *//                       
      4          //*--------------------------------------------------------------------------*//
      5          //*--------------------------------------------------------------------------*//
      6          //*  Nazwa pliku                  : Screen.c                                 *//
      7          //*  Opis                         : Obsluga grafiki i ekranu dotykowego      *//
      8          //*  Autor                        : Pawe³ Narwojsz                           *//
      9          //*  Data utrzorzenia             : 19.09.2007                               *//
     10          //*  Data ostatniej modyfikacji   : --.--.----                               *//
     11          //*--------------------------------------------------------------------------*//
     12          //*                                                                          *//
     13          //*--------------------------------------------------------------------------*//
     14          //* Rejestr zmian  (data - opis):                                            *//
     15          //*                                                                          *//
     16          //*                               Brak zmian                                 *//
     17          //*                                                                          *//
     18          //*__________________________________________________________________________*// 
     19          //****************************************************************************//
     20          //****************************************************************************//
     21          
     22          #ifndef iH
     23          
     24          
     25          
     26          #include "ScreenMENU.h"
     27          #include "Framework.h "
     28          #include "Language.h"
     29          #include "core/device.h"                                                        //³aduje bibliotreki dla odpowiedniego procesora
     30          #include "LCD.h"
     31          #include "ProgramH.h"
     32          
     33          
     34          extern char text[10];
     35          extern char text1[10];
     36          extern char text2[10];
     37          extern char text3[10];
     38          extern char text4[10];
     39          extern char text5[10];
     40          extern char text6[10];
     41          extern char text7[10];
     42          extern char textVal1[8];
     43          extern char textVal2[8];
     44          extern char textVal3[8];
     45          extern char textVal4[8];
     46          extern char textVal5[8];
     47          extern char textVal6[8];
     48          extern char textVal7[8];
     49          
     50          
     51          extern char LCD_Canvas[8][128];
     52          extern int CyklPerSek;
     53          extern char g_level;
     54          extern char g_Password_1[8];
     55          extern char g_Password_2[8];
     56          extern char g_Message;
     57          extern char g_US0_Connect_OK;
     58          extern char g_US1_Connect_OK;
     59          extern RAM ram;
     60          
     61          extern    int dzien;
     62          extern    int mies;
     63          extern    int rok;
     64          extern    int godz;
     65          extern    int mi;
     66          extern    int sek;
     67          
     68          
     69          extern int FlashProgramOfset;
     70          extern int FlashProgramReserveOfset;
     71          
     72          char MainSide_puls=0;
     73          
     74          
     75          int MenuLevel=0;      //poziom menu
     76          
     77          extern char ekran_komunikacja[8][128];
     78          extern int X_down;
     79          extern int Y_down;
     80          extern int X_up;
     81          extern int Y_up;
     82          extern int  g_leng;
     83          extern LangTab Speech[2];
     84          extern char g_PC_Connected;
     85          
     86          extern void Label (char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw);
     87          extern char FloToStr (float Value, char Vstring[8],char ill) ;
     88          
     89          float wartosc_tmp;
     90          char text_label_tmp[10];
     91          
     92          
     93          char Label_move = 0;
     94          int Suw_poz_IO=0;
     95          int Suw_poz_analog=0;
     96          int Suw_poz_dwustan=0;
     97          int Suw_poz_monit=0;
     98          int ScrollMenu_poz=-1;
     99          int ScrollMenu_Paint_exist=-1;
    100          int Rej_poz=0;
    101          char CyklMonit=0;
    102          
    103          int Monitoring_array[30][2]; //tablica monitoringu 1 kol - adres, 2 kol- typ (0 analog, 1 dwustan, 2 IO)
    104          int Monit_Size_scroll=0;
    105          
    106          //*-----------------------------------------------------------------------------
    107          //* Nazwa funkcji :    ScreenEvent
    108          //* Funkcja wrysowania menu ekranowego
    109          //*-----------------------------------------------------------------------------
    110          //* Efekt widoczny po odœwierzeniu LCD (RepaintLCD)
    111          //*-----------------------------------------------------------------------------
    112          
    113          void MenuPaint(void)
    114          {
    115            
    116            if (g_Message==0) 
    117            switch (MenuLevel)
    118            {
    119              case 0        : MainSide_Paint();         break;
    120              case 1        : MainSide_Paint();         break;
    121                  case 11     : MenuSide_Paint();         break; 
    122                      case 111   : MenuAccess_Paint();    break;
    123                          case 1112 : MenuAccessPass_Paint(1); break;
    124                          case 1113 : MenuAccessPass_Paint(2); break;
    125                      case 112   : Sygnal_Paint();    break;
    126                          case 1121   : MonitoringSide_Paint();    break;
    127                          case 1122   : IO_Side_Paint();    break;
    128                              case 11221   : ScrollMenu_Paint(&Suw_poz_IO, 10, 2); break;
    129                                  case 112211   :  Forse_Paint(2); break;
    130                                  case 112213   :  AddToMonitoring(2,ScrollMenu_poz); break;
    131                          case 1123   : ZM_AnalogSide_Paint();    break;  //zmienne analog
    132                              case 11231   : ScrollMenu_Paint(&Suw_poz_analog, 10, 0); break;
    133                                  case 112311   :  Forse_Paint(0); break;
    134                                  case 112313   :  AddToMonitoring(0,ScrollMenu_poz); break;
    135                          case 1124   : ZM_DwustanSide_Paint();    break;
    136                              case 11241   : ScrollMenu_Paint(&Suw_poz_dwustan, 10, 1); break;
    137                                  case 112411   :  Forse_Paint(1); break;
    138                                  case 112413   :  AddToMonitoring(1,ScrollMenu_poz); break;
    139                      case 113   : Rejestrator_Paint();        break;  
    140                      case 114   : Info_Paint();             break;   
    141                      case 115   : Options_Paint();          break;  
    142                          case 1151 : Ask_Paint("Restart",Speech[g_leng].Potwierdz,0);  break;
    143                          case 1152 : Ask_Paint(Speech[g_leng].Odforsuj,Speech[g_leng].Potwierdz,0);  break;
    144                          case 1153 : Ask_Paint(Speech[g_leng].CzyscRej,Speech[g_leng].Potwierdz,0);  break;
    145                      case 116   : Setup_Paint();            break;
    146                          case 1161 : SetupLang_Paint();         break;
    147                          case 1162 : SetupTime_Paint();        break;  
    148                          case 1163 : SetupPass_Paint();         break;
    149                              case 11641 : SetupOldPass_Paint();         break;
    150                                  case 116411 : SetupNewPass_Paint();         break;
    151                              case 11642 : SetupOldPass_Paint();         break;
    152                                  case 116421 : SetupNewPass_Paint();         break;        
    153                          
    154                  
    155            }
    156             
    157          }//_______________________ Koniec funkcji ScreenEvent __________________________
    158          
    159          
    160          
    161          
    162          
    163          //*-----------------------------------------------------------------------------
    164          //* Nazwa funkcji :    ScreenEvent
    165          //* Funkcja obs³ugi zdarzenia menu ekranowego
    166          //*-----------------------------------------------------------------------------
    167          //* Efekt widoczny po odœwierzeniu LCD (RepaintLCD)
    168          //*-----------------------------------------------------------------------------
    169          void ScreenEvent(void)
    170          {
    171            if (g_Message==0)
    172            {
    173            switch (MenuLevel)
    174            {
    175              
    176              case 0     : MainSide_Event();              break;
    177              case 1     : MainSide_Event();              break;
    178          
    179                   case 11  : MenuSide_Event();              break; 
    180                      case 111  : MenuAccess_Event();    break; 
    181                           case 1112  : MenuAccessPass_Event(1);    break; 
    182                           case 1113  : MenuAccessPass_Event(2);    break; 
    183                      case 112   : Sygnal_Event();    break;
    184                           case 1121  : MonitoringSide_Event();    break; 
    185                           case 1122  : IO_Side_Event();    break; 
    186                                case 11221   : ScrollMenu_Event(2); break;
    187                                    case 112211   :  Forse_Event(2,ScrollMenu_poz); break;
    188                           case 1123  : ZM_AnalogSide_Event();    break; 
    189                                case 11231   : ScrollMenu_Event(0); break;
    190                                    case 112311   :  Forse_Event(0,ScrollMenu_poz); break;
    191                           case 1124  : ZM_DwustanSide_Event();    break; 
    192                                case 11241   : ScrollMenu_Event(1); break;
    193                                    case 112411   :  Forse_Event(1,ScrollMenu_poz); break;
    194                      case 113  : Rejestrator_Event();        break;
    195                      case 114  : Info_Event();             break;
    196                      case 115  : Options_Event();          break; 
    197                            case 1151 : Restart_Event();          break; 
    198                            case 1152 : Unforce_Event();          break; 
    199                            case 1153 : CleanReg_Event();          break; 
    200                      case 116  : Setup_Event();            break; 
    201                            case 1161 : SetupLang_Event();         break;
    202                            case 1162 : SetupTime_Event();        break;
    203                            case 1163 : SetupPass_Event();         break;
    204                                  case 11641 : SetupOldPass_Event(1);         break;
    205                                       case 116411 : SetupNewPass_Event(1);         break;
    206                                  case 11642 : SetupOldPass_Event(2);         break;
    207                                       case 116421 : SetupNewPass_Event(2);         break;
    208          
    209            } 
    210            }
    211            else
    212            {
    213              if ((X_up>0) && (Y_up>0)  )
    214              {
    215                  g_Message=0;
    216                  MenuPaint();
    217              }
    218            }
    219          
    220          }//_______________________ Koniec funkcji ScreenEvent __________________________
    221          
    222          
    223          
    224          
    225          
    226          //*-----------------------------------------------------------------------------
    227          //* Nazwa funkcji :    ScreenEvent
    228          //* Funkcja wrysowania menu ekranowego
    229          //*-----------------------------------------------------------------------------
    230          //* Efekt widoczny po odœwierzeniu LCD (RepaintLCD)
    231          //*-----------------------------------------------------------------------------
    232          
    233          void MenuRefresh(Void)
    234          {
    235            if (g_Message==0)
    236            switch (MenuLevel)
    237            {
    238              case 0        : MainSide_Refresh();         break;
    239              case 1        : MainSide_Refresh();         break;
    240                case 1121        : MonitoringSide_Paint();    break;
    241                case 1122        : IO_Side_Paint();    break;
    242                case 1123        : ZM_AnalogSide_Paint();         break;
    243                case 1124        : ZM_DwustanSide_Event();    break; 
    244                case 114   : Info_Refresh();             break; 
    245                    case 1162 : SetupTime_Refresh();        break;
    246            }
    247             
    248          }//_______________________ Koniec funkcji ScreenEvent __________________________
    249          
    250          
    251          
    252          
    253          
    254          //*-----------------------------------------------------------------------------
    255          //* Nazwa funkcji :    MainSide_Paint
    256          //* Funkcja strony g³ównej menu
    257          //*-----------------------------------------------------------------------------
    258          //* Efekt widoczny po odœwierzeniu LCD (RepaintLCD)
    259          //*-----------------------------------------------------------------------------
    260          void MainSide_Paint(void)
    261          {
    262          
    263             char ekran_komunikacja[8][128] = {
    264                                               {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,240,88,88,88,88,88,80,88,88,88,88,88,80,88,88,88,88,88,80,88,88,88,88,88,80,88,88,88,88,88,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    265                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,127,127,127,127,127,127,127,127,127,127,127,127,127,127,0,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    266                            {248,12,244,244,244,228,228,228,228,244,244,244,12,248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,13,13,13,13,13,5,13,45,77,141,141,5,13,13,13,13,13,5,13,13,13,13,13,5,13,13,13,13,13,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    267                            {255,0,255,35,119,119,87,87,39,39,35,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,2,2,2,4,132,72,48,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    268                            {255,0,255,2,119,247,215,199,215,119,2,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,2,4,168,80,160,66,157,29,157,134,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    269                            {255,0,255,145,155,171,171,171,179,179,17,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,124,248,170,85,170,0,255,252,255,0,254,254,254,254,254,254,254,254,254,254,254,254,254,254,254,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    270                            {255,0,255,199,187,187,187,187,187,187,17,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,255,255,128,0,162,69,170,0,255,240,255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    271                            {63,96,95,95,95,79,79,79,79,95,95,95,96,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,7,14,29,58,48,63,3,63,32,47,47,47,47,47,47,47,47,47,47,47,47,47,47,47,32,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    272                            };
    273            CopyToCanvas(ekran_komunikacja);
    274          
    275            
    276            //Komunikacja z komputerem
    277            if (g_PC_Connected==0)
    278            {
    279          
    280          
    281            char ekran_tab[8][128] = {
    282                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,224,240,248,252,252,126,62,62,63,63,63,63,63,127,255,255,255,254,254,254,252,252,248,240,224,128,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,248,8,8,8,8,8,8,8,248,0,0,0,192,64,64,192,64,64,192,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    283                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,183,50,122,90,158,142,143,0,0,252,255,255,255,255,255,255,204,204,204,204,204,204,204,12,28,220,220,220,220,220,28,255,255,255,255,255,255,252,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,15,8,8,8,8,8,8,8,15,0,0,0,71,64,64,71,64,64,247,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    284                            {248,12,244,244,244,228,228,228,228,244,244,244,12,248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,247,147,195,227,115,51,231,0,0,255,255,255,255,255,255,255,247,119,119,119,119,119,247,240,112,115,123,123,123,123,252,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,254,2,2,2,2,2,2,2,254,0,0,0,68,68,68,124,68,68,69,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    285                            {255,0,255,35,119,119,87,87,39,39,35,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,240,25,25,24,24,25,189,0,0,255,255,255,255,255,255,255,0,0,28,30,30,30,31,1,0,128,252,252,60,56,0,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,3,2,2,2,2,2,2,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    286                            {255,0,255,2,119,247,215,199,215,119,2,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,29,29,1,1,129,3,0,0,255,255,255,255,255,255,255,7,6,134,134,134,134,134,6,7,199,199,199,199,199,7,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,248,8,8,8,8,8,8,8,248,0,0,0,68,68,36,60,68,68,60,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    287                            {255,0,255,145,155,171,171,171,179,179,17,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,199,99,99,99,99,99,194,0,0,255,255,255,255,255,255,255,240,240,255,127,127,63,63,48,48,63,127,127,255,255,240,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,15,8,8,8,8,8,8,8,15,0,0,0,6,9,232,38,65,137,6,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    288                            {255,0,255,199,187,187,187,187,187,187,17,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,227,198,198,198,198,230,131,0,0,63,255,255,255,255,255,255,7,1,0,0,0,0,0,0,0,0,0,0,0,1,7,255,255,255,255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,254,2,2,2,2,2,2,2,254,0,0,0,25,165,37,153,165,165,153,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    289                            {63,96,95,95,95,79,79,79,79,95,95,95,96,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,7,15,31,63,63,127,124,120,240,240,224,224,224,224,224,240,240,120,124,127,63,63,31,15,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,3,2,2,2,2,2,2,2,3,0,0,0,3,4,4,4,3,0,7,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    290                            };
    291             
    292              
    293            CopyToCanvas(ekran_tab);
    294            
    295            }
    296            else
    297            {
    298              char ekran_komunikacja[8][128] = {
    299                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,44,44,44,44,44,40,44,172,172,172,172,168,172,172,172,172,172,168,172,172,172,44,44,40,44,44,44,44,44,248,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,248,8,8,8,8,8,8,8,248,0,0,0,192,64,64,192,64,64,192,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    300                            {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,128,128,128,128,128,128,128,191,191,191,191,191,191,191,191,191,191,191,191,191,191,128,128,128,128,128,128,128,128,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,15,8,8,8,8,8,8,8,15,0,0,0,71,64,64,71,64,64,247,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    301                            {248,12,244,244,244,228,228,228,228,244,244,244,12,248,0,0,0,0,0,0,0,0,0,0,0,0,0,3,6,6,6,6,6,2,6,22,38,70,70,130,134,6,6,6,6,2,6,6,6,6,6,2,6,6,6,6,6,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,254,2,2,2,2,2,2,2,254,0,0,0,68,68,68,124,68,68,69,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    302                            {255,0,255,35,119,119,87,87,39,39,35,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,128,0,0,0,1,1,1,130,194,164,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,3,2,2,2,2,2,2,2,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    303                            {255,0,255,2,119,247,215,199,215,119,2,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,1,2,84,168,80,33,206,14,206,67,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,192,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,248,8,8,8,8,8,8,8,248,0,0,0,68,68,36,60,68,68,60,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    304                            {255,0,255,145,155,171,171,171,179,179,17,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,62,124,85,170,85,0,255,126,255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,15,8,8,8,8,8,8,8,15,0,0,0,6,9,232,38,65,137,6,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    305                            {255,0,255,199,187,187,187,187,187,187,17,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,127,255,192,128,81,162,85,0,255,248,255,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,254,2,2,2,2,2,2,2,254,0,0,0,25,165,37,153,165,165,153,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    306                            {63,96,95,95,95,79,79,79,79,95,95,95,96,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,3,7,14,29,24,31,1,31,16,23,23,23,23,23,23,23,23,23,23,23,23,23,23,23,16,31,0,0,0,0,0,0,0,0,0,0,0,0,0,255,0,0,0,0,3,2,2,2,2,2,2,2,3,0,0,0,3,4,4,4,3,0,7,0,0,0,0,255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
    307                            };
    308              CopyToCanvas(ekran_komunikacja);
    309            }
    310              
    311              
    312          }//_______________________ Koniec funkcji MainSide_Paint __________________________
    313          
    314          
    315          
    316          
    317          
    318          //*-----------------------------------------------------------------------------
    319          //* Nazwa funkcji :    MainSide_Paint
    320          //* Funkcja strony g³ównej menu
    321          //*-----------------------------------------------------------------------------
    322          //* Efekt widoczny po odœwierzeniu LCD (RepaintLCD)
    323          //*-----------------------------------------------------------------------------
    324          void MainSide_Event(void)
    325          {
    326             char podswietl=0; 
    327            
    328              if ((X_up>18) && (X_up<62) && (Y_up>0) && (Y_up<13))
    329              {
    330                MenuLevel=11;
    331                MenuPaint();
    332              }
    333              
    334              
    335               //zdarzenie typu down
    336              if ((X_down>18) && (X_down<62) && (Y_down>0) && (Y_down<13))    //"X"
    337              {
    338                MainSide_Paint();
    339                H_line(19,1,44,2);
    340                H_line(19,12,44,2); 
    341                V_line(19,2,10,2); 
    342                V_line(61,2,10,2); 
    343                
    344                podswietl=1;
    345              }
    346              
    347              if ((X_down>=0) && (X_down<64) && (podswietl==0)) MenuPaint();
    348              
    349               
    350          }//_______________________ Koniec funkcji MainSide_Event __________________________
    351          
    352          
    353          
    354          
    355          //*-----------------------------------------------------------------------------
    356          //* Nazwa funkcji :    MainSide_Refresh
    357          //* Funkcja strony g³ównej menu
    358          //*-----------------------------------------------------------------------------
    359          //* Efekt widoczny po odœwierzeniu LCD (RepaintLCD)
    360          //*-----------------------------------------------------------------------------
    361          void MainSide_Refresh(void)
    362          {
    363          
    364            char time_char[9];
    365             
    366             if ((MainSide_puls==0) || (MainSide_puls>1))
    367              { 
    368                char ekran1[2][13] = {
    369                           {0,0,224,24,232,244,244,244,232,24,224,0,0},
    370                            {0,0,0,3,2,5,5,5,2,3,0,0,0}
    371                            };
    372                
    373                for (char i=0; i<=12; i++)
    374                {
    375                   
    376                    LCD_Canvas[0][i]=ekran1[0][i];
    377                    LCD_Canvas[1][i]=ekran1[1][i];
    378                }
    379                
    380              }
    381              if ((MainSide_puls==1))
    382              {
    383                
    384                
    385                char ekran2[2][13] = {
    386                            {240,28,230,250,251,253,253,253,251,250,230,28,240},
    387                            {1,7,12,11,27,23,23,23,27,11,12,7,1},
    388                            };
    389                
    390                for (char i=0; i<=12; i++)
    391                {
    392                   
    393                    LCD_Canvas[0][i]=ekran2[0][i];
    394                    LCD_Canvas[1][i]=ekran2[1][i];
    395                }         
    396              }
    397               
    398             if (MainSide_puls>3) {MainSide_puls=0;} else {MainSide_puls++;}    
    399             TimeToStr(godz,mi,sek,time_char);
    400              time_char[8]=0;
    401             //Label(time_char,0,30,110,8,33,1,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
    402             Label(time_char,0,17,109,8,43,1,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
    403          
    404             
    405             DateToStr(dzien,mies,rok,time_char);//(char dzin, char mies, char rok, char Vstring[8])
    406             time_char[8]=0;
    407             Label(time_char,0,30,120,8,33,1,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
    408          
    409             
    410             //oznaczenia aktywnoœci UARTów
    411             if (g_US0_Connect_OK)  {CleanCanvasArea(37,85,5,5,1);} else {CleanCanvasArea(37,85,5,5,0);} //(char X, char Y, char X_Lenght, char Y_Lenght, char Colour)  
    412             if (g_US1_Connect_OK)  {CleanCanvasArea(51,85,5,5,1);} else {CleanCanvasArea(51,85,5,5,0);} //(char X, char Y, char X_Lenght, char Y_Lenght, char Colour)  
    413             
    414            
    415          }//_______________________ Koniec funkcji MainSide_Refresh __________________________
    416          
    417          
    418          
    419          
    420          
    421          
    422          
    423          //******************************************************************************************************************************
    424          //******************************************************************************************************************************
    425          //******************************************************************************************************************************
    426          //******************************************************************************************************************************
    427          //******************************************************************************************************************************
    428          
    429          
    430          
    431          
    432          
    433          
    434          
    435          
    436          
    437          
    438          //*-----------------------------------------------------------------------------
    439          //* Nazwa funkcji :    Scroll_Event
    440          //* Funkcja strony g³ównej menu
    441          //* max -  maksymalna liczba pól 
    442          //*-----------------------------------------------------------------------------
    443          //*-----------------------------------------------------------------------------
    444          char Scroll_List_select;
    445          char Scroll_Event(int Size_scroll, int *_Suw_poz, char max)
    446          {
    447              Scroll_List_select=0;
    448              char move=((*_Suw_poz)%20);
    449                 //zdarzenie typu down "X"
    450              if ((X_down>1) && (X_down<12) && (Y_down>115) && (Y_down<127))    //"X"
    451              {
    452                  H_line(3,117,7,0);
    453                  H_line(3,124,7,0); 
    454                  V_line(3,118,6,0); 
    455                  V_line(10,118,6,0); 
    456                return 0;
    457           
    458              }
    459              
    460              if ((X_up>1) && (X_up<12) && (Y_up>115) && (Y_up<126))
    461               {
    462                  MenuLevel=(MenuLevel/10);
    463                  return 1;
    464               }  
    465            
    466            
    467              //zdarzenie typu down
    468          
    469              
    470              
    471              int Y_down_tmp=(127-(((127-(Y_down+14-move))/20)*20)-13+move);
    472              if ((X_down>1) && (X_down<42) && (Y_down_tmp<115) && ((Y_down_tmp-18)>1))  
    473              {      
    474                Scroll_List_select=1;
    475                return 1;
    476              }
    477              
    478              //zdarzenie typu up 
    479              //int Y_up_tmp=(127-(((127-(Y_up+14-move))/20)*20)-13+move);
    480              if ((X_up>1) && (X_up<42) && (Y_up<115) && ((Y_up-18)>1))  
    481              {    
    482                char odp = ((127-(Y_up+14-move))/20)+2;
    483                if (odp>max) odp=0;
    484                return odp;
    485              }
    486            
    487            if (Size_scroll>50)
    488            {
    489              //przycisk dó³
    490              if ((X_down>53) && (X_down<63) && (Y_down>0) && (Y_down<16))
    491              {
    492                if ((*_Suw_poz)<Size_scroll) (*_Suw_poz)++;
    493                return 1;
    494              }
    495              //przycisk góra
    496              if ((X_down>53) && (X_down<63) && (Y_down>98) && (Y_down<113))
    497              {
    498                if ((*_Suw_poz)>0) (*_Suw_poz)--;
    499                return 1;
    500              }
    501          
    502              //obszar scroll`a
    503              
    504              int Y_down_TMP=98-((*_Suw_poz*67)/Size_scroll)-7;
    505              if ((Y_down>Y_down_TMP-7) && (Y_down<Y_down_TMP+7) && (X_down>53) && (X_down<63) && (Y_down>16) && (Y_down<98))
    506              { 
    507                
    508                
    509                *_Suw_poz=Size_scroll-(((Y_down-16-7)*Size_scroll)/69);;
    510                if (Y_down<25) *_Suw_poz=Size_scroll;
    511                if (Y_down>91) *_Suw_poz=0;      
    512                return 1;
    513              }
    514            }
    515          
    516              MenuPaint();
    517              return 0;
    518                 
    519          }//_______________________ Koniec funkcji Scroll_Event __________________________
    520          
    521          
    522          
    523          //******************************************************************************************************************************
    524          //******************************************************************************************************************************
    525          //******************************************************************************************************************************
    526          //******************************************************************************************************************************
    527          //******************************************************************************************************************************
    528          
    529          
    530          
    531          
    532          
    533          
    534          
    535          
    536          
    537          //Lista MENU ******************************************************************************************************************
    538          
    539          
    540                //*-----------------------------------------------------------------------
    541                void MenuSide_Paint(void)
    542                {
    543                  char il;
    544                  if (g_level) {il=6;} else {il=4;}
    545          
    546                  List_Paint("MENU",il,15,0,0,3, Speech[g_leng].PoziomDost, Speech[g_leng].Sygnaly, Speech[g_leng].Rejestr, Speech[g_leng].Info, Speech[g_leng].Opcje , Speech[g_leng].Ustawienia,0,0); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char algin, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])
    547          
    548                  
    549                }//_______________________ Koniec funkcji MainSide_Paint __________________________
    550          
    551          
    552          
    553                //*-----------------------------------------------------------------------
    554                void MenuSide_Event(void)
    555                {
    556                  //char podswietl=0;
    557                  int ans;
    558                  
    559                  char il;
    560                  if (g_level) {il=6;} else {il=4;}
    561           
    562                  ans=List_Event(X_up, Y_up, X_down, Y_down, il , 15, 0,0); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
    563            
    564                  if (ans)
    565                    {
    566                    if ((ans>0) && (ans<=il)) MenuLevel=(MenuLevel*10+ans);
    567                    if (ans<0) MenuLevel=(MenuLevel/10);
    568                    MenuPaint();
    569                    } 
    570                }//_______________________________________________________________________
    571          
    572          
    573          
    574          
    575          
    576          //Wybór poziomu dostêpu *************************************************************************************************************
    577                //*-----------------------------------------------------------------------
    578                void MenuAccess_Paint(void)
    579                {
    580                    #define  Y   4   //przesuniêcie w dó³
    581                    List_Paint("X",3,15,Y,5,0,Speech[g_leng].Poziom1, Speech[g_leng].Poziom2,  Speech[g_leng].Poziom3,0,0,0,0,0 ); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char algin, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])      
    582                    char ekran_tab[10] =  {0,4,4,10,11,16,16,32,64,0};
    583                    CopyToCanvasPoint((char *)ekran_tab,49,97-Y-(15*(g_level)),8,10); 
    584                }//_______________________ Koniec funkcji MainSide_Paint __________________________
    585          
    586          
    587          
    588                //*-----------------------------------------------------------------------
    589                void MenuAccess_Event(void)
    590                {
    591                  #define  Y   4   //przesuniêcie w dó³
    592                  int ans;
    593           
    594                  ans=List_Event(X_up, Y_up, X_down, Y_down, 3 , 15, 5,Y); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
    595            
    596                  if (ans)
    597                    {
    598                      if ((ans>0) && (ans<4))
    599                      {
    600                        if (ans>1)
    601                        {
    602                          MenuLevel=(MenuLevel*10+ans);
    603                          MenuPaint();
    604                         
    605                        }
    606                        else
    607                        {
    608                           MenuLevel=(MenuLevel/10);
    609                           g_level=ans-1;
    610                           Message_Paint(2,0,0,Speech[g_leng].Poziom1,0,0);
    611                        }
    612                      }
    613                      
    614                    }
    615                  else
    616                    {
    617                      if ((X_up>0) &&(Y_up>0)) 
    618                      {
    619                        MenuLevel=(MenuLevel/10);
    620                        MenuPaint();
    621                      }
    622                    }
    623                }//_______________________________________________________________________
    624          
    625          
    626          
    627          
    628          
    629          //has³o poziomu 1/2*************************************************************************************************************
    630          
    631          
    632                //*-----------------------------------------------------------------------
    633          char InsertPass1[9]= {0,0,0,0,0,0,0,0,0};
    634                void MenuAccessPass_Paint(char level)
    635                {
    636                   Number_Paint(Speech[g_leng].Wpisz,"C","E");
    637                    
    638                   if (level==1) Label(Speech[g_leng].Haslo,0,3,102,15,58,0,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
    639                   if (level==2) Label(Speech[g_leng].Haslo,0,3,102,15,58,0,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
    640                   
    641                   
    642                }//_______________________ Koniec funkcji MainSide_Paint __________________________
    643          
    644          
    645          
    646                //*-----------------------------------------------------------------------
    647                void MenuAccessPass_Event(char level)
    648                {
    649                  int ans;
    650                  char roz=0;
    651                  char pass_tmp[9]={0,0,0,0,0,0,0,0,0};
    652                  
    653                  ans=Number_Event(X_up, Y_up, X_down, Y_down); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
    654            
    655                  if (ans>0)          {
    656                      MenuPaint();
    657                      if (InsertPass1[8]<=7) 
    658                      { 
    659                          if ((ans<10) || (ans==11)) 
    660                          {
    661                            if (ans<10) InsertPass1[InsertPass1[8]]=ans+48;
    662                            if (ans==11) InsertPass1[InsertPass1[8]]=ans+37;
    663                            InsertPass1[8]++;
    664                          }
    665                          
    666                      }
    667                      if ((ans==10) && (InsertPass1[8]>0) ) {InsertPass1[8]--; InsertPass1[InsertPass1[8]]=0;}
    668                      
    669                      
    670                     char InsertPassVar=0;
    671                     for (char i=0; i<=8; i++)  pass_tmp[i]=0;
    672                     while ((InsertPass1[InsertPassVar]) &&  (InsertPassVar<8))
    673                     {
    674                       pass_tmp[InsertPassVar]=42; //42="*"
    675                       InsertPassVar++;
    676                     }
    677                     Label(pass_tmp,2,4,90,8,55,0,127,0);//(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
    678          
    679                      
    680                      //Sprawdzenie has³a
    681                      if (ans==12)
    682                      {
    683                        roz=0;
    684                        for (int i=0; i<=7; i++)
    685                        {
    686                            if ((g_Password_1[i]!=InsertPass1[i]) && (level==1)) roz=1;
    687                            if ((g_Password_2[i]!=InsertPass1[i]) && (level==2)) roz=1;
    688                        }
    689                        
    690                        
    691                        if (roz==0)                                 //je¿eli poprawne haslo
    692                        {
    693                           MenuLevel=(MenuLevel/100);
    694                           g_level=level;         //poziom dostêpu 1
    695                           for (int i=0; i<=7; i++) InsertPass1[i]=0;
    696                           InsertPass1[8]=0;
    697                           if (level==1)  Message_Paint(2,0,0,Speech[g_leng].Poziom2,0,0);
    698                           if (level==2)  Message_Paint(2,0,0,Speech[g_leng].Poziom3,0,0);
    699                        } 
    700                        else
    701                        {
    702                           //informacja o b³ednym haœle
    703                          for (int i=0; i<=7; i++) InsertPass1[i]=0;
    704                           InsertPass1[8]=0;
    705                        
    706                           Message_Paint(2,0,Speech[g_leng].Bledne,Speech[g_leng].haslo,0,0);
    707                        }
    708                        //MenuPaint();
    709                      }
    710                    }
    711          
    712                  if (ans<0)
    713                    {
    714                        MenuLevel=(MenuLevel/100);
    715                        MenuPaint();
    716                        for (int i=0; i<=7; i++) InsertPass1[i]=0;
    717                        InsertPass1[8]=0;
    718                    }
    719                 
    720                }//_______________________________________________________________________
    721          
    722          
    723                
    724          //rejestrator **************************************************************************************************************
    725                char max_poz_wpisu=0;
    726                //*----------------------------------------------------------------------------
    727                void Rejestrator_Paint(void)
    728                {  
    729                   // List_Paint(Speech[g_leng].Info,1,105,0,0,1," "); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char algin, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])
    730                
    731                  
    732                   
    733          
    734                ConversB_DW_Wpis ConversWpis;
    735          
    736                int Label_move_tmp=Rej_poz;
    737                int wartosc_scroll=0;
    738                
    739                Label_move=Label_move_tmp%10; 
    740                wartosc_scroll=Rej_poz/10;
    741          
    742                char *memory_read;
    743                memory_read=(char*)(AT91C_IFLASH_MEM->Rejestr);
    744                char poz_wpisu =memory_read[0]; 
    745                
    746                unsigned long long *memory_read_L;
    747                memory_read_L=(unsigned long long*)(AT91C_IFLASH_MEM->Rejestr);
    748                
    749                
    750               // ScrollList_Paint(Speech[g_leng].Rejestr, 230 , &Rej_poz , 1);  //(char name[10], char Size_scroll, char _Suw_poz, char poz)
    751                List_Paint(Speech[g_leng].Rejestr,1,108,0,0,3," ",0,0,0,0,0,0,0 ); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char algin, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])      
    752                
    753          
    754                
    755                 int tab_niepelna=0;
    756                 //sprawdzenie czy tablica jest pe³na
    757                 for (int k=1; k<=29; k++)
    758                    {
    759                          ConversWpis.Wpis_DW = memory_read_L[k];  
    760                          if (ConversWpis.Wpis_B[0]==0xFF) {tab_niepelna=1;} else {max_poz_wpisu=k;}
    761                    }
    762                
    763           
    764          
    765                  int pozycja;
    766                
    767                  int j=88;
    768                  for (int i=1; i<=5; i++)
    769                    {
    770                          
    771                       if (tab_niepelna)
    772                       {
    773                          pozycja = poz_wpisu+1-wartosc_scroll-i;
    774                          if (pozycja<=0) pozycja=-1;
    775                       }
    776                       else
    777                       {
    778                          pozycja = poz_wpisu+1-wartosc_scroll-i;
    779                          if (pozycja<=0) { pozycja=29+(poz_wpisu+1-wartosc_scroll-i);}
    780                       }
    781                          
    782                      
    783                          ConversWpis.Wpis_DW = memory_read_L[pozycja];  
    784                          
    785          
    786                        if (pozycja>0)
    787                        {
    788                          char time_char[9];
    789                          TimeToStr(ConversWpis.Wpis_B[3],ConversWpis.Wpis_B[4],ConversWpis.Wpis_B[5],time_char);
    790                          time_char[8]=0;
    791                          
    792                          Label(time_char,0,2,j+(Label_move*2),8,50,16,96,0);   //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
    793                          
    794                          
    795                          DateToStr(ConversWpis.Wpis_B[0],ConversWpis.Wpis_B[1],ConversWpis.Wpis_B[2],time_char);//(char dzin, char mies, char rok, char Vstring[8])
    796                          time_char[6]=0;
    797                          Label(time_char,0,38,j+(Label_move*2),5,23,16,96,0);   //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
    798                          
    799                          
    800                          switch(ConversWpis.Wpis_B[6])
    801                          {
    802                            case 1 :  Label(Speech[g_leng].UruchomienieSter,0,2,j+(Label_move*2)-8,15,8,16,96,0); break;
    803                            case 2 :  Label(Speech[g_leng].RestartSter,0,2,j+(Label_move*2)-8,15,8,16,96,0); break;
    804                            case 3 :  Label(Speech[g_leng].CzyszczonyRej,0,2,j+(Label_move*2)-8,15,8,16,96,0); break;
    805                   
    806                          }       
    807                        }
    808                        
    809                          
    810                          //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
    811                    
    812                         
    813                          /*
    814                          HexToStr((( (ram.BinVarRAM[(wartosc_scroll+i-1)/8]) >> ((wartosc_scroll+i-1)%8) ) & 0x1 ) ,textVal1,1);
    815                          Label(textVal1,1,52,j+(Label_move*2)-8,8,35,1,113,0);
    816                
    817                          if (( (ram.BinVarRAMfors[(wartosc_scroll+i-1)/8]) >> ((wartosc_scroll+i-1)%8) ) & 0x1 )  Label("F",0,4,j+(Label_move*2)-8,1,8,1,113,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
    818          */
    819                          if ((j-10+(Label_move*2))>15)
    820                         {
    821                            H_line(3,j-10+(Label_move*2),58,3);
    822                         }     
    823                         j=j-20;
    824                          
    825                      } 
    826                      
    827                      //H_line(1,15,60,1);   
    828                      //H_line(1,97,60,1);
    829                   
    830                      char LabelButt[2];
    831                      LabelButt[0]=30;
    832                      if (Rej_poz>0) Button(LabelButt,22,97,20,13); //(etykieta ,char poz_X , char poz_Y ,char width, char height)
    833                      LabelButt[0]=31;
    834                      if ((Rej_poz<249) && (max_poz_wpisu>4)) Button(LabelButt,22,2,20,13); //(etykieta ,char poz_X , char poz_Y ,char width, char height)
    835                      
    836                  
    837                }//________________________________________________________________________
    838          
    839              
    840                //*-----------------------------------------------------------------------------
    841                void Rejestrator_Event(void)
    842                {
    843          
    844                char LabelButt[2];
    845                     LabelButt[0]=30;
    846                char odp2=0;
    847                char odp1=0;
    848                
    849                if (Rej_poz>0) odp1=Button(LabelButt,22,97,20,13); //(etykieta ,char poz_X , char poz_Y ,char width, char height)
    850                      LabelButt[0]=31;
    851                if ((Rej_poz<249) && ((max_poz_wpisu*10-40)>Rej_poz)) odp2=Button(LabelButt,22,2,20,13); //(etykieta ,char poz_X , char poz_Y ,char width, char height)
    852                          
    853                          
    854                //przycisk dó³
    855                if (((Rej_poz)<250) && (odp2) && ((max_poz_wpisu*10-40)>Rej_poz))   {(Rej_poz)++;  MenuPaint(); }
    856                if (((Rej_poz)>=250)) MenuPaint();
    857          
    858                //przycisk góra   -- nie zrobiony
    859                if (((Rej_poz)<250) && (odp1) && ((max_poz_wpisu*10-40)>Rej_poz))   {(Rej_poz)--;  MenuPaint(); }
    860                
    861          
    862                  //zdarzenie typu down "X"
    863                  if ((X_down>46) && (X_down<63) && (Y_down>112) && (Y_down<127))    //"X"
    864                  {
    865                    //MenuPaint();
    866                    H_line(49,114,10,0);
    867                    H_line(49,123,10,0); 
    868                    V_line(49,114,10,0); 
    869                    V_line(58,114,10,0); 
    870                    
    871                  }
    872            
    873              
    874                  if ((X_up>46) && (X_up<63) && (Y_up>112) && (Y_up<127))                    //"X"
    875                  {
    876                    Rej_poz=0;
    877                    MenuLevel=(MenuLevel/10);
    878                    MenuPaint();
    879                  }  
    880            
    881               
    882          
    883                }//________________________________________________________________________
    884              
    885                
    886          
    887          
    888          //Info ******************************************************************************************************************
    889          
    890          
    891                //*-----------------------------------------------------------------------
    892                void Info_Paint(void)
    893                {
    894                  char CyklPerSek_char[5];
    895          
    896                  List_Paint(Speech[g_leng].Info,3,25,5,0,1,Speech[g_leng].NazwaProg,Speech[g_leng].DataMod,Speech[g_leng].CzasCyklu,0,0,0,0,0); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char algin, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])
    897          
    898                  
    899                  char *memory_read;
    900                  memory_read=(char*)(AT91C_IFLASH_MEM->FlashProgram+FlashProgramOfset);
    901                  memory_read=memory_read+0x41;
    902                  
    903                  
    904                  char nazwa_dl =0;
    905                  char data_dl=0;
    906                  for (int i=0; i<=32; i++)
    907                  {
    908                     if (memory_read[i]!=0xEA)
    909                     {
    910                       if ((memory_read[i]==0x20) && (nazwa_dl==0)) nazwa_dl=i;
    911                       if ((memory_read[i]==0x20) && (nazwa_dl!=0) && (data_dl==0)) data_dl=i-nazwa_dl;
    912                     }
    913                     else
    914                     {
    915                        i=40; 
    916                     }
    917                  }
    918                  if (nazwa_dl>12) nazwa_dl=13;
    919                  if (data_dl>12) data_dl=13;
    920          
    921                  Label(memory_read,0,4,83,nazwa_dl,57,1,113,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
    922                  Label((memory_read+nazwa_dl+1),0,4,58,data_dl,57,1,113,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
    923                  
    924                  
    925                  FloToStr(CyklPerSek,CyklPerSek_char,4);
    926                  Label(CyklPerSek_char,1,47,32,4,30,1,113,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
    927                  Label("ms",0,48,32,4,10,1,113,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
    928                }//________________________________________________________________________
    929          
    930          
    931                //*-----------------------------------------------------------------------
    932                void Info_Refresh(void)
    933                {
    934                  char CyklPerSek_char[5];
    935          
    936          
    937                  FloToStr(CyklPerSek,CyklPerSek_char,4);
    938              
    939                  Label(CyklPerSek_char,1,47,32,4,30,1,113,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
    940                  Label("ms",0,48,32,4,10,1,113,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
    941                }//________________________________________________________________________
    942                
    943          
    944                //*-----------------------------------------------------------------------------
    945                void Info_Event(void)
    946                {
    947           
    948                  if (List_Event(X_up, Y_up, X_down, Y_down, 0 , 15, 0,5)<0) 
    949                  {
    950                    MenuLevel=(MenuLevel/10);
    951                    MenuPaint();
    952                  }
    953                }//________________________________________________________________________
    954          
    955          
    956                
    957                
    958                
    959                
    960                
    961                
    962          //opcje  **************************************************************************************************************
    963          
    964                //*----------------------------------------------------------------------------
    965                void Options_Paint(void)
    966                {  
    967                    List_Paint(Speech[g_leng].Opcje,3,15,0,0,3,Speech[g_leng].RestartSter, Speech[g_leng].Odforsuj, Speech[g_leng]. CzyscRej,0,0,0,0,0); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char algin, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])
    968                
    969                }//________________________________________________________________________
    970          
    971              
    972                //*-----------------------------------------------------------------------------
    973                void Options_Event(void)
    974                {
    975                  int ans;
    976                  ans= List_Event(X_up, Y_up, X_down, Y_down, 3 , 15, 0,0);//(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
    977                  if (ans)
    978                    {
    979                        if (ans>0) MenuLevel=(MenuLevel*10+ans);
    980                        if (ans<0) MenuLevel=(MenuLevel/10);
    981                        MenuPaint();
    982                    } 
    983                    
    984          
    985                  
    986                }//________________________________________________________________________
    987              
    988                      
    989          
    990          
    991          //Ustawienia ******************************************************************************************************************
    992          
    993                //*----------------------------------------------------------------------------
    994                void Setup_Paint(void)
    995                {  
    996                    
    997                    List_Paint(Speech[g_leng].Ustawienia,3,15,0,0,3,Speech[g_leng].Jezyk,Speech[g_leng].DataCzas,Speech[g_leng].ZmHasla,0,0,0,0,0); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char back, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])
    998                }//________________________________________________________________________
    999          
   1000          
   1001          
   1002                //*-----------------------------------------------------------------------
   1003                void Setup_Event(void)
   1004                {
   1005                  int ans;
   1006           
   1007                  ans=List_Event(X_up, Y_up, X_down, Y_down, 3 , 15, 0,0); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
   1008            
   1009                  if (ans)
   1010                    {
   1011                    if (ans>0) MenuLevel=(MenuLevel*10+ans);
   1012                    if (ans<0) MenuLevel=(MenuLevel/10);
   1013                    MenuPaint();
   1014                    } 
   1015                }//_______________________________________________________________________
   1016          
   1017          
   1018          
   1019          //Ustawienia jêzyka******************************************************************************************************************
   1020          
   1021                //*----------------------------------------------------------------------------
   1022                void SetupLang_Paint(void)
   1023                {  
   1024                    //char Y=3;
   1025                    int Y_tmp = 3;   //przesuniêcie w dó³
   1026          
   1027                    List_Paint("Jezyk",2,15,Y_tmp,7,0,Speech[0].Polski, Speech[1].Angielski,0,0,0,0,0,0 ); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char algin, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])
   1028                
   1029                    
   1030                    char ekran_tab[10] =  {0,4,4,10,11,16,16,32,64,0};
   1031                 
   1032                  
   1033                    CopyToCanvasPoint((char *)ekran_tab,45,97-Y_tmp-(15*(g_leng)),8,10); 
   1034                    
   1035                }//________________________________________________________________________
   1036          
   1037          
   1038          
   1039                //*-----------------------------------------------------------------------
   1040                void SetupLang_Event(void)
   1041                {
   1042                  int ans;
   1043           
   1044                  ans=List_Event(X_up, Y_up, X_down, Y_down, 2 , 15, 7,3); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
   1045            
   1046                  if (ans)
   1047                    {
   1048                      if ((ans>0) && (ans<3))
   1049                      {
   1050                        g_leng=ans-1;
   1051                        MenuLevel=(MenuLevel/10);
   1052                        MenuPaint();
   1053                      }
   1054                    } 
   1055                  else
   1056                    {
   1057                      if ((X_up>0) &&(Y_up>0)) 
   1058                      {
   1059                        MenuLevel=(MenuLevel/10);
   1060                        MenuPaint();
   1061                      }
   1062                    }
   1063                }//_______________________________________________________________________
   1064          
   1065          
   1066          
   1067          
   1068          
   1069          
   1070          
   1071          //Ustawienia hasla wybór poziomu******************************************************************************************************************
   1072          
   1073                //*----------------------------------------------------------------------------
   1074                void SetupPass_Paint(void)
   1075                {  
   1076                    int  Y_tmp = 40;   //przesuniêcie w dó³
   1077                    char il;
   1078                    if (g_level==2) {il=2;} else {il=1;}
   1079                  
   1080                    List_Paint("X",il,15,Y_tmp,10,3,Speech[g_leng].Poziom2,  Speech[g_leng].Poziom3,0,0,0,0,0,0 ); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char algin, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])
   1081                    
   1082                }//________________________________________________________________________
   1083          
   1084          
   1085          
   1086                //*-----------------------------------------------------------------------
   1087                void SetupPass_Event(void)
   1088                {
   1089                  int  Y_tmp = 40;   //przesuniêcie w dó³
   1090                  int ans;
   1091                  char il;
   1092                  if (g_level==2) {il=2;} else {il=1;}
   1093                    
   1094                  ans=List_Event(X_up, Y_up, X_down, Y_down, il , 15, 10,Y_tmp); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
   1095            
   1096                  if (ans)
   1097                    {
   1098                      if ((ans>0) && (ans<=il))
   1099                      {
   1100                         MenuLevel=(MenuLevel*10+ans);
   1101                      }
   1102                      //MenuLevel=(MenuLevel/10);
   1103                      MenuPaint();
   1104                    }
   1105                  else
   1106                    {
   1107                      if ((X_up>0) &&(Y_up>0)) 
   1108                      {
   1109                        MenuLevel=(MenuLevel/10);
   1110                        MenuPaint();
   1111                      }
   1112                    }
   1113                }//_______________________________________________________________________
   1114          
   1115          
   1116                
   1117          
   1118          //Wpisanie obecnego has³a  poziom 1/2**************************************************************************************************************
   1119                char InsertOldPass1[9]={0,0,0,0,0,0,0,0,0};
   1120              //*----------------------------------------------------------------------------
   1121              void SetupOldPass_Paint()
   1122              {  
   1123                    Number_Paint(Speech[g_leng].Wpisz,"C","E");
   1124                    
   1125                    Label(Speech[g_leng].ObecneHaslo,0,3,102,15,58,0,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1126              
   1127                    if (InsertOldPass1[8])  Label(InsertOldPass1,2,4,90,8,55,0,127,0);//(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1128          
   1129                    
   1130              }//________________________________________________________________________
   1131          
   1132          
   1133              
   1134              //*-----------------------------------------------------------------------------
   1135              void SetupOldPass_Event(char level)
   1136              {
   1137                  int ans;
   1138                  char roz=0;
   1139          
   1140                  ans=Number_Event(X_up, Y_up, X_down, Y_down); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
   1141            
   1142                  if (ans>0)
   1143                    {
   1144                      MenuPaint();
   1145                      if (InsertOldPass1[8]<=7) 
   1146                      { 
   1147                          if ((ans<10) || (ans==11)) 
   1148                          {
   1149                            if (ans<10) InsertOldPass1[InsertOldPass1[8]]=ans+48;
   1150                            if (ans==11) InsertOldPass1[InsertOldPass1[8]]=ans+37;
   1151                            InsertOldPass1[8]++;
   1152                          }
   1153                          
   1154                      }
   1155                      if ((ans==10) && (InsertOldPass1[8]>0) ) {InsertOldPass1[8]--; InsertOldPass1[InsertOldPass1[8]]=0;}
   1156                      Label(InsertOldPass1,2,4,90,8,55,0,127,0);//(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1157                      
   1158                      if (ans==12)
   1159                      {
   1160                        roz=0;
   1161                        for (int i=0; i<=7; i++)
   1162                        {
   1163                            if ((g_Password_1[i]!=InsertOldPass1[i]) && (level==1)) roz=1;
   1164                            if ((g_Password_2[i]!=InsertOldPass1[i]) && (level==2)) roz=1;
   1165                        }
   1166                        if (roz==0)
   1167                        {
   1168                           MenuLevel=(MenuLevel*10+1);
   1169                           for (int i=0; i<=7; i++) InsertOldPass1[i]=0;
   1170                           InsertOldPass1[8]=0;
   1171                           MenuPaint();
   1172                        } 
   1173                        else
   1174                        {
   1175                           //informacja o b³ednym haœle
   1176                          Message_Paint(2,0,Speech[g_leng].Bledne,Speech[g_leng].haslo,0,0);
   1177                        }
   1178                        //MenuPaint();
   1179                      }
   1180                    }
   1181                  if (ans<0)
   1182                    {
   1183                        MenuLevel=(MenuLevel/100);
   1184                        MenuPaint();
   1185                        for (int i=0; i<=7; i++) InsertOldPass1[i]=0;
   1186                        InsertOldPass1[8]=0;
   1187                    }
   1188               
   1189              }//________________________________________________________________________
   1190          
   1191              
   1192          
   1193          
   1194          //Wpisanie nowego has³a  poziom 1**************************************************************************************************************
   1195              char InsertNewPass1[9]={0,0,0,0,0,0,0,0,0};
   1196              //*----------------------------------------------------------------------------
   1197              void SetupNewPass_Paint(void)
   1198              {  
   1199                    Number_Paint(Speech[g_leng].Wpisz,"C","E");
   1200                    
   1201                    Label(Speech[g_leng].NoweHaslo,0,3,102,15,58,0,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1202              
   1203                    if (InsertNewPass1[8])  Label(InsertNewPass1,2,4,90,8,55,0,127,0);//(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1204          
   1205                    
   1206              }//________________________________________________________________________
   1207          
   1208          
   1209          
   1210              //*-----------------------------------------------------------------------------
   1211              void SetupNewPass_Event(char level)
   1212              {
   1213                  int ans;
   1214                  ans=Number_Event(X_up, Y_up, X_down, Y_down); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
   1215            
   1216                  if (ans>0)
   1217                    {
   1218                      MenuPaint();
   1219                      if (InsertNewPass1[8]<=7) 
   1220                      { 
   1221                          if ((ans<10) || (ans==11)) 
   1222                          {
   1223                            if (ans<10) InsertNewPass1[InsertNewPass1[8]]=ans+48;
   1224                            if (ans==11) InsertNewPass1[InsertNewPass1[8]]=ans+37;
   1225                            InsertNewPass1[8]++;
   1226                          }
   1227                          
   1228                      }
   1229                      if ((ans==10) && (InsertNewPass1[8]>0) ) {InsertNewPass1[8]--; InsertNewPass1[InsertOldPass1[8]]=0;}
   1230                      Label(InsertNewPass1,2,4,90,8,55,0,127,0);//(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1231                      
   1232                      if ((ans==12) && (InsertNewPass1[8]>0))
   1233                      {
   1234                        
   1235                        for (int i=0; i<=7; i++)
   1236                        {
   1237                            if (level==1) g_Password_1[i]=InsertNewPass1[i];
   1238                            if (level==2) g_Password_2[i]=InsertNewPass1[i];
   1239                            InsertNewPass1[i]=0;
   1240                        }
   1241                        InsertNewPass1[8]=0;
   1242          
   1243                           //informacja o zmianie hasla
   1244                         MenuLevel=(MenuLevel/1000);
   1245                          if (level==1) Message_Paint(2,Speech[g_leng].Nowe,Speech[g_leng].haslo,"------------",g_Password_1,0);
   1246                          if (level==2) Message_Paint(2,Speech[g_leng].Nowe,Speech[g_leng].haslo,"------------",g_Password_2,0);
   1247                      
   1248                        
   1249                        //MenuPaint();
   1250                      }  
   1251                     }
   1252                    
   1253                  if (ans<0)
   1254                    {
   1255                        MenuLevel=(MenuLevel/1000);
   1256                        MenuPaint();
   1257                        for (int i=0; i<=7; i++) InsertNewPass1[i]=0;
   1258                        InsertNewPass1[8]=0;
   1259                    }
   1260                
   1261              }//________________________________________________________________________
   1262          
   1263          
   1264              
   1265          
   1266          
   1267          //Ustawienia ******************************************************************************************************************
   1268          
   1269          
   1270          
   1271          //restart
   1272                //*-----------------------------------------------------------------------
   1273                void Restart_Event(void)
   1274                {
   1275                  AT91S_RSTC  g_AT91S_RSTC;
   1276                  int ans;
   1277           
   1278                  ans=Ask_Event(X_up, Y_up, X_down, Y_down); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
   1279            
   1280                  if (ans)
   1281                    {
   1282                    if (ans==2) 
   1283                    {
   1284                      SaveToReg(2,0);      //wpis do rejestru "Restart"
   1285                      //restart
   1286                      AT91C_BASE_RSTC->RSTC_RCR = AT91C_RSTC_PROCRST | AT91C_RSTC_PERRST | AT91C_RSTC_KEY;
   1287                    }
   1288                    if ((ans<0) || (ans==1))  MenuLevel=(MenuLevel/10);
   1289                    MenuPaint();
   1290                    } 
   1291                }//_______________________________________________________________________
   1292              
   1293              
   1294          
   1295              
   1296              
   1297          //odforsuj wszystkie
   1298                //*-----------------------------------------------------------------------
   1299                void Unforce_Event(void)
   1300                {
   1301                  int ans;
   1302           
   1303                  ans=Ask_Event(X_up, Y_up, X_down, Y_down); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
   1304            
   1305                  if (ans)
   1306                    {
   1307                    if (ans==2) 
   1308                    {
   1309                      //odforsowanie wszystkich
   1310                      for (int i=0; i<BinVarRAM_Size; i++)  ram.BinVarRAMfors[i]=0;
   1311                      
   1312                      for (int i=0; i<AnaVarRAM_Size; i++)  
   1313                      {
   1314                            ram.AnaVarRAMu[i] &= ~(0x1);
   1315                      }
   1316                      
   1317                      MenuLevel=(MenuLevel/100);
   1318                    }
   1319                    if ((ans<0) || (ans==1))  MenuLevel=(MenuLevel/10);
   1320                    MenuPaint();
   1321                    } 
   1322                }//_______________________________________________________________________
   1323               
   1324              
   1325          //odforsuj wszystkie
   1326                //*-----------------------------------------------------------------------
   1327              void UnforceOne_Event(char Type, int NrSygnal)  //Type : 0- analog, 1-dwustan, 2-IO
   1328                {
   1329          
   1330                      //odforsowanie analogów
   1331                      if (Type==0) ram.AnaVarRAMu[NrSygnal] &= ~(0x1);
   1332                      
   1333                      //odforsowanie dwustawnów
   1334                      if (Type==1) ram.BinVarRAMfors[(NrSygnal/8)] &=(~(0x1<<(NrSygnal%8)));
   1335                      
   1336                      //MenuLevel=(MenuLevel/10);
   1337                      //MenuPaint();
   1338          
   1339                }//_______________________________________________________________________
   1340              
   1341              
   1342              
   1343          //czyœæ rejestr
   1344                //*-----------------------------------------------------------------------
   1345              
   1346                void CleanReg_Event(void)
   1347                {
   1348                  int ans;
   1349           
   1350                  ans=Ask_Event(X_up, Y_up, X_down, Y_down); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
   1351            
   1352                  if (ans)
   1353                    {
   1354                    if (ans==2) 
   1355                    {
   1356                      //czyszczenie rejestru
   1357                      CleanReg();
   1358                      MenuLevel=(MenuLevel/10);
   1359                      MenuPaint();
   1360                    }
   1361                    if ((ans<0) || (ans==1))  MenuLevel=(MenuLevel/10);
   1362                    MenuPaint();
   1363                    } 
   1364                }//_______________________________________________________________________
   1365                   
   1366              
   1367              
   1368          //Ustawienia czasu  **************************************************************************************************************
   1369              char SetupTimeCarPoz=1; 
   1370              //*----------------------------------------------------------------------------
   1371              void SetupTime_Paint(void)
   1372              {  
   1373                 List_Paint(Speech[g_leng].DataCzas,1,108,0,0,1," ", 0 ,0,0,0,0,0,0); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char algin, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])
   1374                 
   1375          
   1376                 
   1377                 Label(Speech[g_leng].CzasGMS,0,3,99,10,33,1,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1378                    
   1379                    
   1380                 char time_char[3];
   1381                  
   1382                 CharToStr(godz, time_char, 2); //(char Value, char *Vstring, char ill);
   1383                 Label(time_char,2,12,87,2,11,1,127,((SetupTimeCarPoz)&0x1) );  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1384                 CharToStr(mi, time_char, 2); //(char Value, char *Vstring, char ill);
   1385                 Label(time_char,2,27,87,2,11,1,127,(SetupTimeCarPoz>>1)&0x1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1386                 CharToStr(sek, time_char, 2); //(char Value, char *Vstring, char ill);
   1387                 Label(time_char,2,42,87,2,11,1,127,(SetupTimeCarPoz>>2)&0x1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1388                  
   1389                 
   1390                 Label(Speech[g_leng].DataDMR,0,3,74,10,33,1,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1391                
   1392                 CharToStr(dzien, time_char, 2); //(char Value, char *Vstring, char ill);
   1393                 Label(time_char,2,12,62,2,11,1,127,(SetupTimeCarPoz>>3)&0x1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1394                 CharToStr(mies, time_char, 2); //(char Value, char *Vstring, char ill);
   1395                 Label(time_char,2,27,62,2,11,1,127,(SetupTimeCarPoz>>4)&0x1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1396                 CharToStr(rok, time_char, 2); //(char Value, char *Vstring, char ill);
   1397                 Label(time_char,2,42,62,2,11,1,127,(SetupTimeCarPoz>>5)&0x1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1398                  
   1399              
   1400                 
   1401                 H_line(10,97,46,1); // (char X, int Y, char lenght, char typ) 
   1402                 H_line(10,85,46,1); // (char X, int Y, char lenght, char typ) 
   1403                 V_line(10,86,11,1); // (char X, int Y, char lenght, char typ) 
   1404                 V_line(25,86,11,1); // (char X, int Y, char lenght, char typ) 
   1405                 V_line(40,86,11,1); // (char X, int Y, char lenght, char typ) 
   1406                 V_line(55,86,11,1); // (char X, int Y, char lenght, char typ) 
   1407                 
   1408                 H_line(10,72,46,1); // (char X, int Y, char lenght, char typ) 
   1409                 H_line(10,60,46,1); // (char X, int Y, char lenght, char typ) 
   1410                 V_line(10,61,11,1); // (char X, int Y, char lenght, char typ) 
   1411                 V_line(25,61,11,1); // (char X, int Y, char lenght, char typ) 
   1412                 V_line(40,61,11,1); // (char X, int Y, char lenght, char typ) 
   1413                 V_line(55,61,11,1); // (char X, int Y, char lenght, char typ) 
   1414                 
   1415                
   1416                 
   1417                 char LabelButt[2];
   1418                 LabelButt[0]=30;
   1419                 Button(LabelButt,33,14,19,25); //(etykieta ,char poz_X , char poz_Y ,char width, char height)
   1420                 LabelButt[0]=31;
   1421                 Button(LabelButt,12,14,19,25); //(etykieta char poz_X , char poz_Y ,char width, char height) 
   1422                 
   1423                  //H_line(4,42,30,1); // (char X, int Y, char lenght, char typ) 
   1424              }//________________________________________________________________________
   1425          
   1426              void SetupTime_Refresh(void)
   1427              {  
   1428          
   1429                 char time_char[3];
   1430                  
   1431                 CharToStr(godz, time_char, 2); //(char Value, char *Vstring, char ill);
   1432                 Label(time_char,2,12,87,2,11,1,127,((SetupTimeCarPoz)&0x1) );  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1433                 CharToStr(mi, time_char, 2); //(char Value, char *Vstring, char ill);
   1434                 Label(time_char,2,27,87,2,11,1,127,(SetupTimeCarPoz>>1)&0x1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1435                 CharToStr(sek, time_char, 2); //(char Value, char *Vstring, char ill);
   1436                 Label(time_char,2,42,87,2,11,1,127,(SetupTimeCarPoz>>2)&0x1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1437                  
   1438          
   1439                 CharToStr(dzien, time_char, 2); //(char Value, char *Vstring, char ill);
   1440                 Label(time_char,2,12,62,2,11,1,127,(SetupTimeCarPoz>>3)&0x1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1441                 CharToStr(mies, time_char, 2); //(char Value, char *Vstring, char ill);
   1442                 Label(time_char,2,27,62,2,11,1,127,(SetupTimeCarPoz>>4)&0x1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1443                 CharToStr(rok, time_char, 2); //(char Value, char *Vstring, char ill);
   1444                 Label(time_char,2,42,62,2,11,1,127,(SetupTimeCarPoz>>5)&0x1);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, negatyw) 
   1445                  
   1446              }//________________________________________________________________________
   1447          
   1448          
   1449          
   1450              //*-----------------------------------------------------------------------------
   1451              char SleepModTime=0;
   1452              void SetupTime_Event(void)
   1453              {
   1454                  int ans=List_Event(X_up, Y_up, X_down, Y_down, 1 , 0, 0,0);  //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
   1455                  
   1456                  char  SetupPozTmp=0;
   1457                  if ((X_up>10) && (X_up<56) &&  (Y_up>85) && (Y_up<97))  
   1458                  {
   1459                     SetupPozTmp = (X_up-10)/15;
   1460                     SetupTimeCarPoz=0;
   1461                     SetupTimeCarPoz=1<<SetupPozTmp;
   1462                  }
   1463                  if ((X_up>10) && (X_up<56) &&  (Y_up>60) && (Y_up<72))  
   1464                  {
   1465                     SetupPozTmp = (X_up-10)/15;
   1466                     SetupTimeCarPoz=0;
   1467                     SetupTimeCarPoz=1<<SetupPozTmp+3;
   1468                  }
   1469                  
   1470                 if (ans<0)  
   1471                 {
   1472                    MenuLevel=(MenuLevel/10);
   1473                    MenuPaint();
   1474                 }
   1475                 else
   1476                 {
   1477                  char odp=0;
   1478                  int set_zm=0;
   1479                  char LabelButt[1]={30};
   1480                  odp = (Button(LabelButt,33,14,19,25));
   1481                  if ((odp==2) && (SleepModTime==0)) set_zm=1;
   1482                  if (odp==2) { SleepModTime++; if (SleepModTime>10) SleepModTime=0;};            //(char poz_X , char poz_Y ,char width, char height)
   1483                  
   1484                  
   1485                  if (odp==1) {SleepModTime=0;}
   1486                  
   1487                  LabelButt[0]=31;
   1488                  odp=0;
   1489                  odp = (Button(LabelButt,12,14,19,25));
   1490                  if ((odp==2)&& (SleepModTime==0))  set_zm=-1;
   1491                  if (odp==2) { SleepModTime++; if (SleepModTime>10) SleepModTime=0;};            //(char poz_X , char poz_Y ,char width, char height)
   1492                  
   1493                  if (odp==1) {SleepModTime=0;} 
   1494                  
   1495                  
   1496                  int dzien_tmp= dzien;
   1497                  int mies_tmp=mies;
   1498                  int rok_tmp=rok;
   1499                  int godz_tmp=godz;
   1500                  int mi_tmp=mi;
   1501                  int sek_tmp=sek;
   1502                  
   1503                  
   1504                  switch (SetupTimeCarPoz)
   1505                  {
   1506                    case 1: godz_tmp+=set_zm;  break;
   1507                    case 2: mi_tmp+=set_zm;     break;
   1508                    case 4: sek_tmp+=set_zm;   break;
   1509                    case 8: dzien_tmp+=set_zm;   break;
   1510                    case 16: mies_tmp+=set_zm;   break;
   1511                    case 32: rok_tmp+=set_zm;   break;
   1512                  }
   1513                  
   1514                  if (sek_tmp>59) {sek_tmp=0; mi_tmp++;} 
   1515                  if (mi_tmp>59)  {mi_tmp=0; godz_tmp++;}
   1516                  if (godz_tmp>23) godz_tmp=0;  
   1517                  
   1518                  if (sek_tmp<0) {sek_tmp=59; mi_tmp--;}
   1519                  if (mi_tmp<0)  {mi_tmp=59; godz_tmp--;}
   1520                  if (godz_tmp<0) godz_tmp=23;
   1521                 
   1522                  char mies_tmp2 = mies_tmp;
   1523                  switch (mies_tmp2)
   1524                  {
   1525                    case 1  : if (dzien_tmp>31) {dzien_tmp=1; mies_tmp++;} break;
   1526                    case 2  : if ((rok_tmp%4)>0) {      if (dzien_tmp>28) {dzien_tmp=1; mies_tmp++;} 
   1527                                  }else {if (dzien_tmp>29) {dzien_tmp=1; mies_tmp++;} }     break;
   1528                    case 3  : if (dzien_tmp>31) {dzien_tmp=1; mies_tmp++;} break;
   1529                    case 4  : if (dzien_tmp>30) {dzien_tmp=1; mies_tmp++;} break;
   1530                    case 5  : if (dzien_tmp>31) {dzien_tmp=1; mies_tmp++;} break;
   1531                    case 6  : if (dzien_tmp>30) {dzien_tmp=1; mies_tmp++;} break;
   1532                    case 7  : if (dzien_tmp>31) {dzien_tmp=1; mies_tmp++;} break;
   1533                    case 8  : if (dzien_tmp>31) {dzien_tmp=1; mies_tmp++;} break;
   1534                    case 9  : if (dzien_tmp>30) {dzien_tmp=1; mies_tmp++;} break;
   1535                    case 10 : if (dzien_tmp>31) {dzien_tmp=1; mies_tmp++;} break;
   1536                    case 11 : if (dzien_tmp>30) {dzien_tmp=1; mies_tmp++;} break;
   1537                    case 12 : if (dzien_tmp>31) {dzien_tmp=1; mies_tmp++;} break;
   1538                  }  
   1539                  
   1540                  if (mies_tmp>12)  {mies_tmp=1; rok_tmp++;}
   1541                  if (rok_tmp>99) rok_tmp=0;  
   1542                 
   1543                  mies_tmp2 = mies_tmp;
   1544                  if (dzien_tmp<=0)
   1545                  switch (mies_tmp2)
   1546                  {
   1547                    case 1  : dzien_tmp=31; mies_tmp--; break;
   1548                    case 2  : dzien_tmp=31; mies_tmp--; break;
   1549                    case 3  : if ((rok_tmp%4)>0) { dzien_tmp=28; mies_tmp--; } else { dzien_tmp=29; mies_tmp--; }  break;
   1550                    case 4  : dzien_tmp=31; mies_tmp--;  break;
   1551                    case 5  : dzien_tmp=30; mies_tmp--;  break;
   1552                    case 6  : dzien_tmp=31; mies_tmp--;  break;
   1553                    case 7  : dzien_tmp=30; mies_tmp--;  break;
   1554                    case 8  : dzien_tmp=31; mies_tmp--;  break;
   1555                    case 9  : dzien_tmp=31; mies_tmp--;  break;
   1556                    case 10 : dzien_tmp=30; mies_tmp--;  break;
   1557                    case 11 : dzien_tmp=31; mies_tmp--;  break;
   1558                    case 12 : dzien_tmp=30; mies_tmp--;  break;
   1559                  } 
   1560                   
   1561                  if (mies_tmp<0)  {mies_tmp=12; rok_tmp--;}
   1562                  if (rok_tmp<0) rok_tmp=0;
   1563          
   1564          
   1565                  dzien= dzien_tmp;
   1566                  mies=mies_tmp;
   1567                  rok=rok_tmp;
   1568                  godz=godz_tmp;
   1569                  mi=mi_tmp;
   1570                  sek=sek_tmp;
   1571                  
   1572                 }
   1573                  
   1574              }//________________________________________________________________________
   1575          
   1576              
   1577          
   1578          //Wybór poziomu dostêpu *************************************************************************************************************
   1579                //*-----------------------------------------------------------------------
   1580                void Sygnal_Paint(void)
   1581                {
   1582                    #define _Y   10   //przesuniêcie w dó³
   1583                    List_Paint(Speech[g_leng].Sygnaly,4,15,_Y,0,3,Speech[g_leng].Obserwowane,Speech[g_leng].WeWy, Speech[g_leng].ZmAnalog, Speech[g_leng].ZmDwust,0,0,0,0 ); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char algin, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])      
   1584                }//_______________________ Koniec funkcji MainSide_Paint __________________________    
   1585              
   1586              
   1587                    //*-----------------------------------------------------------------------
   1588                void Sygnal_Event(void)
   1589                {
   1590                  int Y_tmp = 10;   //przesuniêcie w dó³
   1591                  int ans;
   1592          
   1593                  ans=List_Event(X_up, Y_up, X_down, Y_down, 4 , 15,0,Y_tmp); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
   1594            
   1595                  if (ans)
   1596                    {
   1597                      if ((ans>0) && (ans<5))
   1598                      {
   1599                          MenuLevel=(MenuLevel*10+ans);
   1600                          MenuPaint();
   1601                      }
   1602                      if (ans<0)
   1603                      {
   1604                        MenuLevel=(MenuLevel/10);
   1605                        MenuPaint();
   1606                      }
   1607                    }
   1608          
   1609                }//_______________________________________________________________________
   1610          
   1611          
   1612          
   1613          //Wejœcia/wyjœcia ******************************************************************************************************************
   1614              #define IO_Size_scroll    (IO_Size-6)*10 
   1615              
   1616              void IO_Side_Event(void)
   1617              {
   1618                char odp= Scroll_Event(IO_Size_scroll,&Suw_poz_IO,7);
   1619                    if (odp)
   1620                    {
   1621                      ScrollMenu_Paint_exist=-1;
   1622                      if ((odp>1) && (g_level>0))
   1623                      {
   1624                          MenuLevel=(MenuLevel*10+1);
   1625                      }
   1626                      //odmowa dostêpu
   1627                      if ((odp>1) && (g_level==0)) { Message_Paint(2,0,Speech[g_leng].Dostep,Speech[g_leng].zastrzezony,"!!!",0); } else { MenuPaint(); }
   1628                      
   1629                    }
   1630              }
   1631              
   1632              //*-----------------------------------------------------------------------------
   1633              void IO_Side_Paint(void)
   1634              {
   1635          
   1636                char textVal1[8]={0,0,0,0,0,0,0,0};
   1637                char text1[9]={0,0,0,0,0,0,0,0,0};
   1638                int wartosc_scroll_tmp=0;
   1639                int Label_move_tmp=Suw_poz_IO;
   1640                int wartosc_scroll=0;
   1641                
   1642                Label_move=Label_move_tmp%10; 
   1643          
   1644                if (Suw_poz_IO>3)  { wartosc_scroll=Suw_poz_IO/10; }  else  { wartosc_scroll=0; Label_move=0; }
   1645            
   1646                
   1647                if (CyklMonit<=4) ScrollList_Paint(Speech[g_leng].WeWy, IO_Size_scroll , &Suw_poz_IO , 1);  //(char name[10], char Size_scroll, char _Suw_poz, char poz)
   1648                if (CyklMonit>4)  ScrollList_Paint("     ", IO_Size_scroll , &Suw_poz_IO , 1);  //(char name[10], char Size_scroll, char _Suw_poz, char poz)
   1649                if (CyklMonit>6) {CyklMonit=0;} else {CyklMonit++;}  
   1650          
   1651                  int j=105;
   1652                  for (int i=1; i<=7; i++)
   1653                    {
   1654                        
   1655                      
   1656                          Label("Q",0,2,j+(Label_move*2),8,50,1,113,0);
   1657                          
   1658                          wartosc_scroll_tmp=wartosc_scroll+i-1;
   1659                          HexToStr(wartosc_scroll_tmp,text1,2);
   1660                          Label(text1,0,8,j+(Label_move*2),8,20,2,113,0);
   1661                      
   1662                     switch (ram.IO_type[wartosc_scroll+i-1])
   1663                     {
   1664                        case 0 : Label("IN a.",0,22,j+(Label_move*2),8,26,1,113,0);  break;
   1665                        case 1 : Label("OUT a.",0,22,j+(Label_move*2),8,26,1,113,0);  break;
   1666                        case 2 : Label("IN b.",0,22,j+(Label_move*2),8,26,1,113,0);  break;
   1667                        case 3 : Label("OUT b.",0,22,j+(Label_move*2),8,26,1,113,0);  break;
   1668                     } 
   1669                     
   1670                     if (ram.IO_type[wartosc_scroll+i-1]<2)     
   1671                     {
   1672                          HexToStr(ram.IOu[wartosc_scroll+i-1]&0x1 ,textVal1,1);
   1673                          Label(textVal1,1,52,j+(Label_move*2)-8,8,35,1,113,0);
   1674                
   1675                          if (( (ram.IOu[(wartosc_scroll+i-1)/8]) >> 1) & 0x1 )  Label("F",0,4,j+(Label_move*2)-8,1,8,1,113,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1676                     }
   1677                     else
   1678                     {
   1679                          FloToStr(ram.IO[wartosc_scroll+i-1],textVal1,8);
   1680                          Label(textVal1,1,52,j+(Label_move*2)-8,8,35,1,113,0);
   1681                
   1682                          if ((ram.IOu[wartosc_scroll+i-1]) & 0x1)  Label("F",0,4,j+(Label_move*2)-8,1,8,1,113,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1683                     }
   1684                          
   1685                          
   1686                          if ((j-10+(Label_move*2))>0)
   1687                         {
   1688                            H_line(3,j-10+(Label_move*2),49,3);
   1689                         }     
   1690                         j=j-20;
   1691                      } 
   1692                  
   1693                  Scroll_list_selsct_paint(Label_move, 10000);
   1694              }//_________________________________________________________________________
   1695          
   1696                 
   1697              
   1698              
   1699          
   1700          //Zmienne dwustanowe ******************************************************************************************************************
   1701              #define BinVarRAM_Size_scroll    ((BinVarRAM_Size*8)-6)*10
   1702              void ZM_DwustanSide_Event(void)
   1703              {
   1704                    char odp= Scroll_Event(BinVarRAM_Size_scroll,&Suw_poz_dwustan,7);
   1705                    if (odp)
   1706                    {
   1707                      ScrollMenu_Paint_exist=-1;
   1708                      
   1709                      if ((odp>1) && (g_level>0))
   1710                      {
   1711                          MenuLevel=(MenuLevel*10+1);
   1712                      }
   1713                      //odmowa dostêpu
   1714                      if ((odp>1) && (g_level==0)) { Message_Paint(2,0,Speech[g_leng].Dostep,Speech[g_leng].zastrzezony,"!!!",0); } else { MenuPaint(); }
   1715                      
   1716                    }
   1717              }
   1718              
   1719              //*-----------------------------------------------------------------------------
   1720              void ZM_DwustanSide_Paint(void)
   1721              {
   1722          
   1723                char textVal1[8]={0,0,0,0,0,0,0,0};
   1724                char text1[9]={0,0,0,0,0,0,0,0,0};
   1725                int wartosc_scroll_tmp=0;
   1726                int Label_move_tmp=Suw_poz_dwustan;
   1727                int wartosc_scroll=0;
   1728                
   1729                Label_move=Label_move_tmp%10; 
   1730          
   1731                if (Suw_poz_dwustan>3)  { wartosc_scroll=Suw_poz_dwustan/10; }  else  { wartosc_scroll=0; Label_move=0; }
   1732            
   1733                if (CyklMonit<=4) ScrollList_Paint(Speech[g_leng].ZmDwust, BinVarRAM_Size_scroll , &Suw_poz_dwustan , 1);  //(char name[10], char Size_scroll, char _Suw_poz, char poz)
   1734                if (CyklMonit>4)  ScrollList_Paint("     ", BinVarRAM_Size_scroll , &Suw_poz_dwustan , 1);   //(char name[10], char Size_scroll, char _Suw_poz, char poz)
   1735                if (CyklMonit>6) {CyklMonit=0;} else {CyklMonit++;}  
   1736                
   1737                
   1738                  int j=105;
   1739                  for (int i=1; i<=7; i++)
   1740                    {
   1741                          wartosc_scroll_tmp=wartosc_scroll+0xB000+i-1;
   1742                          HexToStr(wartosc_scroll_tmp,text1,4);
   1743                          Label(text1,0,2,j+(Label_move*2),8,50,1,113,0);
   1744                      
   1745                          HexToStr((( (ram.BinVarRAM[(wartosc_scroll+i-1)/8]) >> ((wartosc_scroll+i-1)%8) ) & 0x1 ) ,textVal1,1);
   1746                          Label(textVal1,1,52,j+(Label_move*2)-8,8,35,1,113,0);
   1747                
   1748                          if (( (ram.BinVarRAMfors[(wartosc_scroll+i-1)/8]) >> ((wartosc_scroll+i-1)%8) ) & 0x1 )  Label("F",0,4,j+(Label_move*2)-8,1,8,1,113,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1749          
   1750                          if ((j-10+(Label_move*2))>0)
   1751                         {
   1752                            H_line(3,j-10+(Label_move*2),49,3);
   1753                         }     
   1754                         j=j-20;
   1755                      } 
   1756                  Scroll_list_selsct_paint(Label_move, 10000);
   1757              }//_________________________________________________________________________
   1758          
   1759             
   1760              
   1761            
   1762          //Wybór zdarzenia zmiennych******************************************************************************************************************    
   1763            void ScrollMenu_Paint(int *_Suw_poz, char mol, char Type)  //Type: 0-analogi, 1-dwustany, 2-IO
   1764              {    
   1765             
   1766               char move;
   1767               int Y_up_tmp; 
   1768                
   1769              if (ScrollMenu_Paint_exist==-1)
   1770              {
   1771                Scroll_List_select=0;
   1772                move=((*_Suw_poz)%mol);
   1773                Y_up_tmp=127-(127-(((127-(Y_up+14))/20)*20)-13-move+15);
   1774                if (Y_up_tmp>63) Y_up_tmp=63;
   1775                if (Y_up_tmp<0) Y_up_tmp=0;
   1776                ScrollMenu_Paint_exist=Y_up_tmp;
   1777                
   1778          
   1779                ScrollMenu_poz=(((*_Suw_poz)/mol)+((127-(Y_up-14-move))/20))-1;
   1780                
   1781              }
   1782              
   1783              char text_tmp[5]={0,0,0,0,0};
   1784              if (Type==0)  HexToStr(ScrollMenu_poz+0xA000,text_tmp,4);
   1785              if (Type==1)  HexToStr(ScrollMenu_poz+0xB000,text_tmp,4);    
   1786              if (Type==2)
   1787              {
   1788                HexToStr(ScrollMenu_poz+0xA000,text_tmp,4);
   1789                text_tmp[0]=0x51;
   1790              }
   1791              text_tmp[4]=0;
   1792                   
   1793                 List_Paint(text_tmp,3,15,15,0,3,Speech[g_leng].Forsuj, Speech[g_leng].Odforsuj,  Speech[g_leng].Monitoruj,0,0,0,0,0 ); //(char name[7], char Rows, char RowWith, char Y, char FormStyle, char algin, char p1[12], char p2[12] , char p3[12] , char p4[12] , char p5[12] , char p6[12] , char p7[12] , char p8[12])      
   1794                       
   1795              }//_________________________________________________________________________
   1796             
   1797             
   1798              void ScrollMenu_Event(char Type)
   1799              {    
   1800             
   1801                int ans;
   1802                  ans=List_Event(X_up, Y_up, X_down, Y_down, 3 , 15, 0,15); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
   1803            
   1804                  if (ans>0)
   1805                    {
   1806                      if ((ans>0) && (ans<4))
   1807                      {
   1808                       if ((ans==1) || (ans==3))
   1809                       {
   1810                         MenuLevel=(MenuLevel*10+ans);
   1811                         MenuPaint();
   1812                       }
   1813                       if (ans==2) 
   1814                        {  
   1815                          UnforceOne_Event(Type,ScrollMenu_poz);
   1816                          MenuLevel=(MenuLevel/10);
   1817                          MenuPaint();
   1818                        }
   1819                      }
   1820                    }
   1821                  if (ans<0)
   1822                    {
   1823          
   1824                        ScrollMenu_Paint_exist=-1;
   1825                        MenuLevel=(MenuLevel/10);
   1826                        MenuPaint();
   1827          
   1828                    }
   1829                
   1830              }//_________________________________________________________________________
   1831                
   1832              
   1833          //Zmienne analogowe ******************************************************************************************************************
   1834              #define  AnaVarRAM_Size_scroll    (AnaVarRAM_Size-6)*10
   1835              
   1836              
   1837              void ZM_AnalogSide_Event(void)
   1838              {
   1839                  char odp= Scroll_Event(AnaVarRAM_Size_scroll,&Suw_poz_analog,7);
   1840                    if (odp)
   1841                    {
   1842                      ScrollMenu_Paint_exist=-1;
   1843                      if ((odp>1) && (g_level>0))
   1844                      {
   1845                          MenuLevel=(MenuLevel*10+1);
   1846                          
   1847                      }
   1848                      
   1849                      //odmowa dostêpu
   1850                      if ((odp>1) && (g_level==0)) { Message_Paint(2,0,Speech[g_leng].Dostep,Speech[g_leng].zastrzezony,"!!!",0); } else { MenuPaint(); }
   1851                    }
   1852              }
   1853                 
   1854              
   1855              
   1856              //*-----------------------------------------------------------------------------
   1857              void ZM_AnalogSide_Paint(void)
   1858              {
   1859          
   1860                char textVal1[8]={0,0,0,0,0,0,0,0};
   1861                char text1[9]={0,0,0,0,0,0,0,0};
   1862                int wartosc_scroll_tmp=0;
   1863                int Label_move_tmp=Suw_poz_analog;
   1864                int wartosc_scroll=0;
   1865                
   1866                Label_move=Label_move_tmp%10; 
   1867          
   1868                if (Suw_poz_analog>3)  { wartosc_scroll=Suw_poz_analog/10; }  else  { wartosc_scroll=0; Label_move=0; }
   1869            
   1870                
   1871                if (CyklMonit<=4) ScrollList_Paint(Speech[g_leng].ZmAnalog, AnaVarRAM_Size_scroll , &Suw_poz_analog , 1);  //(char name[10], char Size_scroll, char _Suw_poz, char poz)
   1872                if (CyklMonit>4)  ScrollList_Paint("     ", AnaVarRAM_Size_scroll , &Suw_poz_analog , 1);  //(char name[10], char Size_scroll, char _Suw_poz, char poz)
   1873                if (CyklMonit>6) {CyklMonit=0;} else {CyklMonit++;}  
   1874                
   1875                  int j_tmp=105;
   1876                  for (int i=1; i<=7; i++)
   1877                    {
   1878                           wartosc_scroll_tmp=wartosc_scroll+0xA000+i-1;
   1879                          HexToStr(wartosc_scroll_tmp,text1,4);
   1880                          Label(text1,0,2,j_tmp+(Label_move*2),8,50,1,113,0);
   1881                          
   1882                          for (char j_tmp2=0; j_tmp2<=7; j_tmp2++) {textVal1[j_tmp2]=0;}; 
   1883                            
   1884                          FloToStr(ram.AnaVarRAM[wartosc_scroll+i-1],textVal1,8);
   1885                          Label(textVal1,1,52,j_tmp+(Label_move*2)-8,8,35,1,113,0);
   1886                
   1887                          if (ram.AnaVarRAMu[wartosc_scroll+i-1] & 0x1)  Label("F",0,4,j_tmp+(Label_move*2)-8,1,8,1,113,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1888          
   1889                          if ((j_tmp-10+(Label_move*2))>0)
   1890                         {
   1891                            H_line(3,j_tmp-10+(Label_move*2),49,3);
   1892                         }     
   1893                         j_tmp=j_tmp-20;
   1894                      } 
   1895                  
   1896                  
   1897                  Scroll_list_selsct_paint(Label_move, 10000);
   1898              
   1899          
   1900                  
   1901              }//_________________________________________________________________________
   1902          
   1903             
   1904              
   1905          //Monitoring
   1906              //*-----------------------------------------------------------------------------
   1907              
   1908              void MonitoringSide_Paint(void)
   1909              {
   1910          
   1911                char textVal1[8]={0,0,0,0,0,0,0,0};
   1912                char text1[9]={0,0,0,0,0,0,0,0,0};
   1913                int wartosc_scroll_tmp=0;
   1914                int Label_move_tmp=Suw_poz_monit;
   1915                int wartosc_scroll=0;
   1916                
   1917                Label_move=Label_move_tmp%10; 
   1918          
   1919                if (Suw_poz_monit>3)  { wartosc_scroll=Suw_poz_monit/10; }  else  { wartosc_scroll=0; Label_move=0; }
   1920            
   1921                if (CyklMonit<=4) ScrollList_Paint(Speech[g_leng].Obserwowane, Monit_Size_scroll , &Suw_poz_monit , 1);  //(char name[10], char Size_scroll, char _Suw_poz, char poz)
   1922                if (CyklMonit>4)  ScrollList_Paint("     ", Monit_Size_scroll , &Suw_poz_monit , 1);  //(char name[10], char Size_scroll, char _Suw_poz, char poz)
   1923                if (CyklMonit>6) {CyklMonit=0;} else {CyklMonit++;}  
   1924          
   1925                
   1926                int wartosc_scroll_new;
   1927                  int j=105;
   1928                  
   1929                  if (Monit_Size_scroll==0)
   1930                  {
   1931                    Label(Speech[g_leng].Puste,2,5,60,8,45,1,113,0); //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1932                  }
   1933                  
   1934                  if (Monit_Size_scroll)  
   1935                  for (int i=1; i<=7; i++)
   1936                    {
   1937                       wartosc_scroll_new = (Monitoring_array[wartosc_scroll+i-1][0])-1;
   1938                       if ((Monitoring_array[wartosc_scroll+i-1][1]==0) && (Monitoring_array[wartosc_scroll+i-1][0]!=0))
   1939                       {
   1940                          wartosc_scroll_tmp=wartosc_scroll_new+0xA000;
   1941                          HexToStr(wartosc_scroll_tmp,text1,4);
   1942                          Label(text1,0,2,j+(Label_move*2),8,50,1,113,0);
   1943                          
   1944                          for (char j_tmp2=0; j_tmp2<=7; j_tmp2++) textVal1[j_tmp2]=0; 
   1945                            
   1946                          FloToStr(ram.AnaVarRAM[wartosc_scroll_new],textVal1,8);
   1947                          Label(textVal1,1,52,j+(Label_move*2)-8,8,35,1,113,0);
   1948                
   1949                          if (ram.AnaVarRAMu[wartosc_scroll_new] & 0x1)  Label("F",0,4,j+(Label_move*2)-8,1,8,1,113,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1950          
   1951                          if ((j-10+(Label_move*2))>0)
   1952                         {
   1953                            H_line(3,j-10+(Label_move*2),49,3);
   1954                         }     
   1955                         j=j-20;
   1956                       }
   1957                       if ((Monitoring_array[wartosc_scroll+i-1][1]==1) && (Monitoring_array[wartosc_scroll+i-1][0]!=0))
   1958                       {
   1959                          wartosc_scroll_tmp=wartosc_scroll_new+0xB000;
   1960                          HexToStr(wartosc_scroll_tmp,text1,4);
   1961                          Label(text1,0,2,j+(Label_move*2),8,50,1,113,0);
   1962                      
   1963                          HexToStr((( (ram.BinVarRAM[(wartosc_scroll_new)/8]) >> ((wartosc_scroll_new)%8) ) & 0x1 ) ,textVal1,1);
   1964                          Label(textVal1,1,52,j+(Label_move*2)-8,8,35,1,113,0);
   1965                
   1966                          if (( (ram.BinVarRAMfors[(wartosc_scroll_new)/8]) >> ((wartosc_scroll_new)%8) ) & 0x1 )  Label("F",0,4,j+(Label_move*2)-8,1,8,1,113,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   1967          
   1968                          if ((j-10+(Label_move*2))>0)
   1969                         {
   1970                            H_line(3,j-10+(Label_move*2),49,3);
   1971                         }     
   1972                         j=j-20;
   1973                       }     
   1974                            
   1975                     } 
   1976                  
   1977                  
   1978                  Scroll_list_selsct_paint(Label_move, (Monit_Size_scroll/10));
   1979              
   1980          
   1981                  
   1982              }//_________________________________________________________________________
   1983          
   1984             
   1985            
   1986            
   1987          //Zmienne analogowe ******************************************************************************************************************
   1988              
   1989              
   1990              
   1991              void MonitoringSide_Event(void)
   1992              {
   1993                  char odp= Scroll_Event(Monit_Size_scroll,&Suw_poz_monit, (Monit_Size_scroll/10));
   1994                    if (odp)
   1995                    {
   1996                      if ((odp>1) && (g_level>0))
   1997                      {
   1998                          MenuLevel=(MenuLevel*10+1);
   1999                          
   2000                      }
   2001                      
   2002                      //odmowa dostêpu
   2003                      if ((odp>1) && (g_level==0)) { Message_Paint(2,0,Speech[g_leng].Dostep,Speech[g_leng].zastrzezony,"!!!",0); } else { MenuPaint(); }
   2004                    }
   2005              }
   2006                   
   2007              
   2008            
   2009            
   2010          
   2011          //*-----------------------------------------------------------------------------
   2012          //* Nazwa funkcji :    Scroll_list_selsct_paint
   2013          //* Funkcja rysowania zaznaczeñ listy
   2014          //*-----------------------------------------------------------------------------
   2015          //* Label_move - przesuniecie
   2016          //*-----------------------------------------------------------------------------
   2017          
   2018              void Scroll_list_selsct_paint(char Label_move, int max)
   2019              {
   2020                
   2021                int Y_down_tmp=(127-(((127-(Y_down+14-(Label_move*2)))/20)*20)-13+(Label_move*2));
   2022                if ((Scroll_List_select) && (X_down>1) && (X_down<42) && (Y_down_tmp<115) && ((Y_down_tmp-18)>1))   
   2023                {
   2024                  
   2025                  if (((127-(Y_down+14-(Label_move*2)))/20)<max)
   2026                  {
   2027                    H_line(2,Y_down_tmp,50,1);
   2028                    H_line(2,Y_down_tmp-18,50,1);
   2029                    V_line(1,Y_down_tmp-18,19,1);
   2030                    V_line(52,Y_down_tmp-18,19,1);
   2031                  }
   2032                } 
   2033                
   2034              }//_________________________________________________________________________
   2035          
   2036          
   2037          
   2038          
   2039          
   2040          
   2041          
   2042          //has³o poziomu 1/2*************************************************************************************************************
   2043          
   2044          
   2045                //*-----------------------------------------------------------------------
   2046          
   2047                void Forse_Paint(char Type)
   2048                {
   2049          
   2050                      char text_tmp[5]={0,0,0,0,0};
   2051                      if (Type==0)  HexToStr(ScrollMenu_poz+0xA000,text_tmp,4);
   2052                      if (Type==1)  HexToStr(ScrollMenu_poz+0xB000,text_tmp,4);    
   2053                      if (Type==2)
   2054                        {
   2055                          HexToStr(ScrollMenu_poz+0xA000,text_tmp,4);
   2056                          text_tmp[0]=0x51;
   2057                        }
   2058                      text_tmp[4]=0;
   2059                     
   2060                  Number_Paint(Speech[g_leng].Forsuj,".","F");
   2061                    
   2062                   Label(text_tmp,0,3,102,15,58,0,127,0);  //(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2063                   
   2064                   
   2065                }//_______________________ Koniec funkcji MainSide_Paint __________________________
   2066          
   2067          char tmp;
   2068          
   2069                //*-----------------------------------------------------------------------
   2070          char InsertForse[10]={0,0,0,0,0,0,0,0,0,0};
   2071                void Forse_Event(char Type, int NrSygnal)
   2072                {
   2073                  int ans;
   2074                  
   2075                  char err =0;
   2076                  
   2077                  ans=Number_Event(X_up, Y_up, X_down, Y_down); //(char X_up, char Y_up, char X_down, char Y_down, char Rows, char RowWith, char FormStyle, char Y)
   2078            
   2079                  if (ans>0)
   2080                    {
   2081                      MenuPaint();
   2082                      
   2083                      if ((Type==1) && ( (ans==11) || (ans==1) )) 
   2084                      
   2085                      if ((InsertForse[8]<=7) && (err==0)) 
   2086                      { 
   2087                            if (ans<10) InsertForse[InsertForse[8]]=ans+48;
   2088                            if (ans==11) InsertForse[InsertForse[8]]=ans+37;
   2089                            if (ans==10) InsertForse[InsertForse[8]]=46;
   2090                            if (Type==0) InsertForse[8]++;
   2091                      }
   2092                      
   2093                      
   2094                      Label(InsertForse,2,4,90,8,55,0,127,0);//(char *Vstring, char alig, char X, int Y, char maxChar, char clean, char minY, char maxY, char negatyw) 
   2095          
   2096                      
   2097                      //Zatwierdzenie forsowania
   2098                      if (ans==12)
   2099                      {
   2100          
   2101                         char ch=0;
   2102                         int point = -1;
   2103                         float VarFlo_tmp=0;
   2104                         while( (ch<8) && (InsertForse[ch]!=0))
   2105                         {
   2106                             if (InsertForse[ch]==46) point=ch;
   2107                             ch++;
   2108                         }
   2109                         ch--;
   2110                         
   2111          
   2112                         
   2113                         char i_tmp=0;
   2114                         
   2115                         if (point<0) point=ch+1;
   2116                         
   2117                  
   2118                         if (point>0)
   2119                         {
   2120                          // i_tmp=0;
   2121                          
   2122                       if (Type==0)
   2123                       {
   2124                         for (int i=point-1; i>=0; i--)
   2125                         {
   2126                              switch(i_tmp)
   2127                              {
   2128                                case 0 : VarFlo_tmp+=(float) (1*(InsertForse[i]-48));  break;
   2129                                case 1 : VarFlo_tmp+=(float) (10*(InsertForse[i]-48));  break;
   2130                                case 2 : VarFlo_tmp+=(float) (100*(InsertForse[i]-48));  break;
   2131                                case 3 : VarFlo_tmp+=(float) (1000*(InsertForse[i]-48));  break;
   2132                                case 4 : VarFlo_tmp+=(float) (10000*(InsertForse[i]-48));  break;
   2133                                case 5 : VarFlo_tmp+=(float) (100000*(InsertForse[i]-48));  break;
   2134                                case 6 : VarFlo_tmp+=(float) (1000000*(InsertForse[i]-48));  break;
   2135                                case 7 : VarFlo_tmp+=(float) (10000000*(InsertForse[i]-48));  break;
   2136                              } 
   2137                              i_tmp++;
   2138                         }
   2139                          
   2140                         }
   2141                         i_tmp=0;
   2142                         if (point<ch)
   2143                         {
   2144                            for (int i=point+1; i<=ch; i++)
   2145                            {
   2146                              switch(i_tmp)
   2147                              {
   2148                                case 0 : VarFlo_tmp+=0.1 *((float) ((InsertForse[i]-48)));  break;
   2149                                case 1 : VarFlo_tmp+=0.01*((float) ((InsertForse[i]-48)));  break;
   2150                                case 2 : VarFlo_tmp+=0.001*((float) ((InsertForse[i]-48)));  break;
   2151                                case 3 : VarFlo_tmp+=0.0001*((float) ((InsertForse[i]-48)));  break;
   2152                                case 4 : VarFlo_tmp+=0.00001*((float) ((InsertForse[i]-48)));  break;
   2153                                case 5 : VarFlo_tmp+=0.000001*((float) ((InsertForse[i]-48)));  break;
   2154                                case 6 : VarFlo_tmp+=0.0000001*((float) ((InsertForse[i]-48)));  break;
   2155                                case 7 : VarFlo_tmp+=0.00000001*((float) ((InsertForse[i]-48)));  break;
   2156                              }
   2157                              i_tmp++;
   2158                            }
   2159                          }
   2160                          
   2161                         ram.AnaVarRAM[NrSygnal]=VarFlo_tmp;
   2162                         }
   2163                         
   2164                       
   2165                         //Jezeli forsowanie dwustanu
   2166                         if (Type==1) 
   2167                         {
   2168                           tmp = (~(0x1<<(NrSygnal%8)));
   2169                           if (InsertForse[0]==48)   ram.BinVarRAM[(NrSygnal/8)] &=(~(0x1<<(NrSygnal%8)));
   2170                           if (InsertForse[0]==49)   ram.BinVarRAM[(NrSygnal/8)] |=0x1<<(NrSygnal%8) ;
   2171                         }
   2172                         
   2173                         
   2174                          
   2175          
   2176                          //odforsowanie analogów
   2177                          if (Type==0) ram.AnaVarRAMu[NrSygnal] |= (0x1);
   2178                      
   2179                          //odforsowanie dwustawnów
   2180                          if (Type==1) ram.BinVarRAMfors[(NrSygnal/8)]|=0x1<<(NrSygnal%8);
   2181                      
   2182                         
   2183                          for (int i=0; i<=9; i++) InsertForse[i]=0;
   2184                          MenuLevel=(MenuLevel/100);
   2185                          MenuPaint();
   2186                         }   
   2187                         
   2188                        
   2189              
   2190                    }
   2191                  if (ans<0)
   2192                    {
   2193                        MenuLevel=(MenuLevel/100);
   2194                        MenuPaint();
   2195                        for (int i=0; i<=9; i++) InsertForse[i]=0;
   2196                        InsertPass1[8]=0;
   2197                    }
   2198                 
   2199                }//_______________________________________________________________________
   2200          
   2201          
   2202          
   2203          //Dodanie do monitoringu      
   2204          void AddToMonitoring(char Type, int NrSygnal)
   2205          {
   2206             char MiejsceTab = Monit_Size_scroll/10;
   2207             char istnieje=0;
   2208             
   2209             for (char i=0; i<=30; i++)
   2210             {
   2211               if ((Monitoring_array[i][0]==NrSygnal+1) && (Monitoring_array[i][1]==Type)) istnieje=1;
   2212             }
   2213             
   2214             if (istnieje)
   2215             {
   2216               MenuLevel=(MenuLevel/100);
   2217               Message_Paint(2,0,Speech[g_leng].Istnieje,0,0,0);
   2218             }
   2219             else
   2220             {
   2221                if (MiejsceTab<=30)
   2222                {
   2223                  Monitoring_array[MiejsceTab][0]=NrSygnal+1;
   2224                  Monitoring_array[MiejsceTab][1]=Type;
   2225                  Monit_Size_scroll+=10;
   2226                  MenuLevel=(MenuLevel/100);
   2227                  MenuPaint();
   2228               
   2229                }
   2230                else
   2231                {
   2232                  MenuLevel=(MenuLevel/100);
   2233                  Message_Paint(2,0,Speech[g_leng].Brak,Speech[g_leng].miejsca,"!!!",0);
   2234                }
   2235              }
   2236          }
   2237          
   2238          
   2239          
   2240          
   2241          
   2242          #endif
   2243          


 
 
 0 bytes of memory

Errors: none
Warnings: none
